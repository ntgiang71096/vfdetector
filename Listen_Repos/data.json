[{"id": "1dce1ddd62b4d9f7434bffa347defe0ad286bfab", "message": "Propagate graph rewrite options from model server flags to tfrt SavedModel API.\n\nPiperOrigin-RevId: 519535644", "patch": ["@@ -234,7 +234,6 @@ static Status CreateHloXlaPipeline(", "   if (options.outline_with_xla_framework) {", "     pm.addPass(mlir::xla_framework::CreateOutlineWithXLAFrameworkPass());", "   }", "-  pm.addPass(mlir::createInlinerPass());", " ", "   if (options.experimental_deallocation) {", "     CHECK(!options.sparse_bufferization)", "@@ -2053,6 +2053,22 @@ class Subgraph {", "     return kTfLiteOk;", "   }", " ", "+  static TfLiteStatus CheckTensorStaticOrPersistentRoAllocation(", "+      TfLiteContext* context, const TfLiteTensor& tensor, int tensor_index,", "+      int node_index) {", "+    if (tensor.allocation_type == kTfLiteMmapRo ||", "+        tensor.allocation_type == kTfLitePersistentRo ||", "+        tensor.data.raw_const == nullptr) {", "+      return kTfLiteOk;", "+    }", "+    TF_LITE_MAYBE_KERNEL_LOG(", "+        context,", "+        \"invalid allocation type in tensor #%d in node #%d: \"", "+        \"expected static or persistent read-only tensor\",", "+        tensor_index, node_index);", "+    return kTfLiteError;", "+  }", "+", "   static TfLiteStatus CheckTensorsDimensionMatch(", "       TfLiteContext* context, const TfLiteTensor& input_tensor,", "       const TfLiteTensor& output_tensor, int dimension_index, int node_index,", "@@ -4583,7 +4599,7 @@ class Subgraph {", "                                             node_index));", "       TF_LITE_ENSURE_STATUS(CheckShapeTensorShape(", "           logging_context, shape_tensor, node->inputs->data[1], node_index));", "-      TF_LITE_ENSURE_STATUS(CheckTensorStaticAllocation(", "+      TF_LITE_ENSURE_STATUS(CheckTensorStaticOrPersistentRoAllocation(", "           logging_context, shape_tensor, node->inputs->data[1], node_index));", "     }", " ", "@@ -4130,7 +4130,7 @@ void IrEmitterUnnested::WriteReductionOutput(", "     const HloReduceInstruction* reduction, int partial_result_idx,", "     const absl::Span<TypedPointer const> values) {", "   const HloComputation* reducer = reduction->to_apply();", "-  for (auto [oidx, typed_ptr] : llvm::enumerate(values)) {", "+  for (const auto& [oidx, typed_ptr] : llvm::enumerate(values)) {", "     auto [output_ptr, type] = typed_ptr;", "     llvm::Value* output_address = GetOutputAddressForReduction(", "         partial_result_idx, index_ty, reduction_codegen_state,", "@@ -4,8 +4,8 @@ load(\"//third_party:repo.bzl\", \"tf_http_archive\")", " ", " def repo(name):", "     \"\"\"Imports LLVM.\"\"\"", "-    LLVM_COMMIT = \"89a1af749166627704cdf9d676455d32616c2c06\"", "-    LLVM_SHA256 = \"ce1aa46fc0fc6bd2caf4d311a7a862e9293978da42e8ac60008463c82db18ad5\"", "+    LLVM_COMMIT = \"c5d22f4e1866549f0d8c3aad598c0153c31679e7\"", "+    LLVM_SHA256 = \"01851eda543900458c84023b15cfb7c37d28f3ac497b5a73cc4c2600fbb80e69\"", " ", "     tf_http_archive(", "         name = name,", "@@ -170,6 +170,7 @@ cc_test(", "         \":c_api_experimental\",", "         \":c_api_types\",", "         \":common\",", "+        \"//tensorflow/core/platform:resource_loader\",", "         \"//tensorflow/lite/c:c_api_internal\",", "         \"//tensorflow/lite/delegates:delegate_test_util\",", "         \"//tensorflow/lite/schema:schema_fbs\",", "@@ -194,6 +195,7 @@ cc_test(", "         \":c_api_types\",", "         \":c_api_without_op_resolver_without_alwayslink\",", "         \":common\",", "+        \"//tensorflow/core/platform:resource_loader\",", "         \"//tensorflow/lite/c:c_api_internal\",", "         \"//tensorflow/lite/c:selectively_built_c_api_test_lib\",", "         \"//tensorflow/lite/delegates:delegate_test_util\",", "@@ -208,8 +208,9 @@ const TfLiteRegistrationExternal* MyFindCustomOpExternal(void*,", " ", " // Test using TfLiteInterpreterCreateWithSelectedOps.", " TEST(CApiExperimentalTest, SetOpResolverExternal) {", "-  TfLiteModel* model =", "-      TfLiteModelCreateFromFile(\"third_party/tensorflow/lite/testdata/add.bin\");", "+  TfLiteModel* model = TfLiteModelCreateFromFile(", "+      tensorflow::GetDataDependencyFilepath(\"tensorflow/lite/testdata/add.bin\")", "+          .c_str());", "   ASSERT_NE(model, nullptr);", " ", "   TfLiteInterpreterOptions* options = TfLiteInterpreterOptionsCreate();", "@@ -28,6 +28,7 @@ limitations under the License.", " ", " #include <gmock/gmock.h>", " #include <gtest/gtest.h>", "+#include \"tensorflow/core/platform/resource_loader.h\"", " #include \"tensorflow/lite/c/c_api_internal.h\"", " #include \"tensorflow/lite/core/c/builtin_op_data.h\"", " #include \"tensorflow/lite/core/c/c_api_opaque.h\"", "@@ -64,8 +65,9 @@ TEST(CApiSimple, SchemaVersion) {", " }", " ", " TEST(CApiSimple, Smoke) {", "-  TfLiteModel* model =", "-      TfLiteModelCreateFromFile(\"tensorflow/lite/testdata/add.bin\");", "+  TfLiteModel* model = TfLiteModelCreateFromFile(", "+      tensorflow::GetDataDependencyFilepath(\"tensorflow/lite/testdata/add.bin\")", "+          .c_str());", "   ASSERT_NE(model, nullptr);", " ", "   TfLiteInterpreterOptions* options = TfLiteInterpreterOptionsCreate();", "@@ -141,7 +143,9 @@ TEST(CApiSimple, Smoke) {", " ", " TEST(CApiSimple, QuantizationParams) {", "   TfLiteModel* model = TfLiteModelCreateFromFile(", "-      \"third_party/tensorflow/lite/testdata/add_quantized.bin\");", "+      tensorflow::GetDataDependencyFilepath(", "+          \"tensorflow/lite/testdata/add_quantized.bin\")", "+          .c_str());", "   ASSERT_NE(model, nullptr);", " ", "   TfLiteInterpreter* interpreter = TfLiteInterpreterCreate(model, nullptr);", "@@ -200,8 +204,9 @@ TEST(CApiSimple, QuantizationParams) {", " }", " ", " TEST(CApiSimple, TfLiteInterpreterGetTensor) {", "-  TfLiteModel* model =", "-      TfLiteModelCreateFromFile(\"tensorflow/lite/testdata/add.bin\");", "+  TfLiteModel* model = TfLiteModelCreateFromFile(", "+      tensorflow::GetDataDependencyFilepath(\"tensorflow/lite/testdata/add.bin\")", "+          .c_str());", "   ASSERT_NE(model, nullptr);", " ", "   TfLiteInterpreterOptions* options = TfLiteInterpreterOptionsCreate();", "@@ -223,7 +228,7 @@ TEST(CApiSimple, TfLiteInterpreterGetTensor) {", "             kTfLiteOk);", "   ASSERT_EQ(TfLiteInterpreterAllocateTensors(interpreter), kTfLiteOk);", " ", "-  // The 'third_party/tensorflow/lite/testdata/add.bin' model uses model tensor", "+  // The 'tensorflow/lite/testdata/add.bin' model uses model tensor", "   // at index 1 as the input tensor.", "   TfLiteTensor* input_tensor = TfLiteInterpreterGetTensor(interpreter, 1);", "   ASSERT_NE(input_tensor, nullptr);", "@@ -246,7 +251,7 @@ TEST(CApiSimple, TfLiteInterpreterGetTensor) {", " ", "   ASSERT_EQ(TfLiteInterpreterInvoke(interpreter), kTfLiteOk);", " ", "-  // The 'third_party/tensorflow/lite/testdata/add.bin' model uses model tensor", "+  // The 'tensorflow/lite/testdata/add.bin' model uses model tensor", "   // at index 2 as the output tensor.", "   const TfLiteTensor* output_tensor =", "       TfLiteInterpreterGetTensor(interpreter, 2);", "@@ -274,8 +279,9 @@ TEST(CApiSimple, TfLiteInterpreterGetTensor) {", " }", " ", " TEST(CApiSimple, Delegate) {", "-  TfLiteModel* model =", "-      TfLiteModelCreateFromFile(\"tensorflow/lite/testdata/add.bin\");", "+  TfLiteModel* model = TfLiteModelCreateFromFile(", "+      tensorflow::GetDataDependencyFilepath(\"tensorflow/lite/testdata/add.bin\")", "+          .c_str());", " ", "   // Create and install a delegate instance.", "   bool delegate_prepared = false;", "@@ -300,8 +306,9 @@ TEST(CApiSimple, Delegate) {", " }", " ", " TEST(CApiSimple, DelegateExternal_GetExecutionPlan) {", "-  TfLiteModel* model =", "-      TfLiteModelCreateFromFile(\"tensorflow/lite/testdata/add.bin\");", "+  TfLiteModel* model = TfLiteModelCreateFromFile(", "+      tensorflow::GetDataDependencyFilepath(\"tensorflow/lite/testdata/add.bin\")", "+          .c_str());", " ", "   // Create and install a delegate instance.", "   bool delegate_prepared = false;", "@@ -337,8 +344,9 @@ TEST(CApiSimple, DelegateExternal_GetExecutionPlan) {", " }", " ", " TEST(CApiSimple, DelegateFails) {", "-  TfLiteModel* model =", "-      TfLiteModelCreateFromFile(\"tensorflow/lite/testdata/add.bin\");", "+  TfLiteModel* model = TfLiteModelCreateFromFile(", "+      tensorflow::GetDataDependencyFilepath(\"tensorflow/lite/testdata/add.bin\")", "+          .c_str());", " ", "   // Create and install a delegate instance.", "   TfLiteDelegate delegate = TfLiteDelegateCreate();", "@@ -404,8 +412,9 @@ TfLiteRegistrationExternal* CreateDelegateKernelExternalRegistration() {", " TEST(CApiSimple, OpaqueDelegate_ReplaceNodeSubsetsWithDelegateKernels) {", "   g_nodes_to_replace = new std::vector<int>();", " ", "-  TfLiteModel* model =", "-      TfLiteModelCreateFromFile(\"tensorflow/lite/testdata/add.bin\");", "+  TfLiteModel* model = TfLiteModelCreateFromFile(", "+      tensorflow::GetDataDependencyFilepath(\"tensorflow/lite/testdata/add.bin\")", "+          .c_str());", " ", "   // Create and install a delegate instance.", "   DelegateState delegate_state{false};", "@@ -448,7 +457,7 @@ TEST(CApiSimple, OpaqueDelegate_ReplaceNodeSubsetsWithDelegateKernels) {", "   // The delegate should have been applied.", "   EXPECT_TRUE(delegate_state.delegate_prepared);", "   std::vector<int>& nodes_to_replace = *g_nodes_to_replace;", "-  // We know that \"third_party/tensorflow/lite/testdata/add.bin\" contains two", "+  // We know that \"tensorflow/lite/testdata/add.bin\" contains two", "   // nodes, 0 and 1, and that 0 comes before 1 in the execution plan.", "   EXPECT_EQ(nodes_to_replace.size(), 2);", "   EXPECT_EQ(nodes_to_replace[0], 0);", "@@ -465,8 +474,9 @@ TEST(CApiSimple,", "      OpaqueDelegate_TransferRegistrationExternalOwnershipWithoutNodeToReplace) {", "   g_nodes_to_replace = new std::vector<int>();", " ", "-  TfLiteModel* model =", "-      TfLiteModelCreateFromFile(\"tensorflow/lite/testdata/add.bin\");", "+  TfLiteModel* model = TfLiteModelCreateFromFile(", "+      tensorflow::GetDataDependencyFilepath(\"tensorflow/lite/testdata/add.bin\")", "+          .c_str());", " ", "   // Create and install a delegate instance.", "   DelegateState delegate_state{false};", "@@ -599,8 +609,9 @@ TEST(CApiSimple, InterpreterOptionsCopy) {", " }", " ", " TEST(CApiSimple, ErrorReporter) {", "-  TfLiteModel* model =", "-      TfLiteModelCreateFromFile(\"tensorflow/lite/testdata/add.bin\");", "+  TfLiteModel* model = TfLiteModelCreateFromFile(", "+      tensorflow::GetDataDependencyFilepath(\"tensorflow/lite/testdata/add.bin\")", "+          .c_str());", "   TfLiteInterpreterOptions* options = TfLiteInterpreterOptionsCreate();", " ", "   // Install a custom error reporter into the interpreter by way of options.", "@@ -628,7 +639,9 @@ TEST(CApiSimple, ModelCreateWithErrorReporter) {", "   tflite::TestErrorReporter reporter;", " ", "   // valid model with error reporter", "-  std::ifstream model_file(\"tensorflow/lite/testdata/add.bin\");", "+  std::ifstream model_file(", "+      tensorflow::GetDataDependencyFilepath(\"tensorflow/lite/testdata/add.bin\")", "+          .c_str());", "   model_file.seekg(0, std::ios_base::end);", "   std::vector<char> model_buffer(model_file.tellg());", "   model_file.seekg(0, std::ios_base::beg);", "@@ -655,8 +668,9 @@ TEST(CApiSimple, ModelCreateFromFileWithErrorReporter) {", " ", "   // valid model file with error reporter", "   model = TfLiteModelCreateFromFileWithErrorReporter(", "-      \"third_party/tensorflow/lite/testdata/add.bin\", error_reporter,", "-      &reporter);", "+      tensorflow::GetDataDependencyFilepath(\"tensorflow/lite/testdata/add.bin\")", "+          .c_str(),", "+      error_reporter, &reporter);", "   ASSERT_NE(model, nullptr);", "   EXPECT_EQ(reporter.error_messages(), \"\");", "   TfLiteModelDelete(model);", "@@ -740,8 +754,9 @@ TfLiteRegistrationExternal* CreateReg() {", " }", " ", " TEST(CApiSimple, OpaqueDelegate_TfLiteOpaqueTensorGet) {", "-  TfLiteModel* model =", "-      TfLiteModelCreateFromFile(\"tensorflow/lite/testdata/add.bin\");", "+  TfLiteModel* model = TfLiteModelCreateFromFile(", "+      tensorflow::GetDataDependencyFilepath(\"tensorflow/lite/testdata/add.bin\")", "+          .c_str());", " ", "   struct DelegateState {", "     bool delegate_prepared = false;", "@@ -848,8 +863,9 @@ TEST(CApiSimple, OpaqueContextGetNodeAndRegistration) {", "   };", "   DelegatePrepareStatus delegate_state{false};", " ", "-  TfLiteModel* model =", "-      TfLiteModelCreateFromFile(\"tensorflow/lite/testdata/add.bin\");", "+  TfLiteModel* model = TfLiteModelCreateFromFile(", "+      tensorflow::GetDataDependencyFilepath(\"tensorflow/lite/testdata/add.bin\")", "+          .c_str());", " ", "   TfLiteOpaqueDelegateBuilder opaque_delegate_builder{};", "   opaque_delegate_builder.data = &delegate_state;", "@@ -905,8 +921,9 @@ TEST(CApiSimple, TfLiteOpaqueContextResizeTensor) {", "   };", "   DelegatePrepareStatus delegate_state{false};", " ", "-  TfLiteModel* model =", "-      TfLiteModelCreateFromFile(\"tensorflow/lite/testdata/add.bin\");", "+  TfLiteModel* model = TfLiteModelCreateFromFile(", "+      tensorflow::GetDataDependencyFilepath(\"tensorflow/lite/testdata/add.bin\")", "+          .c_str());", " ", "   TfLiteOpaqueDelegateBuilder opaque_delegate_builder{};", "   opaque_delegate_builder.data = &delegate_state;", "@@ -955,7 +972,9 @@ TEST(CApiSimple, TfLiteOpaqueContextResizeTensor) {", " }", " ", " TEST(CApiSimple, ValidModel) {", "-  std::ifstream model_file(\"tensorflow/lite/testdata/add.bin\");", "+  std::ifstream model_file(", "+      tensorflow::GetDataDependencyFilepath(\"tensorflow/lite/testdata/add.bin\")", "+          .c_str());", " ", "   model_file.seekg(0, std::ios_base::end);", "   std::vector<char> model_buffer(model_file.tellg());", "@@ -970,8 +989,9 @@ TEST(CApiSimple, ValidModel) {", " }", " ", " TEST(CApiSimple, ValidModelFromFile) {", "-  TfLiteModel* model =", "-      TfLiteModelCreateFromFile(\"tensorflow/lite/testdata/add.bin\");", "+  TfLiteModel* model = TfLiteModelCreateFromFile(", "+      tensorflow::GetDataDependencyFilepath(\"tensorflow/lite/testdata/add.bin\")", "+          .c_str());", "   ASSERT_NE(model, nullptr);", "   TfLiteModelDelete(model);", " }", "@@ -996,7 +1016,7 @@ void* FlexSinhInit(TfLiteOpaqueContext* context, const char* buffer,", "                    size_t length) {", "   auto sinh_params = new SinhParams;", "   // The buffer that is passed into here is the custom_options", "-  // field from the flatbuffer (third_party/tensorflow/lite/schema/schema.fbs)", "+  // field from the flatbuffer (tensorflow/lite/schema/schema.fbs)", "   // `Operator` for this node.", "   // Typically it should be stored as a FlexBuffer, but for this test", "   // we assume that it is just a string.", "@@ -1035,8 +1055,10 @@ TfLiteStatus FlexSinhEval(TfLiteOpaqueContext* context,", " }", " ", " TEST(CApiSimple, CustomOpSupport) {", "-  TfLiteModel* model = TfLiteModelCreateFromFile(", "-      \"third_party/tensorflow/lite/testdata/custom_sinh.bin\");", "+  TfLiteModel* model =", "+      TfLiteModelCreateFromFile(tensorflow::GetDataDependencyFilepath(", "+                                    \"tensorflow/lite/testdata/custom_sinh.bin\")", "+                                    .c_str());", "   ASSERT_NE(model, nullptr);", " ", "   TfLiteRegistrationExternal* reg =", "@@ -15,6 +15,7 @@ limitations under the License.", " ", " #include \"tensorflow/core/kernels/batch_kernels.h\"", " ", "+#include <algorithm>", " #include <memory>", " #include <utility>", " ", "@@ -59,8 +60,8 @@ constexpr int64_t kBatchThreadPoolSize = 128;", " }  // namespace", " ", " // Per-model inflight batches parameters.", "-const int64_t kMinInflightBatches = 16;", "-const int64_t kInitialInflightBatches = 16;", "+const int64_t kMinInflightBatches = 1;", "+const int64_t kInitialInflightBatches = 2;", " const int64_t kBatchesToAverageOver = 10;", " const int64_t kMaxInflightBatches = 64;", " ", "@@ -315,10 +316,23 @@ void BatchFunctionKernel::ComputeAsync(OpKernelContext* c, DoneCallback done) {", "           adaptive_shared_batch_scheduler_options;", "       adaptive_shared_batch_scheduler_options.thread_pool_name =", "           \"adaptive_batch_threads\";", "-      adaptive_shared_batch_scheduler_options.num_batch_threads =", "-          adaptive_batch_scheduler_options_->max_in_flight_batches_limit;", "       adaptive_shared_batch_scheduler_options.thread_pool =", "           GetOrCreateBatchThreadsPool();", "+", "+      // When we explicitly specify 'thread_pool', you'd think ASBS would ignore", "+      // 'num_batch_threads', but in fact ASBS still uses num_batch_threads as", "+      // the max number of in-flight batches.  It makes no sense to have more", "+      // in-flight batches than threads (it would result in strictly bad", "+      // batching decisions), so we cap this parameter (which otherwise comes", "+      // from the saved model) to the actual number of batch threads (which", "+      // comes from a process-wide environment variable).", "+      //", "+      // We have to apply the same capping to min_ and initial_", "+      // in_flight_batches_limit below to produce valid configurations.", "+      adaptive_shared_batch_scheduler_options.num_batch_threads = std::min(", "+          NumBatchThreadsFromEnvironmentWithDefault(kBatchThreadPoolSize),", "+          adaptive_batch_scheduler_options_->max_in_flight_batches_limit);", "+", "       // adaptive_shared_batch_scheduler_options.full_batch_scheduling_boost_micros", "       // is 0 (default value) intentionally, so tasks are scheduled in a FIFO", "       // way.", "@@ -332,9 +346,13 @@ void BatchFunctionKernel::ComputeAsync(OpKernelContext* c, DoneCallback done) {", "       // the batch processing latency (which varies on a model basis).", "       // If a non-zero value is not set properly, it harms tail latency.", "       adaptive_shared_batch_scheduler_options.min_in_flight_batches_limit =", "-          adaptive_batch_scheduler_options_->min_in_flight_batches_limit;", "-      adaptive_shared_batch_scheduler_options.initial_in_flight_batches_limit =", "-          adaptive_batch_scheduler_options_->initial_in_flight_batches_limit;", "+          std::min(", "+              NumBatchThreadsFromEnvironmentWithDefault(kBatchThreadPoolSize),", "+              adaptive_batch_scheduler_options_->min_in_flight_batches_limit);", "+      adaptive_shared_batch_scheduler_options", "+          .initial_in_flight_batches_limit = std::min(", "+          NumBatchThreadsFromEnvironmentWithDefault(kBatchThreadPoolSize),", "+          adaptive_batch_scheduler_options_->initial_in_flight_batches_limit);", "       adaptive_shared_batch_scheduler_options.batches_to_average_over =", "           adaptive_batch_scheduler_options_->batches_to_average_over;", "       if (adaptive_batch_scheduler_options_", "@@ -19,10 +19,11 @@ limitations under the License.", " // 8-bit Floating Point Interchange Format, as described by", " //   https://arxiv.org/abs/2209.05433", " ", "-#include <cmath>", "+#include <algorithm>", " #include <cstdint>", " #include <limits>", " #include <ostream>", "+#include <type_traits>", " #include <utility>", " ", " #include \"absl/numeric/bits.h\"", "@@ -569,49 +570,42 @@ namespace float8_internal {", " ", " // Free-functions for use with ADL and in Eigen.", " constexpr inline float8_e4m3fn abs(const float8_e4m3fn& a) {", "-  return float8_e4m3fn::FromRep(a.rep() & 0x7F);", "+  return float8_e4m3fn::FromRep(a.rep() & 0b0'1111'111);", " }", " ", " constexpr inline bool isnan(const float8_e4m3fn& a) {", "-  return (a.rep() & 0x7F) == 0x7F;", "-}", "-", "-constexpr inline bool isinf(const float8_e4m3fn& a) {", "-  return false;  // No inf representation.", "-}", "-", "-constexpr inline bool isfinite(const float8_e4m3fn& a) {", "-  return !isnan(a) && !isinf(a);", "+  return abs(a).rep() == std::numeric_limits<float8_e4m3fn>::quiet_NaN().rep();", " }", " ", " constexpr inline float8_e4m3b11 abs(const float8_e4m3b11& a) {", "-  return (a.rep() & 0x7F) == 0 ? float8_e4m3b11::FromRep(a.rep())", "-                               : float8_e4m3b11::FromRep(a.rep() & 0x7F);", "-}", "-", "-constexpr inline bool isnan(const float8_e4m3b11& a) { return a.rep() == 0x80; }", "-", "-constexpr inline bool isinf(const float8_e4m3b11& a) {", "-  return false;  // No inf representation.", "+  return (a.rep() & 0b0'1111'111) == 0", "+             ? float8_e4m3b11::FromRep(a.rep())", "+             : float8_e4m3b11::FromRep(a.rep() & 0b0'1111'111);", " }", " ", "-constexpr inline bool isfinite(const float8_e4m3b11& a) {", "-  return !isnan(a) && !isinf(a);", "+constexpr inline bool isnan(const float8_e4m3b11& a) {", "+  return a.rep() == std::numeric_limits<float8_e4m3b11>::quiet_NaN().rep();", " }", " ", " constexpr inline float8_e5m2 abs(const float8_e5m2& a) {", "-  return float8_e5m2::FromRep(a.rep() & 0x7F);", "+  return float8_e5m2::FromRep(a.rep() & 0b0'11111'11);", " }", " ", " constexpr inline bool isnan(const float8_e5m2& a) {", "-  return (a.rep() & 0x7F) > 0x7C;", "+  return abs(a).rep() > std::numeric_limits<float8_e5m2>::infinity().rep();", " }", " ", "-constexpr inline bool isinf(const float8_e5m2& a) {", "-  return (a.rep() & 0x7F) == 0x7C;", "+template <typename T>", "+constexpr inline std::enable_if_t<std::is_base_of_v<float8_base<T>, T>, bool>", "+isinf(const T& a) {", "+  return std::numeric_limits<T>::has_infinity", "+             ? abs(a).rep() == std::numeric_limits<T>::infinity().rep()", "+             : false;  // No inf representation.", " }", " ", "-constexpr inline bool isfinite(const float8_e5m2& a) {", "+template <typename T>", "+constexpr inline std::enable_if_t<std::is_base_of_v<float8_base<T>, T>, bool>", "+isfinite(const T& a) {", "   return !isnan(a) && !isinf(a);", " }", " ", "@@ -625,29 +619,10 @@ std::ostream& operator<<(std::ostream& os, const float8_base<Float8>& f8) {", " // Inline conversion routines between float8 and other types.", " //==============================================================================", " ", "-// Helper struct for getting a bit representation provided a byte size.", "+// Helper for getting a bit representation provided a byte size.", " template <int kNumBytes>", "-struct GetUnsignedInteger;", "-", "-template <>", "-struct GetUnsignedInteger<1> {", "-  using type = uint8_t;", "-};", "-", "-template <>", "-struct GetUnsignedInteger<2> {", "-  using type = uint16_t;", "-};", "-", "-template <>", "-struct GetUnsignedInteger<4> {", "-  using type = uint32_t;", "-};", "-", "-template <>", "-struct GetUnsignedInteger<8> {", "-  using type = uint64_t;", "-};", "+using GetUnsignedInteger =", "+    typename Eigen::numext::get_integer_by_size<kNumBytes>::unsigned_type;", " ", " // Converts between two floating-point types.", " template <typename From, typename To, bool kSaturate, bool kTruncate,", "@@ -678,7 +653,7 @@ struct ConvertImpl<Scalar, Scalar, /*kSaturate=*/true, /*kTruncate=*/true,", " ", " template <typename Float>", " struct TraitsBase {", "-  using BitsType = typename GetUnsignedInteger<sizeof(Float)>::type;", "+  using BitsType = GetUnsignedInteger<sizeof(Float)>;", "   static constexpr int kBits = sizeof(Float) * CHAR_BIT;", "   static constexpr int kMantissaBits = Eigen::NumTraits<Float>::digits() - 1;", "   static constexpr int kExponentBits = kBits - kMantissaBits - 1;", "@@ -691,57 +666,13 @@ template <typename Float>", " struct Traits : public TraitsBase<Float> {", "   using Base = TraitsBase<Float>;", "   static constexpr int kExponentBias = (1 << (Base::kExponentBits - 1)) - 1;", "-  static EIGEN_DEVICE_FUNC Float ConstructFromSignAndBits(", "-      typename Base::BitsType sign, typename Base::BitsType bits) {", "-    return Eigen::numext::bit_cast<Float>(", "-        static_cast<typename Base::BitsType>(bits | sign));", "-  }", " };", " ", " template <>", " struct Traits<float8_e4m3b11> : public TraitsBase<float8_e4m3b11> {", "-  using Base = TraitsBase<float8_e4m3b11>;", "   static constexpr int kExponentBias = 11;", "-  static EIGEN_DEVICE_FUNC float8_e4m3b11 ConstructFromSignAndBits(", "-      typename Base::BitsType sign, typename Base::BitsType bits) {", "-    // float8_e4m3b11 does not support signed zero, ignore the sign if we try to", "-    // make one.", "-    if (bits == 0) {", "-      sign = 0;", "-    }", "-    return Eigen::numext::bit_cast<float8_e4m3b11>(", "-        static_cast<typename Base::BitsType>(bits | sign));", "-  }", " };", " ", "-// Shift bits in the appropriate directions and add the exponent offset", "-// to convert between bit representations.  The input `in` must be a", "-// positive normalized value.", "-template <typename From, typename To,", "-          typename FromBits = typename Traits<From>::BitsType,", "-          typename ToBits = typename Traits<To>::BitsType>", "-constexpr FromBits ToFromBits(ToBits in) {", "-  using FromTraits = Traits<From>;", "-  constexpr int kFromMantissaBits = FromTraits::kMantissaBits;", "-  constexpr int kFromExponentBias = FromTraits::kExponentBias;", "-", "-  using ToTraits = Traits<To>;", "-  constexpr int kToMantissaBits = ToTraits::kMantissaBits;", "-  constexpr int kToExponentBias = ToTraits::kExponentBias;", "-", "-  constexpr int kExponentOffset = kFromExponentBias - kToExponentBias;", "-  constexpr int kDigitShift = kFromMantissaBits - kToMantissaBits;", "-", "-  FromBits out = static_cast<FromBits>(in);", "-  if constexpr (kDigitShift > 0) {", "-    out <<= kDigitShift;", "-  } else if constexpr (kDigitShift < 0) {", "-    out >>= -kDigitShift;", "-  }", "-  out += static_cast<FromBits>(kExponentOffset) << kFromMantissaBits;", "-  return out;", "-}", "-", " template <typename Bits>", " constexpr inline Bits RoundBitsToNearestEven(Bits bits, int roundoff) {", "   // Round to nearest even by adding a bias term.", "@@ -762,7 +693,7 @@ template <typename From, typename To, bool kSaturate, bool kTruncate>", " struct ConvertImpl<From, To, kSaturate, kTruncate,", "                    std::enable_if_t<!std::is_same_v<From, To>>> {", "   using FromTraits = Traits<From>;", "-  using FromBits = typename GetUnsignedInteger<sizeof(From)>::type;", "+  using FromBits = typename FromTraits::BitsType;", "   static constexpr int kFromBits = FromTraits::kBits;", "   static constexpr int kFromMantissaBits = FromTraits::kMantissaBits;", "   static constexpr int kFromExponentBits = FromTraits::kExponentBits;", "@@ -770,55 +701,50 @@ struct ConvertImpl<From, To, kSaturate, kTruncate,", "   static constexpr FromBits kFromExponentMask = FromTraits::kExponentMask;", " ", "   using ToTraits = Traits<To>;", "-  using ToBits = typename GetUnsignedInteger<sizeof(To)>::type;", "+  using ToBits = typename ToTraits::BitsType;", "   static constexpr int kToBits = ToTraits::kBits;", "   static constexpr int kToMantissaBits = ToTraits::kMantissaBits;", "   static constexpr int kToExponentBits = ToTraits::kExponentBits;", "   static constexpr int kToExponentBias = ToTraits::kExponentBias;", "   static constexpr ToBits kToExponentMask = ToTraits::kExponentMask;", " ", "+  // `WideBits` is wide enough to accomodate the largest exponent and mantissa", "+  // in either `From` or `To`.", "+  static constexpr int kWideBits =", "+      (std::max(kToMantissaBits, kFromMantissaBits)) +  // Max significand.", "+      (std::max(kToExponentBits, kFromExponentBits));   // Max exponent.", "+  static constexpr int kWideBytes = (kWideBits + (CHAR_BIT - 1)) / CHAR_BIT;", "+  using WideBits = GetUnsignedInteger<kWideBytes>;", "   static constexpr int kExponentOffset = kToExponentBias - kFromExponentBias;", "   static constexpr int kDigitShift = kToMantissaBits - kFromMantissaBits;", "-  static constexpr int kSignShift = kToBits - kFromBits;", " ", "   static EIGEN_DEVICE_FUNC inline To run(const From& from) {", "     // Shift bits to destination type, without sign bit.", "-    FromBits from_bits = Eigen::numext::bit_cast<FromBits>(from);", "-    const FromBits from_sign =", "-        from_bits ^ Eigen::numext::bit_cast<FromBits>(Eigen::numext::abs(from));", "-    ToBits sign;", "-    if constexpr (kSignShift >= 0) {", "-      sign = ToBits{from_sign} << kSignShift;", "-    } else if constexpr (kSignShift < 0) {", "-      sign = static_cast<ToBits>(from_sign >> -kSignShift);", "-    }", "-    from_bits ^= from_sign;  // Zeros sign bit to obtain absolute value.", "+    const bool from_sign_bit =", "+        Eigen::numext::bit_cast<FromBits>(from) >> (kFromBits - 1);", "+    const FromBits from_bits =", "+        Eigen::numext::bit_cast<FromBits>(Eigen::numext::abs(from));", " ", "     // Special values, preserving sign.", "     if (Eigen::numext::isinf(from)) {", "-      return sign != 0 ? -Eigen::NumTraits<To>::infinity()", "-                       : Eigen::NumTraits<To>::infinity();", "+      return from_sign_bit ? -Eigen::NumTraits<To>::infinity()", "+                           : Eigen::NumTraits<To>::infinity();", "     }", "     if (Eigen::numext::isnan(from)) {", "-      return sign != 0 ? -Eigen::NumTraits<To>::quiet_NaN()", "-                       : Eigen::NumTraits<To>::quiet_NaN();", "+      return from_sign_bit ? -Eigen::NumTraits<To>::quiet_NaN()", "+                           : Eigen::NumTraits<To>::quiet_NaN();", "     }", "     if (from_bits == 0) {", "-      return ToTraits::ConstructFromSignAndBits(/*sign=*/sign, /*bits=*/0);", "+      return from_sign_bit ? -To{} : To{};", "     }", " ", "-    // Adjust mantissa.", "-    FromBits rounded_from_bits = from_bits;", "-    if constexpr (kDigitShift < 0) {", "-      if constexpr (!kTruncate) {", "-        rounded_from_bits = RoundBitsToNearestEven(from_bits, -kDigitShift);", "-      }", "-      // Zero-out tail bits.", "-      rounded_from_bits &= ~((FromBits{1} << (-kDigitShift)) - 1);", "-    }", "+    const int biased_from_exponent = from_bits >> kFromMantissaBits;", " ", "-    if constexpr (kExponentOffset > 0) {", "-      if ((from.rep() & kFromExponentMask) == 0) {", "+    // `To` supports more exponents near zero which means that some subnormal", "+    // values in `From` may become normal.", "+    if constexpr (std::numeric_limits<To>::min_exponent <", "+                  std::numeric_limits<From>::min_exponent) {", "+      if (biased_from_exponent == 0) {", "         // Subnormals.", "         ToBits bits = from_bits;", " ", "@@ -835,29 +761,20 @@ struct ConvertImpl<From, To, kSaturate, kTruncate,", "         // Insert the exponent bits.", "         bits |= static_cast<ToBits>(kExponentOffset - normalization_factor + 1)", "                 << kToMantissaBits;", "-        return ToTraits::ConstructFromSignAndBits(/*sign=*/sign, /*bits=*/bits);", "-      }", "-    } else if constexpr (kExponentOffset < 0) {", "-      // Check for overflows.", "-", "-      // Shift up exponent and mantissa, add offset to adjust exponent to", "-      // source type.", "-      constexpr ToBits kToHighest = Eigen::NumTraits<To>::highest().rep();", "-      constexpr FromBits kHighest = ToFromBits<From, To>(kToHighest);", "-", "-      if (rounded_from_bits > kHighest) {", "-        ToBits bits =", "-            kSaturate ? kToHighest : Eigen::NumTraits<To>::infinity().rep();", "-        return ToTraits::ConstructFromSignAndBits(/*sign=*/sign, /*bits=*/bits);", "+        To to = Eigen::numext::bit_cast<To>(bits);", "+        return from_sign_bit ? -to : to;", "       }", "-", "+    }", "+    // `To` supports fewer exponents near zero which means that some values in", "+    // `From` may become subnormal.", "+    if constexpr (std::numeric_limits<To>::min_exponent >", "+                  std::numeric_limits<From>::min_exponent) {", "+      const int unbiased_exponent = biased_from_exponent - kFromExponentBias;", "+      const int biased_to_exponent = unbiased_exponent + kToExponentBias;", "       // Subnormals and zero.", "-      constexpr FromBits kLowestNormal =", "-          ToFromBits<From, To>(std::numeric_limits<To>::min().rep());", "-      if (rounded_from_bits < kLowestNormal) {", "+      if (biased_to_exponent <= 0) {", "         // Round and shift mantissa down.", "-        int exponent = ((from_bits >> kFromMantissaBits) - kFromExponentBias);", "-        int exponent_shift = -kDigitShift - exponent - kToExponentBias + 1;", "+        int exponent_shift = -kDigitShift - biased_to_exponent + 1;", " ", "         // Insert the implicit leading 1 bit on the mantissa.  This assumes", "         // the input is normalized.  If it is not, then the mantissa bits -", "@@ -866,8 +783,8 @@ struct ConvertImpl<From, To, kSaturate, kTruncate,", "         // the lower precision bits may already be lost.  There is an edge-case", "         // where rounding to a normalized value would normally round down,", "         // but for a subnormal, we need to round up.", "-        rounded_from_bits = ((from_bits & FromTraits::kMantissaMask) |", "-                             (FromBits{1} << kFromMantissaBits));", "+        FromBits rounded_from_bits = ((from_bits & FromTraits::kMantissaMask) |", "+                                      (FromBits{1} << kFromMantissaBits));", "         ToBits bits = 0;", "         // To avoid UB, limit rounding and shifting to the full mantissa plus", "         // leading 1.", "@@ -879,22 +796,55 @@ struct ConvertImpl<From, To, kSaturate, kTruncate,", "           bits = (rounded_from_bits >> exponent_shift);", "         }", "         // Insert sign and return.", "-        return ToTraits::ConstructFromSignAndBits(/*sign=*/sign, /*bits=*/bits);", "+        To to = Eigen::numext::bit_cast<To>(bits);", "+        return from_sign_bit ? -to : to;", "       }", "     }", " ", "-    // Shift bits.", "+    // Round the mantissa if it is shrinking.", "+    WideBits rounded_from_bits = from_bits;", "+    if constexpr (kDigitShift < 0) {", "+      if constexpr (!kTruncate) {", "+        rounded_from_bits = RoundBitsToNearestEven(from_bits, -kDigitShift);", "+      }", "+      // Zero-out tail bits.", "+      rounded_from_bits &= ~((WideBits{1} << (-kDigitShift)) - 1);", "+    }", "+", "+    // Re-bias the exponent.", "+    rounded_from_bits += static_cast<WideBits>(kExponentOffset)", "+                         << kFromMantissaBits;", "+", "     ToBits bits;", "+    // Check for overflows by aligning the significands. We always align the", "+    // narrower significand to the wider significand.", "+    const WideBits kToHighestRep =", "+        Eigen::numext::bit_cast<ToBits>(Eigen::NumTraits<To>::highest());", "+    WideBits aligned_highest{kToHighestRep};", "     if constexpr (kDigitShift < 0) {", "+      aligned_highest <<= -kDigitShift;", "+      // Shift down, all dropped bits should already be zero.", "       bits = static_cast<ToBits>(rounded_from_bits >> -kDigitShift);", "     } else if constexpr (kDigitShift >= 0) {", "-      bits = ToBits{rounded_from_bits} << kDigitShift;", "+      // Shift up, inserting zeros in the newly created digits.", "+      rounded_from_bits <<= kDigitShift;", "+      bits = ToBits{rounded_from_bits};", "     }", "-    // Increase exponent by offset difference.", "-    bits += static_cast<ToBits>(kExponentOffset) << kToMantissaBits;", " ", "+    To to = Eigen::numext::bit_cast<To>(bits);", "+    // `From` supports larger values than `To`, we may overflow.", "+    if constexpr (std::make_pair(std::numeric_limits<To>::max_exponent,", "+                                 std::numeric_limits<To>::digits) <", "+                  std::make_pair(std::numeric_limits<From>::max_exponent,", "+                                 std::numeric_limits<From>::digits)) {", "+      if (rounded_from_bits > aligned_highest) {", "+        // Overflowed values map to highest or infinity depending on kSaturate.", "+        to = kSaturate ? Eigen::NumTraits<To>::highest()", "+                       : Eigen::NumTraits<To>::infinity();", "+      }", "+    }", "     // Insert sign bit.", "-    return ToTraits::ConstructFromSignAndBits(/*sign=*/sign, /*bits=*/bits);", "+    return from_sign_bit ? -to : to;", "   }", " };", " ", "@@ -930,7 +880,7 @@ struct ConvertImpl<Eigen::half, float8_e5m2, kSaturate, kTruncate> {", "       // value if saturation is requested.", "       if constexpr (kSaturate) {", "         const float8_e5m2 kHighest = Eigen::NumTraits<float8_e5m2>::highest();", "-        if ((from_bits & 0x7FFF) > static_cast<uint16_t>(kHighest.rep()) << 8) {", "+        if ((from_bits & 0x7F00) > static_cast<uint16_t>(kHighest.rep()) << 8) {", "           const bool from_sign_bit = from_bits >> 15;", "           return from_sign_bit ? -kHighest : kHighest;", "         }", "@@ -1163,43 +1163,14 @@ template <typename T>", " struct Ceil {", "   T operator()(T a) { return T(std::ceil(static_cast<float>(a))); }", " };", "-", "-// Helper struct for getting a bit representation provided a byte size.", "-template <int kNumBytes>", "-struct GetUnsignedInteger;", "-", "-template <>", "-struct GetUnsignedInteger<1> {", "-  using type = uint8_t;", "-};", "-", "-template <>", "-struct GetUnsignedInteger<2> {", "-  using type = uint16_t;", "-};", "-", "-template <typename T>", "-using BitsType = typename GetUnsignedInteger<sizeof(T)>::type;", "-", "-template <typename T>", "-std::pair<BitsType<T>, BitsType<T>> SignAndMagnitude(T x) {", "-  const BitsType<T> x_abs_bits =", "-      Eigen::numext::bit_cast<BitsType<T>>(Eigen::numext::abs(x));", "-  const BitsType<T> x_bits = Eigen::numext::bit_cast<BitsType<T>>(x);", "-  const BitsType<T> x_sign = x_bits ^ x_abs_bits;", "-  return {x_sign, x_abs_bits};", "-}", "-", " template <typename T>", " struct CopySign {", "   T operator()(T a, T b) {", "-    auto [a_sign, a_abs_bits] = SignAndMagnitude(a);", "-    auto [b_sign, b_abs_bits] = SignAndMagnitude(b);", "-    BitsType<T> rep = a_abs_bits | b_sign;", "-    return Eigen::numext::bit_cast<T>(rep);", "+    auto abs_a = Eigen::numext::abs(a);", "+    bool b_sign = static_cast<bool>(Eigen::numext::signbit(b));", "+    return b_sign ? -abs_a : abs_a;", "   }", " };", "-", " template <typename T>", " struct Exp {", "   T operator()(T a) { return T(std::exp(static_cast<float>(a))); }", "@@ -1344,10 +1315,7 @@ struct Sign {", " };", " template <typename T>", " struct SignBit {", "-  bool operator()(T a) {", "-    auto [sign_a, abs_a] = SignAndMagnitude(a);", "-    return sign_a;", "-  }", "+  bool operator()(T a) { return static_cast<bool>(Eigen::numext::signbit(a)); }", " };", " template <typename T>", " struct Sqrt {", "@@ -1507,40 +1475,35 @@ struct LogicalXor {", " ", " template <typename T>", " struct NextAfter {", "+  using BitsType =", "+      typename Eigen::numext::get_integer_by_size<sizeof(T)>::unsigned_type;", "   T operator()(T from, T to) {", "-    BitsType<T> from_rep = Eigen::numext::bit_cast<BitsType<T>>(from);", "-    BitsType<T> to_rep = Eigen::numext::bit_cast<BitsType<T>>(to);", "     if (Eigen::numext::isnan(from) || Eigen::numext::isnan(to)) {", "       return std::numeric_limits<T>::quiet_NaN();", "     }", "-    if (from_rep == to_rep) {", "+    if (from == to) {", "       return to;", "     }", "-    auto [from_sign, from_abs] = SignAndMagnitude(from);", "-    auto [to_sign, to_abs] = SignAndMagnitude(to);", "-    if (from_abs == 0) {", "-      if (to_abs == 0) {", "-        return to;", "-      } else {", "-        // Smallest subnormal signed like `to`.", "-        return Eigen::numext::bit_cast<T>(", "-            static_cast<BitsType<T>>(0x01 | to_sign));", "-      }", "+    CopySign<T> copysign;", "+    if (from == T(0)) {", "+      // Smallest subnormal signed like `to`.", "+      return copysign(std::numeric_limits<T>::denorm_min(), to);", "     }", "-    BitsType<T> magnitude_adjustment =", "-        (from_abs > to_abs || from_sign != to_sign)", "-            ? static_cast<BitsType<T>>(-1)", "-            : static_cast<BitsType<T>>(1);", "-    BitsType<T> out_int = from_rep + magnitude_adjustment;", "-    T out = Eigen::numext::bit_cast<T>(out_int);", "     // Some non-IEEE compatible formats may have a representation for NaN", "     // instead of -0, ensure we return a zero in such cases.", "+    const bool from_is_bigger = from > to;", "     if constexpr (!std::numeric_limits<T>::is_iec559) {", "-      if (Eigen::numext::isnan(out)) {", "-        return Eigen::numext::bit_cast<T>(BitsType<T>{0});", "+      if (from == std::numeric_limits<T>::denorm_min() && from_is_bigger) {", "+        return copysign(T(0), from);", "       }", "     }", "-    return out;", "+    const bool from_sign = static_cast<bool>(Eigen::numext::signbit(from));", "+    const BitsType magnitude_adjustment = from_is_bigger != from_sign", "+                                              ? static_cast<BitsType>(-1)", "+                                              : static_cast<BitsType>(1);", "+    const BitsType from_rep = Eigen::numext::bit_cast<BitsType>(from);", "+    const BitsType out_int = from_rep + magnitude_adjustment;", "+    return Eigen::numext::bit_cast<T>(out_int);", "   }", " };", " ", "@@ -4,7 +4,6 @@ load(\"//tensorflow:tensorflow.default.bzl\", \"cuda_py_test\", \"tf_py_test\")", " ", " package(", "     # copybara:uncomment default_applicable_licenses = [\"//tensorflow:license\"],", "-    default_visibility = [\"//tensorflow:internal\"],", "     licenses = [\"notice\"],", " )", " ", "@@ -155,217 +155,165 @@ This release contains contributions from many people at Google, as well as:", " ", " # Release 2.12.0", " ", "-# Breaking Changes", "-", "-* <DOCUMENT BREAKING CHANGES HERE>", "-* <THIS SECTION SHOULD CONTAIN API, ABI AND BEHAVIORAL BREAKING CHANGES>", "+### Breaking Changes", " ", " *   Build, Compilation and Packaging", " ", "-    *   Removal of redundant packages: the `tensorflow-gpu` and `tf-nightly-gpu`", "-        packages have been effectively removed and replaced with packages that", "-        direct users to switch to `tensorflow` or `tf-nightly` respectively.", "-        The naming difference was the only difference between the two sets of", "-        packages ever since TensorFlow 2.1, so there is no loss of functionality", "-        or GPU support. See", "-        https://pypi.org/project/tensorflow-gpu for more details.", "+    *   Removed redundant packages `tensorflow-gpu` and `tf-nightly-gpu`. These packages were removed and replaced with packages that direct users to switch to `tensorflow` or `tf-nightly` respectively. Since TensorFlow 2.1, the only difference between these two sets of packages was their names, so there is no loss of functionality or GPU support. See https://pypi.org/project/tensorflow-gpu for more details.", " ", " *   `tf.function`:", " ", "-    *   tf.function now uses the Python inspect library directly for parsing", "-        the signature of the Python function it is decorated on.", "-    *   This can break certain cases that were previously ignored where the", "-        signature is malformed, e.g.", "-            *   Using functools.wraps on a function with different signature", "-            *   Using functools.partial with an invalid tf.function input", "-    *   tf.function now enforces input parameter names to be valid Python", "-        identifiers. Incompatible names are automatically sanitized similarly to", "-        existing SavedModel signature behavior.", "-    *   Parameterless tf.functions are assumed to have an empty input_signature", "-        instead of an undefined one even if the input_signature is unspecified.", "-    *   tf.types.experimental.TraceType now requires an additional", "-        `placeholder_value` method to be defined.", "-    *   tf.function now traces with placeholder values generated by TraceType", "-        instead of the value itself.", "-", "-*   `tf.config.experimental.enable_mlir_graph_optimization`:", "-", "-    * Experimental API removed.", "-", "-*   `tf.config.experimental.disable_mlir_graph_optimization`:", "-", "-    * Experimental API removed.", "-", "-*   `tf.keras`", "-", "-    * Moved all saving-related utilities to a new namespace, `keras.saving`,", "-      i.e. `keras.saving.load_model`, `keras.saving.save_model`,", "-      `keras.saving.custom_object_scope`, `keras.saving.get_custom_objects`,", "-      `keras.saving.register_keras_serializable`,", "-      `keras.saving.get_registered_name` and", "-      `keras.saving.get_registered_object`.", "-      The previous API locations (in `keras.utils` and `keras.models`) will", "-      stay available indefinitely, but we recommend that you update your code", "-      to point to the new API locations.", "-    * Improvements and fixes in Keras loss masking:", "-        * Whether you represent a ragged tensor as a `tf.RaggedTensor` or using", "-          [keras masking](https://www.tensorflow.org/guide/keras/masking_and_padding),", "-          the returned loss values should be the identical to each other.", "-          In previous versions Keras may have silently ignored the mask.", "-        * If you use masked losses with Keras the loss values may be different", "-          in TensorFlow `2.12` compared to previous versions.", "-        * In cases where the mask was previously ignored, you will now get", "-          an error if you pass a mask with an incompatible shape.", "-", "-*   `tf.SavedModel`", "-", "-    * Introduce new class `tf.saved_model.experimental.Fingerprint` that", "-      contains the fingerprint of the SavedModel. See the", "-      [SavedModel Fingerprinting RFC](https://github.com/tensorflow/community/pull/415)", "-      for details.", "-    * Introduce API `tf.saved_model.experimental.read_fingerprint(export_dir)`", "-      for reading the fingerprint of a SavedModel.", "-", "+    *   `tf.function` now uses the Python inspect library directly for parsing the signature of the Python function it is decorated on. This change may break code where the function signature is malformed, but was ignored previously, such as:", "+        *   Using `functools.wraps` on a function with different signature", "+        *   Using `functools.partial` with an invalid `tf.function` input", "+    *   `tf.function` now enforces input parameter names to be valid Python identifiers. Incompatible names are automatically sanitized similarly to existing SavedModel signature behavior.", "+    *   Parameterless `tf.function`s are assumed to have an empty `input_signature` instead of an undefined one even if the `input_signature` is unspecified.", "+    *   `tf.types.experimental.TraceType` now requires an additional `placeholder_value` method to be defined.", "+    *   `tf.function` now traces with placeholder values generated by TraceType instead of the value itself.", " ", "-# Known Caveats", "+*   Experimental APIs `tf.config.experimental.enable_mlir_graph_optimization` and `tf.config.experimental.disable_mlir_graph_optimization` were removed.", " ", "-* <CAVEATS REGARDING THE RELEASE (BUT NOT BREAKING CHANGES).>", "-* <ADDING/BUMPING DEPENDENCIES SHOULD GO HERE>", "-* <KNOWN LACK OF SUPPORT ON SOME PLATFORM, SHOULD GO HERE>", "+### Major Features and Improvements", " ", "-# Major Features and Improvements", "+*  Support for Python 3.11 has been added.", "+*  Support for Python 3.7 has been removed. We are not releasing any more patches for Python 3.7.", " ", " *   `tf.lite`:", " ", "     *   Add 16-bit float type support for built-in op `fill`.", "     *   Transpose now supports 6D tensors.", "-    *   Float LSTM now supports diagonal recurrent tensors:", "-        https://arxiv.org/abs/1903.08023", "-", "-*   `tf.keras`:", "-", "-    *   The new Keras model saving format (`.keras`) is available. You can start", "-        using it via `model.save(f\"{fname}.keras\", save_format=\"keras_v3\")`. In", "-        the future it will become the default for all files with the `.keras`", "-        extension. This file format targets the Python runtime only and makes", "-        it possible to reload Python objects identical to the saved originals.", "-        The format supports non-numerical state such as vocabulary files and", "-        lookup tables, and it is easy to customize in the case of custom layers", "-        with exotic elements of state (e.g. a FIFOQueue). The format", "-        does not rely on bytecode or pickling, and is safe by default. Note", "-        that as a result, Python `lambdas` are disallowed at loading time. If", "-        you want to use `lambdas`, you can pass `safe_mode=False` to the loading", "-        method (only do this if you trust the source of the model).", "-    *   Added a `model.export(filepath)` API to create a lightweight SavedModel", "-        artifact that can be used for inference (e.g. with TF-Serving).", "-    *   Added `keras.export.ExportArchive` class for low-level customization of", "-        the process of exporting SavedModel artifacts for inference.", "-        Both ways of exporting models are based on `tf.function` tracing", "-        and produce a TF program composed of TF ops. They are meant primarily", "-        for environments where the TF runtime is available,", "-        but not the Python interpreter, as is typical", "-        for production with TF Serving.", "-    *   Added utility `tf.keras.utils.FeatureSpace`, a one-stop shop for", "-        structured data preprocessing and encoding.", "-    *   Added `tf.SparseTensor` input support to `tf.keras.layers.Embedding`", "-        layer. The layer now accepts a new boolean argument `sparse`. If", "-        `sparse` is set to True, the layer returns a SparseTensor instead of a", "-        dense Tensor. Defaults to False.", "-    *   Added `jit_compile` as a settable property to `tf.keras.Model`.", "-    *   Added `synchronized` optional parameter to `layers.BatchNormalization`.", "-    *   Added deprecation warning to", "-        `layers.experimental.SyncBatchNormalization` and suggested to use", "-        `layers.BatchNormalization` with `synchronized=True` instead.", "-    *   Updated `tf.keras.layers.BatchNormalization` to support masking of the", "-        inputs (`mask` argument) when computing the mean and variance.", "-    *   Add `tf.keras.layers.Identity`, a placeholder pass-through layer.", "-    *   Add `show_trainable` option to `tf.keras.utils.model_to_dot` to display", "-        layer trainable status in model plots.", "-    *   Add ability to save a `tf.keras.utils.FeatureSpace` object, via", "-        `feature_space.save(\"myfeaturespace.keras\")`, and reload it via", "-        `feature_space = tf.keras.models.load_model(\"myfeaturespace.keras\")`.", "-    *   Added utility `tf.keras.utils.to_ordinal` to convert class vector to", "-        ordinal regression / classification matrix.", "+    *   Float LSTM now supports diagonal recurrent tensors: https://arxiv.org/abs/1903.08023", " ", " *   `tf.experimental.dtensor`:", " ", "-    *   Coordination service now works with", "-        `dtensor.initialize_accelerator_system`, and enabled by default.", "-    *   Add `tf.experimental.dtensor.is_dtensor` to check if a tensor is a", "-        DTensor instance.", "+    *   Coordination service now works with `dtensor.initialize_accelerator_system`, and enabled by default.", "+    *   Add `tf.experimental.dtensor.is_dtensor` to check if a tensor is a DTensor instance.", " ", " *   `tf.data`:", " ", "-    *   Added support for alternative checkpointing protocol which makes it", "-        possible to checkpoint the state of the input pipeline without having to", "-        store the contents of internal buffers. The new functionality can be", "-        enabled through the `experimental_symbolic_checkpoint` option of", "-        `tf.data.Options()`.", "-    *   Added a new `rerandomize_each_iteration` argument for the", "-        `tf.data.Dataset.random()` operation, which controls whether the", "-        sequence of generated random numbers should be re-randomized every epoch", "-        or not (the default behavior). If `seed` is set and", "-        `rerandomize_each_iteration=True`, the `random()` operation will produce", "-        a different (deterministic) sequence of numbers every epoch.", "-    *   Added a new `rerandomize_each_iteration` argument for the", "-        `tf.data.Dataset.sample_from_datasets()` operation, which controls", "-        whether the sequence of generated random numbers used for sampling", "-        should be re-randomized every epoch or not. If `seed` is set and", "-        `rerandomize_each_iteration=True`, the `sample_from_datasets()`", "-        operation will use a different (deterministic) sequence of numbers every", "-        epoch.", "-    *   Added a new field, `warm_start`, to", "-        `tf.data.experimental.OptimizationOptions`. If it is set to `True`,", "-        tf.data will start background threads of asynchronous", "-        transformations upon iterator creation (as opposed to upon first call", "-        to `GetNext`). To enable this behavior, set `warm_start=True` in", "-        `tf.data.experimental.OptimizationOptions`. It should be noted that this", "-        possibly improves the latency of the initial 'GetNext' call at the", "-        expense of requiring more memory to hold prefetched elements between", "-        the time of iterator construction and usage.", "+    *   Added support for alternative checkpointing protocol which makes it possible to checkpoint the state of the input pipeline without having to store the contents of internal buffers. The new functionality can be enabled through the `experimental_symbolic_checkpoint` option of `tf.data.Options()`.", "+    *   Added a new `rerandomize_each_iteration` argument for the `tf.data.Dataset.random()` operation, which controls whether the sequence of generated random numbers should be re-randomized every epoch or not (the default behavior). If `seed` is set and `rerandomize_each_iteration=True`, the `random()` operation will produce a different (deterministic) sequence of numbers every epoch.", "+    *   Added a new `rerandomize_each_iteration` argument for the `tf.data.Dataset.sample_from_datasets()` operation, which controls whether the sequence of generated random numbers used for sampling should be re-randomized every epoch or not. If `seed` is set and `rerandomize_each_iteration=True`, the `sample_from_datasets()` operation will use a different (deterministic) sequence of numbers every epoch.", "+", " *   `tf.test`:", " ", "-    *   Added `tf.test.experimental.sync_devices`, which is useful for", "-        accurately measuring performance in benchmarks.", "+    *   Added `tf.test.experimental.sync_devices`, which is useful for accurately measuring performance in benchmarks.", " ", " *   `tf.experimental.dtensor`:", " ", "     *   Added experimental support to ReduceScatter fuse on GPU (NCCL).", " ", "-# Bug Fixes and Other Changes", "-", "-* <SIMILAR TO ABOVE SECTION, BUT FOR OTHER IMPORTANT CHANGES / BUG FIXES>", "-* <IF A CHANGE CLOSES A GITHUB ISSUE, IT SHOULD BE DOCUMENTED HERE>", "-* <NOTES SHOULD BE GROUPED PER AREA>", "+### Bug Fixes and Other Changes", " ", "+*   `tf.SavedModel`:", "+    * Introduced new class `tf.saved_model.experimental.Fingerprint` that contains the fingerprint of the SavedModel. See the [SavedModel Fingerprinting RFC](https://github.com/tensorflow/community/pull/415) for details.", "+    * Introduced API `tf.saved_model.experimental.read_fingerprint(export_dir)` for reading the fingerprint of a SavedModel.", " * `tf.random`", "-  * Added non-experimental aliases for `tf.random.split` and", "-    `tf.random.fold_in`, the experimental endpoints are still available", "-    so no code changes are necessary.", "+  * Added non-experimental aliases for `tf.random.split` and `tf.random.fold_in`, the experimental endpoints are still available so no code changes are necessary.", " * `tf.experimental.ExtensionType`", "-  * Added function `experimental.extension_type.as_dict()`, which converts an", "-    instance of `tf.experimental.ExtensionType` to a `dict` representation.", "+  * Added function `experimental.extension_type.as_dict()`, which converts an instance of `tf.experimental.ExtensionType` to a `dict` representation.", " * `stream_executor`", "-  * Top level `stream_executor` directory has been deleted, users should use", "-    equivalent headers and targets under `compiler/xla/stream_executor`.", "+  * Top level `stream_executor` directory has been deleted, users should use equivalent headers and targets under `compiler/xla/stream_executor`.", " * `tf.nn`", "-  * Added `tf.nn.experimental.general_dropout`, which is similar to", "-    `tf.random.experimental.stateless_dropout` but accepts a custom sampler", "-    function.", "+  * Added `tf.nn.experimental.general_dropout`, which is similar to `tf.random.experimental.stateless_dropout` but accepts a custom sampler function.", " * `tf.types.experimental.GenericFunction`", "-  * The `experimental_get_compiler_ir` method supports tf.TensorSpec", "-   compilation arguments.", "+  * The `experimental_get_compiler_ir` method supports tf.TensorSpec compilation arguments.", " *  `tf.config.experimental.mlir_bridge_rollout`", "-    *   Removed enums `MLIR_BRIDGE_ROLLOUT_SAFE_MODE_ENABLED` and", "-    `MLIR_BRIDGE_ROLLOUT_SAFE_MODE_FALLBACK_ENABLED` which are no longer used by", "-    the tf2xla bridge", "+    *   Removed enums `MLIR_BRIDGE_ROLLOUT_SAFE_MODE_ENABLED` and `MLIR_BRIDGE_ROLLOUT_SAFE_MODE_FALLBACK_ENABLED` which are no longer used by the tf2xla bridge", "+", "+## Keras", "+", "+ Keras is a framework built on top of the TensorFlow. See more details on the Keras [website](https://keras.io/).", "+", "+### Breaking Changes", "+", " ", "+`tf.keras`:", " ", "-# Thanks to our Contributors", "+* Moved all saving-related utilities to a new namespace, `keras.saving`, for example: `keras.saving.load_model`, `keras.saving.save_model`, `keras.saving.custom_object_scope`, `keras.saving.get_custom_objects`, `keras.saving.register_keras_serializable`,`keras.saving.get_registered_name` and `keras.saving.get_registered_object`. The previous API locations (in `keras.utils` and `keras.models`) will be available indefinitely, but we recommend you update your code to point to the new API locations.", "+ * Improvements and fixes in Keras loss masking:", "+    * Whether you represent a ragged tensor as a `tf.RaggedTensor` or using [keras masking](https://www.tensorflow.org/guide/keras/masking_and_padding), the returned loss values should be the identical to each other. In previous versions Keras may have silently ignored the mask.", "+ * If you use masked losses with Keras the loss values may be different in TensorFlow `2.12` compared to previous versions.", "+ * In cases where the mask was previously ignored, you will now get an error if you pass a mask with an incompatible shape.", "+", "+### Major Features and Improvements", "+", "+`tf.keras`:", "+", "+ *   The new Keras model saving format (`.keras`) is available. You can start using it via `model.save(f\"{fname}.keras\", save_format=\"keras_v3\")`. In the future it will become the default for all files with the `.keras` extension. This file format targets the Python runtime only and makes it possible to reload Python objects identical to the saved originals. The format supports non-numerical state such as vocabulary files and lookup tables, and it is easy to customize in the case of custom layers with exotic elements of state (e.g. a FIFOQueue). The format does not rely on bytecode or pickling, and is safe by default. Note that as a result, Python `lambdas` are disallowed at loading time. If you want to use `lambdas`, you can pass `safe_mode=False` to the loading method (only do this if you trust the source of the model).", "+*   Added a `model.export(filepath)` API to create a lightweight SavedModel artifact that can be used for inference (e.g. with TF-Serving).", "+*   Added `keras.export.ExportArchive` class for low-level customization of the process of exporting SavedModel artifacts for inference. Both ways of exporting models are based on `tf.function` tracing and produce a TF program composed of TF ops. They are meant primarily for environments where the TF runtime is available, but not the Python interpreter, as is typical for production with TF Serving.", "+ *   Added utility `tf.keras.utils.FeatureSpace`, a one-stop shop for structured data preprocessing and encoding.", "+ *   Added `tf.SparseTensor` input support to `tf.keras.layers.Embedding` layer. The layer now accepts a new boolean argument `sparse`. If `sparse` is set to True, the layer returns a SparseTensor instead of a dense Tensor. Defaults to False.", "+ *   Added `jit_compile` as a settable property to `tf.keras.Model`.", "+ *   Added `synchronized` optional parameter to `layers.BatchNormalization`.", "+ *   Added deprecation warning to `layers.experimental.SyncBatchNormalization` and suggested to use `layers.BatchNormalization` with `synchronized=True` instead.", "+ *   Updated `tf.keras.layers.BatchNormalization` to support masking of the inputs (`mask` argument) when computing the mean and variance.", "+ *   Add `tf.keras.layers.Identity`, a placeholder pass-through layer.", "+ *   Add `show_trainable` option to `tf.keras.utils.model_to_dot` to display layer trainable status in model plots.", "+ *   Add ability to save a `tf.keras.utils.FeatureSpace` object, via `feature_space.save(\"myfeaturespace.keras\")`, and reload it via `feature_space = tf.keras.models.load_model(\"myfeaturespace.keras\")`.", "+*   Added utility `tf.keras.utils.to_ordinal` to convert class vector to ordinal regression / classification matrix.", "+", "+### Bug Fixes and Other Changes", "+", "+*   N/A", "+", "+## Security", "+", "+*   Fixes an FPE in TFLite in conv kernel [CVE-2023-27579](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-27579)", "+*   Fixes a double free in Fractional(Max/Avg)Pool [CVE-2023-25801](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25801)", "+*   Fixes a null dereference on ParallelConcat with XLA [CVE-2023-25676](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25676)", "+*   Fixes a segfault in Bincount with XLA [CVE-2023-25675](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25675)", "+*   Fixes an NPE in RandomShuffle with XLA enable [CVE-2023-25674](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25674)", "+*   Fixes an FPE in TensorListSplit with XLA [CVE-2023-25673](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25673)", "+*   Fixes segmentation fault in tfg-translate [CVE-2023-25671](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25671)", "+*   Fixes an NPE in QuantizedMatMulWithBiasAndDequantize [CVE-2023-25670](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25670)", "+*   Fixes an FPE in AvgPoolGrad with XLA [CVE-2023-25669](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25669)", "+*   Fixes a heap out-of-buffer read vulnerability in the QuantizeAndDequantize operation [CVE-2023-25668](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25668)", "+*   Fixes a segfault when opening multiframe gif [CVE-2023-25667](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25667)", "+*   Fixes an NPE in SparseSparseMaximum [CVE-2023-25665](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25665)", "+*   Fixes an FPE in AudioSpectrogram [CVE-2023-25666](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25666)", "+*   Fixes a heap-buffer-overflow in AvgPoolGrad  [CVE-2023-25664](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25664)", "+*   Fixes a NPE in TensorArrayConcatV2  [CVE-2023-25663](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25663)", "+*   Fixes a Integer overflow in EditDistance  [CVE-2023-25662](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25662)", "+*   Fixes a Seg fault in `tf.raw_ops.Print` [CVE-2023-25660](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25660)", "+*   Fixes a OOB read in DynamicStitch [CVE-2023-25659](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25659)", "+*   Fixes a OOB Read in GRUBlockCellGrad [CVE-2023-25658](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25658)", "+", "+## Thanks to our Contributors", " ", " This release contains contributions from many people at Google, as well as:", " ", "-<INSERT>, <NAME>, <HERE>, <USING>, <GITHUB>, <HANDLE>", "+103yiran, 8bitmp3, Aakar, Aakar Dwivedi, Abinash Satapathy, Aditya Kane, ag.ramesh, Alexander Grund, Andrei Pikas, andreii, Andrew Goodbody, angerson, Anthony_256, Ashay Rane, Ashiq Imran, Awsaf, Balint Cristian, Banikumar Maiti (Intel Aipg), Ben Barsdell, bhack, cfRod, Chao Chen, chenchongsong, Chris Mc, Daniil Kutz, David Rubinstein, dianjiaogit, dixr, Dongfeng Yu, dongfengy, drah, Eric Kunze, Feiyue Chen, Frederic Bastien, Gauri1 Deshpande, guozhong.zhuang, hDn248, HYChou, ingkarat, James Hilliard, Jason Furmanek, Jaya, Jens Glaser, Jerry Ge, Jiao Dian'S Power Plant, Jie Fu, Jinzhe Zeng, Jukyy, Kaixi Hou, Kanvi Khanna, Karel Ha, karllessard, Koan-Sin Tan, Konstantin Beluchenko, Kulin Seth, Kun Lu, Kyle Gerard Felker, Leopold Cambier, Lianmin Zheng, linlifan, liuyuanqiang, Lukas Geiger, Luke Hutton, Mahmoud Abuzaina, Manas Mohanty, Mateo Fidabel, Maxiwell S. Garcia, Mayank Raunak, mdfaijul, meatybobby, Meenakshi Venkataraman, Michael Holman, Nathan John Sircombe, Nathan Luehr, nitins17, Om Thakkar, Patrice Vignola, Pavani Majety, per1234, Philipp Hack, pollfly, Prianka Liz Kariat, Rahul Batra, rahulbatra85, ratnam.parikh, Rickard Hallerb\u00e4ck, Roger Iyengar, Rohit Santhanam, Roman Baranchuk, Sachin Muradi, sanadani, Saoirse Stewart, seanshpark, Shawn Wang, shuw, Srinivasan Narayanamoorthy, Stewart Miles, Sunita Nadampalli, SuryanarayanaY, Takahashi Shuuji, Tatwai Chong, Thibaut Goetghebuer-Planchon, tilakrayal, Tirumalesh, TJ, Tony Sung, Trevor Morris, unda, Vertexwahn, Vinila S, William Muir, Xavier Bonaventura, xiang.zhang, Xiao-Yong Jin, yleeeee, Yong Tang, Yuriy Chernyshov, Zhang, Xiangze, zhaozheng09", "+", "+", "+# Release 2.11.1", "+", "+**Note**: TensorFlow 2.10 was the last TensorFlow release that supported GPU on native-Windows. Starting with TensorFlow 2.11, you will need to install TensorFlow in WSL2, or install tensorflow-cpu and, optionally, try the TensorFlow-DirectML-Plugin.", "+*   Security vulnerability fixes will no longer be patched to this Tensorflow version. The latest Tensorflow version includes the security vulnerability fixes. You can update to the latest version (recommended) or patch security vulnerabilities yourself [steps](https://github.com/tensorflow/tensorflow#patching-guidelines). You can refer to the [release notes](https://github.com/tensorflow/tensorflow/releases) of the latest Tensorflow version for a list of newly fixed vulnerabilities. If you have any questions, please create a GitHub issue to let us know.", "+", "+This release also introduces several vulnerability fixes:", "+", "+*   Fixes an FPE in TFLite in conv kernel [CVE-2023-27579](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-27579)", "+*   Fixes a double free in Fractional(Max/Avg)Pool [CVE-2023-25801](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25801)", "+*   Fixes a null dereference on ParallelConcat with XLA [CVE-2023-25676](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25676)", "+*   Fixes a segfault in Bincount with XLA [CVE-2023-25675](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25675)", "+*   Fixes an NPE in RandomShuffle with XLA enable [CVE-2023-25674](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25674)", "+*   Fixes an FPE in TensorListSplit with XLA [CVE-2023-25673](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25673)", "+*   Fixes segmentation fault in tfg-translate [CVE-2023-25671](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25671)", "+*   Fixes an NPE in QuantizedMatMulWithBiasAndDequantize [CVE-2023-25670](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25670)", "+*   Fixes an FPE in AvgPoolGrad with XLA [CVE-2023-25669](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25669)", "+*   Fixes a heap out-of-buffer read vulnerability in the QuantizeAndDequantize operation [CVE-2023-25668](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25668)", "+*   Fixes a segfault when opening multiframe gif [CVE-2023-25667](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25667)", "+*   Fixes an NPE in SparseSparseMaximum [CVE-2023-25665](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25665)", "+*   Fixes an FPE in AudioSpectrogram [CVE-2023-25666](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25666)", "+*   Fixes a heap-buffer-overflow in AvgPoolGrad  [CVE-2023-25664](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25664)", "+*   Fixes a NPE in TensorArrayConcatV2  [CVE-2023-25663](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25663)", "+*   Fixes a Integer overflow in EditDistance  [CVE-2023-25662](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25662)", "+*   Fixes a Seg fault in `tf.raw_ops.Print` [CVE-2023-25660](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25660)", "+*   Fixes a OOB read in DynamicStitch [CVE-2023-25659](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25659)", "+*   Fixes a OOB Read in GRUBlockCellGrad [CVE-2023-25658](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-25658)", "+", " ", " # Release 2.11.0", " ", "@@ -98,6 +98,23 @@ class Fingerprint(object):", "         pass", "     return False", " ", "+  def __str__(self):", "+    return \"\\n\".join([", "+        f\"SavedModel Fingerprint\",", "+        f\"  saved_model_checksum: {self.saved_model_checksum}\",", "+        f\"  graph_def_program_hash: {self.graph_def_program_hash}\",", "+        f\"  signature_def_hash: {self.signature_def_hash}\",", "+        f\"  saved_object_graph_hash: {self.saved_object_graph_hash}\",", "+        f\"  checkpoint_hash: {self.checkpoint_hash}\"", "+    ])", "+", "+  def __repr__(self):", "+    return (f\"Fingerprint({self.saved_model_checksum}, \"", "+            f\"{self.graph_def_program_hash}, \"", "+            f\"{self.signature_def_hash}, \"", "+            f\"{self.saved_object_graph_hash}, \"", "+            f\"{self.checkpoint_hash})\")", "+", "   def singleprint(self):", "     \"\"\"Canonical fingerprinting ID for a SavedModel.", " ", "@@ -72,6 +72,12 @@ class FingerprintingTest(test.TestCase):", "       fingerprint_def.ParseFromString(f.read())", "     return fingerprint_def", " ", "+  def _read_saved_model(self, filename):", "+    saved_model_def = saved_model_pb2.SavedModel()", "+    with file_io.FileIO(filename, \"rb\") as f:", "+      saved_model_def.ParseFromString(f.read())", "+    return saved_model_def", "+", "   def setUp(self):", "     super().setUp()", "     flags.config().saved_model_fingerprinting.reset(True)", "@@ -134,35 +140,31 @@ class FingerprintingTest(test.TestCase):", "     fingerprint = fingerprinting.read_fingerprint(save_dir)", " ", "     fingerprint_def = self._read_fingerprint(", "-        file_io.join(save_dir, constants.FINGERPRINT_FILENAME)", "-    )", "-", "-    self.assertEqual(", "-        fingerprint.saved_model_checksum, fingerprint_def.saved_model_checksum", "-    )", "-    self.assertEqual(", "-        fingerprint.graph_def_program_hash,", "-        fingerprint_def.graph_def_program_hash,", "-    )", "-    self.assertEqual(", "-        fingerprint.signature_def_hash, fingerprint_def.signature_def_hash", "-    )", "-    self.assertEqual(", "-        fingerprint.saved_object_graph_hash,", "-        fingerprint_def.saved_object_graph_hash,", "-    )", "-    self.assertEqual(", "-        fingerprint.checkpoint_hash, fingerprint_def.checkpoint_hash", "-    )", "-    self.assertEqual(", "-        fingerprint.version.producer, fingerprint_def.version.producer", "-    )", "+        file_io.join(save_dir, constants.FINGERPRINT_FILENAME))", "+", "+    self.assertEqual(fingerprint, fingerprint_def)", " ", "   def test_read_fingerprint_api_invalid(self):", "     with self.assertRaisesRegex(FileNotFoundError,", "                                 \"SavedModel Fingerprint Error\"):", "       fingerprinting.read_fingerprint(\"foo\")", " ", "+  def test_write_fingerprint(self):", "+    save_dir = os.path.join(self.get_temp_dir(), \"model_and_fingerprint\")", "+    save.save_and_return_nodes(", "+        self._create_model_with_data(), save_dir,", "+        experimental_skip_checkpoint=True)  # checkpoint data won't be loaded*", "+", "+    new_dir = os.path.join(self.get_temp_dir(), \"fingerprint_dir\")", "+    os.mkdir(new_dir)", "+    serialized_model = self._read_saved_model(  # *here", "+        os.path.join(save_dir, \"saved_model.pb\")).SerializeToString()", "+    fingerprinting_utils.write_fingerprint(new_dir, serialized_model)", "+", "+    model_fingerprint = fingerprinting.read_fingerprint(save_dir)", "+    solo_fingerprint = fingerprinting.read_fingerprint(new_dir)", "+    self.assertEqual(model_fingerprint, solo_fingerprint)", "+", "   def test_valid_singleprint(self):", "     save_dir = os.path.join(self.get_temp_dir(), \"singleprint_model\")", "     save.save(self._create_model_with_data(), save_dir)", "@@ -46,8 +46,11 @@ def write_fingerprint(export_dir, saved_model_serialized):", "         compat.as_str(export_dir),", "         compat.as_str(constants.FINGERPRINT_FILENAME))", "     logging.info(\"Writing fingerprint to %s\", fingerprint_path)", "-    fingerprint_serialized = fingerprinting_pywrap.CreateFingerprintDef(", "-        saved_model_serialized, export_dir)", "+    try:", "+      fingerprint_serialized = fingerprinting_pywrap.CreateFingerprintDef(", "+          saved_model_serialized, export_dir)", "+    except fingerprinting_pywrap.FingerprintException as e:", "+      raise ValueError(e) from None", "     file_io.atomic_write_string_to_file(fingerprint_path,", "                                         fingerprint_serialized)", "     # We need to deserialize the fingerprint in order to send its values.", "@@ -326,6 +326,86 @@ tfcompile_test_dep_configs = [", "     for suffix, mlir_component in tfcompile_test_dep_configs", " ]", " ", "+tfcompile_bench_tfmatmul_mkn = [", "+    (x, x, x)", "+    for x in (16, 32, 64, 128, 256, 512, 1024)", "+] + [", "+    (1, 2, 256),", "+    (1, 8, 256),", "+    (1, 18, 300),", "+    (1, 37, 256),", "+    (1, 91, 256),", "+    (1, 111, 256),", "+    (1, 192, 192),", "+    (1, 226, 256),", "+    (1, 256, 192),", "+    (1, 256, 256),", "+    (1, 512, 512),", "+    (1, 300, 18),", "+    (21, 24, 1),", "+    (21, 120, 1),", "+    (10, 10, 10),", "+    (100, 100, 100),", "+    (18, 1, 300),", "+    (18, 300, 1),", "+    (300, 1, 18),", "+    (300, 18, 1),", "+]", "+", "+tfcompile_bench_tfmatmul = [", "+    (", "+        \"bench_graph_tfmatmul_%sx%sx%s\" % (m, k, n),", "+        \"bench_graph_tfmatmul_%sx%sx%s.config.pbtxt\" % (m, k, n),", "+        \"bench_graph_tfmatmul.template.pbtxt\",", "+        \"-e \\\"s|<M>|%s|g\\\" -e \\\"s|<K>|%s|g\\\" -e \\\"s|<N>|%s|g\\\"\" % (m, k, n),", "+    )", "+    for (m, k, n) in tfcompile_bench_tfmatmul_mkn", "+]", "+", "+test_suite(", "+    name = \"all_tfmatmul_benchmarks\",", "+    tags = [\"manual\"],", "+    tests = [", "+        (\":%s_test\" % bench_name)", "+        for (bench_name, _, _, _) in tfcompile_bench_tfmatmul", "+    ],", "+    visibility = [\"//visibility:public\"],", "+)", "+", "+test_suite(", "+    name = \"all_tfmatmul_mlir_benchmarks\",", "+    tags = [\"manual\"],", "+    tests = [", "+        (\":%s_mlir_test\" % bench_name)", "+        for (bench_name, _, _, _) in tfcompile_bench_tfmatmul", "+    ],", "+    visibility = [\"//visibility:public\"],", "+)", "+", "+[[", "+    genrule(", "+        name = \"gen_\" + config_file,", "+        testonly = 1,", "+        srcs = [template_file],", "+        outs = [config_file],", "+        cmd = (\"sed \" + sed_replace + \" \" +", "+               \"$(location \" + template_file + \") \" +", "+               \"> $(OUTS)\"),", "+        tags = [\"manual\"],", "+    ),", "+    tf_library(", "+        name = bench_name,", "+        testonly = 1,", "+        config = config_file,", "+        cpp_class = \"foo::bar::MatMulComp\",", "+        graph = \"test_graph_tfmatmul.pb\",", "+        tags = [", "+            \"manual\",", "+            \"no_mac\",  # TODO(b/228273415)", "+        ],", "+    ),", "+] for (bench_name, config_file, template_file, sed_replace) in tfcompile_bench_tfmatmul]", "+", " tf_cc_test(", "     name = \"tfcompile_test\",", "     srcs = [\"tfcompile_test.cc\"],", "@@ -0,0 +1,18 @@", "+# Text form of tensorflow.tf2xla.Config proto.", "+feed {", "+  id { node_name: \"x_hold\" }", "+  shape {", "+    dim { size: <M> }", "+    dim { size: <K> }", "+  }", "+}", "+feed {", "+  id { node_name: \"y_hold\" }", "+  shape {", "+    dim { size: <K> }", "+    dim { size: <N> }", "+  }", "+}", "+fetch {", "+  id { node_name: \"x_y_prod\" }", "+}", "@@ -35,6 +35,7 @@ py_library(", "     deps = [", "         \":checkpoint_context\",", "         \"//tensorflow/python/tpu:tpu_embedding_v2\",", "+        \"//tensorflow/python/util:object_identity\",", "     ],", " )", " ", "@@ -78,7 +79,6 @@ py_library(", "         \"//tensorflow/python:session\",", "         \"//tensorflow/python:tensor_shape\",", "         \"//tensorflow/python:tensor_util\",", "-        \"//tensorflow/python:util\",", "         \"//tensorflow/python:variable_scope\",", "         \"//tensorflow/python:variables\",", "         \"//tensorflow/python/checkpoint:checkpoint_management\",", "@@ -89,6 +89,12 @@ py_library(", "         \"//tensorflow/python/trackable:base\",", "         \"//tensorflow/python/trackable:data_structures\",", "         \"//tensorflow/python/training/saving:saveable_object_util\",", "+        \"//tensorflow/python/util:compat\",", "+        \"//tensorflow/python/util:deprecation\",", "+        \"//tensorflow/python/util:lazy_loader\",", "+        \"//tensorflow/python/util:object_identity\",", "+        \"//tensorflow/python/util:tf_decorator\",", "+        \"//tensorflow/python/util:tf_export\",", "     ],", " )", " ", "@@ -182,6 +188,7 @@ py_library(", "         \"//tensorflow/python/framework:errors\",", "         \"//tensorflow/python/trackable:base\",", "         \"//tensorflow/python/training:py_checkpoint_reader\",", "+        \"//tensorflow/python/util:object_identity\",", "         \"//tensorflow/python/util:tf_export\",", "     ],", " )", "@@ -205,9 +212,9 @@ py_library(", "     deps = [", "         \":save_util_v1\",", "         \":trackable_view\",", "-        \"//tensorflow/python:util\",", "         \"//tensorflow/python/trackable:base\",", "         \"//tensorflow/python/trackable:converter\",", "+        \"//tensorflow/python/util:tf_export\",", "     ],", " )", " ", "@@ -221,13 +228,13 @@ py_library(", "         \"//tensorflow/python:constant_op\",", "         \"//tensorflow/python:dtypes\",", "         \"//tensorflow/python:framework_ops\",", "-        \"//tensorflow/python:util\",", "         \"//tensorflow/python/saved_model/registration\",", "         \"//tensorflow/python/trackable:base\",", "         \"//tensorflow/python/trackable:python_state\",", "         \"//tensorflow/python/trackable:trackable_utils\",", "         \"//tensorflow/python/training/saving:saveable_object\",", "         \"//tensorflow/python/training/saving:saveable_object_util\",", "+        \"//tensorflow/python/util:object_identity\",", "     ],", " )", " ", "@@ -240,13 +247,13 @@ py_library(", "         \"//tensorflow/python:constant_op\",", "         \"//tensorflow/python:dtypes\",", "         \"//tensorflow/python:framework_ops\",", "-        \"//tensorflow/python:util\",", "         \"//tensorflow/python/saved_model/registration\",", "         \"//tensorflow/python/trackable:base\",", "         \"//tensorflow/python/trackable:python_state\",", "         \"//tensorflow/python/trackable:trackable_utils\",", "         \"//tensorflow/python/training/saving:saveable_object\",", "         \"//tensorflow/python/training/saving:saveable_object_util\",", "+        \"//tensorflow/python/util:object_identity\",", "     ],", " )", " ", "@@ -256,11 +263,11 @@ tf_py_test(", "     deps = [", "         \":graph_view\",", "         \":save_util_v1\",", "-        \"//tensorflow/python:util\",", "         \"//tensorflow/python:variables\",", "         \"//tensorflow/python/eager:test\",", "         \"//tensorflow/python/saved_model/registration\",", "         \"//tensorflow/python/trackable:autotrackable\",", "+        \"//tensorflow/python/util:object_identity\",", "     ],", " )", " ", "@@ -270,9 +277,9 @@ py_library(", "     srcs_version = \"PY3\",", "     tags = [\"no_pip\"],", "     deps = [", "-        \"//tensorflow/python:util\",", "         \"//tensorflow/python/trackable:base\",", "         \"//tensorflow/python/trackable:converter\",", "+        \"//tensorflow/python/util:object_identity\",", "         \"//tensorflow/python/util:tf_export\",", "     ],", " )", "@@ -294,9 +301,9 @@ py_library(", "     deps = [", "         \"//tensorflow/core:protos_all_py\",", "         \"//tensorflow/python:resource_variable_ops\",", "-        \"//tensorflow/python:util\",", "         \"//tensorflow/python:variables\",", "         \"//tensorflow/python/trackable:trackable_utils\",", "+        \"//tensorflow/python/util:object_identity\",", "     ],", " )", " ", "@@ -321,7 +328,7 @@ py_library(", "         \"//tensorflow/python/trackable:python_state\",", "         \"//tensorflow/python/trackable:trackable_utils\",", "         \"//tensorflow/python/training/saving:saveable_object_util\",", "-        \"//tensorflow/python/util\",", "+        \"//tensorflow/python/util:object_identity\",", "     ],", " )", " ", "@@ -355,7 +362,7 @@ py_library(", "     srcs = [\"checkpoint_options.py\"],", "     srcs_version = \"PY3\",", "     deps = [", "-        \"//tensorflow/python:util\",", "+        \"//tensorflow/python/util:deprecation\",", "         \"//tensorflow/python/util:tf_export\",", "     ],", " )", "@@ -371,6 +378,8 @@ py_library(", "         \"//tensorflow/python/trackable:trackable_utils\",", "         \"//tensorflow/python/training/saving:saveable_object\",", "         \"//tensorflow/python/training/saving:saveable_object_util\",", "+        \"//tensorflow/python/util:nest\",", "+        \"//tensorflow/python/util:object_identity\",", "     ],", " )", " ", "@@ -420,10 +429,11 @@ py_library(", "         \"//tensorflow/python:framework_ops\",", "         \"//tensorflow/python:lib\",", "         \"//tensorflow/python:platform\",", "-        \"//tensorflow/python:util\",", "         \"//tensorflow/python:variable_scope\",", "         \"//tensorflow/python/eager:context\",", "         \"//tensorflow/python/training:training_util\",", "+        \"//tensorflow/python/util:compat\",", "+        \"//tensorflow/python/util:deprecation\",", "         \"//tensorflow/python/util:tf_export\",", "     ],", " )", "@@ -332,7 +332,6 @@ py_strict_library(", "         \"//tensorflow/python/trackable:base\",", "         \"//tensorflow/python/util:compat\",", "         \"//tensorflow/python/util:nest\",", "-        \"//tensorflow/python/util:tf_decorator\",", "         \"@absl_py//absl/logging\",", "     ],", " )", "@@ -432,6 +431,7 @@ tf_py_test(", "         \"//tensorflow/python:error_interpolation\",", "         \"//tensorflow/python/eager:def_function\",", "         \"//tensorflow/python/eager:test\",", "+        \"//tensorflow/python/util:compat\",", "         \"@absl_py//absl/testing:parameterized\",", "     ],", " )", "@@ -534,6 +534,7 @@ cuda_py_test(", "         \":save\",", "         \"@absl_py//absl/testing:parameterized\",", "         \"//tensorflow/python:while_loop\",", "+        \"//tensorflow/python/util:tf_decorator\",", "         \"//tensorflow/python:constant_op\",", "         \"//tensorflow/python:dtypes\",", "         \"//tensorflow/python:lib\",", "@@ -723,6 +724,7 @@ tf_py_test(", "         \"//tensorflow/core:protos_all_py\",", "         \"//tensorflow/python:framework\",", "         \"//tensorflow/python/eager:test\",", "+        \"//tensorflow/python/util:compat\",", "     ],", " )", " ", "@@ -44,9 +44,10 @@ py_library(", "         \"//tensorflow/python:control_flow_ops_gen\",", "         \"//tensorflow/python:dtypes\",", "         \"//tensorflow/python:framework_ops\",", "-        \"//tensorflow/python:util\",", "         \"//tensorflow/python/eager:context\",", "         \"//tensorflow/python/training/saving:saveable_object\",", "+        \"//tensorflow/python/util:tf_decorator\",", "+        \"//tensorflow/python/util:tf_export\",", "     ],", " )", " ", "@@ -124,6 +125,7 @@ py_library(", "         \"//tensorflow/python:lib\",", "         \"//tensorflow/python/eager:context\",", "         \"//tensorflow/python/framework:tensor_conversion_registry\",", "+        \"//tensorflow/python/util:tf_export\",", "     ],", " )", " ", "@@ -134,6 +136,7 @@ py_library(", "     deps = [", "         \":base\",", "         \":data_structures\",", "+        \"//tensorflow/python/util:tf_export\",", "     ],", " )", " ", "@@ -144,6 +147,7 @@ tf_py_test(", "         \":autotrackable\",", "         \":data_structures\",", "         \"//tensorflow/python:client_testlib\",", "+        \"//tensorflow/python/util:nest\",", "     ],", " )", " ", "@@ -154,6 +158,8 @@ py_library(", "     visibility = [\"//tensorflow:internal\"],", "     deps = [", "         \":base\",", "+        \"//tensorflow/python/util:tf_decorator\",", "+        \"//tensorflow/python/util:tf_export\",", "     ],", " )", " ", "@@ -170,6 +176,7 @@ py_library(", "     name = \"layer_utils\",", "     srcs = [\"layer_utils.py\"],", "     srcs_version = \"PY3\",", "+    deps = [\"//tensorflow/python/util:object_identity\"],", " )", " ", " py_library(", "@@ -179,6 +186,8 @@ py_library(", "     deps = [", "         \":base\",", "         \":layer_utils\",", "+        \"//tensorflow/python/util:compat\",", "+        \"//tensorflow/python/util:tf_export\",", "         \"@wrapt\",", "     ],", " )", "@@ -198,6 +207,8 @@ tf_py_test(", "         \"//tensorflow/python:math_ops\",", "         \"//tensorflow/python/eager:context\",", "         \"//tensorflow/python/eager:test\",", "+        \"//tensorflow/python/util:nest\",", "+        \"//tensorflow/python/util:serialization\",", "     ],", " )", " ", "@@ -158,6 +158,7 @@ COMMON_PIP_DEPS = [", "     \"//tensorflow/python/tpu\",", "     \"//tensorflow/python/util:example_parser_configuration\",", "     \"//tensorflow/python/util:function_utils\",", "+    \"//tensorflow/python/util:serialization\",", "     \"//tensorflow/python:image_grad_test_base\",", "     \"//tensorflow/python:memory_checker\",", "     \"//tensorflow/python:test_ops\",", "@@ -397,6 +397,7 @@ cc_library(", "         \"//tensorflow/tsl/platform:errors\",", "         \"@com_google_absl//absl/container:flat_hash_map\",", "         \"@com_google_absl//absl/container:flat_hash_set\",", "+        \"@com_google_absl//absl/types:span\",", "     ],", " )", " ", "@@ -120,6 +120,38 @@ StatusOr<HloInstruction*> CreateSyncVariant(HloInstruction* async_start,", "   return sync_instruction;", " }", " ", "+/*static*/ Status", "+ConvertAsyncCollectivesToSync::ReplaceAsyncInstructionsWithSync(", "+    HloComputation* computation,", "+    absl::Span<const std::pair<HloInstruction*, HloInstruction*>> async_pairs) {", "+  absl::flat_hash_map<HloInstruction*, HloInstruction*> replaced_ops;", "+  for (auto& [async_start, async_done] : async_pairs) {", "+    TF_ASSIGN_OR_RETURN(HloInstruction * sync,", "+                        CreateSyncVariant(async_start, async_done));", "+    replaced_ops[async_start] = nullptr;", "+    replaced_ops[async_done] = sync;", "+  }", "+", "+  // Update schedule.", "+  HloModule* module = computation->parent();", "+  const HloInstructionSequence& sequence =", "+      module->schedule().sequence(computation);", "+  std::vector<HloInstruction*> new_sequence;", "+  new_sequence.reserve(sequence.size());", "+  for (HloInstruction* instr : sequence.instructions()) {", "+    auto it = replaced_ops.find(instr);", "+    if (it != replaced_ops.end()) {", "+      if (it->second != nullptr) {", "+        new_sequence.push_back(it->second);", "+      }", "+    } else {", "+      new_sequence.push_back(instr);", "+    }", "+  }", "+  module->schedule().set_sequence(computation, new_sequence);", "+  return OkStatus();", "+}", "+", " StatusOr<bool> ConvertAsyncCollectivesToSync::RunOnComputation(", "     HloComputation* computation) {", "   HloModule* module = computation->parent();", "@@ -165,29 +197,8 @@ StatusOr<bool> ConvertAsyncCollectivesToSync::RunOnComputation(", "     return false;", "   }", " ", "-  // Replace async pairs with corresponding sync op.", "-  absl::flat_hash_map<HloInstruction*, HloInstruction*> replaced_ops;", "-  for (auto& [async_start, async_done] : async_pairs) {", "-    TF_ASSIGN_OR_RETURN(HloInstruction * sync,", "-                        CreateSyncVariant(async_start, async_done));", "-    replaced_ops[async_start] = nullptr;", "-    replaced_ops[async_done] = sync;", "-  }", "-", "-  // Update schedule.", "-  std::vector<HloInstruction*> new_sequence;", "-  new_sequence.reserve(sequence.size());", "-  for (HloInstruction* instr : sequence.instructions()) {", "-    auto it = replaced_ops.find(instr);", "-    if (it != replaced_ops.end()) {", "-      if (it->second != nullptr) {", "-        new_sequence.push_back(it->second);", "-      }", "-    } else {", "-      new_sequence.push_back(instr);", "-    }", "-  }", "-  module->schedule().set_sequence(computation, new_sequence);", "+  TF_RETURN_IF_ERROR(", "+      ReplaceAsyncInstructionsWithSync(computation, async_pairs));", "   return true;", " }", " ", "@@ -16,6 +16,10 @@ limitations under the License.", " #ifndef TENSORFLOW_COMPILER_XLA_SERVICE_CONVERT_ASYNC_COLLECTIVES_TO_SYNC_H_", " #define TENSORFLOW_COMPILER_XLA_SERVICE_CONVERT_ASYNC_COLLECTIVES_TO_SYNC_H_", " ", "+#include <utility>", "+", "+#include \"absl/types/span.h\"", "+#include \"tensorflow/compiler/xla/hlo/ir/hlo_computation.h\"", " #include \"tensorflow/compiler/xla/service/hlo_pass_interface.h\"", " ", " namespace xla {", "@@ -36,6 +40,13 @@ class ConvertAsyncCollectivesToSync : public HloModulePass {", "       HloModule* module,", "       const absl::flat_hash_set<absl::string_view>& execution_threads) override;", " ", "+  // Helper utility to replace pair of async-start/done ops in a computation", "+  // with their synchronous variants and update the schedule.", "+  static Status ReplaceAsyncInstructionsWithSync(", "+      HloComputation* computation,", "+      absl::Span<const std::pair<HloInstruction*, HloInstruction*>>", "+          async_pairs);", "+", "  private:", "   StatusOr<bool> RunOnComputation(HloComputation* computation);", "   HloPredicate is_nop_;", "@@ -76,16 +76,6 @@ llvm::Module* ModuleFromIRBuilder(llvm::IRBuilder<>* b) {", " ", " }  // namespace", " ", "-std::unique_ptr<llvm::Module> DropConstantInitializers(", "-    const llvm::Module& module) {", "-  std::unique_ptr<llvm::Module> cloned_module = CloneModule(module);", "-  for (llvm::GlobalVariable& global_var : cloned_module->globals()) {", "-    global_var.setInitializer(nullptr);", "-    global_var.setLinkage(llvm::GlobalValue::LinkageTypes::ExternalLinkage);", "-  }", "-  return cloned_module;", "-}", "-", " std::string DumpToString(const llvm::Module* module) {", "   return DumpToStringTempl(module);", " }", "@@ -616,7 +606,6 @@ static Status CreateAndWriteStringToFile(const std::string& directory_name,", " void DumpIrIfEnabled(const HloModule& hlo_module,", "                      const llvm::Module& llvm_module, bool optimized,", "                      absl::string_view filename_suffix) {", "-  const auto& debug_opts = hlo_module.config().debug_options();", "   if (!DumpingEnabledForHloModule(hlo_module)) {", "     return;", "   }", "@@ -628,15 +617,6 @@ void DumpIrIfEnabled(const HloModule& hlo_module,", "                    filename_suffix.empty() ? \"\" : \".\", filename_suffix);", "   DumpToFileInDirOrStdout(hlo_module, \"\", absl::StrCat(suffix, \".ll\"),", "                           DumpToString(&llvm_module));", "-", "-  // For some models the embedded constants can be huge, so also dump the module", "-  // with the constants stripped to get IR that is easier to manipulate.  Skip", "-  // this if we're dumping to stdout; there's no point in duplicating everything", "-  // when writing to the terminal.", "-  if (!DumpingToStdout(debug_opts)) {", "-    DumpToFileInDir(hlo_module, \"\", absl::StrCat(suffix, \"-noconst.ll\"),", "-                    DumpToString(DropConstantInitializers(llvm_module).get()));", "-  }", " }", " ", " llvm::Function* CreateCpuFunction(llvm::FunctionType* function_type,", "@@ -317,6 +317,33 @@ cc_library(", "     alwayslink = 1,", " )", " ", "+cc_library(", "+    name = \"legalize_tf_xla_call_module_to_stablehlo_pass\",", "+    srcs = [", "+        \"transforms/legalize_tf_xla_call_module_to_stablehlo_pass.cc\",", "+    ],", "+    hdrs = [", "+        \"transforms/legalize_tf_xla_call_module_to_stablehlo_pass.h\",", "+    ],", "+    copts = [", "+        \"-Ithird_party\",", "+    ],", "+    deps = [", "+        \"//tensorflow/compiler/mlir/tensorflow\",", "+        \"@llvm-project//llvm:Support\",", "+        \"@llvm-project//mlir:FuncDialect\",", "+        \"@llvm-project//mlir:IR\",", "+        \"@llvm-project//mlir:Pass\",", "+        \"@llvm-project//mlir:QuantOps\",", "+        \"@llvm-project//mlir:ShapeDialect\",", "+        \"@llvm-project//mlir:Transforms\",", "+        \"@stablehlo//:stablehlo_ops\",", "+        \"@stablehlo//:stablehlo_serialization\",", "+        \"@stablehlo//:vhlo_ops\",", "+    ],", "+    alwayslink = 1,", "+)", "+", " cc_library(", "     name = \"optimize\",", "     srcs = [", "@@ -387,6 +414,7 @@ tf_cc_binary(", "     deps = [", "         \":fold_broadcast_pass\",", "         \":fuse_convolution_pass\",", "+        \":legalize_tf_xla_call_module_to_stablehlo_pass\",", "         \":optimize\",", "         \":stablehlo_tfl\",", "         \":tf_stablehlo\",", "@@ -0,0 +1,176 @@", "+/* Copyright 2023 The TensorFlow Authors. All Rights Reserved.", "+", "+Licensed under the Apache License, Version 2.0 (the \"License\");", "+you may not use this file except in compliance with the License.", "+You may obtain a copy of the License at", "+", "+    http://www.apache.org/licenses/LICENSE-2.0", "+", "+Unless required by applicable law or agreed to in writing, software", "+distributed under the License is distributed on an \"AS IS\" BASIS,", "+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.", "+See the License for the specific language governing permissions and", "+limitations under the License.", "+==============================================================================*/", "+", "+#include \"tensorflow/compiler/mlir/lite/stablehlo/transforms/legalize_tf_xla_call_module_to_stablehlo_pass.h\"", "+", "+#include <memory>", "+#include <string>", "+#include <string_view>", "+#include <utility>", "+", "+#include \"llvm/ADT/SmallVector.h\"", "+#include \"mlir/Dialect/Func/IR/FuncOps.h\"  // from @llvm-project", "+#include \"mlir/Dialect/Quant/QuantOps.h\"  // from @llvm-project", "+#include \"mlir/Dialect/Shape/IR/Shape.h\"  // from @llvm-project", "+#include \"mlir/IR/Builders.h\"  // from @llvm-project", "+#include \"mlir/IR/BuiltinAttributes.h\"  // from @llvm-project", "+#include \"mlir/IR/BuiltinTypes.h\"  // from @llvm-project", "+#include \"mlir/IR/MLIRContext.h\"  // from @llvm-project", "+#include \"mlir/IR/PatternMatch.h\"  // from @llvm-project", "+#include \"mlir/IR/Types.h\"  // from @llvm-project", "+#include \"mlir/IR/Value.h\"  // from @llvm-project", "+#include \"mlir/Pass/Pass.h\"  // from @llvm-project", "+#include \"mlir/Pass/PassRegistry.h\"  // from @llvm-project", "+#include \"mlir/Transforms/GreedyPatternRewriteDriver.h\"  // from @llvm-project", "+#include \"stablehlo/dialect/Serialization.h\"  // from @stablehlo", "+#include \"stablehlo/dialect/StablehloOps.h\"  // from @stablehlo", "+#include \"stablehlo/dialect/VhloOps.h\"  // from @stablehlo", "+#include \"tensorflow/compiler/mlir/tensorflow/ir/tf_ops.h\"", "+", "+namespace mlir {", "+namespace odml {", "+", "+static constexpr std::string_view kStablehloModuleDefaultEntryFuncName = \"main\";", "+static constexpr std::string_view kStablehloFuncNamePrefix = \"XlaCallModule\";", "+", "+class ConvertTFXlaCallModuleOp", "+    : public mlir::OpRewritePattern<mlir::TF::XlaCallModuleOp> {", "+ public:", "+  explicit ConvertTFXlaCallModuleOp(MLIRContext *context, ModuleOp module_op)", "+      : OpRewritePattern<mlir::TF::XlaCallModuleOp>(context),", "+        module_op_(module_op) {}", "+  using OpRewritePattern<mlir::TF::XlaCallModuleOp>::OpRewritePattern;", "+", "+ private:", "+  ModuleOp module_op_;", "+  mlir::LogicalResult matchAndRewrite(", "+      mlir::TF::XlaCallModuleOp op, PatternRewriter &rewriter) const override {", "+    mlir::OwningOpRef<ModuleOp> stablehlo_module_op =", "+        mlir::stablehlo::deserializePortableArtifact(op.getModuleAttr(),", "+                                                     getContext());", "+    if (stablehlo_module_op.get() == nullptr) {", "+      return mlir::failure();", "+    }", "+    SymbolTable parent_module_symbol_table(module_op_);", "+    SymbolTable stablehlo_module_symbol_table(stablehlo_module_op.get());", "+    if (stablehlo_module_symbol_table.lookup<mlir::func::FuncOp>(", "+            kStablehloModuleDefaultEntryFuncName) == nullptr) {", "+      return rewriter.notifyMatchFailure(", "+          op, \"could not find main function in XlaCallModuleOp\");", "+    }", "+    mlir::Builder stablehlo_builder(stablehlo_module_op.get().getContext());", "+    // Rename XlaCallModuleOp's functions to avoid naming conflicts.", "+    for (auto func_op :", "+         stablehlo_module_op.get().getOps<mlir::func::FuncOp>()) {", "+      const std::string new_func_name =", "+          CreateNewFuncName(func_op.getSymName(), parent_module_symbol_table);", "+      if (failed(stablehlo_module_symbol_table.replaceAllSymbolUses(", "+              func_op, stablehlo_builder.getStringAttr(new_func_name),", "+              stablehlo_module_op.get()))) {", "+        return mlir::failure();", "+      }", "+      mlir::SymbolTable::setSymbolName(func_op, new_func_name);", "+    }", "+    // Move all functions from XlaCallModuleOp's stablehlo module, to parent", "+    // module. Also marks the stablehlo module entry function as private.", "+    mlir::func::FuncOp main_fn;", "+    for (auto func_op :", "+         stablehlo_module_op.get().getOps<mlir::func::FuncOp>()) {", "+      mlir::func::FuncOp cloned_func_op = func_op.clone();", "+      if (cloned_func_op.getSymName().contains(", "+              kStablehloModuleDefaultEntryFuncName)) {", "+        main_fn = cloned_func_op;", "+        main_fn.setSymVisibility(stablehlo_builder.getStringAttr(\"private\"));", "+      }", "+      parent_module_symbol_table.insert(cloned_func_op);", "+    }", "+", "+    // The stablehlo module main function's input tensor types might be", "+    // different from the XlaCallModuleOp's input tensor types. For example,", "+    // The XlaCallModuleOp's input is tensor<*xf32> while the function's", "+    // argument type is tensor<1x2f32>.", "+    llvm::SmallVector<Value, 4> casted_operands;", "+    casted_operands.reserve(main_fn.getNumArguments());", "+    for (const auto &operand_and_type :", "+         zip(op.getOperands(), main_fn.getFunctionType().getInputs())) {", "+      Value operand = std::get<0>(operand_and_type);", "+      Type expected_type = std::get<1>(operand_and_type);", "+      if (operand.getType() != expected_type) {", "+        operand = rewriter.create<TF::CastOp>(", "+            op.getLoc(), expected_type, operand,", "+            /*Truncate=*/rewriter.getBoolAttr(false));", "+      }", "+      casted_operands.push_back(operand);", "+    }", "+", "+    auto call = rewriter.create<func::CallOp>(", "+        op->getLoc(), main_fn.getSymName(), main_fn.getResultTypes(),", "+        casted_operands);", "+    rewriter.replaceOp(op, call->getResults());", "+", "+    return mlir::success();", "+  }", "+", "+  // Creates a new function name to avoid collision. The naming scheme is", "+  // XlaCallModule_%s_%d where %s is the original function name and %d is the", "+  // counter.", "+  std::string CreateNewFuncName(const StringRef func_name,", "+                                SymbolTable &symbol_table) const {", "+    int suffix_id = 0;", "+    std::string new_func_name = absl::StrCat(kStablehloFuncNamePrefix, \"_\",", "+                                             func_name.str(), \"_\", suffix_id);", "+    while (symbol_table.lookup(new_func_name)) {", "+      suffix_id++;", "+      new_func_name = absl::StrCat(kStablehloFuncNamePrefix, \"_\",", "+                                   func_name.str(), \"_\", suffix_id);", "+    }", "+    return new_func_name;", "+  }", "+};", "+", "+class TFXlaCallModuleOpToStablehloPass", "+    : public PassWrapper<TFXlaCallModuleOpToStablehloPass,", "+                         OperationPass<ModuleOp>> {", "+ public:", "+  StringRef getArgument() const final {", "+    return \"tf-xla-call-module-op-to-stablehlo-pass\";", "+  }", "+  StringRef getDescription() const final {", "+    return \"Legalize TF_XlaCallModule Op to stablehlo\";", "+  }", "+  void getDependentDialects(::mlir::DialectRegistry &registry) const override {", "+    registry.insert<mlir::stablehlo::StablehloDialect, mlir::vhlo::VhloDialect,", "+                    mlir::quant::QuantizationDialect, shape::ShapeDialect>();", "+  }", "+", "+  void runOnOperation() override {", "+    ModuleOp module_op = getOperation();", "+    RewritePatternSet patterns(&getContext());", "+    patterns.add<ConvertTFXlaCallModuleOp>(&getContext(), module_op);", "+    if (failed(applyPatternsAndFoldGreedily(module_op, std::move(patterns)))) {", "+      return signalPassFailure();", "+    }", "+  }", "+};", "+", "+std::unique_ptr<mlir::OperationPass<ModuleOp>>", "+CreateLegalizeTFXlaCallModuleToStablehloPass() {", "+  return std::make_unique<TFXlaCallModuleOpToStablehloPass>();", "+}", "+", "+static PassRegistration<TFXlaCallModuleOpToStablehloPass> pass;", "+", "+}  // namespace odml", "+}  // namespace mlir", "@@ -0,0 +1,35 @@", "+/* Copyright 2023 The TensorFlow Authors. All Rights Reserved.", "+", "+Licensed under the Apache License, Version 2.0 (the \"License\");", "+you may not use this file except in compliance with the License.", "+You may obtain a copy of the License at", "+", "+    http://www.apache.org/licenses/LICENSE-2.0", "+", "+Unless required by applicable law or agreed to in writing, software", "+distributed under the License is distributed on an \"AS IS\" BASIS,", "+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.", "+See the License for the specific language governing permissions and", "+limitations under the License.", "+==============================================================================*/", "+", "+#ifndef TENSORFLOW_COMPILER_MLIR_LITE_STABLEHLO_TRANSFORMS_LEGALIZE_TF_XLA_CALL_MODULE_TO_STABLEHLO_PASS_H_", "+#define TENSORFLOW_COMPILER_MLIR_LITE_STABLEHLO_TRANSFORMS_LEGALIZE_TF_XLA_CALL_MODULE_TO_STABLEHLO_PASS_H_", "+", "+#include <memory>", "+", "+#include \"mlir/IR/BuiltinOps.h\"  // from @llvm-project", "+#include \"mlir/Pass/Pass.h\"  // from @llvm-project", "+", "+namespace mlir {", "+namespace odml {", "+", "+// Adds passes which transform TF_XlaCallModule Op to StableHLO Ops.", "+// Note that this pass only supports static shape tensors for now.", "+std::unique_ptr<mlir::OperationPass<ModuleOp>>", "+CreateLegalizeTFXlaCallModuleToStablehloPass();", "+", "+}  // namespace odml", "+}  // namespace mlir", "+", "+#endif  // TENSORFLOW_COMPILER_MLIR_LITE_STABLEHLO_TRANSFORMS_LEGALIZE_TF_XLA_CALL_MODULE_TO_STABLEHLO_PASS_H_", "@@ -1,4 +1,1387 @@", " Auto generated patch. Do not edit or delete it, even if empty.", "+diff -ruN --strip-trailing-cr a/clang/include/clang/Serialization/ASTWriter.h b/clang/include/clang/Serialization/ASTWriter.h", "+--- a/clang/include/clang/Serialization/ASTWriter.h", "++++ b/clang/include/clang/Serialization/ASTWriter.h", "+@@ -514,6 +514,7 @@", "+   void WriteTypeAbbrevs();", "+   void WriteType(QualType T);", "+ ", "++  bool isLookupResultExternal(StoredDeclsList &Result, DeclContext *DC);", "+   bool isLookupResultEntirelyExternal(StoredDeclsList &Result, DeclContext *DC);", "+ ", "+   void GenerateNameLookupTable(const DeclContext *DC,", "+diff -ruN --strip-trailing-cr a/clang/lib/Serialization/ASTWriter.cpp b/clang/lib/Serialization/ASTWriter.cpp", "+--- a/clang/lib/Serialization/ASTWriter.cpp", "++++ b/clang/lib/Serialization/ASTWriter.cpp", "+@@ -3849,6 +3849,12 @@", "+ ", "+ } // namespace", "+ ", "++bool ASTWriter::isLookupResultExternal(StoredDeclsList &Result,", "++                                       DeclContext *DC) {", "++  return Result.hasExternalDecls() &&", "++         DC->hasNeedToReconcileExternalVisibleStorage();", "++}", "++", "+ bool ASTWriter::isLookupResultEntirelyExternal(StoredDeclsList &Result,", "+                                                DeclContext *DC) {", "+   for (auto *D : Result.getLookupResult())", "+@@ -3891,7 +3897,8 @@", "+     // don't need to write an entry for the name at all. If we can't", "+     // write out a lookup set without performing more deserialization,", "+     // just skip this entry.", "+-    if (isLookupResultEntirelyExternal(Result, DC))", "++    if (isLookupResultExternal(Result, DC) &&", "++        isLookupResultEntirelyExternal(Result, DC))", "+       continue;", "+ ", "+     // We also skip empty results. If any of the results could be external and", "+diff -ruN --strip-trailing-cr a/clang/test/Modules/pr61065.cppm b/clang/test/Modules/pr61065.cppm", "+--- a/clang/test/Modules/pr61065.cppm", "++++ b/clang/test/Modules/pr61065.cppm", "+@@ -1,55 +0,0 @@", "+-// From https://github.com/llvm/llvm-project/issues/61065", "+-// RUN: rm -rf %t", "+-// RUN: mkdir -p %t", "+-// RUN: split-file %s %t", "+-//", "+-// RUN: %clang_cc1 -std=c++20 %t/a.cppm -emit-module-interface -o %t/a.pcm", "+-// RUN: %clang_cc1 -std=c++20 %t/b.cppm -emit-module-interface -o %t/b.pcm \\", "+-// RUN:     -fprebuilt-module-path=%t", "+-// RUN: %clang_cc1 -std=c++20 %t/c.cppm -emit-module-interface -o %t/c.pcm \\", "+-// RUN:     -fprebuilt-module-path=%t", "+-// RUN: %clang_cc1 -std=c++20 %t/d.cpp -fsyntax-only -verify -fprebuilt-module-path=%t", "+-", "+-//--- a.cppm", "+-export module a;", "+-", "+-struct base {", "+-\tbase(int) {}", "+-};", "+-", "+-export struct a : base {", "+-\tusing base::base;", "+-};", "+-", "+-//--- b.cppm", "+-export module b;", "+-", "+-import a;", "+-", "+-a b() {", "+-\treturn a(1);", "+-}", "+-", "+-//--- c.cppm", "+-export module c;", "+-", "+-import a;", "+-import b;", "+-", "+-struct noncopyable {", "+-\tnoncopyable(noncopyable const &) = delete;", "+-    noncopyable() = default;", "+-};", "+-", "+-export struct c {", "+-\tnoncopyable c0;", "+-\ta c1 = 43;", "+-    c() = default;", "+-};", "+-", "+-//--- d.cpp", "+-// expected-no-diagnostics", "+-import c;", "+-void d() {", "+-    c _;", "+-}", "+diff -ruN --strip-trailing-cr a/llvm/include/llvm/ExecutionEngine/JITLink/ELF_aarch32.h b/llvm/include/llvm/ExecutionEngine/JITLink/ELF_aarch32.h", "+--- a/llvm/include/llvm/ExecutionEngine/JITLink/ELF_aarch32.h", "++++ b/llvm/include/llvm/ExecutionEngine/JITLink/ELF_aarch32.h", "+@@ -1,38 +0,0 @@", "+-//===---- ELF_aarch32.h - JIT link functions for arm/thumb -----*- C++ -*--===//", "+-//", "+-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.", "+-// See https://llvm.org/LICENSE.txt for license information.", "+-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception", "+-//", "+-//===----------------------------------------------------------------------===//", "+-//", "+-// jit-link functions for ELF/aarch32.", "+-//", "+-//===----------------------------------------------------------------------===//", "+-", "+-#ifndef LLVM_EXECUTIONENGINE_JITLINK_ELF_AARCH32", "+-#define LLVM_EXECUTIONENGINE_JITLINK_ELF_AARCH32", "+-", "+-#include \"llvm/ExecutionEngine/JITLink/JITLink.h\"", "+-#include \"llvm/ExecutionEngine/JITLink/aarch32.h\"", "+-", "+-namespace llvm {", "+-namespace jitlink {", "+-", "+-/// Create a LinkGraph from an ELF/arm relocatable object", "+-///", "+-/// Note: The graph does not take ownership of the underlying buffer, nor copy", "+-/// its contents. The caller is responsible for ensuring that the object buffer", "+-/// outlives the graph.", "+-Expected<std::unique_ptr<LinkGraph>>", "+-createLinkGraphFromELFObject_aarch32(MemoryBufferRef ObjectBuffer);", "+-", "+-/// jit-link the given object buffer, which must be an ELF arm/thumb object", "+-/// file.", "+-void link_ELF_aarch32(std::unique_ptr<LinkGraph> G,", "+-                      std::unique_ptr<JITLinkContext> Ctx);", "+-", "+-} // end namespace jitlink", "+-} // end namespace llvm", "+-", "+-#endif // LLVM_EXECUTIONENGINE_JITLINK_ELF_AARCH32", "+diff -ruN --strip-trailing-cr a/llvm/include/llvm/ExecutionEngine/JITLink/aarch32.h b/llvm/include/llvm/ExecutionEngine/JITLink/aarch32.h", "+--- a/llvm/include/llvm/ExecutionEngine/JITLink/aarch32.h", "++++ b/llvm/include/llvm/ExecutionEngine/JITLink/aarch32.h", "+@@ -1,293 +0,0 @@", "+-//===------ aarch32.h - Generic JITLink arm/thumb utilities -----*- C++ -*-===//", "+-//", "+-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.", "+-// See https://llvm.org/LICENSE.txt for license information.", "+-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception", "+-//", "+-//===----------------------------------------------------------------------===//", "+-//", "+-// Generic utilities for graphs representing arm/thumb objects.", "+-//", "+-//===----------------------------------------------------------------------===//", "+-", "+-#ifndef LLVM_EXECUTIONENGINE_JITLINK_AARCH32", "+-#define LLVM_EXECUTIONENGINE_JITLINK_AARCH32", "+-", "+-#include \"TableManager.h\"", "+-#include \"llvm/ExecutionEngine/JITLink/JITLink.h\"", "+-#include \"llvm/ExecutionEngine/Orc/Shared/ExecutorAddress.h\"", "+-#include \"llvm/Support/ARMBuildAttributes.h\"", "+-#include \"llvm/Support/Error.h\"", "+-", "+-namespace llvm {", "+-namespace jitlink {", "+-namespace aarch32 {", "+-", "+-/// JITLink-internal AArch32 fixup kinds", "+-enum EdgeKind_aarch32 : Edge::Kind {", "+-", "+-  ///", "+-  /// Relocations of class Data", "+-  ///", "+-  FirstDataRelocation = Edge::FirstRelocation,", "+-", "+-  /// Plain 32-bit value relocation in target endianness", "+-  Data_Delta32 = FirstDataRelocation,", "+-", "+-  LastDataRelocation = Data_Delta32,", "+-", "+-  ///", "+-  /// Relocations of class Arm (covers fixed-width 4-byte instruction subset)", "+-  ///", "+-  FirstArmRelocation,", "+-", "+-  /// TODO: Arm_Call is here only as a placeholder for now.", "+-  Arm_Call = FirstArmRelocation,", "+-", "+-  LastArmRelocation = Arm_Call,", "+-", "+-  ///", "+-  /// Relocations of class Thumb16 and Thumb32 (covers Thumb instruction subset)", "+-  ///", "+-  FirstThumbRelocation,", "+-", "+-  /// Write immediate value for PC-relative branch with link (can bridge between", "+-  /// Arm and Thumb).", "+-  Thumb_Call = FirstThumbRelocation,", "+-", "+-  /// Write immediate value for (unconditional) PC-relative branch without link.", "+-  Thumb_Jump24,", "+-", "+-  /// Write immediate value to the lower halfword of the destination register", "+-  Thumb_MovwAbsNC,", "+-", "+-  /// Write immediate value to the top halfword of the destination register", "+-  Thumb_MovtAbs,", "+-", "+-  LastThumbRelocation = Thumb_MovtAbs,", "+-};", "+-", "+-/// Flags enum for AArch32-specific symbol properties", "+-enum TargetFlags_aarch32 : TargetFlagsType {", "+-  ThumbSymbol = 1 << 0,", "+-};", "+-", "+-/// Human-readable name for a given CPU architecture kind", "+-const char *getCPUArchName(ARMBuildAttrs::CPUArch K);", "+-", "+-/// Get a human-readable name for the given AArch32 edge kind.", "+-const char *getEdgeKindName(Edge::Kind K);", "+-", "+-/// AArch32 uses stubs for a number of purposes, like branch range extension", "+-/// or interworking between Arm and Thumb instruction subsets.", "+-///", "+-/// Stub implementations vary depending on CPU architecture (v4, v6, v7),", "+-/// instruction subset and branch type (absolute/PC-relative).", "+-///", "+-/// For each kind of stub, the StubsFlavor defines one concrete form that is", "+-/// used throughout the LinkGraph.", "+-///", "+-/// Stubs are often called \"veneers\" in the official docs and online.", "+-///", "+-enum StubsFlavor {", "+-  Unsupported = 0,", "+-  Thumbv7,", "+-};", "+-", "+-/// JITLink sub-arch configuration for Arm CPU models", "+-struct ArmConfig {", "+-  bool J1J2BranchEncoding = false;", "+-  StubsFlavor Stubs = Unsupported;", "+-};", "+-", "+-/// Obtain the sub-arch configuration for a given Arm CPU model.", "+-inline ArmConfig getArmConfigForCPUArch(ARMBuildAttrs::CPUArch CPUArch) {", "+-  ArmConfig ArmCfg;", "+-  switch (CPUArch) {", "+-  case ARMBuildAttrs::v7:", "+-  case ARMBuildAttrs::v8_A:", "+-    ArmCfg.J1J2BranchEncoding = true;", "+-    ArmCfg.Stubs = Thumbv7;", "+-    break;", "+-  default:", "+-    DEBUG_WITH_TYPE(\"jitlink\", {", "+-      dbgs() << \"  Warning: ARM config not defined for CPU architecture \"", "+-             << getCPUArchName(CPUArch);", "+-    });", "+-    break;", "+-  }", "+-  return ArmCfg;", "+-}", "+-", "+-/// Immutable pair of halfwords, Hi and Lo, with overflow check", "+-struct HalfWords {", "+-  constexpr HalfWords() : Hi(0), Lo(0) {}", "+-  constexpr HalfWords(uint32_t Hi, uint32_t Lo) : Hi(Hi), Lo(Lo) {", "+-    assert(isUInt<16>(Hi) && \"Overflow in first half-word\");", "+-    assert(isUInt<16>(Lo) && \"Overflow in second half-word\");", "+-  }", "+-  const uint16_t Hi; // First halfword", "+-  const uint16_t Lo; // Second halfword", "+-};", "+-", "+-/// Collection of named constants per fixup kind. It may contain but is not", "+-/// limited to the following entries:", "+-///", "+-///   Opcode      - Values of the op-code bits in the instruction, with", "+-///                 unaffected bits nulled", "+-///   OpcodeMask  - Mask with all bits set that encode the op-code", "+-///   ImmMask     - Mask with all bits set that encode the immediate value", "+-///   RegMask     - Mask with all bits set that encode the register", "+-///", "+-template <EdgeKind_aarch32 Kind> struct FixupInfo {};", "+-", "+-template <> struct FixupInfo<Thumb_Jump24> {", "+-  static constexpr HalfWords Opcode{0xf000, 0x8000};", "+-  static constexpr HalfWords OpcodeMask{0xf800, 0x8000};", "+-  static constexpr HalfWords ImmMask{0x07ff, 0x2fff};", "+-  static constexpr uint16_t LoBitConditional = 0x1000;", "+-};", "+-", "+-template <> struct FixupInfo<Thumb_Call> {", "+-  static constexpr HalfWords Opcode{0xf000, 0xc000};", "+-  static constexpr HalfWords OpcodeMask{0xf800, 0xc000};", "+-  static constexpr HalfWords ImmMask{0x07ff, 0x2fff};", "+-  static constexpr uint16_t LoBitH = 0x0001;", "+-  static constexpr uint16_t LoBitNoBlx = 0x1000;", "+-};", "+-", "+-template <> struct FixupInfo<Thumb_MovtAbs> {", "+-  static constexpr HalfWords Opcode{0xf2c0, 0x0000};", "+-  static constexpr HalfWords OpcodeMask{0xfbf0, 0x8000};", "+-  static constexpr HalfWords ImmMask{0x040f, 0x70ff};", "+-  static constexpr HalfWords RegMask{0x0000, 0x0f00};", "+-};", "+-", "+-template <>", "+-struct FixupInfo<Thumb_MovwAbsNC> : public FixupInfo<Thumb_MovtAbs> {", "+-  static constexpr HalfWords Opcode{0xf240, 0x0000};", "+-};", "+-", "+-/// Helper function to read the initial addend for Data-class relocations.", "+-Expected<int64_t> readAddendData(LinkGraph &G, Block &B, const Edge &E);", "+-", "+-/// Helper function to read the initial addend for Arm-class relocations.", "+-Expected<int64_t> readAddendArm(LinkGraph &G, Block &B, const Edge &E);", "+-", "+-/// Helper function to read the initial addend for Thumb-class relocations.", "+-Expected<int64_t> readAddendThumb(LinkGraph &G, Block &B, const Edge &E,", "+-                                  const ArmConfig &ArmCfg);", "+-", "+-/// Read the initial addend for a REL-type relocation. It's the value encoded", "+-/// in the immediate field of the fixup location by the compiler.", "+-inline Expected<int64_t> readAddend(LinkGraph &G, Block &B, const Edge &E,", "+-                                    const ArmConfig &ArmCfg) {", "+-  Edge::Kind Kind = E.getKind();", "+-  if (Kind <= LastDataRelocation)", "+-    return readAddendData(G, B, E);", "+-", "+-  if (Kind <= LastArmRelocation)", "+-    return readAddendArm(G, B, E);", "+-", "+-  if (Kind <= LastThumbRelocation)", "+-    return readAddendThumb(G, B, E, ArmCfg);", "+-", "+-  llvm_unreachable(\"Relocation must be of class Data, Arm or Thumb\");", "+-}", "+-", "+-/// Helper function to apply the fixup for Data-class relocations.", "+-Error applyFixupData(LinkGraph &G, Block &B, const Edge &E);", "+-", "+-/// Helper function to apply the fixup for Arm-class relocations.", "+-Error applyFixupArm(LinkGraph &G, Block &B, const Edge &E);", "+-", "+-/// Helper function to apply the fixup for Thumb-class relocations.", "+-Error applyFixupThumb(LinkGraph &G, Block &B, const Edge &E,", "+-                      const ArmConfig &ArmCfg);", "+-", "+-/// Apply fixup expression for edge to block content.", "+-inline Error applyFixup(LinkGraph &G, Block &B, const Edge &E,", "+-                        const ArmConfig &ArmCfg) {", "+-  Edge::Kind Kind = E.getKind();", "+-", "+-  if (Kind <= LastDataRelocation)", "+-    return applyFixupData(G, B, E);", "+-", "+-  if (Kind <= LastArmRelocation)", "+-    return applyFixupArm(G, B, E);", "+-", "+-  if (Kind <= LastThumbRelocation)", "+-    return applyFixupThumb(G, B, E, ArmCfg);", "+-", "+-  llvm_unreachable(\"Relocation must be of class Data, Arm or Thumb\");", "+-}", "+-", "+-/// Stubs builder for a specific StubsFlavor", "+-///", "+-/// Right now we only have one default stub kind, but we want to extend this", "+-/// and allow creation of specific kinds in the future (e.g. branch range", "+-/// extension or interworking).", "+-///", "+-/// Let's keep it simple for the moment and not wire this through a GOT.", "+-///", "+-template <StubsFlavor Flavor>", "+-class StubsManager : public TableManager<StubsManager<Flavor>> {", "+-public:", "+-  StubsManager() = default;", "+-", "+-  /// Name of the object file section that will contain all our stubs.", "+-  static StringRef getSectionName() { return \"__llvm_jitlink_STUBS\"; }", "+-", "+-  /// Implements link-graph traversal via visitExistingEdges().", "+-  bool visitEdge(LinkGraph &G, Block *B, Edge &E) {", "+-    if (E.getTarget().isDefined())", "+-      return false;", "+-", "+-    switch (E.getKind()) {", "+-    case Thumb_Call:", "+-    case Thumb_Jump24: {", "+-      DEBUG_WITH_TYPE(\"jitlink\", {", "+-        dbgs() << \"  Fixing \" << G.getEdgeKindName(E.getKind()) << \" edge at \"", "+-               << B->getFixupAddress(E) << \" (\" << B->getAddress() << \" + \"", "+-               << formatv(\"{0:x}\", E.getOffset()) << \")\\n\";", "+-      });", "+-      E.setTarget(this->getEntryForTarget(G, E.getTarget()));", "+-      return true;", "+-    }", "+-    }", "+-    return false;", "+-  }", "+-", "+-  /// Create a branch range extension stub for the class's flavor.", "+-  Symbol &createEntry(LinkGraph &G, Symbol &Target);", "+-", "+-private:", "+-  /// Create a new node in the link-graph for the given stub template.", "+-  template <size_t Size>", "+-  Block &addStub(LinkGraph &G, const uint8_t (&Code)[Size],", "+-                 uint64_t Alignment) {", "+-    ArrayRef<char> Template(reinterpret_cast<const char *>(Code), Size);", "+-    return G.createContentBlock(getStubsSection(G), Template,", "+-                                orc::ExecutorAddr(), Alignment, 0);", "+-  }", "+-", "+-  /// Get or create the object file section that will contain all our stubs.", "+-  Section &getStubsSection(LinkGraph &G) {", "+-    if (!StubsSection)", "+-      StubsSection = &G.createSection(getSectionName(),", "+-                                      orc::MemProt::Read | orc::MemProt::Exec);", "+-    return *StubsSection;", "+-  }", "+-", "+-  Section *StubsSection = nullptr;", "+-};", "+-", "+-/// Create a branch range extension stub with Thumb encoding for v7 CPUs.", "+-template <>", "+-Symbol &StubsManager<Thumbv7>::createEntry(LinkGraph &G, Symbol &Target);", "+-", "+-} // namespace aarch32", "+-} // namespace jitlink", "+-} // namespace llvm", "+-", "+-#endif // LLVM_EXECUTIONENGINE_JITLINK_AARCH32", "+diff -ruN --strip-trailing-cr a/llvm/lib/ExecutionEngine/JITLink/CMakeLists.txt b/llvm/lib/ExecutionEngine/JITLink/CMakeLists.txt", "+--- a/llvm/lib/ExecutionEngine/JITLink/CMakeLists.txt", "++++ b/llvm/lib/ExecutionEngine/JITLink/CMakeLists.txt", "+@@ -20,7 +20,6 @@", "+   # ELF", "+   ELF.cpp", "+   ELFLinkGraphBuilder.cpp", "+-  ELF_aarch32.cpp", "+   ELF_aarch64.cpp", "+   ELF_i386.cpp", "+   ELF_loongarch.cpp", "+@@ -34,7 +33,6 @@", "+   COFF_x86_64.cpp", "+ ", "+   # Architectures:", "+-  aarch32.cpp", "+   aarch64.cpp", "+   i386.cpp", "+   loongarch.cpp", "+diff -ruN --strip-trailing-cr a/llvm/lib/ExecutionEngine/JITLink/ELF.cpp b/llvm/lib/ExecutionEngine/JITLink/ELF.cpp", "+--- a/llvm/lib/ExecutionEngine/JITLink/ELF.cpp", "++++ b/llvm/lib/ExecutionEngine/JITLink/ELF.cpp", "+@@ -13,7 +13,6 @@", "+ #include \"llvm/ExecutionEngine/JITLink/ELF.h\"", "+ ", "+ #include \"llvm/BinaryFormat/ELF.h\"", "+-#include \"llvm/ExecutionEngine/JITLink/ELF_aarch32.h\"", "+ #include \"llvm/ExecutionEngine/JITLink/ELF_aarch64.h\"", "+ #include \"llvm/ExecutionEngine/JITLink/ELF_i386.h\"", "+ #include \"llvm/ExecutionEngine/JITLink/ELF_loongarch.h\"", "+@@ -70,8 +69,6 @@", "+   switch (*TargetMachineArch) {", "+   case ELF::EM_AARCH64:", "+     return createLinkGraphFromELFObject_aarch64(ObjectBuffer);", "+-  case ELF::EM_ARM:", "+-    return createLinkGraphFromELFObject_aarch32(ObjectBuffer);", "+   case ELF::EM_LOONGARCH:", "+     return createLinkGraphFromELFObject_loongarch(ObjectBuffer);", "+   case ELF::EM_RISCV:", "+@@ -93,12 +90,6 @@", "+   case Triple::aarch64:", "+     link_ELF_aarch64(std::move(G), std::move(Ctx));", "+     return;", "+-  case Triple::arm:", "+-  case Triple::armeb:", "+-  case Triple::thumb:", "+-  case Triple::thumbeb:", "+-    link_ELF_aarch32(std::move(G), std::move(Ctx));", "+-    return;", "+   case Triple::loongarch32:", "+   case Triple::loongarch64:", "+     link_ELF_loongarch(std::move(G), std::move(Ctx));", "+diff -ruN --strip-trailing-cr a/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h b/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h", "+--- a/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h", "++++ b/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h", "+@@ -127,12 +127,6 @@", "+   Error graphifySections();", "+   Error graphifySymbols();", "+ ", "+-  /// Override in derived classes to suppress certain sections in the link", "+-  /// graph.", "+-  virtual bool excludeSection(const typename ELFT::Shdr &Sect) const {", "+-    return false;", "+-  }", "+-", "+   /// Traverse all matching ELFT::Rela relocation records in the given section.", "+   /// The handler function Func should be callable with this signature:", "+   ///   Error(const typename ELFT::Rela &,", "+@@ -327,13 +321,6 @@", "+     auto Name = Obj.getSectionName(Sec, SectionStringTab);", "+     if (!Name)", "+       return Name.takeError();", "+-    if (excludeSection(Sec)) {", "+-      LLVM_DEBUG({", "+-        dbgs() << \"    \" << SecIndex << \": Skipping section \\\"\" << *Name", "+-               << \"\\\" explicitly\\n\";", "+-      });", "+-      continue;", "+-    }", "+ ", "+     // Skip null sections.", "+     if (Sec.sh_type == ELF::SHT_NULL) {", "+@@ -577,10 +564,6 @@", "+     LLVM_DEBUG(dbgs() << \"    skipped (dwarf section)\\n\\n\");", "+     return Error::success();", "+   }", "+-  if (excludeSection(**FixupSection)) {", "+-    LLVM_DEBUG(dbgs() << \"    skipped (fixup section excluded explicitly)\\n\\n\");", "+-    return Error::success();", "+-  }", "+ ", "+   // Lookup the link-graph node corresponding to the target section name.", "+   auto *BlockToFix = getGraphBlock(RelSect.sh_info);", "+@@ -627,10 +610,6 @@", "+     LLVM_DEBUG(dbgs() << \"    skipped (dwarf section)\\n\\n\");", "+     return Error::success();", "+   }", "+-  if (excludeSection(**FixupSection)) {", "+-    LLVM_DEBUG(dbgs() << \"    skipped (fixup section excluded explicitly)\\n\\n\");", "+-    return Error::success();", "+-  }", "+ ", "+   // Lookup the link-graph node corresponding to the target section name.", "+   auto *BlockToFix = getGraphBlock(RelSect.sh_info);", "+diff -ruN --strip-trailing-cr a/llvm/lib/ExecutionEngine/JITLink/ELF_aarch32.cpp b/llvm/lib/ExecutionEngine/JITLink/ELF_aarch32.cpp", "+--- a/llvm/lib/ExecutionEngine/JITLink/ELF_aarch32.cpp", "++++ b/llvm/lib/ExecutionEngine/JITLink/ELF_aarch32.cpp", "+@@ -1,299 +0,0 @@", "+-//===----- ELF_aarch32.cpp - JIT linker implementation for arm/thumb ------===//", "+-//", "+-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.", "+-// See https://llvm.org/LICENSE.txt for license information.", "+-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception", "+-//", "+-//===----------------------------------------------------------------------===//", "+-//", "+-// ELF/aarch32 jit-link implementation.", "+-//", "+-//===----------------------------------------------------------------------===//", "+-", "+-#include \"llvm/ExecutionEngine/JITLink/ELF_aarch32.h\"", "+-", "+-#include \"llvm/BinaryFormat/ELF.h\"", "+-#include \"llvm/ExecutionEngine/JITLink/JITLink.h\"", "+-#include \"llvm/ExecutionEngine/JITLink/aarch32.h\"", "+-#include \"llvm/Object/ELF.h\"", "+-#include \"llvm/Object/ELFObjectFile.h\"", "+-#include \"llvm/Support/Endian.h\"", "+-#include \"llvm/Support/ErrorHandling.h\"", "+-#include \"llvm/TargetParser/ARMTargetParser.h\"", "+-", "+-#include \"ELFLinkGraphBuilder.h\"", "+-#include \"JITLinkGeneric.h\"", "+-", "+-#define DEBUG_TYPE \"jitlink\"", "+-", "+-using namespace llvm::object;", "+-", "+-namespace llvm {", "+-namespace jitlink {", "+-", "+-/// Translate from ELF relocation type to JITLink-internal edge kind.", "+-Expected<aarch32::EdgeKind_aarch32> getJITLinkEdgeKind(uint32_t ELFType) {", "+-  switch (ELFType) {", "+-  case ELF::R_ARM_REL32:", "+-    return aarch32::Data_Delta32;", "+-  case ELF::R_ARM_CALL:", "+-    return aarch32::Arm_Call;", "+-  case ELF::R_ARM_THM_CALL:", "+-    return aarch32::Thumb_Call;", "+-  case ELF::R_ARM_THM_JUMP24:", "+-    return aarch32::Thumb_Jump24;", "+-  case ELF::R_ARM_THM_MOVW_ABS_NC:", "+-    return aarch32::Thumb_MovwAbsNC;", "+-  case ELF::R_ARM_THM_MOVT_ABS:", "+-    return aarch32::Thumb_MovtAbs;", "+-  }", "+-", "+-  return make_error<JITLinkError>(", "+-      \"Unsupported aarch32 relocation \" + formatv(\"{0:d}: \", ELFType) +", "+-      object::getELFRelocationTypeName(ELF::EM_ARM, ELFType));", "+-}", "+-", "+-/// Translate from JITLink-internal edge kind back to ELF relocation type.", "+-Expected<uint32_t> getELFRelocationType(Edge::Kind Kind) {", "+-  switch (static_cast<aarch32::EdgeKind_aarch32>(Kind)) {", "+-  case aarch32::Data_Delta32:", "+-    return ELF::R_ARM_REL32;", "+-  case aarch32::Arm_Call:", "+-    return ELF::R_ARM_CALL;", "+-  case aarch32::Thumb_Call:", "+-    return ELF::R_ARM_THM_CALL;", "+-  case aarch32::Thumb_Jump24:", "+-    return ELF::R_ARM_THM_JUMP24;", "+-  case aarch32::Thumb_MovwAbsNC:", "+-    return ELF::R_ARM_THM_MOVW_ABS_NC;", "+-  case aarch32::Thumb_MovtAbs:", "+-    return ELF::R_ARM_THM_MOVT_ABS;", "+-  }", "+-", "+-  return make_error<JITLinkError>(formatv(\"Invalid aarch32 edge {0:d}: \",", "+-                                          Kind));", "+-}", "+-", "+-/// Get a human-readable name for the given ELF AArch32 edge kind.", "+-const char *getELFAArch32EdgeKindName(Edge::Kind R) {", "+-  // No ELF-specific edge kinds yet", "+-  return aarch32::getEdgeKindName(R);", "+-}", "+-", "+-class ELFJITLinker_aarch32 : public JITLinker<ELFJITLinker_aarch32> {", "+-  friend class JITLinker<ELFJITLinker_aarch32>;", "+-", "+-public:", "+-  ELFJITLinker_aarch32(std::unique_ptr<JITLinkContext> Ctx,", "+-                       std::unique_ptr<LinkGraph> G, PassConfiguration PassCfg,", "+-                       aarch32::ArmConfig ArmCfg)", "+-      : JITLinker(std::move(Ctx), std::move(G), std::move(PassCfg)),", "+-        ArmCfg(std::move(ArmCfg)) {}", "+-", "+-private:", "+-  aarch32::ArmConfig ArmCfg;", "+-", "+-  Error applyFixup(LinkGraph &G, Block &B, const Edge &E) const {", "+-    return aarch32::applyFixup(G, B, E, ArmCfg);", "+-  }", "+-};", "+-", "+-template <support::endianness DataEndianness>", "+-class ELFLinkGraphBuilder_aarch32", "+-    : public ELFLinkGraphBuilder<ELFType<DataEndianness, false>> {", "+-private:", "+-  using ELFT = ELFType<DataEndianness, false>;", "+-  using Base = ELFLinkGraphBuilder<ELFT>;", "+-", "+-  bool excludeSection(const typename ELFT::Shdr &Sect) const override {", "+-    // TODO: An .ARM.exidx (Exception Index table) entry is 8-bytes in size and", "+-    // consists of 2 words. It might be sufficient to process only relocations", "+-    // in the the second word (offset 4). Please find more details in: Exception", "+-    // Handling ABI for the Arm\u00ae Architecture -> Index table entries", "+-    if (Sect.sh_type == ELF::SHT_ARM_EXIDX)", "+-      return true;", "+-    return false;", "+-  }", "+-", "+-  Error addRelocations() override {", "+-    LLVM_DEBUG(dbgs() << \"Processing relocations:\\n\");", "+-    using Self = ELFLinkGraphBuilder_aarch32<DataEndianness>;", "+-    for (const auto &RelSect : Base::Sections) {", "+-      if (Error Err = Base::forEachRelRelocation(RelSect, this,", "+-                                                 &Self::addSingleRelRelocation))", "+-        return Err;", "+-    }", "+-    return Error::success();", "+-  }", "+-", "+-  Error addSingleRelRelocation(const typename ELFT::Rel &Rel,", "+-                               const typename ELFT::Shdr &FixupSect,", "+-                               Block &BlockToFix) {", "+-    uint32_t SymbolIndex = Rel.getSymbol(false);", "+-    auto ObjSymbol = Base::Obj.getRelocationSymbol(Rel, Base::SymTabSec);", "+-    if (!ObjSymbol)", "+-      return ObjSymbol.takeError();", "+-", "+-    Symbol *GraphSymbol = Base::getGraphSymbol(SymbolIndex);", "+-    if (!GraphSymbol)", "+-      return make_error<StringError>(", "+-          formatv(\"Could not find symbol at given index, did you add it to \"", "+-                  \"JITSymbolTable? index: {0}, shndx: {1} Size of table: {2}\",", "+-                  SymbolIndex, (*ObjSymbol)->st_shndx,", "+-                  Base::GraphSymbols.size()),", "+-          inconvertibleErrorCode());", "+-", "+-    uint32_t Type = Rel.getType(false);", "+-    Expected<aarch32::EdgeKind_aarch32> Kind = getJITLinkEdgeKind(Type);", "+-    if (!Kind)", "+-      return Kind.takeError();", "+-", "+-    auto FixupAddress = orc::ExecutorAddr(FixupSect.sh_addr) + Rel.r_offset;", "+-    Edge::OffsetT Offset = FixupAddress - BlockToFix.getAddress();", "+-    Edge E(*Kind, Offset, *GraphSymbol, 0);", "+-", "+-    Expected<int64_t> Addend =", "+-        aarch32::readAddend(*Base::G, BlockToFix, E, ArmCfg);", "+-    if (!Addend)", "+-      return Addend.takeError();", "+-", "+-    E.setAddend(*Addend);", "+-    LLVM_DEBUG({", "+-      dbgs() << \"    \";", "+-      printEdge(dbgs(), BlockToFix, E, getELFAArch32EdgeKindName(*Kind));", "+-      dbgs() << \"\\n\";", "+-    });", "+-", "+-    BlockToFix.addEdge(std::move(E));", "+-    return Error::success();", "+-  }", "+-", "+-  aarch32::ArmConfig ArmCfg;", "+-", "+-protected:", "+-  TargetFlagsType makeTargetFlags(const typename ELFT::Sym &Sym) override {", "+-    if (Sym.getValue() & 0x01)", "+-      return aarch32::ThumbSymbol;", "+-    return TargetFlagsType{};", "+-  }", "+-", "+-  orc::ExecutorAddrDiff getRawOffset(const typename ELFT::Sym &Sym,", "+-                                     TargetFlagsType Flags) override {", "+-    assert((makeTargetFlags(Sym) & Flags) == Flags);", "+-    static constexpr uint64_t ThumbBit = 0x01;", "+-    return Sym.getValue() & ~ThumbBit;", "+-  }", "+-", "+-public:", "+-  ELFLinkGraphBuilder_aarch32(StringRef FileName, const ELFFile<ELFT> &Obj,", "+-                              Triple TT, aarch32::ArmConfig ArmCfg)", "+-      : ELFLinkGraphBuilder<ELFT>(Obj, std::move(TT), FileName,", "+-                                  getELFAArch32EdgeKindName),", "+-        ArmCfg(std::move(ArmCfg)) {}", "+-};", "+-", "+-template <aarch32::StubsFlavor Flavor>", "+-Error buildTables_ELF_aarch32(LinkGraph &G) {", "+-  LLVM_DEBUG(dbgs() << \"Visiting edges in graph:\\n\");", "+-", "+-  aarch32::StubsManager<Flavor> PLT;", "+-  visitExistingEdges(G, PLT);", "+-  return Error::success();", "+-}", "+-", "+-Expected<std::unique_ptr<LinkGraph>>", "+-createLinkGraphFromELFObject_aarch32(MemoryBufferRef ObjectBuffer) {", "+-  LLVM_DEBUG({", "+-    dbgs() << \"Building jitlink graph for new input \"", "+-           << ObjectBuffer.getBufferIdentifier() << \"...\\n\";", "+-  });", "+-", "+-  auto ELFObj = ObjectFile::createELFObjectFile(ObjectBuffer);", "+-  if (!ELFObj)", "+-    return ELFObj.takeError();", "+-", "+-  // Find out what exact AArch32 instruction set and features we target.", "+-  auto TT = (*ELFObj)->makeTriple();", "+-  ARM::ArchKind AK = ARM::parseArch(TT.getArchName());", "+-  if (AK == ARM::ArchKind::INVALID)", "+-    return make_error<JITLinkError>(", "+-        \"Failed to build ELF link graph: Invalid ARM ArchKind\");", "+-", "+-  // Resolve our internal configuration for the target. If at some point the", "+-  // CPUArch alone becomes too unprecise, we can find more details in the", "+-  // Tag_CPU_arch_profile.", "+-  aarch32::ArmConfig ArmCfg;", "+-  using namespace ARMBuildAttrs;", "+-  auto Arch = static_cast<CPUArch>(ARM::getArchAttr(AK));", "+-  switch (Arch) {", "+-  case v7:", "+-  case v8_A:", "+-    ArmCfg = aarch32::getArmConfigForCPUArch(Arch);", "+-    assert(ArmCfg.Stubs != aarch32::Unsupported &&", "+-           \"Provide a config for each supported CPU\");", "+-    break;", "+-  default:", "+-    return make_error<JITLinkError>(", "+-        \"Failed to build ELF link graph: Unsupported CPU arch \" +", "+-        StringRef(aarch32::getCPUArchName(Arch)));", "+-  }", "+-", "+-  // Populate the link-graph.", "+-  switch (TT.getArch()) {", "+-  case Triple::arm:", "+-  case Triple::thumb: {", "+-    auto &ELFFile = cast<ELFObjectFile<ELF32LE>>(**ELFObj).getELFFile();", "+-    return ELFLinkGraphBuilder_aarch32<support::little>(", "+-               (*ELFObj)->getFileName(), ELFFile, TT, ArmCfg)", "+-        .buildGraph();", "+-  }", "+-  case Triple::armeb:", "+-  case Triple::thumbeb: {", "+-    auto &ELFFile = cast<ELFObjectFile<ELF32BE>>(**ELFObj).getELFFile();", "+-    return ELFLinkGraphBuilder_aarch32<support::big>((*ELFObj)->getFileName(),", "+-                                                     ELFFile, TT, ArmCfg)", "+-        .buildGraph();", "+-  }", "+-  default:", "+-    return make_error<JITLinkError>(", "+-        \"Failed to build ELF/aarch32 link graph: Invalid target triple \" +", "+-        TT.getTriple());", "+-  }", "+-}", "+-", "+-void link_ELF_aarch32(std::unique_ptr<LinkGraph> G,", "+-                      std::unique_ptr<JITLinkContext> Ctx) {", "+-  const Triple &TT = G->getTargetTriple();", "+-", "+-  using namespace ARMBuildAttrs;", "+-  ARM::ArchKind AK = ARM::parseArch(TT.getArchName());", "+-  auto CPU = static_cast<CPUArch>(ARM::getArchAttr(AK));", "+-  aarch32::ArmConfig ArmCfg = aarch32::getArmConfigForCPUArch(CPU);", "+-", "+-  PassConfiguration PassCfg;", "+-  if (Ctx->shouldAddDefaultTargetPasses(TT)) {", "+-    // Add a mark-live pass.", "+-    if (auto MarkLive = Ctx->getMarkLivePass(TT))", "+-      PassCfg.PrePrunePasses.push_back(std::move(MarkLive));", "+-    else", "+-      PassCfg.PrePrunePasses.push_back(markAllSymbolsLive);", "+-", "+-    switch (ArmCfg.Stubs) {", "+-    case aarch32::Thumbv7:", "+-      PassCfg.PostPrunePasses.push_back(", "+-          buildTables_ELF_aarch32<aarch32::Thumbv7>);", "+-      break;", "+-    case aarch32::Unsupported:", "+-      llvm_unreachable(\"Check before building graph\");", "+-    }", "+-  }", "+-", "+-  if (auto Err = Ctx->modifyPassConfig(*G, PassCfg))", "+-    return Ctx->notifyFailed(std::move(Err));", "+-", "+-  ELFJITLinker_aarch32::link(std::move(Ctx), std::move(G), std::move(PassCfg),", "+-                             std::move(ArmCfg));", "+-}", "+-", "+-} // namespace jitlink", "+-} // namespace llvm", "+diff -ruN --strip-trailing-cr a/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp b/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp", "+--- a/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp", "++++ b/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp", "+@@ -1,514 +0,0 @@", "+-//===--------- aarch32.cpp - Generic JITLink arm/thumb utilities ----------===//", "+-//", "+-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.", "+-// See https://llvm.org/LICENSE.txt for license information.", "+-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception", "+-//", "+-//===----------------------------------------------------------------------===//", "+-//", "+-// Generic utilities for graphs representing arm/thumb objects.", "+-//", "+-//===----------------------------------------------------------------------===//", "+-", "+-#include \"llvm/ExecutionEngine/JITLink/aarch32.h\"", "+-", "+-#include \"llvm/ADT/StringExtras.h\"", "+-#include \"llvm/BinaryFormat/ELF.h\"", "+-#include \"llvm/ExecutionEngine/JITLink/JITLink.h\"", "+-#include \"llvm/Object/ELFObjectFile.h\"", "+-#include \"llvm/Support/Endian.h\"", "+-#include \"llvm/Support/MathExtras.h\"", "+-", "+-#define DEBUG_TYPE \"jitlink\"", "+-", "+-namespace llvm {", "+-namespace jitlink {", "+-namespace aarch32 {", "+-", "+-using namespace support;", "+-using namespace support::endian;", "+-", "+-/// Encode 22-bit immediate value for branch instructions without J1J2 range", "+-/// extension (formats B T4, BL T1 and BLX T2).", "+-///", "+-///   00000:Imm11H:Imm11L:0 -> [ 00000:Imm11H, 00000:Imm11L ]", "+-///                                            J1^ ^J2 will always be 1", "+-///", "+-HalfWords encodeImmBT4BlT1BlxT2(int64_t Value) {", "+-  constexpr uint32_t J1J2 = 0x2800;", "+-  uint32_t Imm11H = (Value >> 12) & 0x07ff;", "+-  uint32_t Imm11L = (Value >> 1) & 0x07ff;", "+-  return HalfWords{Imm11H, Imm11L | J1J2};", "+-}", "+-", "+-/// Decode 22-bit immediate value for branch instructions without J1J2 range", "+-/// extension (formats B T4, BL T1 and BLX T2).", "+-///", "+-///   [ 00000:Imm11H, 00000:Imm11L ] -> 00000:Imm11H:Imm11L:0", "+-///                   J1^ ^J2 will always be 1", "+-///", "+-int64_t decodeImmBT4BlT1BlxT2(uint32_t Hi, uint32_t Lo) {", "+-  uint32_t Imm11H = Hi & 0x07ff;", "+-  uint32_t Imm11L = Lo & 0x07ff;", "+-  return SignExtend64<22>(Imm11H << 12 | Imm11L << 1);", "+-}", "+-", "+-/// Encode 25-bit immediate value for branch instructions with J1J2 range", "+-/// extension (formats B T4, BL T1 and BLX T2).", "+-///", "+-///   S:I1:I2:Imm10:Imm11:0 -> [ 00000:S:Imm10, 00:J1:0:J2:Imm11 ]", "+-///", "+-HalfWords encodeImmBT4BlT1BlxT2_J1J2(int64_t Value) {", "+-  uint32_t S = (Value >> 14) & 0x0400;", "+-  uint32_t J1 = (((~(Value >> 10)) ^ (Value >> 11)) & 0x2000);", "+-  uint32_t J2 = (((~(Value >> 11)) ^ (Value >> 13)) & 0x0800);", "+-  uint32_t Imm10 = (Value >> 12) & 0x03ff;", "+-  uint32_t Imm11 = (Value >> 1) & 0x07ff;", "+-  return HalfWords{S | Imm10, J1 | J2 | Imm11};", "+-}", "+-", "+-/// Decode 25-bit immediate value for branch instructions with J1J2 range", "+-/// extension (formats B T4, BL T1 and BLX T2).", "+-///", "+-///   [ 00000:S:Imm10, 00:J1:0:J2:Imm11] -> S:I1:I2:Imm10:Imm11:0", "+-///", "+-int64_t decodeImmBT4BlT1BlxT2_J1J2(uint32_t Hi, uint32_t Lo) {", "+-  uint32_t S = Hi & 0x0400;", "+-  uint32_t I1 = ~((Lo ^ (Hi << 3)) << 10) & 0x00800000;", "+-  uint32_t I2 = ~((Lo ^ (Hi << 1)) << 11) & 0x00400000;", "+-  uint32_t Imm10 = Hi & 0x03ff;", "+-  uint32_t Imm11 = Lo & 0x07ff;", "+-  return SignExtend64<25>(S << 14 | I1 | I2 | Imm10 << 12 | Imm11 << 1);", "+-}", "+-", "+-/// Encode 16-bit immediate value for move instruction formats MOVT T1 and", "+-/// MOVW T3.", "+-///", "+-///   Imm4:Imm1:Imm3:Imm8 -> [ 00000:i:000000:Imm4, 0:Imm3:0000:Imm8 ]", "+-///", "+-HalfWords encodeImmMovtT1MovwT3(uint16_t Value) {", "+-  uint32_t Imm4 = (Value >> 12) & 0x0f;", "+-  uint32_t Imm1 = (Value >> 11) & 0x01;", "+-  uint32_t Imm3 = (Value >> 8) & 0x07;", "+-  uint32_t Imm8 = Value & 0xff;", "+-  return HalfWords{Imm1 << 10 | Imm4, Imm3 << 12 | Imm8};", "+-}", "+-", "+-/// Decode 16-bit immediate value from move instruction formats MOVT T1 and", "+-/// MOVW T3.", "+-///", "+-///   [ 00000:i:000000:Imm4, 0:Imm3:0000:Imm8 ] -> Imm4:Imm1:Imm3:Imm8", "+-///", "+-uint16_t decodeImmMovtT1MovwT3(uint32_t Hi, uint32_t Lo) {", "+-  uint32_t Imm4 = Hi & 0x0f;", "+-  uint32_t Imm1 = (Hi >> 10) & 0x01;", "+-  uint32_t Imm3 = (Lo >> 12) & 0x07;", "+-  uint32_t Imm8 = Lo & 0xff;", "+-  uint32_t Imm16 = Imm4 << 12 | Imm1 << 11 | Imm3 << 8 | Imm8;", "+-  assert(Imm16 <= 0xffff && \"Decoded value out-of-range\");", "+-  return Imm16;", "+-}", "+-", "+-/// Encode register ID for instruction formats MOVT T1 and MOVW T3.", "+-///", "+-///   Rd4 -> [0000000000000000, 0000:Rd4:00000000]", "+-///", "+-HalfWords encodeRegMovtT1MovwT3(int64_t Value) {", "+-  uint32_t Rd4 = (Value & 0x0f) << 8;", "+-  return HalfWords{0, Rd4};", "+-}", "+-", "+-/// Decode register ID from instruction formats MOVT T1 and MOVW T3.", "+-///", "+-///   [0000000000000000, 0000:Rd4:00000000] -> Rd4", "+-///", "+-int64_t decodeRegMovtT1MovwT3(uint32_t Hi, uint32_t Lo) {", "+-  uint32_t Rd4 = (Lo >> 8) & 0x0f;", "+-  return Rd4;", "+-}", "+-", "+-/// 32-bit Thumb instructions are stored as two little-endian halfwords.", "+-/// An instruction at address A encodes bytes A+1, A in the first halfword (Hi),", "+-/// followed by bytes A+3, A+2 in the second halfword (Lo).", "+-struct WritableThumbRelocation {", "+-  /// Create a writable reference to a Thumb32 fixup.", "+-  WritableThumbRelocation(char *FixupPtr)", "+-      : Hi{*reinterpret_cast<support::ulittle16_t *>(FixupPtr)},", "+-        Lo{*reinterpret_cast<support::ulittle16_t *>(FixupPtr + 2)} {}", "+-", "+-  support::ulittle16_t &Hi; // First halfword", "+-  support::ulittle16_t &Lo; // Second halfword", "+-};", "+-", "+-struct ThumbRelocation {", "+-  /// Create a read-only reference to a Thumb32 fixup.", "+-  ThumbRelocation(const char *FixupPtr)", "+-      : Hi{*reinterpret_cast<const support::ulittle16_t *>(FixupPtr)},", "+-        Lo{*reinterpret_cast<const support::ulittle16_t *>(FixupPtr + 2)} {}", "+-", "+-  /// Create a read-only Thumb32 fixup from a writeable one.", "+-  ThumbRelocation(WritableThumbRelocation &Writable)", "+-      : Hi{Writable.Hi}, Lo(Writable.Lo) {}", "+-", "+-  const support::ulittle16_t &Hi; // First halfword", "+-  const support::ulittle16_t &Lo; // Second halfword", "+-};", "+-", "+-Error makeUnexpectedOpcodeError(const LinkGraph &G, const ThumbRelocation &R,", "+-                                Edge::Kind Kind) {", "+-  return make_error<JITLinkError>(", "+-      formatv(\"Invalid opcode [ 0x{0:x4}, 0x{1:x4} ] for relocation: {2}\", R.Hi,", "+-              R.Lo, G.getEdgeKindName(Kind)));", "+-}", "+-", "+-template <EdgeKind_aarch32 Kind> bool checkOpcode(const ThumbRelocation &R) {", "+-  uint16_t Hi = R.Hi & FixupInfo<Kind>::OpcodeMask.Hi;", "+-  uint16_t Lo = R.Lo & FixupInfo<Kind>::OpcodeMask.Lo;", "+-  return Hi == FixupInfo<Kind>::Opcode.Hi && Lo == FixupInfo<Kind>::Opcode.Lo;", "+-}", "+-", "+-template <EdgeKind_aarch32 Kind>", "+-bool checkRegister(const ThumbRelocation &R, HalfWords Reg) {", "+-  uint16_t Hi = R.Hi & FixupInfo<Kind>::RegMask.Hi;", "+-  uint16_t Lo = R.Lo & FixupInfo<Kind>::RegMask.Lo;", "+-  return Hi == Reg.Hi && Lo == Reg.Lo;", "+-}", "+-", "+-template <EdgeKind_aarch32 Kind>", "+-bool writeRegister(WritableThumbRelocation &R, HalfWords Reg) {", "+-  static constexpr HalfWords Mask = FixupInfo<Kind>::RegMask;", "+-  assert((Mask.Hi & Reg.Hi) == Reg.Hi && (Mask.Hi & Reg.Hi) == Reg.Hi &&", "+-         \"Value bits exceed bit range of given mask\");", "+-  R.Hi = (R.Hi & ~Mask.Hi) | Reg.Hi;", "+-  R.Lo = (R.Lo & ~Mask.Lo) | Reg.Lo;", "+-}", "+-", "+-template <EdgeKind_aarch32 Kind>", "+-void writeImmediate(WritableThumbRelocation &R, HalfWords Imm) {", "+-  static constexpr HalfWords Mask = FixupInfo<Kind>::ImmMask;", "+-  assert((Mask.Hi & Imm.Hi) == Imm.Hi && (Mask.Hi & Imm.Hi) == Imm.Hi &&", "+-         \"Value bits exceed bit range of given mask\");", "+-  R.Hi = (R.Hi & ~Mask.Hi) | Imm.Hi;", "+-  R.Lo = (R.Lo & ~Mask.Lo) | Imm.Lo;", "+-}", "+-", "+-Expected<int64_t> readAddendData(LinkGraph &G, Block &B, const Edge &E) {", "+-  endianness Endian = G.getEndianness();", "+-  assert(Endian != native && \"Declare as little or big explicitly\");", "+-", "+-  Edge::Kind Kind = E.getKind();", "+-  const char *BlockWorkingMem = B.getContent().data();", "+-  const char *FixupPtr = BlockWorkingMem + E.getOffset();", "+-", "+-  switch (Kind) {", "+-  case Data_Delta32:", "+-    return SignExtend64<32>((Endian == little) ? read32<little>(FixupPtr)", "+-                                               : read32<big>(FixupPtr));", "+-  default:", "+-    return make_error<JITLinkError>(", "+-        \"In graph \" + G.getName() + \", section \" + B.getSection().getName() +", "+-        \" can not read implicit addend for aarch32 edge kind \" +", "+-        G.getEdgeKindName(E.getKind()));", "+-  }", "+-}", "+-", "+-Expected<int64_t> readAddendArm(LinkGraph &G, Block &B, const Edge &E) {", "+-  Edge::Kind Kind = E.getKind();", "+-", "+-  switch (Kind) {", "+-  case Arm_Call:", "+-    return make_error<JITLinkError>(", "+-        \"Addend extraction for relocation type not yet implemented: \" +", "+-        StringRef(G.getEdgeKindName(Kind)));", "+-  default:", "+-    return make_error<JITLinkError>(", "+-        \"In graph \" + G.getName() + \", section \" + B.getSection().getName() +", "+-        \" can not read implicit addend for aarch32 edge kind \" +", "+-        G.getEdgeKindName(E.getKind()));", "+-  }", "+-}", "+-", "+-Expected<int64_t> readAddendThumb(LinkGraph &G, Block &B, const Edge &E,", "+-                                  const ArmConfig &ArmCfg) {", "+-  ThumbRelocation R(B.getContent().data() + E.getOffset());", "+-  Edge::Kind Kind = E.getKind();", "+-", "+-  switch (Kind) {", "+-  case Thumb_Call:", "+-    if (!checkOpcode<Thumb_Call>(R))", "+-      return makeUnexpectedOpcodeError(G, R, Kind);", "+-    return LLVM_LIKELY(ArmCfg.J1J2BranchEncoding)", "+-               ? decodeImmBT4BlT1BlxT2_J1J2(R.Hi, R.Lo)", "+-               : decodeImmBT4BlT1BlxT2(R.Hi, R.Lo);", "+-", "+-  case Thumb_Jump24:", "+-    if (!checkOpcode<Thumb_Jump24>(R))", "+-      return makeUnexpectedOpcodeError(G, R, Kind);", "+-    if (R.Lo & FixupInfo<Thumb_Jump24>::LoBitConditional)", "+-      return make_error<JITLinkError>(\"Relocation expects an unconditional \"", "+-                                      \"B.W branch instruction: \" +", "+-                                      StringRef(G.getEdgeKindName(Kind)));", "+-    return LLVM_LIKELY(ArmCfg.J1J2BranchEncoding)", "+-                  ? decodeImmBT4BlT1BlxT2_J1J2(R.Hi, R.Lo)", "+-                  : decodeImmBT4BlT1BlxT2(R.Hi, R.Lo);", "+-", "+-  case Thumb_MovwAbsNC:", "+-    if (!checkOpcode<Thumb_MovwAbsNC>(R))", "+-      return makeUnexpectedOpcodeError(G, R, Kind);", "+-    // Initial addend is interpreted as a signed value", "+-    return SignExtend64<16>(decodeImmMovtT1MovwT3(R.Hi, R.Lo));", "+-", "+-  case Thumb_MovtAbs:", "+-    if (!checkOpcode<Thumb_MovtAbs>(R))", "+-      return makeUnexpectedOpcodeError(G, R, Kind);", "+-    // Initial addend is interpreted as a signed value", "+-    return SignExtend64<16>(decodeImmMovtT1MovwT3(R.Hi, R.Lo));", "+-", "+-  default:", "+-    return make_error<JITLinkError>(", "+-        \"In graph \" + G.getName() + \", section \" + B.getSection().getName() +", "+-        \" can not read implicit addend for aarch32 edge kind \" +", "+-        G.getEdgeKindName(E.getKind()));", "+-  }", "+-}", "+-", "+-Error applyFixupData(LinkGraph &G, Block &B, const Edge &E) {", "+-  using namespace support;", "+-", "+-  char *BlockWorkingMem = B.getAlreadyMutableContent().data();", "+-  char *FixupPtr = BlockWorkingMem + E.getOffset();", "+-", "+-  auto Write32 = [FixupPtr, Endian = G.getEndianness()](int64_t Value) {", "+-    assert(Endian != native && \"Must be explicit: little or big\");", "+-    assert(isInt<32>(Value) && \"Must be in signed 32-bit range\");", "+-    uint32_t Imm = static_cast<int32_t>(Value);", "+-    if (LLVM_LIKELY(Endian == little))", "+-      endian::write32<little>(FixupPtr, Imm);", "+-    else", "+-      endian::write32<big>(FixupPtr, Imm);", "+-  };", "+-", "+-  Edge::Kind Kind = E.getKind();", "+-  uint64_t FixupAddress = (B.getAddress() + E.getOffset()).getValue();", "+-  int64_t Addend = E.getAddend();", "+-  Symbol &TargetSymbol = E.getTarget();", "+-  uint64_t TargetAddress = TargetSymbol.getAddress().getValue();", "+-  assert(!TargetSymbol.hasTargetFlags(ThumbSymbol));", "+-", "+-  // Regular data relocations have size 4, alignment 1 and write the full 32-bit", "+-  // result to the place; no need for overflow checking. There are three", "+-  // exceptions: R_ARM_ABS8, R_ARM_ABS16, R_ARM_PREL31", "+-  switch (Kind) {", "+-  case Data_Delta32: {", "+-    int64_t Value = TargetAddress - FixupAddress + Addend;", "+-    if (!isInt<32>(Value))", "+-      return makeTargetOutOfRangeError(G, B, E);", "+-    Write32(Value);", "+-    return Error::success();", "+-  }", "+-  default:", "+-    return make_error<JITLinkError>(", "+-        \"In graph \" + G.getName() + \", section \" + B.getSection().getName() +", "+-        \" encountered unfixable aarch32 edge kind \" +", "+-        G.getEdgeKindName(E.getKind()));", "+-  }", "+-}", "+-", "+-Error applyFixupArm(LinkGraph &G, Block &B, const Edge &E) {", "+-  Edge::Kind Kind = E.getKind();", "+-", "+-  switch (Kind) {", "+-  case Arm_Call:", "+-    return make_error<JITLinkError>(", "+-        \"Fix-up for relocation type not yet implemented: \" +", "+-        StringRef(G.getEdgeKindName(Kind)));", "+-  default:", "+-    return make_error<JITLinkError>(", "+-        \"In graph \" + G.getName() + \", section \" + B.getSection().getName() +", "+-        \" encountered unfixable aarch32 edge kind \" +", "+-        G.getEdgeKindName(E.getKind()));", "+-  }", "+-}", "+-", "+-Error applyFixupThumb(LinkGraph &G, Block &B, const Edge &E,", "+-                      const ArmConfig &ArmCfg) {", "+-  WritableThumbRelocation R(B.getAlreadyMutableContent().data() +", "+-                            E.getOffset());", "+-", "+-  Edge::Kind Kind = E.getKind();", "+-  uint64_t FixupAddress = (B.getAddress() + E.getOffset()).getValue();", "+-  int64_t Addend = E.getAddend();", "+-  Symbol &TargetSymbol = E.getTarget();", "+-  uint64_t TargetAddress = TargetSymbol.getAddress().getValue();", "+-  if (TargetSymbol.hasTargetFlags(ThumbSymbol))", "+-    TargetAddress |= 0x01;", "+-", "+-  switch (Kind) {", "+-  case Thumb_Jump24: {", "+-    if (!checkOpcode<Thumb_Jump24>(R))", "+-      return makeUnexpectedOpcodeError(G, R, Kind);", "+-    if (R.Lo & FixupInfo<Thumb_Jump24>::LoBitConditional)", "+-      return make_error<JITLinkError>(\"Relocation expects an unconditional \"", "+-                                      \"B.W branch instruction: \" +", "+-                                      StringRef(G.getEdgeKindName(Kind)));", "+-    if (!(TargetSymbol.hasTargetFlags(ThumbSymbol)))", "+-      return make_error<JITLinkError>(\"Branch relocation needs interworking \"", "+-                                      \"stub when bridging to ARM: \" +", "+-                                      StringRef(G.getEdgeKindName(Kind)));", "+-", "+-    int64_t Value = TargetAddress - FixupAddress + Addend;", "+-    if (LLVM_LIKELY(ArmCfg.J1J2BranchEncoding)) {", "+-      if (!isInt<25>(Value))", "+-        return makeTargetOutOfRangeError(G, B, E);", "+-      writeImmediate<Thumb_Jump24>(R, encodeImmBT4BlT1BlxT2_J1J2(Value));", "+-    } else {", "+-      if (!isInt<22>(Value))", "+-        return makeTargetOutOfRangeError(G, B, E);", "+-      writeImmediate<Thumb_Jump24>(R, encodeImmBT4BlT1BlxT2(Value));", "+-    }", "+-", "+-    return Error::success();", "+-  }", "+-", "+-  case Thumb_Call: {", "+-    if (!checkOpcode<Thumb_Call>(R))", "+-      return makeUnexpectedOpcodeError(G, R, Kind);", "+-", "+-    int64_t Value = TargetAddress - FixupAddress + Addend;", "+-", "+-    // The call instruction itself is Thumb. The call destination can either be", "+-    // Thumb or Arm. We use BL to stay in Thumb and BLX to change to Arm.", "+-    bool TargetIsArm = !TargetSymbol.hasTargetFlags(ThumbSymbol);", "+-    bool InstrIsBlx = (R.Lo & FixupInfo<Thumb_Call>::LoBitNoBlx) == 0;", "+-    if (TargetIsArm != InstrIsBlx) {", "+-      if (LLVM_LIKELY(TargetIsArm)) {", "+-        // Change opcode BL -> BLX and fix range value (account for 4-byte", "+-        // aligned destination while instruction may only be 2-byte aligned", "+-        // and clear Thumb bit).", "+-        R.Lo = R.Lo & ~FixupInfo<Thumb_Call>::LoBitNoBlx;", "+-        R.Lo = R.Lo & ~FixupInfo<Thumb_Call>::LoBitH;", "+-        Value = alignTo(Value, 4);", "+-      } else {", "+-        // Change opcode BLX -> BL and set Thumb bit", "+-        R.Lo = R.Lo & ~FixupInfo<Thumb_Call>::LoBitNoBlx;", "+-        Value |= 0x01;", "+-      }", "+-    }", "+-", "+-    if (LLVM_LIKELY(ArmCfg.J1J2BranchEncoding)) {", "+-      if (!isInt<25>(Value))", "+-        return makeTargetOutOfRangeError(G, B, E);", "+-      writeImmediate<Thumb_Call>(R, encodeImmBT4BlT1BlxT2_J1J2(Value));", "+-    } else {", "+-      if (!isInt<22>(Value))", "+-        return makeTargetOutOfRangeError(G, B, E);", "+-      writeImmediate<Thumb_Call>(R, encodeImmBT4BlT1BlxT2(Value));", "+-    }", "+-", "+-    assert(((R.Lo & FixupInfo<Thumb_Call>::LoBitNoBlx) ||", "+-            (R.Lo & FixupInfo<Thumb_Call>::LoBitH) == 0) &&", "+-           \"Opcode BLX implies H bit is clear (avoid UB in BLX T2)\");", "+-    return Error::success();", "+-  }", "+-", "+-  case Thumb_MovwAbsNC: {", "+-    if (!checkOpcode<Thumb_MovwAbsNC>(R))", "+-      return makeUnexpectedOpcodeError(G, R, Kind);", "+-    uint16_t Value = (TargetAddress + Addend) & 0xffff;", "+-    writeImmediate<Thumb_MovwAbsNC>(R, encodeImmMovtT1MovwT3(Value));", "+-    return Error::success();", "+-  }", "+-", "+-  case Thumb_MovtAbs: {", "+-    if (!checkOpcode<Thumb_MovtAbs>(R))", "+-      return makeUnexpectedOpcodeError(G, R, Kind);", "+-    uint16_t Value = ((TargetAddress + Addend) >> 16) & 0xffff;", "+-    writeImmediate<Thumb_MovtAbs>(R, encodeImmMovtT1MovwT3(Value));", "+-    return Error::success();", "+-  }", "+-", "+-  default:", "+-    return make_error<JITLinkError>(", "+-        \"In graph \" + G.getName() + \", section \" + B.getSection().getName() +", "+-        \" encountered unfixable aarch32 edge kind \" +", "+-        G.getEdgeKindName(E.getKind()));", "+-  }", "+-}", "+-", "+-const uint8_t Thumbv7ABS[] = {", "+-    0x40, 0xf2, 0x00, 0x0c, // movw r12, #0x0000    ; lower 16-bit", "+-    0xc0, 0xf2, 0x00, 0x0c, // movt r12, #0x0000    ; upper 16-bit", "+-    0x60, 0x47              // bx   r12", "+-};", "+-", "+-template <>", "+-Symbol &StubsManager<Thumbv7>::createEntry(LinkGraph &G, Symbol &Target) {", "+-  constexpr uint64_t Alignment = 4;", "+-  Block &B = addStub(G, Thumbv7ABS, Alignment);", "+-  LLVM_DEBUG({", "+-    const char *StubPtr = B.getContent().data();", "+-    HalfWords Reg12 = encodeRegMovtT1MovwT3(12);", "+-    assert(checkRegister<Thumb_MovwAbsNC>(StubPtr, Reg12) &&", "+-           checkRegister<Thumb_MovtAbs>(StubPtr + 4, Reg12) &&", "+-           \"Linker generated stubs may only corrupt register r12 (IP)\");", "+-  });", "+-  B.addEdge(Thumb_MovwAbsNC, 0, Target, 0);", "+-  B.addEdge(Thumb_MovtAbs, 4, Target, 0);", "+-  Symbol &Stub = G.addAnonymousSymbol(B, 0, B.getSize(), true, false);", "+-  Stub.setTargetFlags(ThumbSymbol);", "+-  return Stub;", "+-}", "+-", "+-const char *getEdgeKindName(Edge::Kind K) {", "+-#define KIND_NAME_CASE(K)                                                      \\", "+-  case K:                                                                      \\", "+-    return #K;", "+-", "+-  switch (K) {", "+-    KIND_NAME_CASE(Data_Delta32)", "+-    KIND_NAME_CASE(Arm_Call)", "+-    KIND_NAME_CASE(Thumb_Call)", "+-    KIND_NAME_CASE(Thumb_Jump24)", "+-    KIND_NAME_CASE(Thumb_MovwAbsNC)", "+-    KIND_NAME_CASE(Thumb_MovtAbs)", "+-  default:", "+-    return getGenericEdgeKindName(K);", "+-  }", "+-#undef KIND_NAME_CASE", "+-}", "+-", "+-const char *getCPUArchName(ARMBuildAttrs::CPUArch K) {", "+-#define CPUARCH_NAME_CASE(K)                                                   \\", "+-  case K:                                                                      \\", "+-    return #K;", "+-", "+-  using namespace ARMBuildAttrs;", "+-  switch (K) {", "+-    CPUARCH_NAME_CASE(Pre_v4)", "+-    CPUARCH_NAME_CASE(v4)", "+-    CPUARCH_NAME_CASE(v4T)", "+-    CPUARCH_NAME_CASE(v5T)", "+-    CPUARCH_NAME_CASE(v5TE)", "+-    CPUARCH_NAME_CASE(v5TEJ)", "+-    CPUARCH_NAME_CASE(v6)", "+-    CPUARCH_NAME_CASE(v6KZ)", "+-    CPUARCH_NAME_CASE(v6T2)", "+-    CPUARCH_NAME_CASE(v6K)", "+-    CPUARCH_NAME_CASE(v7)", "+-    CPUARCH_NAME_CASE(v6_M)", "+-    CPUARCH_NAME_CASE(v6S_M)", "+-    CPUARCH_NAME_CASE(v7E_M)", "+-    CPUARCH_NAME_CASE(v8_A)", "+-    CPUARCH_NAME_CASE(v8_R)", "+-    CPUARCH_NAME_CASE(v8_M_Base)", "+-    CPUARCH_NAME_CASE(v8_M_Main)", "+-    CPUARCH_NAME_CASE(v8_1_M_Main)", "+-    CPUARCH_NAME_CASE(v9_A)", "+-  }", "+-  llvm_unreachable(\"Missing CPUArch in switch?\");", "+-#undef CPUARCH_NAME_CASE", "+-}", "+-", "+-} // namespace aarch32", "+-} // namespace jitlink", "+-} // namespace llvm", "+diff -ruN --strip-trailing-cr a/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp b/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp", "+--- a/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp", "++++ b/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp", "+@@ -8,7 +8,6 @@", "+ ", "+ #include \"llvm/ExecutionEngine/Orc/ObjectLinkingLayer.h\"", "+ #include \"llvm/ExecutionEngine/JITLink/EHFrameSupport.h\"", "+-#include \"llvm/ExecutionEngine/JITLink/aarch32.h\"", "+ #include \"llvm/ExecutionEngine/Orc/DebugObjectManagerPlugin.h\"", "+ #include \"llvm/ExecutionEngine/Orc/ObjectFileInterface.h\"", "+ #include \"llvm/ExecutionEngine/Orc/Shared/ObjectFormats.h\"", "+@@ -41,10 +40,7 @@", "+ }", "+ ", "+ JITTargetAddress getJITSymbolPtrForSymbol(Symbol &Sym) {", "+-  uint64_t CallableAddr = Sym.getAddress().getValue();", "+-  if (Sym.isCallable() && Sym.hasTargetFlags(aarch32::ThumbSymbol))", "+-    CallableAddr |= 0x01; // thumb bit", "+-  return CallableAddr;", "++  return Sym.getAddress().getValue();", "+ }", "+ ", "+ JITSymbolFlags getJITSymbolFlagsForSymbol(Symbol &Sym) {", " diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp b/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp", " --- a/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp", " +++ b/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp", "@@ -23,3 +1406,274 @@ diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/IPO/MemProfContextDisambigua", "  ", "      // Find the node for the last stack id, which should be the same", "      // across all calls recorded for this id, and is the id for this", "+diff -ruN --strip-trailing-cr a/llvm/test/ExecutionEngine/JITLink/AArch32/ELF_thumbv7_printf.s b/llvm/test/ExecutionEngine/JITLink/AArch32/ELF_thumbv7_printf.s", "+--- a/llvm/test/ExecutionEngine/JITLink/AArch32/ELF_thumbv7_printf.s", "++++ b/llvm/test/ExecutionEngine/JITLink/AArch32/ELF_thumbv7_printf.s", "+@@ -1,46 +0,0 @@", "+-// RUN: llvm-mc -triple=thumbv7-none-linux-gnueabi -arm-add-build-attributes -filetype=obj -o %t.o %s", "+-// RUN: llvm-jitlink -noexec -slab-address 0x76ff0000 -slab-allocate 10Kb -slab-page-size 4096 -abs printf=0x76bbe880 -show-entry-es %t.o | FileCheck %s", "+-", "+-// Check that main is a thumb symbol (with LSB set) and printf is arm (with LSB clear)", "+-//", "+-// CHECK-LABEL: Symbol table:", "+-// CHECK-NEXT:    \"main\":   0x{{[0-9a-f]+[13579bdf]}} [Callable] Ready", "+-// CHECK-NEXT:    \"printf\": 0x76bbe880 [Data] Ready", "+-", "+-\t.globl\tmain", "+-\t.p2align\t2", "+-\t.type\tmain,%function", "+-\t.code\t16", "+-\t.thumb_func", "+-main:", "+-\t.fnstart", "+-\t.save\t{r7, lr}", "+-\tpush\t{r7, lr}", "+-\t.setfp\tr7, sp", "+-\tmov\tr7, sp", "+-\t.pad\t#8", "+-\tsub\tsp, #8", "+-\tmovs\tr0, #0", "+-\tstr\tr0, [sp]", "+-\tstr\tr0, [sp, #4]", "+-\tldr\tr0, .LCPI0_0", "+-.LPC0_0:", "+-\tadd\tr0, pc", "+-\tbl\tprintf", "+-\tldr\tr0, [sp]", "+-\tadd\tsp, #8", "+-\tpop\t{r7, pc}", "+-", "+-\t.p2align\t2", "+-.LCPI0_0:", "+-\t.long\t.L.str-(.LPC0_0+4)", "+-", "+-\t.size\tmain, .-main", "+-\t.cantunwind", "+-\t.fnend", "+-", "+-\t.type\t.L.str,%object", "+-\t.section\t.rodata.str1.1,\"aMS\",%progbits,1", "+-.L.str:", "+-\t.asciz\t\"Hello AArch32!\\n\"", "+-\t.size\t.L.str, 12", "+diff -ruN --strip-trailing-cr a/llvm/test/ExecutionEngine/JITLink/AArch32/lit.local.cfg b/llvm/test/ExecutionEngine/JITLink/AArch32/lit.local.cfg", "+--- a/llvm/test/ExecutionEngine/JITLink/AArch32/lit.local.cfg", "++++ b/llvm/test/ExecutionEngine/JITLink/AArch32/lit.local.cfg", "+@@ -1,2 +0,0 @@", "+-if not 'ARM' in config.root.targets:", "+-  config.unsupported = True", "+diff -ruN --strip-trailing-cr a/llvm/unittests/ExecutionEngine/JITLink/AArch32Tests.cpp b/llvm/unittests/ExecutionEngine/JITLink/AArch32Tests.cpp", "+--- a/llvm/unittests/ExecutionEngine/JITLink/AArch32Tests.cpp", "++++ b/llvm/unittests/ExecutionEngine/JITLink/AArch32Tests.cpp", "+@@ -1,200 +0,0 @@", "+-//===------- AArch32Tests.cpp - Unit tests for the AArch32 backend --------===//", "+-//", "+-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.", "+-// See https://llvm.org/LICENSE.txt for license information.", "+-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception", "+-//", "+-//===----------------------------------------------------------------------===//", "+-", "+-#include <llvm/BinaryFormat/ELF.h>", "+-#include <llvm/ExecutionEngine/JITLink/aarch32.h>", "+-", "+-#include \"gtest/gtest.h\"", "+-", "+-using namespace llvm;", "+-using namespace llvm::jitlink;", "+-using namespace llvm::jitlink::aarch32;", "+-using namespace llvm::support;", "+-using namespace llvm::support::endian;", "+-", "+-struct MutableHalfWords {", "+-  MutableHalfWords(HalfWords Preset) : Hi(Preset.Hi), Lo(Preset.Lo) {}", "+-", "+-  void patch(HalfWords Value, HalfWords Mask) {", "+-    Hi = (Hi & ~Mask.Hi) | Value.Hi;", "+-    Lo = (Lo & ~Mask.Lo) | Value.Lo;", "+-  }", "+-", "+-  uint16_t Hi; // First halfword", "+-  uint16_t Lo; // Second halfword", "+-};", "+-", "+-namespace llvm {", "+-namespace jitlink {", "+-", "+-Expected<aarch32::EdgeKind_aarch32> getJITLinkEdgeKind(uint32_t ELFType);", "+-Expected<uint32_t> getELFRelocationType(Edge::Kind Kind);", "+-", "+-} // namespace jitlink", "+-} // namespace llvm", "+-", "+-TEST(AArch32_ELF, EdgeKinds) {", "+-  // Fails: Invalid ELF type -> JITLink kind", "+-  Expected<uint32_t> ErrKind = getJITLinkEdgeKind(ELF::R_ARM_NONE);", "+-  EXPECT_TRUE(errorToBool(ErrKind.takeError()));", "+-", "+-  // Fails: Invalid JITLink kind -> ELF type", "+-  Expected<uint32_t> ErrType = getELFRelocationType(Edge::Invalid);", "+-  EXPECT_TRUE(errorToBool(ErrType.takeError()));", "+-", "+-  for (Edge::Kind K = FirstDataRelocation; K < LastThumbRelocation; K += 1) {", "+-    Expected<uint32_t> ELFType = getELFRelocationType(K);", "+-    EXPECT_FALSE(errorToBool(ELFType.takeError()))", "+-        << \"Failed to translate JITLink kind -> ELF type\";", "+-", "+-    Expected<Edge::Kind> JITLinkKind = getJITLinkEdgeKind(*ELFType);", "+-    EXPECT_FALSE(errorToBool(JITLinkKind.takeError()))", "+-        << \"Failed to translate ELF type -> JITLink kind\";", "+-", "+-    EXPECT_EQ(*JITLinkKind, K) << \"Round-trip value inconsistent?\";", "+-  }", "+-}", "+-", "+-namespace llvm {", "+-namespace jitlink {", "+-namespace aarch32 {", "+-", "+-HalfWords encodeImmBT4BlT1BlxT2(int64_t Value);", "+-HalfWords encodeImmBT4BlT1BlxT2_J1J2(int64_t Value);", "+-HalfWords encodeImmMovtT1MovwT3(uint16_t Value);", "+-HalfWords encodeRegMovtT1MovwT3(int64_t Value);", "+-", "+-int64_t decodeImmBT4BlT1BlxT2(uint32_t Hi, uint32_t Lo);", "+-int64_t decodeImmBT4BlT1BlxT2_J1J2(uint32_t Hi, uint32_t Lo);", "+-uint16_t decodeImmMovtT1MovwT3(uint32_t Hi, uint32_t Lo);", "+-int64_t decodeRegMovtT1MovwT3(uint32_t Hi, uint32_t Lo);", "+-", "+-} // namespace aarch32", "+-} // namespace jitlink", "+-} // namespace llvm", "+-", "+-// Big-endian for v7 and v8 (and v6 unless in legacy backwards compatible mode", "+-// be32) have little-endian instructions and big-endian data. In ELF relocatable", "+-// objects big-endian instructions may still be encountered. A be8 supporting", "+-// linker is expected to endian-reverse instructions for the executable.", "+-template <endianness Endian>", "+-static HalfWords makeHalfWords(std::array<uint8_t, 4> Mem) {", "+-  return HalfWords{read16<Endian>(Mem.data()), read16<Endian>(Mem.data() + 2)};", "+-}", "+-", "+-/// 25-bit branch with link (with J1J2 range extension)", "+-TEST(AArch32_Relocations, Thumb_Call_J1J2) {", "+-  static_assert(isInt<25>(16777215), \"Max value\");", "+-  static_assert(isInt<25>(-16777215), \"Min value\");", "+-  static_assert(!isInt<25>(16777217), \"First overflow\");", "+-  static_assert(!isInt<25>(-16777217), \"First underflow\");", "+-", "+-  constexpr HalfWords ImmMask = FixupInfo<Thumb_Call>::ImmMask;", "+-", "+-  static std::array<HalfWords, 3> MemPresets{", "+-      makeHalfWords<little>({0xff, 0xf7, 0xfe, 0xef}), // common", "+-      makeHalfWords<little>({0x00, 0x00, 0x00, 0x00}), // zeros", "+-      makeHalfWords<little>({0xff, 0xff, 0xff, 0xff}), // ones", "+-  };", "+-", "+-  auto EncodeDecode = [ImmMask](int64_t In, MutableHalfWords &Mem) {", "+-    Mem.patch(encodeImmBT4BlT1BlxT2_J1J2(In), ImmMask);", "+-    return decodeImmBT4BlT1BlxT2_J1J2(Mem.Hi, Mem.Lo);", "+-  };", "+-", "+-  for (MutableHalfWords Mem : MemPresets) {", "+-    HalfWords UnaffectedBits(Mem.Hi & ~ImmMask.Hi, Mem.Lo & ~ImmMask.Lo);", "+-", "+-    EXPECT_EQ(EncodeDecode(1, Mem), 0);                 // Zero value", "+-    EXPECT_EQ(EncodeDecode(0x41, Mem), 0x40);           // Common value", "+-    EXPECT_EQ(EncodeDecode(16777215, Mem), 16777214);   // Maximum value", "+-    EXPECT_EQ(EncodeDecode(-16777215, Mem), -16777216); // Minimum value", "+-    EXPECT_NE(EncodeDecode(16777217, Mem), 16777217);   // First overflow", "+-    EXPECT_NE(EncodeDecode(-16777217, Mem), -16777217); // First underflow", "+-", "+-    EXPECT_TRUE(UnaffectedBits.Hi == (Mem.Hi & ~ImmMask.Hi) &&", "+-                UnaffectedBits.Lo == (Mem.Lo & ~ImmMask.Lo))", "+-        << \"Diff outside immediate field\";", "+-  }", "+-}", "+-", "+-/// 22-bit branch with link (without J1J2 range extension)", "+-TEST(AArch32_Relocations, Thumb_Call_Bare) {", "+-  static_assert(isInt<22>(2097151), \"Max value\");", "+-  static_assert(isInt<22>(-2097151), \"Min value\");", "+-  static_assert(!isInt<22>(2097153), \"First overflow\");", "+-  static_assert(!isInt<22>(-2097153), \"First underflow\");", "+-", "+-  constexpr HalfWords ImmMask = FixupInfo<Thumb_Call>::ImmMask;", "+-", "+-  static std::array<HalfWords, 3> MemPresets{", "+-      makeHalfWords<little>({0xff, 0xf7, 0xfe, 0xef}), // common", "+-      makeHalfWords<little>({0x00, 0x00, 0x00, 0x00}), // zeros", "+-      makeHalfWords<little>({0xff, 0xff, 0xff, 0xff}), // ones", "+-  };", "+-", "+-  auto EncodeDecode = [ImmMask](int64_t In, MutableHalfWords &Mem) {", "+-    Mem.patch(encodeImmBT4BlT1BlxT2_J1J2(In), ImmMask);", "+-    return decodeImmBT4BlT1BlxT2_J1J2(Mem.Hi, Mem.Lo);", "+-  };", "+-", "+-  for (MutableHalfWords Mem : MemPresets) {", "+-    HalfWords UnaffectedBits(Mem.Hi & ~ImmMask.Hi, Mem.Lo & ~ImmMask.Lo);", "+-", "+-    EXPECT_EQ(EncodeDecode(1, Mem), 0);               // Zero value", "+-    EXPECT_EQ(EncodeDecode(0x41, Mem), 0x40);         // Common value", "+-    EXPECT_EQ(EncodeDecode(2097151, Mem), 2097150);   // Maximum value", "+-    EXPECT_EQ(EncodeDecode(-2097151, Mem), -2097152); // Minimum value", "+-    EXPECT_NE(EncodeDecode(2097153, Mem), 2097153);   // First overflow", "+-    EXPECT_NE(EncodeDecode(-2097153, Mem), -2097153); // First underflow", "+-", "+-    EXPECT_TRUE(UnaffectedBits.Hi == (Mem.Hi & ~ImmMask.Hi) &&", "+-                UnaffectedBits.Lo == (Mem.Lo & ~ImmMask.Lo))", "+-        << \"Diff outside immediate field\";", "+-  }", "+-}", "+-", "+-/// Write immediate value to the top halfword of the destination register", "+-TEST(AArch32_Relocations, Thumb_MovtAbs) {", "+-  static_assert(isUInt<16>(65535), \"Max value\");", "+-  static_assert(!isUInt<16>(65536), \"First overflow\");", "+-", "+-  constexpr HalfWords ImmMask = FixupInfo<Thumb_MovtAbs>::ImmMask;", "+-  constexpr HalfWords RegMask = FixupInfo<Thumb_MovtAbs>::RegMask;", "+-", "+-  static std::array<uint8_t, 3> Registers{0, 5, 12};", "+-  static std::array<HalfWords, 3> MemPresets{", "+-      makeHalfWords<little>({0xff, 0xf7, 0xfe, 0xef}), // common", "+-      makeHalfWords<little>({0x00, 0x00, 0x00, 0x00}), // zeros", "+-      makeHalfWords<little>({0xff, 0xff, 0xff, 0xff}), // ones", "+-  };", "+-", "+-  auto EncodeDecode = [ImmMask](uint32_t In, MutableHalfWords &Mem) {", "+-    Mem.patch(encodeImmMovtT1MovwT3(In), ImmMask);", "+-    return decodeImmMovtT1MovwT3(Mem.Hi, Mem.Lo);", "+-  };", "+-", "+-  for (MutableHalfWords Mem : MemPresets) {", "+-    for (uint8_t Reg : Registers) {", "+-      HalfWords UnaffectedBits(Mem.Hi & ~(ImmMask.Hi | RegMask.Hi),", "+-                               Mem.Lo & ~(ImmMask.Lo | RegMask.Lo));", "+-", "+-      Mem.patch(encodeRegMovtT1MovwT3(Reg), RegMask);", "+-      EXPECT_EQ(EncodeDecode(0x76bb, Mem), 0x76bb);   // Common value", "+-      EXPECT_EQ(EncodeDecode(0, Mem), 0);             // Minimum value", "+-      EXPECT_EQ(EncodeDecode(0xffff, Mem), 0xffff);   // Maximum value", "+-      EXPECT_NE(EncodeDecode(0x10000, Mem), 0x10000); // First overflow", "+-", "+-      // Destination register as well as unaffacted bits should be intact", "+-      EXPECT_EQ(decodeRegMovtT1MovwT3(Mem.Hi, Mem.Lo), Reg);", "+-      EXPECT_TRUE(UnaffectedBits.Hi == (Mem.Hi & ~(ImmMask.Hi | RegMask.Hi)) &&", "+-                  UnaffectedBits.Lo == (Mem.Lo & ~(ImmMask.Lo | RegMask.Lo)))", "+-          << \"Diff outside immediate/register field\";", "+-    }", "+-  }", "+-}", "+diff -ruN --strip-trailing-cr a/llvm/unittests/ExecutionEngine/JITLink/CMakeLists.txt b/llvm/unittests/ExecutionEngine/JITLink/CMakeLists.txt", "+--- a/llvm/unittests/ExecutionEngine/JITLink/CMakeLists.txt", "++++ b/llvm/unittests/ExecutionEngine/JITLink/CMakeLists.txt", "+@@ -8,7 +8,6 @@", "+   )", "+ ", "+ add_llvm_unittest(JITLinkTests", "+-    AArch32Tests.cpp", "+     EHFrameSupportTests.cpp", "+     LinkGraphTests.cpp", "+   )", "@@ -4,8 +4,8 @@ load(\"//third_party:repo.bzl\", \"tf_http_archive\")", " ", " def repo(name):", "     \"\"\"Imports LLVM.\"\"\"", "-    LLVM_COMMIT = \"c5d22f4e1866549f0d8c3aad598c0153c31679e7\"", "-    LLVM_SHA256 = \"01851eda543900458c84023b15cfb7c37d28f3ac497b5a73cc4c2600fbb80e69\"", "+    LLVM_COMMIT = \"c640a146c4caa3cca559e308e2e7ecc78c45140d\"", "+    LLVM_SHA256 = \"40f70bdf85c955d609086dee109f600ed1001d79eb9d34d30d7966c58ab63485\"", " ", "     tf_http_archive(", "         name = name,", "@@ -44,7 +44,7 @@ profiler = _xla.profiler", " ", " # Just an internal arbitrary increasing number to help with backward-compatible", " # changes.", "-_version = 143", "+_version = 144", " ", " # Version number for MLIR:Python components.", " mlir_api_version = 47", "@@ -145,7 +145,7 @@ def transform_function(", "   # functions can also re-use them.", "   graph = ops.get_default_graph()", "   for edf in cf.graph._functions.values():  # pylint: disable=protected-access", "-    edf.add_to_graph(graph, overwrite=False)", "+    graph._add_function_recursive(edf)  # pylint: disable=protected-access", " ", "   # Initialize the `runtime_client`.", "   eager_ctx = runtime_client.GlobalPythonEagerContext()", "@@ -184,7 +184,7 @@ def transform_function(", "         edf_mlir_pipeline = nested_mlir_transforms.get(edf_name, [])", "         transformed_edf = transform_eager_defined_function(", "             rt, nested_functions[edf_name], edf_transform_fn, edf_mlir_pipeline)", "-        transformed_edf.add_to_graph(graph, overwrite=True)", "+        graph._add_function_recursive(transformed_edf, overwrite=True)  # pylint: disable=protected-access", "         transformed_edf_name = compat.as_str(transformed_edf.name)", "         transformed_nested_functions[transformed_edf_name] = transformed_edf", "         nested_transforms_map[edf_name] = transformed_edf_name", "@@ -241,7 +241,7 @@ def transform_function(", "   # Register the ConcreteFunction with the python Graph.", "   if nested_fn_transforms or nested_mlir_transforms:", "     for transformed_edf in transformed_nested_functions.values():", "-      transformed_edf.add_to_graph(updated_cf.graph, overwrite=True)", "+      updated_cf.graph._add_function_recursive(transformed_edf, overwrite=True)  # pylint: disable=protected-access", "   updated_cf.add_to_graph(graph, overwrite=True)", " ", "   return updated_cf", "@@ -168,25 +168,6 @@ class EagerDefinedFunction(object):", "       self._cached_definition = self.definition", "     return self._cached_definition", " ", "-  def add_to_graph(self, g=None, overwrite=False):", "-    \"\"\"Add the function to the current context or a graph, if supplied.", "-", "-    Args:", "-      g: the graph to add the function to. If not supplied, the function will be", "-        added to the current context.", "-      overwrite: A bool. If True, this function will overwrite any existing", "-        function of the same signature name in the graph `g` or context.", "-    \"\"\"", "-    if not g and self._bound_context.executing_eagerly():", "-      if self._bound_context.has_function(self.name):", "-        if overwrite:", "-          self._bound_context.remove_function(self.name)", "-          self._bound_context.add_function_def(self.definition)", "-      else:", "-        self._bound_context.add_function_def(self.definition)", "-    else:", "-      g._add_function_recursive(self, overwrite)  # pylint: disable=protected-access", "-", "   @property", "   def name(self):", "     return self._name", "@@ -239,7 +239,8 @@ class _DelayedRewriteGradientFunctions(object):", "     forward_function, backwards_function = self.forward_backward(len(doutputs))", "     if not backwards_function.outputs:", "       return backwards_function.structured_outputs", "-    forward_function.add_to_graph(op.graph)", "+", "+    op.graph._add_function_recursive(forward_function)  # pylint: disable=protected-access", " ", "     # pylint: disable=protected-access", "     # Rewrite an inference call op to be a forward call op", "@@ -1590,16 +1591,18 @@ class ConcreteFunction(core.ConcreteFunction, trackable.Trackable):", " ", "     if not context.executing_eagerly() and not g:", "       g = ops.get_default_graph()", "-    self._delayed_rewrite_functions.forward().add_to_graph(g, overwrite)", "+", "+    if g is not None:", "+      g._add_function_recursive(self._delayed_rewrite_functions.forward())  # pylint: disable=protected-access", " ", "   def add_gradient_functions_to_graph(self, g=None):", "     \"\"\"Add forward/backward functions to graph `g` or the current context.\"\"\"", "     if not context.executing_eagerly() and not g:", "       g = ops.get_default_graph()", "-    self._delayed_rewrite_functions.forward().add_to_graph(g)", "+    g._add_function_recursive(self._delayed_rewrite_functions.forward())  # pylint: disable=protected-access", "     forward_function, backward_function = (", "         self._delayed_rewrite_functions.forward_backward())", "-    forward_function.add_to_graph(g)", "+    g._add_function_recursive(forward_function)  # pylint: disable=protected-access", "     backward_function.add_to_graph(g)", " ", "   def _get_gradient_function(self):", "@@ -587,7 +587,7 @@ class _DefinedFunction(object):", " ", "     # Ensures related sub-routines are defined in 'g', too.", "     for f in self._sub_functions.values():", "-      f.add_to_graph(g)", "+      g._add_function_recursive(f)  # pylint: disable=protected-access", " ", "     # Adds its gradient function, too.", "     if self._grad_func:", "@@ -3210,13 +3210,14 @@ class Graph(pywrap_tf_session.PyGraph):", "     else:", "       self._add_function(function)", " ", "-    for f in function.graph._functions.values():  # pylint: disable=protected-access", "-      if self._is_function(f.name):", "-        if overwrite:", "-          self._remove_function(f.name)", "+    if hasattr(function, \"graph\"):", "+      for f in function.graph._functions.values():  # pylint: disable=protected-access", "+        if self._is_function(f.name):", "+          if overwrite:", "+            self._remove_function(f.name)", "+            self._add_function(f)", "+        else:", "           self._add_function(f)", "-      else:", "-        self._add_function(f)", " ", "   def _add_function(self, function):", "     \"\"\"Adds a function to the graph.", "@@ -68,7 +68,8 @@ def create_new_tf_function(func_graph):", "   \"\"\"", "   func = function._EagerDefinedFunction(  # pylint: disable=protected-access", "       func_graph.name, func_graph, func_graph.inputs, func_graph.outputs, {})", "-  func.add_to_graph(func_graph.outer_graph)", "+", "+  func_graph.outer_graph._add_function_recursive(func)  # pylint: disable=protected-access", "   return func_graph.name", " ", " ", "@@ -1204,7 +1204,7 @@ def partitioned_call(args,", "   config_proto = attr_value_pb2.AttrValue(s=config)", " ", "   graph = ops.get_default_graph()", "-  f.add_to_graph(graph)", "+  graph._add_function_recursive(f)  # pylint: disable=protected-access", "   op_name = \"StatefulPartitionedCall\" if f.stateful_ops else \"PartitionedCall\"", " ", "   # Propagate the attribute indicating the need to compile from function to the", "@@ -547,6 +547,7 @@ cuda_py_test(", "         \"//tensorflow/python/trackable:asset\",", "         \"//tensorflow/python/trackable:autotrackable\",", "         \"//tensorflow/python/trackable:resource\",", "+        \"//tensorflow/python:array_ops\",", "     ] + if_google([", "         \"//tensorflow/cc/experimental/tf2:runtime_pybind\",", "     ]),", "@@ -637,6 +638,7 @@ py_strict_library(", "     deps = [", "         \":nested_structure_coder\",", "         \"//tensorflow/core:protos_all_py\",", "+        \"//tensorflow/python:array_ops\",", "         \"//tensorflow/python:default_gradient\",", "         \"//tensorflow/python:framework_ops\",", "         \"//tensorflow/python:func_graph\",", "@@ -645,7 +647,6 @@ py_strict_library(", "         \"//tensorflow/python:op_def_registry\",", "         \"//tensorflow/python:resource_variable_ops\",", "         \"//tensorflow/python:tensor_spec\",", "-        \"//tensorflow/python:tf_decorator\",", "         \"//tensorflow/python:type_spec\",", "         \"//tensorflow/python/eager:def_function\",", "         \"//tensorflow/python/eager:function\",", "@@ -653,7 +654,6 @@ py_strict_library(", "         \"//tensorflow/python/util:compat\",", "         \"//tensorflow/python/util:nest\",", "         \"//tensorflow/python/util:tf_decorator\",", "-        \"//tensorflow/python/util:tf_inspect\",", "         \"@absl_py//absl/logging\",", "     ],", " )", "@@ -17,6 +17,7 @@", " import collections", " import pprint", " import re", "+", " from absl import logging", " ", " from tensorflow.core.protobuf import saved_object_graph_pb2", "@@ -29,6 +30,7 @@ from tensorflow.python.framework import op_def_registry", " from tensorflow.python.framework import ops", " from tensorflow.python.framework import tensor_spec", " from tensorflow.python.framework import type_spec", "+from tensorflow.python.ops import array_ops", " from tensorflow.python.ops import custom_gradient", " from tensorflow.python.ops import default_gradient", " from tensorflow.python.ops import resource_variable_ops", "@@ -462,9 +464,24 @@ def _gen_gradient_func(func):", "     # expects tensors. Replacing with zeros is correct since the `None` values", "     # occur when the gradient is unconnected, and thus the gradient is", "     # \"statically proven to be zero.\" See `tf.UnconnectedGradients` for details.", "+", "+    def none_to_zero(x, t):", "+      if x is not None:", "+        return x", "+", "+      shape, dtype = default_gradient.shape_and_dtype(t)", "+", "+      if shape.is_fully_defined():", "+        return default_gradient.zeros_like(t)", "+", "+      dims = []", "+      if shape.rank is not None:", "+        dims = [1 if d is None else d for d in shape.as_list()]", "+", "+      return array_ops.zeros(dims, dtype)", "+", "     result_grads = [", "-        x if x is not None else default_gradient.zeros_like(t)", "-        for (x, t) in zip(result_grads, func.graph.inputs)", "+        none_to_zero(x, t) for (x, t) in zip(result_grads, func.graph.inputs)", "     ]", " ", "     return func(*result_grads)", "@@ -2622,6 +2622,56 @@ class LoadTest(test.TestCase, parameterized.TestCase):", " ", "     self.assertAllClose(grads, expected_grads)", " ", "+  def test_custom_gradients_with_none_grad_and_partial_shape(", "+      self, cycles, use_cpp_bindings", "+  ):", "+    # TODO(b/264869228) Fix LoadTest", "+    if use_cpp_bindings:", "+      self.skipTest(\"Not implemented for cpp.\")", "+    # https://github.com/google/jax/issues/7123", "+", "+    @custom_gradient.custom_gradient", "+    def f(params, state):", "+      def grad_fn(*args):", "+        return args", "+", "+      return (params, state), grad_fn", "+", "+    @def_function.function(", "+        input_signature=[", "+            tensor_spec.TensorSpec(None, dtypes.float32),", "+            tensor_spec.TensorSpec(None, dtypes.int32),", "+        ]", "+    )", "+    def predict(params, state):", "+      return f(params, state)", "+", "+    params = variables.Variable(1.0)", "+    # None grads only appear when state is an int.", "+    state = constant_op.constant(3, dtype=dtypes.int32)", "+    with backprop.GradientTape() as tape:", "+      tape.watch(params)", "+      y = predict(params, state)", "+      expected_grads = tape.gradient(y, params)", "+", "+    root = autotrackable.AutoTrackable()", "+    root.fn = predict", "+    loaded = cycle(", "+        root,", "+        cycles,", "+        save_option=save_options.SaveOptions(", "+            experimental_custom_gradients=True", "+        ),", "+        use_cpp_bindings=use_cpp_bindings,", "+    )", "+", "+    with backprop.GradientTape() as tape:", "+      tape.watch(params)", "+      y = loaded.fn(params, state)", "+      grads = tape.gradient(y, params)", "+", "+    self.assertAllClose(grads, expected_grads)", "+", " ", " @parameterized.named_parameters(*_test_params())", " class SingleCycleTests(test.TestCase, parameterized.TestCase):", "@@ -18,6 +18,8 @@ limitations under the License.", " ", " #include <memory>", " #include <optional>", "+#include <string>", "+#include <vector>", " ", " #include \"mlir/IR/BuiltinOps.h\"  // from @llvm-project", " #include \"tensorflow/compiler/xla/pjrt/pjrt_client.h\"", "@@ -46,6 +48,15 @@ class PjRtDeviceTopology {", " ", "   // If non-null, overrides the compiler for this topology.", "   virtual std::optional<PjRtCompiler*> compiler() const { return std::nullopt; }", "+", "+  // If not-null, returns vendor specific attributes about each device. For", "+  // example, the model number of a GPU, or the mesh coordinates of a TPU", "+  // device.", "+  virtual std::optional<", "+      std::vector<absl::flat_hash_map<std::string, PjRtDeviceAttribute>>>", "+  DeviceAttributes() const {", "+    return std::nullopt;", "+  }", " };", " ", " // Abstract interface that all registered compilers must implement.", "@@ -76,7 +87,7 @@ void PjRtRegisterCompiler(absl::string_view platform_name,", " // registered for the platform using PjRtRegisterCompiler. The returned", " // PjRtExecutable must be loaded by a compatible client before execution.", " //", "-// The actual compiler used may be overriden by Topology::compiler().", "+// The actual compiler used may be overridden by Topology::compiler().", " //", " // Returns error::NotFound if a compiler has not been registered for the", " // platform. Forwards errors returned from the registered compiler in case of a", "@@ -753,9 +753,17 @@ PYBIND11_MODULE(xla_extension, m) {", "         \"representation\");", " ", "   py::class_<PjRtDeviceTopology>(m, \"DeviceTopology\")", "-      .def_property_readonly(\"platform\", [](PjRtDeviceTopology& topology) {", "-        return topology.platform_name();", "-      });", "+      .def_property_readonly(", "+          \"platform\",", "+          [](PjRtDeviceTopology& topology) { return topology.platform_name(); })", "+      .def_property_readonly(\"platform_version\",", "+                             [](PjRtDeviceTopology& topology) {", "+                               return topology.platform_version();", "+                             })", "+      .def_property_readonly(\"device_attributes\",", "+                             [](PjRtDeviceTopology& topology) {", "+                               return py::cast(topology.DeviceAttributes());", "+                             });", " ", "   py::class_<PjRtExecutable, std::shared_ptr<PjRtExecutable>>(m, \"Executable\")", "       .def(\"hlo_modules\", &PjRtExecutable::GetHloModules)", "@@ -572,6 +572,8 @@ class Executable:", " ", " class DeviceTopology:", "   platform: str", "+  platform_version: str", "+  device_attributes: List[Dict[str, Any]]", " ", " def compile(topology: DeviceTopology, mlir_module: str) -> Executable: ...", " ", "@@ -1030,7 +1030,6 @@ py_library(", "         \":op_def_registry\",", "         \":registry\",", "         \":stack\",", "-        \":tensor_conversion\",", "         \":tensor_conversion_registry\",", "         \":tensor_shape\",", "         \":tensor_util\",", "@@ -1113,8 +1112,8 @@ py_library(", "     srcs_version = \"PY3\",", "     deps = [", "         \":tensor_conversion_registry\",", "-        \"//tensorflow/python/util\",", "         \"//tensorflow/python/util:deprecation\",", "+        \"//tensorflow/python/util:dispatch\",", "         \"//tensorflow/python/util:tf_export\",", "     ],", " )", "@@ -53,7 +53,6 @@ from tensorflow.python.framework import errors", " from tensorflow.python.framework import op_callbacks", " from tensorflow.python.framework import registry", " from tensorflow.python.framework import stack", "-from tensorflow.python.framework import tensor_conversion", " from tensorflow.python.framework import tensor_conversion_registry", " from tensorflow.python.framework import tensor_shape", " from tensorflow.python.framework import tensor_util", "@@ -1359,22 +1358,6 @@ EagerTensor = tf_export(\"__internal__.EagerTensor\", v1=[])(", "     pywrap_tfe.TFE_Py_InitEagerTensor(_EagerTensorBase))", " ", " ", "-convert_to_tensor_v1_with_dispatch = (", "-    tensor_conversion.convert_to_tensor_v1_with_dispatch", "-)", "-", "-", "-convert_to_tensor_v1 = tensor_conversion.convert_to_tensor_v1", "-", "-", "-convert_to_tensor_v2_with_dispatch = (", "-    tensor_conversion.convert_to_tensor_v2_with_dispatch", "-)", "-", "-", "-convert_to_tensor_v2 = tensor_conversion.convert_to_tensor_v2", "-", "-", " def _add_error_prefix(msg, *, name=None):", "   return msg if name is None else f\"{name}: {msg}\"", " ", "@@ -263,7 +263,7 @@ TEST(DelegateTest, TestDataMultiAddBin_MultiInputMultiOutput_FullyDelegated) {", "   TfLiteModelDelete(model);", " }", " ", "-TfLiteRegistrationExternal* GetDelegateKernelRegistrationImpl(", "+TfLiteRegistrationExternal* CreateDelegateKernelRegistrationImpl(", "     SimpleOpaqueDelegateInterface* delegate) {", "   TfLiteRegistrationExternal* kernel_registration =", "       TfLiteRegistrationExternalCreate(kTfLiteBuiltinDelegate, delegate->Name(),", "@@ -388,7 +388,7 @@ TEST_F(TestDelegate, SetBufferHandle) {", "         TF_LITE_ENSURE_STATUS(TfLiteOpaqueContextGetExecutionPlan(", "             opaque_context, &execution_plan));", "         TfLiteRegistrationExternal* delegate_kernel_registration =", "-            GetDelegateKernelRegistrationImpl(simple_opaque_delegate);", "+            CreateDelegateKernelRegistrationImpl(simple_opaque_delegate);", " ", "         return TfLiteOpaqueContextReplaceNodeSubsetsWithDelegateKernels(", "             opaque_context, delegate_kernel_registration, execution_plan,", "@@ -15,6 +15,12 @@ limitations under the License.", " #ifndef TENSORFLOW_LITE_C_C_API_H_", " #define TENSORFLOW_LITE_C_C_API_H_", " ", "+/// \\file", "+///", "+/// C API for TensorFlow Lite.", "+///", "+/// For documentation, see tensorflow/lite/core/c/c_api.h", "+", " #include \"tensorflow/lite/core/c/c_api.h\"", " ", " #endif  // TENSORFLOW_LITE_C_C_API_H_", "@@ -278,6 +278,7 @@ dtensor_test(", "     env = {", "         \"DTENSOR_GPU_USE_NCCL_COMMUNICATION\": \"1\",", "         \"NCCL_P2P_DISABLE\": \"1\",  # FIXME(b/251183104): p2p detection in cuda 10.1+ is broken.", "+        \"NCCL_PROTO\": \"Simple\",  # FIXME(b/272050398): Delete this when the Clang-16/NCCL incompatibility has been resolved.", "     },", "     tags = [", "         \"no_windows\",", "@@ -322,6 +323,7 @@ dtensor_test(", "     env = {", "         \"DTENSOR_GPU_USE_NCCL_COMMUNICATION\": \"1\",", "         \"NCCL_P2P_DISABLE\": \"1\",  # FIXME(b/251183104): p2p detection in cuda 10.1+ is broken.", "+        \"NCCL_PROTO\": \"Simple\",  # FIXME(b/272050398): Delete this when the Clang-16/NCCL incompatibility has been resolved.", "     },", "     tags = [", "         \"no_windows\",", "@@ -530,7 +530,8 @@ class QuantizedModelTest(test.TestCase, parameterized.TestCase):", "         shape=array_ops.shape(input_vocabs_placeholder), dtype=dtypes.float32", "     )", "     # shape: (?, 2)", "-    weight = array_ops.transpose_v2(array_ops.stack([weight_row, weight_row]))", "+    weight = array_ops.transpose_v2(", "+        array_ops_stack.stack([weight_row, weight_row]))", "     # shape: (2, 2)", "     output_tensor = math_ops.matmul(matmul_input, weight)", " ", "@@ -784,7 +785,8 @@ class QuantizedModelTest(test.TestCase, parameterized.TestCase):", "         shape=array_ops.shape(input_vocabs_placeholder), dtype=dtypes.float32", "     )", "     # shape: (?, 2)", "-    weight = array_ops.transpose_v2(array_ops.stack([weight_row, weight_row]))", "+    weight = array_ops.transpose_v2(", "+        array_ops_stack.stack([weight_row, weight_row]))", "     weight = array_ops.fake_quant_with_min_max_args(", "         weight, min=-0.1, max=0.2, num_bits=8, narrow_range=False", "     )", "@@ -1414,7 +1414,7 @@ py_library(", "     srcs = [\"ops/control_flow_case.py\"],", "     srcs_version = \"PY3\",", "     deps = [", "-        \":array_ops\",", "+        \":array_ops_stack\",", "         \":cond\",", "         \":control_flow_assert\",", "         \":math_ops\",", "@@ -1435,12 +1435,6 @@ def parallel_stack(values, name=\"parallel_stack\"):", "         [expand_dims(value, 0) for value in values], shape=output_shape)", " ", " ", "-# This function is deprecated. Use the one in array_ops_stack.py instead.", "-# TODO(b/269481974): Delete this function when all references have been moved.", "-def stack(values, axis=0, name=\"stack\"):", "-  return array_ops_stack.stack(values, axis, name)", "-", "-", " # pylint: disable=invalid-name", " def _autopacking_helper(list_or_tuple, dtype, name):", "   \"\"\"Converts the given list or tuple to a tensor by packing.", "@@ -1561,12 +1555,6 @@ tensor_conversion_registry.register_tensor_conversion_function(", "     (list, tuple), _autopacking_conversion_function, 99)", " ", " ", "-# This function is deprecated. Use the one in array_ops_stack.py instead.", "-# TODO(b/269481974): Delete this function when all references have been moved.", "-def unstack(value, num=None, axis=0, name=\"unstack\"):", "-  return array_ops_stack.unstack(value, num, axis, name)", "-", "-", " @tf_export(\"concat\")", " @dispatch.add_dispatch_support", " def concat(values, axis, name=\"concat\"):", "@@ -20,7 +20,7 @@ from tensorflow.python.eager import context", " from tensorflow.python.framework import constant_op", " from tensorflow.python.framework import dtypes", " from tensorflow.python.framework import ops", "-from tensorflow.python.ops import array_ops", "+from tensorflow.python.ops import array_ops_stack", " from tensorflow.python.ops import cond", " from tensorflow.python.ops import control_flow_assert", " from tensorflow.python.ops import math_ops", "@@ -251,7 +251,7 @@ def _assert_at_most_n_true(predicates, n, msg):", "     n: maximum number of true predicates allowed.", "     msg: Error message.", "   \"\"\"", "-  preds_c = array_ops.stack(predicates, name=\"preds_c\")", "+  preds_c = array_ops_stack.stack(predicates, name=\"preds_c\")", "   num_true_conditions = math_ops.reduce_sum(", "       math_ops.cast(preds_c, dtypes.int32), name=\"num_true_conds\")", "   condition = math_ops.less_equal(num_true_conditions,", "@@ -288,7 +288,7 @@ def _case_create_default_action(predicates, actions):", "                   \"predicates are True: \" % k)", "     default_msg = (\"Input error: \"", "                    \"None of conditions evaluated as True:\",", "-                   array_ops.stack(predicates, name=\"preds_c\"))", "+                   array_ops_stack.stack(predicates, name=\"preds_c\"))", "     with ops.control_dependencies([", "         _assert_at_most_n_true(  # pylint: disable=protected-access", "             other_predicates, n=0, msg=others_msg),", "@@ -156,6 +156,7 @@ py_library(", "     srcs_version = \"PY3\",", "     deps = [", "         \":ragged_tensor\",", "+        \"//tensorflow/python:array_ops_stack\",", "         \"//tensorflow/python:embedding_ops\",", "     ],", " )", "@@ -17,6 +17,7 @@", " from tensorflow.python.framework import dtypes", " from tensorflow.python.framework import ops", " from tensorflow.python.ops import array_ops", "+from tensorflow.python.ops import array_ops_stack", " from tensorflow.python.ops import embedding_ops", " from tensorflow.python.ops import math_ops", " from tensorflow.python.ops import resource_variable_ops", "@@ -366,7 +367,7 @@ def safe_embedding_lookup_sparse(", "       # for use in Select.", "       is_row_empty = array_ops.tile(", "           array_ops.reshape(is_row_empty, [-1, 1]),", "-          array_ops.stack([1, array_ops.shape(result)[1]]),", "+          array_ops_stack.stack([1, array_ops.shape(result)[1]]),", "       )", " ", "       result = array_ops.where(", "@@ -83,8 +83,6 @@", "         `tf.keras.optimizers` directly. The API namespace for", "         `tf.keras.dtensor.experimental.optimizers` will be removed in future", "         releases.", "-    *   Added support for `class_weight` for 3+ dimensional targets (e.g.", "-        image segmentation masks) in `Model.fit`.", " ", " *   `tf.function`:", " ", "@@ -385,7 +385,6 @@ cc_library(", "         \"@llvm-project//llvm:ir_headers\",", "         \"@llvm-project//mlir:ArithDialect\",", "         \"@llvm-project//mlir:ArithToLLVM\",", "-        \"@llvm-project//mlir:BuiltinToLLVMIRTranslation\",", "         \"@llvm-project//mlir:FuncDialect\",", "         \"@llvm-project//mlir:IR\",", "         \"@llvm-project//mlir:IndexToLLVM\",", "@@ -46,7 +46,6 @@ limitations under the License.", " #include \"mlir/IR/BuiltinOps.h\"  // from @llvm-project", " #include \"mlir/IR/BuiltinTypeInterfaces.h\"  // from @llvm-project", " #include \"mlir/IR/BuiltinTypes.h\"  // from @llvm-project", "-#include \"mlir/IR/DialectRegistry.h\"  // from @llvm-project", " #include \"mlir/IR/ImplicitLocOpBuilder.h\"  // from @llvm-project", " #include \"mlir/IR/Location.h\"  // from @llvm-project", " #include \"mlir/IR/PatternMatch.h\"  // from @llvm-project", "@@ -55,7 +54,6 @@ limitations under the License.", " #include \"mlir/IR/Verifier.h\"  // from @llvm-project", " #include \"mlir/Pass/PassManager.h\"  // from @llvm-project", " #include \"mlir/Support/LogicalResult.h\"  // from @llvm-project", "-#include \"mlir/Target/LLVMIR/Dialect/Builtin/BuiltinToLLVMIRTranslation.h\"  // from @llvm-project", " #include \"mlir/Transforms/Passes.h\"  // from @llvm-project", " #include \"tensorflow/compiler/xla/hlo/ir/hlo_casting_utils.h\"", " #include \"tensorflow/compiler/xla/hlo/ir/hlo_instruction.h\"", "@@ -670,9 +668,6 @@ std::optional<LaunchDimensions> TritonWrapper(", "   // TODO(b/264317991): Pass in a context instead if this becomes to slow.", "   mlir::MLIRContext mlir_context;", "   mlir_context.loadDialect<mt::TritonDialect>();", "-  mlir::DialectRegistry registry;", "-  mlir::registerBuiltinDialectTranslation(registry);", "-  mlir_context.appendDialectRegistry(registry);", "   mlir::OpBuilder b(&mlir_context);", "   auto loc = mlir::NameLoc::get(b.getStringAttr(hlo_computation->name()));", "   auto triton_module = mlir::ModuleOp::create(loc);", "@@ -0,0 +1,32 @@", "+==== triton/BUILD#9 - triton/BUILD#10 ====", "+# action=edit type=text", "+--- triton/BUILD\t2023-03-10 07:24:02.000000000 -0800", "++++ triton/BUILD\t2023-03-23 08:38:30.000000000 -0700", "+@@ -442,6 +442,7 @@", "+         \"@llvm-project//llvm:IRReader\",", "+         \"@llvm-project//llvm:Linker\",", "+         \"@llvm-project//llvm:Support\",", "++        \"@llvm-project//mlir:BuiltinToLLVMIRTranslation\",", "+         \"@llvm-project//mlir:ConversionPasses\",", "+         \"@llvm-project//mlir:ExecutionEngine\",", "+         \"@llvm-project//mlir:ExecutionEngineUtils\",", "+==== triton/lib/Target/LLVMIR/LLVMIRTranslation.cpp#9 - triton/lib/Target/LLVMIR/LLVMIRTranslation.cpp#10 ====", "+# action=edit type=text", "+--- triton/lib/Target/LLVMIR/LLVMIRTranslation.cpp\t2023-03-10 07:24:02.000000000 -0800", "++++ triton/lib/Target/LLVMIR/LLVMIRTranslation.cpp\t2023-03-23 08:38:30.000000000 -0700", "+@@ -7,6 +7,7 @@", "+ #include \"mlir/IR/Dialect.h\"", "+ #include \"mlir/Pass/Pass.h\"", "+ #include \"mlir/Pass/PassManager.h\"", "++#include \"mlir/Target/LLVMIR/Dialect/Builtin/BuiltinToLLVMIRTranslation.h\"", "+ #include \"mlir/Target/LLVMIR/Dialect/LLVMIR/LLVMToLLVMIRTranslation.h\"", "+ #include \"mlir/Target/LLVMIR/Dialect/NVVM/NVVMToLLVMIRTranslation.h\"", "+ #include \"mlir/Target/LLVMIR/Export.h\"", "+@@ -233,6 +234,7 @@", "+ std::unique_ptr<llvm::Module>", "+ translateLLVMToLLVMIR(llvm::LLVMContext *llvmContext, mlir::ModuleOp module) {", "+   DialectRegistry registry;", "++  mlir::registerBuiltinDialectTranslation(registry);", "+   mlir::registerLLVMDialectTranslation(registry);", "+   mlir::registerNVVMDialectTranslation(registry);", "+   module->getContext()->appendDialectRegistry(registry);", "@@ -14,5 +14,5 @@ def repo():", "         strip_prefix = \"triton-{commit}\".format(commit = TRITON_COMMIT),", "         urls = tf_mirror_urls(\"https://github.com/openxla/triton/archive/{commit}.tar.gz\".format(commit = TRITON_COMMIT)),", "         # For temporary changes which haven't landed upstream yet.", "-        patch_file = [],", "+        patch_file = [\"//third_party/triton:cl518645628.patch\"],", "     )", "@@ -2352,6 +2352,7 @@ cc_library(", "     hdrs = [\"utils/tpu_rewrite_device_util.h\"],", "     deps = [", "         \":tensorflow\",", "+        \":tensorflow_types\",", "         \"//tensorflow/compiler/mlir/utils:string_container_utils\",", "         \"//tensorflow/compiler/xla:array4d\",", "         \"//tensorflow/compiler/xla:xla_data_proto_cc\",", "@@ -0,0 +1,130 @@", "+// RUN: tf-opt %s -split-input-file -verify-diagnostics -tf-tpu-validate-inputs | FileCheck %s", "+", "+// CHECK-LABEL: func @num_replicas_replicated", "+func.func @num_replicas_replicated(%arg0: tensor<i32>, %arg1: tensor<i32>, %arg2: tensor<i32>, %arg3: tensor<i32>) -> (tensor<i32>, tensor<i32>) {", "+  %0:2 = tf_executor.graph {", "+    %control = tf_executor.island() wraps \"tf.TPUReplicateMetadata\"() {_xla_compile_device_type = \"TPU\", _tpu_replicate = \"cluster\", device = \"/device:TPU:0\", num_replicas = 2, topology = \"topology\"} : () -> ()", "+    %ri, %c0 = tf_executor.island wraps \"tf.TPUReplicatedInput\"(%arg0, %arg1) {index = 1 : i64, is_mirrored_variable = false, is_packed = false} : (tensor<i32>, tensor<i32>) -> tensor<i32>", "+    %out, %c1 = tf_executor.island wraps \"tf.opA\"(%ri) {_tpu_replicate = \"cluster\"} : (tensor<i32>) -> tensor<i32>", "+    %ro:2, %c2 = tf_executor.island wraps \"tf.TPUReplicatedOutput\"(%out) : (tensor<i32>) -> (tensor<i32>, tensor<i32>)", "+    tf_executor.fetch %ro#0, %ro#1 : tensor<i32>, tensor<i32>", "+  }", "+  return %0#0, %0#1 : tensor<i32>, tensor<i32>", "+}", "+", "+// -----", "+", "+func.func @num_replicas_replicated_input(%arg0: tensor<i32>, %arg1: tensor<i32>, %arg2: tensor<i32>, %arg3: tensor<i32>) -> (tensor<i32>, tensor<i32>) {", "+  %0:2 = tf_executor.graph {", "+    %control = tf_executor.island() wraps \"tf.TPUReplicateMetadata\"() {_xla_compile_device_type = \"TPU\", _tpu_replicate = \"cluster\", device = \"/device:TPU:0\", num_replicas = 2, topology = \"topology\"} : () -> ()", "+    // expected-error @+1 {{'tf.TPUReplicatedInput' op TF2XLA TPU bridge input check: number of inputs inconsistent. num_replicas=2 no. of inputs=3}}", "+    %ri, %c0 = tf_executor.island wraps \"tf.TPUReplicatedInput\"(%arg0, %arg1, %arg1) {index = 1 : i64, is_mirrored_variable = false, is_packed = false} : (tensor<i32>, tensor<i32>, tensor<i32>) -> tensor<i32>", "+    %out, %c1 = tf_executor.island wraps \"tf.opA\"(%ri) {_tpu_replicate = \"cluster\"} : (tensor<i32>) -> tensor<i32>", "+    %ro:2, %c2 = tf_executor.island wraps \"tf.TPUReplicatedOutput\"(%out) : (tensor<i32>) -> (tensor<i32>, tensor<i32>)", "+    tf_executor.fetch %ro#0, %ro#1 : tensor<i32>, tensor<i32>", "+  }", "+  return %0#0, %0#1 : tensor<i32>, tensor<i32>", "+}", "+", "+// -----", "+", "+func.func @num_replicas_replicated_input_packed(%arg0: tensor<i32>, %arg1: tensor<i32>, %arg2: tensor<i32>, %arg3: tensor<i32>) -> (tensor<i32>, tensor<i32>) {", "+  %0:2 = tf_executor.graph {", "+    %control = tf_executor.island() wraps \"tf.TPUReplicateMetadata\"() {_xla_compile_device_type = \"TPU\", _tpu_replicate = \"cluster\", device = \"/device:TPU:0\", num_replicas = 2, topology = \"topology\"} : () -> ()", "+    // expected-error @+1 {{'tf.TPUReplicatedInput' op TF2XLA TPU bridge input check: packed with number of inputs not 1. num_replicas=2 no. of inputs=2}}", "+    %ri, %c0 = tf_executor.island wraps \"tf.TPUReplicatedInput\"(%arg0, %arg1) {index = 1 : i64, is_mirrored_variable = false, is_packed = true} : (tensor<i32>, tensor<i32>) -> tensor<i32>", "+    %out, %c1 = tf_executor.island wraps \"tf.opA\"(%ri) {_tpu_replicate = \"cluster\"} : (tensor<i32>) -> tensor<i32>", "+    %ro:2, %c2 = tf_executor.island wraps \"tf.TPUReplicatedOutput\"(%out) : (tensor<i32>) -> (tensor<i32>, tensor<i32>)", "+    tf_executor.fetch %ro#0, %ro#1 : tensor<i32>, tensor<i32>", "+  }", "+  return %0#0, %0#1 : tensor<i32>, tensor<i32>", "+}", "+", "+// -----", "+", "+func.func @num_replicas_replicated_output(%arg0: tensor<i32>, %arg1: tensor<i32>, %arg2: tensor<i32>, %arg3: tensor<i32>) -> (tensor<i32>, tensor<i32>) {", "+  %0:2 = tf_executor.graph {", "+    %control = tf_executor.island() wraps \"tf.TPUReplicateMetadata\"() {_xla_compile_device_type = \"TPU\", _tpu_replicate = \"cluster\", device = \"/device:TPU:0\", num_replicas = 2, topology = \"topology\"} : () -> ()", "+    %ri, %c0 = tf_executor.island wraps \"tf.TPUReplicatedInput\"(%arg0, %arg1) {index = 1 : i64, is_mirrored_variable = false, is_packed = false} : (tensor<i32>, tensor<i32>) -> tensor<i32>", "+    %out, %c1 = tf_executor.island wraps \"tf.opA\"(%ri) {_tpu_replicate = \"cluster\"} : (tensor<i32>) -> tensor<i32>", "+    // expected-error @+1 {{'tf.TPUReplicatedOutput' op TF2XLA TPU bridge input check: number of outputs inconsistent. num_replicas=2 no. of outputs=3}}", "+    %ro:3, %c2 = tf_executor.island wraps \"tf.TPUReplicatedOutput\"(%out) : (tensor<i32>) -> (tensor<i32>, tensor<i32>, tensor<i32>)", "+    tf_executor.fetch %ro#0, %ro#1 : tensor<i32>, tensor<i32>", "+  }", "+  return %0#0, %0#1 : tensor<i32>, tensor<i32>", "+}", "+", "+// -----", "+", "+func.func @num_core_per_replica_partitioned_input(%arg0: tensor<i32>, %arg1: tensor<i32>, %arg2: tensor<i32>, %arg3: tensor<i32>) -> (tensor<i32>, tensor<i32>) {", "+  %0:2 = tf_executor.graph {", "+    %control = tf_executor.island() wraps \"tf.TPUReplicateMetadata\"() {_xla_compile_device_type = \"TPU\", _tpu_replicate = \"cluster\", device = \"/device:TPU:0\", num_cores_per_replica = 2 : i64, num_replicas = 1 : i64, topology = \"topology\"} : () -> ()", "+    // expected-error @+1 {{'tf.TPUPartitionedInput' op TF2XLA TPU bridge input check: number of inputs inconsistent. num_cores_per_replica=2 no. of inputs=3}}", "+    %pi, %c0 = tf_executor.island wraps \"tf.TPUPartitionedInput\"(%arg0, %arg1, %arg1) {index = 1 : i64} : (tensor<i32>, tensor<i32>, tensor<i32>) -> tensor<i32>", "+    %out, %c1 = tf_executor.island wraps \"tf.opA\"(%pi) {_tpu_replicate = \"cluster\"} : (tensor<i32>) -> tensor<i32>", "+    %po:2, %c2 = tf_executor.island wraps \"tf.TPUPartitionedOutput\"(%out) : (tensor<i32>) -> (tensor<i32>, tensor<i32>)", "+    tf_executor.fetch %po#0, %po#1 : tensor<i32>, tensor<i32>", "+  }", "+  return %0#0, %0#1 : tensor<i32>, tensor<i32>", "+}", "+", "+// -----", "+", "+func.func @num_core_per_replica_partitioned_output(%arg0: tensor<i32>, %arg1: tensor<i32>, %arg2: tensor<i32>, %arg3: tensor<i32>) -> (tensor<i32>, tensor<i32>) {", "+  %0:2 = tf_executor.graph {", "+    %control = tf_executor.island() wraps \"tf.TPUReplicateMetadata\"() {_xla_compile_device_type = \"TPU\", _tpu_replicate = \"cluster\", device = \"/device:TPU:0\", num_cores_per_replica = 2 : i64, num_replicas = 1 : i64, topology = \"topology\"} : () -> ()", "+    %pi, %c0 = tf_executor.island wraps \"tf.TPUPartitionedInput\"(%arg0, %arg1) {index = 1 : i64} : (tensor<i32>, tensor<i32>) -> tensor<i32>", "+    %out, %c1 = tf_executor.island wraps \"tf.opA\"(%pi) {_tpu_replicate = \"cluster\"} : (tensor<i32>) -> tensor<i32>", "+    // expected-error @+1 {{'tf.TPUPartitionedOutput' op TF2XLA TPU bridge input check: number of outputs inconsistent. num_cores_per_replica=2 no. of outputs=3}}", "+    %po:3, %c2 = tf_executor.island wraps \"tf.TPUPartitionedOutput\"(%out) : (tensor<i32>) -> (tensor<i32>, tensor<i32>, tensor<i32>)", "+    tf_executor.fetch %po#0, %po#1 : tensor<i32>, tensor<i32>", "+  }", "+  return %0#0, %0#1 : tensor<i32>, tensor<i32>", "+}", "+", "+// -----", "+", "+func.func @validate_tpu_replicate_no_attr(%arg0: tensor<i32>, %arg1: tensor<i32>, %arg2: tensor<i32>, %arg3: tensor<i32>) -> (tensor<i32>, tensor<i32>) {", "+  %0:2 = tf_executor.graph {", "+    %control = tf_executor.island() wraps \"tf.TPUReplicateMetadata\"() {_xla_compile_device_type = \"TPU\", _tpu_replicate = \"cluster\", device = \"/device:TPU:0\", num_replicas = 2, topology = \"topology\"} : () -> ()", "+    %ri, %c0 = tf_executor.island wraps \"tf.TPUReplicatedInput\"(%arg0, %arg1) {index = 1 : i64, is_mirrored_variable = false, is_packed = false} : (tensor<i32>, tensor<i32>) -> tensor<i32>", "+    %out, %c1 = tf_executor.island wraps \"tf.opA\"(%ri) {_tpu_replicate=\"cluster\"}: (tensor<i32>) -> tensor<i32>", "+    // expected-warning @+1 {{TF2XLA TPU bridge input check: cluster op = tf.opA with cluster = cluster has successor as non cluster op tf.opB}}", "+    %out2, %c2 = tf_executor.island wraps \"tf.opB\"(%out) : (tensor<i32>) -> tensor<i32>", "+    // expected-error @+1 {{tf.TPUReplicatedOutput' op TF2XLA TPU bridge input check: non-cluster op = tf.opB has invalid successor op = tf.TPUReplicatedOutput}}", "+    %ro:2, %c4 = tf_executor.island wraps \"tf.TPUReplicatedOutput\"(%out2) : (tensor<i32>) -> (tensor<i32>, tensor<i32>)", "+    tf_executor.fetch %ro#0, %ro#1 : tensor<i32>, tensor<i32>", "+  }", "+  return %0#0, %0#1 : tensor<i32>, tensor<i32>", "+}", "+", "+// -----", "+", "+func.func @validate_tpu_replicate_wrong_attr(%arg0: tensor<i32>, %arg1: tensor<i32>, %arg2: tensor<i32>, %arg3: tensor<i32>) -> (tensor<i32>, tensor<i32>) {", "+  %0:2 = tf_executor.graph {", "+    %control = tf_executor.island() wraps \"tf.TPUReplicateMetadata\"() {_xla_compile_device_type = \"TPU\", _tpu_replicate = \"cluster\", device = \"/device:TPU:0\", num_replicas = 2, topology = \"topology\"} : () -> ()", "+    // expected-error @+1 {{TF2XLA TPU bridge input check: no tf.TPUReplicateMetadata op with cluster = cluster_wrong The Parent op = tf.opA}}", "+    %ri, %c0 = tf_executor.island wraps \"tf.TPUReplicatedInput\"(%arg0, %arg1) {index = 1 : i64, is_mirrored_variable = false, is_packed = false} : (tensor<i32>, tensor<i32>) -> tensor<i32>", "+     // expected-error @+1 {{tf_executor.yield' op TF2XLA TPU bridge input check: no tf.TPUReplicateMetadata op with cluster = cluster_wrong The Parent op = tf.opB}}", "+    %out, %c1 = tf_executor.island wraps \"tf.opA\"(%ri) {_tpu_replicate = \"cluster_wrong\"}: (tensor<i32>) -> tensor<i32>", "+    %out2, %c2 = tf_executor.island wraps \"tf.opB\"(%out) {_tpu_replicate = \"cluster_wrong\"}: (tensor<i32>) -> tensor<i32>", "+    %ro:2, %c3 = tf_executor.island wraps \"tf.TPUReplicatedOutput\"(%out2) : (tensor<i32>) -> (tensor<i32>, tensor<i32>)", "+    tf_executor.fetch %ro#0, %ro#1 : tensor<i32>, tensor<i32>", "+  }", "+  return %0#0, %0#1 : tensor<i32>, tensor<i32>", "+}", "+", "+// -----", "+", "+func.func @valid_xla_nonxla(%arg0: tensor<i32>, %arg1: tensor<i32>, %arg2: tensor<i32>, %arg3: tensor<i32>) -> (tensor<i32>, tensor<i32>) {", "+  %0:2 = tf_executor.graph {", "+    %control = tf_executor.island wraps \"tf.TPUReplicateMetadata\"() {_xla_compile_device_type = \"TPU\", _tpu_replicate = \"cluster\", device = \"/device:TPU:0\", num_replicas = 2, topology = \"topology\"} : () -> ()", "+    %ri, %c0 = tf_executor.island wraps \"tf.TPUReplicatedInput\"(%arg0, %arg1) {index = 1 : i64, is_mirrored_variable = false, is_packed = false} : (tensor<i32>, tensor<i32>) -> tensor<i32>", "+    %out, %c1 = tf_executor.island wraps \"tf.opA\"(%ri) {_tpu_replicate = \"cluster\", device = \"TPU\"} : (tensor<i32>) -> tensor<i32>", "+    %ro:2, %c2 = tf_executor.island wraps \"tf.TPUReplicatedOutput\"(%out) : (tensor<i32>) -> (tensor<i32>, tensor<i32>)", "+    tf_executor.fetch %ro#0, %ro#1 : tensor<i32>, tensor<i32>", "+  }", "+  return %0#0, %0#1 : tensor<i32>, tensor<i32>", "+}", "+", "+// -----", "\\ No newline at end of file", "@@ -332,14 +332,6 @@ bool HasDynamicExternalValues(Operation* op) {", "       .wasInterrupted();", " }", " ", "-// Checks if `type` is allowed for XLA. String and resources are not XLA types.", "-// There are other TF types that are not XLA types which will be removed by", "-// successive passes in TF/XLA bridge phase 2.", "-bool TypeValidForXLA(const Type& type) {", "-  const Type elem = getElementTypeOrSelf(type);", "-  return !elem.isa<TF::ResourceType>() && !elem.isa<TF::StringType>();", "-}", "-", " // Returns operands of `cluster_ops` that need to be", " // communicated from device->host. This is for the case when all operands have a", " // static shape.", "@@ -354,7 +346,7 @@ llvm::SmallSetVector<Value, 4> GetStaticExternalOperands(", "               walked_op))", "         return WalkResult::advance();", "       for (Value v : walked_op->getOperands()) {", "-        if (!TypeValidForXLA(v.getType())) continue;", "+        if (!tensorflow::TypeValidForXLA(v.getType())) continue;", "         if (auto* defining_op = v.getDefiningOp()) {", "           if (!op->isAncestor(defining_op) &&", "               device_cluster->isAncestor(defining_op) &&", "@@ -385,7 +377,7 @@ llvm::SmallSetVector<Value, 4> GetAllExternalOperands(", "   for (Operation* op : cluster_ops) {", "     op->walk([&](Operation* walked_op) {", "       for (Value v : walked_op->getOperands()) {", "-        if (!TypeValidForXLA(v.getType())) continue;", "+        if (!tensorflow::TypeValidForXLA(v.getType())) continue;", "         Operation* defining_op = v.getDefiningOp();", "         if (!defining_op || !cluster_ops.count(defining_op)) {", "           external_values.insert(v);", "@@ -431,8 +423,8 @@ void GetExternalOutputs(const llvm::SmallSetVector<Operation*, 4>& cluster_ops,", "           HasDynamicOutputs(user)) {", "         if (!user_set.insert(user).second) continue;", "         for (Value v : user->getOperands()) {", "-          if (TypeValidForXLA(v.getType()) && v.getDefiningOp() == op &&", "-              !isa<tf_device::ReturnOp>(user))", "+          if (tensorflow::TypeValidForXLA(v.getType()) &&", "+              v.getDefiningOp() == op && !isa<tf_device::ReturnOp>(user))", "             external_outputs.insert(v);", "           if (v.getDefiningOp() == op && isa<tf_device::ReturnOp>(user))", "             tmp_host_outputs.push_back(v);", "@@ -489,7 +481,7 @@ bool ShouldCloseCluster(llvm::ArrayRef<Value> outputs) {", "           return true;", "       }", "     }", "-    if (!TypeValidForXLA(v.getType()))", "+    if (!tensorflow::TypeValidForXLA(v.getType()))", "       for (const Operation* user : v.getUsers())", "         if (!isa<tf_device::ReturnOp>(user)) has_nonxla_output = true;", "   }", "@@ -1167,7 +1159,7 @@ LogicalResult CreateParallelExecuteForOutsideCompilation(", " // have a valid XLA type.", " LogicalResult CheckClusterResults(tf_device::ClusterOp cluster) {", "   for (OpResult result : cluster.getResults()) {", "-    if (!TypeValidForXLA(result.getType())) {", "+    if (!tensorflow::TypeValidForXLA(result.getType())) {", "       cluster.emitError()", "           << \"The ExtractHeadTailOutsideCompilation pass produced a Device \"", "              \"cluster with a result with a non-XLA type: \"", "@@ -17,6 +17,7 @@ limitations under the License.", " #include <string>", " #include <unordered_map>", " ", "+#include \"absl/strings/match.h\"", " #include \"llvm/Support/raw_ostream.h\"", " #include \"mlir/Dialect/Func/IR/FuncOps.h\"  // from @llvm-project", " #include \"mlir/IR/BuiltinOps.h\"  // from @llvm-project", "@@ -25,7 +26,9 @@ limitations under the License.", " #include \"mlir/Pass/Pass.h\"  // from @llvm-project", " #include \"tensorflow/compiler/mlir/tensorflow/ir/tf_executor.h\"", " #include \"tensorflow/compiler/mlir/tensorflow/ir/tf_ops.h\"", "+#include \"tensorflow/compiler/mlir/tensorflow/ir/tf_types.h\"", " #include \"tensorflow/compiler/mlir/tensorflow/utils/attribute_utils.h\"", "+#include \"tensorflow/compiler/mlir/tensorflow/utils/tpu_rewrite_device_util.h\"", " ", " namespace mlir {", " namespace TFTPU {", "@@ -72,7 +75,22 @@ bool IsTpuRegularOp(Operation* op) {", " ", " bool IsPartitionedCall(Operation* op) {", "   return (isa<TF::PartitionedCallOp>(op) || isa<TF::TPUPartitionedCallOp>(op) ||", "-          isa<TF::StatefulPartitionedCallOp>(op));", "+          isa<TF::StatefulPartitionedCallOp>(op) || isa<TF::IdentityOp>(op));", "+}", "+", "+bool IsIntersectionXlaNonXlaOps(Operation* op) {", "+  static auto* ops = [] {", "+    llvm::SmallDenseSet<mlir::TypeID, 32>* ops_set =", "+        new llvm::SmallDenseSet<mlir::TypeID, 32>{", "+            TypeID::get<TF::ConstOp>(),", "+            TypeID::get<TF::WhileOp>(),", "+            TypeID::get<TF::AssertOp>(),", "+        };", "+    return ops_set;", "+  }();", "+  auto abstractOp = op->getRegisteredInfo();", "+  if (!abstractOp) return true;", "+  return ops->count(abstractOp->getTypeID()) == 0;", " }", " // Gets the successors of an op wrapped in a tf_executor.island.", " llvm::SmallVector<Operation*> GetSuccessors(Operation* op) {", "@@ -99,7 +117,7 @@ llvm::SmallVector<Operation*> GetPredecessors(Operation* op) {", " }", " bool CheckTpuReplicateAttr(Operation* op, StringAttr attr,", "                            std::function<std::string()> errormsg) {", "-  if (!op->hasAttr(\"_tpu_replicate\")) {", "+  if (!op->hasAttr(TF::kTpuReplicateAttr)) {", "     op->emitOpError(\"TF2XLA TPU bridge input check: \" + errormsg() +", "                     \"missing _tpu_replicate attr\");", "     return false;", "@@ -309,7 +327,7 @@ bool CheckNonClusterPredecessors(Operation* op, Operation* parent,", " }", " ", " bool CheckOpsClusterIO(Operation* op, MetadataMap& metadata_map) {", "-  if (op->hasAttr(\"_tpu_replicate\")) {", "+  if (op->hasAttr(TF::kTpuReplicateAttr)) {", "     std::string cluster =", "         op->getAttrOfType<StringAttr>(TF::kTpuReplicateAttr).str();", "     if (cluster.empty()) {", "@@ -336,6 +354,60 @@ bool CheckOpsClusterIO(Operation* op, MetadataMap& metadata_map) {", "   return true;", " }", " ", "+bool InTypeMustBeNonXLA(const Type& type) {", "+  const Type elem = getElementTypeOrSelf(type);", "+  return !elem.isa<TF::ResourceType>() && !tensorflow::TypeValidForXLA(type);", "+}", "+", "+// Check if the op cannot be XLA compiled. If the op does not satisfy this", "+// criteria, then it is possible for the op to be XLA and non-XLA. But this", "+// function specifically checks if the op must be non-xla.", "+bool IsMustNotBeXlaOp(Operation* op) {", "+  for (auto& input : op->getOpOperands()) {", "+    if (InTypeMustBeNonXLA(input.get().getType())) return true;", "+  }", "+  for (auto output_types : op->getResultTypes()) {", "+    if (!tensorflow::TypeValidForXLA(output_types)) return true;", "+  }", "+  return false;", "+}", "+", "+// Check if the op must be compiled with XLA. If the op does not satisfy this", "+// critiria for \"must be xla\" then it is still possible for this op to be xla", "+// and non-xla as well. But below function specifically checks for the op to be", "+// only XLA op.", "+bool IsMustBeXlaOp(Operation* op, MetadataMap metadata_map) {", "+  if (!op->hasAttr(TF::kTpuReplicateAttr)) return false;", "+  auto cluster = op->getAttrOfType<StringAttr>(TF::kTpuReplicateAttr).str();", "+  if (metadata_map.find(cluster) == metadata_map.end()) return false;", "+  auto metadata = metadata_map[cluster];", "+  if (!metadata.getAllowSoftPlacement() &&", "+      !op->hasAttr(TF::kXlaOutsideCompilationAttr))", "+    return true;", "+  std::string device = \"\";", "+  if (op->hasAttr(TF::kDeviceAttr))", "+    device = op->getAttrOfType<StringAttr>(TF::kDeviceAttr).str();", "+  else", "+    return false;", "+  if (absl::StrContains(device, TF::kTpuDevice)) return true;", "+  return false;", "+}", "+bool ValidateIntersectionXlaNonXlaOps(Operation* op, MetadataMap metadata_map) {", "+  if (isa<TF::TPUReplicateMetadataOp>(op) ||", "+      isa<TF::TPUReplicatedInputOp>(op) || isa<TF::TPUReplicatedOutputOp>(op) ||", "+      isa<TF::TPUPartitionedInputOp>(op) ||", "+      isa<TF::TPUPartitionedInputV2Op>(op) ||", "+      isa<TF::TPUPartitionedOutputOp>(op) ||", "+      isa<TF::TPUPartitionedOutputV2Op>(op))", "+    return true;", "+  if (IsMustBeXlaOp(op, metadata_map) && IsMustNotBeXlaOp(op)) {", "+    op->emitOpError(\"TF/XLA TPU bridge input check: found invalid op. \")", "+        << \"Can't be both xla and non-xla\";", "+    return false;", "+  }", "+  return true;", "+}", "+", " void TPUValidateInputsPass::runOnOperation() {", "   ModuleOp module = getOperation();", "   bool success = true;", "@@ -358,6 +430,8 @@ void TPUValidateInputsPass::runOnOperation() {", "     if (IsTpuRegularOp(op)) {", "       success &= CheckOpsClusterIO(op, metadata_map);", "     }", "+    if (IsIntersectionXlaNonXlaOps(op))", "+      success &= ValidateIntersectionXlaNonXlaOps(op, metadata_map);", "   });", "   if (!success) {", "     signalPassFailure();", "@@ -43,6 +43,11 @@ inline constexpr llvm::StringRef kReplicationInfoAttr = \"_replication_info\";", " inline constexpr llvm::StringRef kTpuReplicateAttr = \"_tpu_replicate\";", " // Device types.", " inline constexpr llvm::StringRef kTpuDevice = \"TPU\";", "+// _xla_outside_compilation", "+inline constexpr llvm::StringRef kXlaOutsideCompilationAttr =", "+    \"_xla_outside_compilation\";", "+// device attr", "+inline constexpr llvm::StringRef kDeviceAttr = \"device\";", " // Function attribute to signal that a function should be skipped from TPU", " // island outlining. The attribute is set in", " // `TpuV1BridgeExecutorIslandCoarsening` and removed in the subsequent", "@@ -30,6 +30,7 @@ limitations under the License.", " #include \"llvm/Support/FormatVariadic.h\"", " #include \"mlir/IR/Attributes.h\"  // from @llvm-project", " #include \"tensorflow/compiler/mlir/tensorflow/ir/tf_device.h\"", "+#include \"tensorflow/compiler/mlir/tensorflow/ir/tf_types.h\"", " #include \"tensorflow/compiler/mlir/utils/string_container_utils.h\"", " #include \"tensorflow/compiler/xla/array4d.h\"", " #include \"tensorflow/compiler/xla/service/computation_placer.h\"", "@@ -596,4 +597,11 @@ bool IsTPUReplicatedCore(llvm::StringRef device) {", "     return false;", "   return parsed_device.has_type && parsed_device.type == kTPUReplicatedCore;", " }", "+", "+bool TypeValidForXLA(const mlir::Type& type) {", "+  const mlir::Type elem = getElementTypeOrSelf(type);", "+  return !elem.isa<mlir::TF::ResourceType>() &&", "+         !elem.isa<mlir::TF::StringType>();", "+}", "+", " }  // namespace tensorflow", "@@ -262,6 +262,11 @@ bool IsTPUDevice(llvm::StringRef device);", " // Checks if a device string is a TPU replicated core device.", " bool IsTPUReplicatedCore(llvm::StringRef device);", " ", "+// Checks if `type` is allowed for XLA. String and resources are not XLA types.", "+// There are other TF types that are not XLA types which will be removed by", "+// successive passes in TF/XLA bridge phase 2.", "+bool TypeValidForXLA(const mlir::Type& type);", "+", " }  // namespace tensorflow", " ", " #endif  // TENSORFLOW_COMPILER_MLIR_TENSORFLOW_UTILS_TPU_REWRITE_DEVICE_UTIL_H_", "@@ -20,6 +20,13 @@ limitations under the License.", " ", " #include \"flatbuffers/flatbuffers.h\"", " ", "+// Ensure the included flatbuffers.h is the same version as when this file was", "+// generated, otherwise it may not be compatible.", "+static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&", "+              FLATBUFFERS_VERSION_MINOR == 1 &&", "+              FLATBUFFERS_VERSION_REVISION == 20,", "+             \"Non-compatible flatbuffers version included\");", "+", " namespace tflite {", " namespace gpu {", " namespace cl {", "@@ -31,7 +38,7 @@ struct ProgramBuilder;", " struct CompiledCache;", " struct CompiledCacheBuilder;", " ", "-struct Program FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct Program FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ProgramBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_FINGERPRINT = 4,", "@@ -40,10 +47,10 @@ struct Program FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   uint64_t fingerprint() const {", "     return GetField<uint64_t>(VT_FINGERPRINT, 0);", "   }", "-  const flatbuffers::Vector<uint8_t> *binary() const {", "-    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BINARY);", "+  const ::flatbuffers::Vector<uint8_t> *binary() const {", "+    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_BINARY);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<uint64_t>(verifier, VT_FINGERPRINT, 8) &&", "            VerifyOffset(verifier, VT_BINARY) &&", "@@ -54,37 +61,37 @@ struct Program FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct ProgramBuilder {", "   typedef Program Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_fingerprint(uint64_t fingerprint) {", "     fbb_.AddElement<uint64_t>(Program::VT_FINGERPRINT, fingerprint, 0);", "   }", "-  void add_binary(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> binary) {", "+  void add_binary(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> binary) {", "     fbb_.AddOffset(Program::VT_BINARY, binary);", "   }", "-  explicit ProgramBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit ProgramBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<Program> Finish() {", "+  ::flatbuffers::Offset<Program> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<Program>(end);", "+    auto o = ::flatbuffers::Offset<Program>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<Program> CreateProgram(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<Program> CreateProgram(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     uint64_t fingerprint = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> binary = 0) {", "+    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> binary = 0) {", "   ProgramBuilder builder_(_fbb);", "   builder_.add_fingerprint(fingerprint);", "   builder_.add_binary(binary);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<Program> CreateProgramDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<Program> CreateProgramDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     uint64_t fingerprint = 0,", "     const std::vector<uint8_t> *binary = nullptr) {", "   auto binary__ = binary ? _fbb.CreateVector<uint8_t>(*binary) : 0;", "@@ -94,19 +101,19 @@ inline flatbuffers::Offset<Program> CreateProgramDirect(", "       binary__);", " }", " ", "-struct CompiledCache FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct CompiledCache FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef CompiledCacheBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_DRIVER_VERSION = 4,", "     VT_PROGRAMS = 6", "   };", "-  const flatbuffers::String *driver_version() const {", "-    return GetPointer<const flatbuffers::String *>(VT_DRIVER_VERSION);", "+  const ::flatbuffers::String *driver_version() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_DRIVER_VERSION);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::cl::data::Program>> *programs() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::cl::data::Program>> *>(VT_PROGRAMS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::cl::data::Program>> *programs() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::cl::data::Program>> *>(VT_PROGRAMS);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_DRIVER_VERSION) &&", "            verifier.VerifyString(driver_version()) &&", "@@ -119,41 +126,41 @@ struct CompiledCache FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct CompiledCacheBuilder {", "   typedef CompiledCache Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_driver_version(flatbuffers::Offset<flatbuffers::String> driver_version) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_driver_version(::flatbuffers::Offset<::flatbuffers::String> driver_version) {", "     fbb_.AddOffset(CompiledCache::VT_DRIVER_VERSION, driver_version);", "   }", "-  void add_programs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::cl::data::Program>>> programs) {", "+  void add_programs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::cl::data::Program>>> programs) {", "     fbb_.AddOffset(CompiledCache::VT_PROGRAMS, programs);", "   }", "-  explicit CompiledCacheBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit CompiledCacheBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<CompiledCache> Finish() {", "+  ::flatbuffers::Offset<CompiledCache> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<CompiledCache>(end);", "+    auto o = ::flatbuffers::Offset<CompiledCache>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<CompiledCache> CreateCompiledCache(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::String> driver_version = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::cl::data::Program>>> programs = 0) {", "+inline ::flatbuffers::Offset<CompiledCache> CreateCompiledCache(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::String> driver_version = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::cl::data::Program>>> programs = 0) {", "   CompiledCacheBuilder builder_(_fbb);", "   builder_.add_programs(programs);", "   builder_.add_driver_version(driver_version);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<CompiledCache> CreateCompiledCacheDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<CompiledCache> CreateCompiledCacheDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const char *driver_version = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::gpu::cl::data::Program>> *programs = nullptr) {", "+    const std::vector<::flatbuffers::Offset<tflite::gpu::cl::data::Program>> *programs = nullptr) {", "   auto driver_version__ = driver_version ? _fbb.CreateString(driver_version) : 0;", "-  auto programs__ = programs ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::cl::data::Program>>(*programs) : 0;", "+  auto programs__ = programs ? _fbb.CreateVector<::flatbuffers::Offset<tflite::gpu::cl::data::Program>>(*programs) : 0;", "   return tflite::gpu::cl::data::CreateCompiledCache(", "       _fbb,", "       driver_version__,", "@@ -161,11 +168,11 @@ inline flatbuffers::Offset<CompiledCache> CreateCompiledCacheDirect(", " }", " ", " inline const tflite::gpu::cl::data::CompiledCache *GetCompiledCache(const void *buf) {", "-  return flatbuffers::GetRoot<tflite::gpu::cl::data::CompiledCache>(buf);", "+  return ::flatbuffers::GetRoot<tflite::gpu::cl::data::CompiledCache>(buf);", " }", " ", " inline const tflite::gpu::cl::data::CompiledCache *GetSizePrefixedCompiledCache(const void *buf) {", "-  return flatbuffers::GetSizePrefixedRoot<tflite::gpu::cl::data::CompiledCache>(buf);", "+  return ::flatbuffers::GetSizePrefixedRoot<tflite::gpu::cl::data::CompiledCache>(buf);", " }", " ", " inline const char *CompiledCacheIdentifier() {", "@@ -173,22 +180,22 @@ inline const char *CompiledCacheIdentifier() {", " }", " ", " inline bool CompiledCacheBufferHasIdentifier(const void *buf) {", "-  return flatbuffers::BufferHasIdentifier(", "+  return ::flatbuffers::BufferHasIdentifier(", "       buf, CompiledCacheIdentifier());", " }", " ", " inline bool SizePrefixedCompiledCacheBufferHasIdentifier(const void *buf) {", "-  return flatbuffers::BufferHasIdentifier(", "+  return ::flatbuffers::BufferHasIdentifier(", "       buf, CompiledCacheIdentifier(), true);", " }", " ", " inline bool VerifyCompiledCacheBuffer(", "-    flatbuffers::Verifier &verifier) {", "+    ::flatbuffers::Verifier &verifier) {", "   return verifier.VerifyBuffer<tflite::gpu::cl::data::CompiledCache>(CompiledCacheIdentifier());", " }", " ", " inline bool VerifySizePrefixedCompiledCacheBuffer(", "-    flatbuffers::Verifier &verifier) {", "+    ::flatbuffers::Verifier &verifier) {", "   return verifier.VerifySizePrefixedBuffer<tflite::gpu::cl::data::CompiledCache>(CompiledCacheIdentifier());", " }", " ", "@@ -197,14 +204,14 @@ inline const char *CompiledCacheExtension() {", " }", " ", " inline void FinishCompiledCacheBuffer(", "-    flatbuffers::FlatBufferBuilder &fbb,", "-    flatbuffers::Offset<tflite::gpu::cl::data::CompiledCache> root) {", "+    ::flatbuffers::FlatBufferBuilder &fbb,", "+    ::flatbuffers::Offset<tflite::gpu::cl::data::CompiledCache> root) {", "   fbb.Finish(root, CompiledCacheIdentifier());", " }", " ", " inline void FinishSizePrefixedCompiledCacheBuffer(", "-    flatbuffers::FlatBufferBuilder &fbb,", "-    flatbuffers::Offset<tflite::gpu::cl::data::CompiledCache> root) {", "+    ::flatbuffers::FlatBufferBuilder &fbb,", "+    ::flatbuffers::Offset<tflite::gpu::cl::data::CompiledCache> root) {", "   fbb.FinishSizePrefixed(root, CompiledCacheIdentifier());", " }", " ", "@@ -20,8 +20,15 @@ limitations under the License.", " ", " #include \"flatbuffers/flatbuffers.h\"", " ", "-#include \"serialization_base_generated.h\"", "+// Ensure the included flatbuffers.h is the same version as when this file was", "+// generated, otherwise it may not be compatible.", "+static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&", "+              FLATBUFFERS_VERSION_MINOR == 1 &&", "+              FLATBUFFERS_VERSION_REVISION == 20,", "+             \"Non-compatible flatbuffers version included\");", "+", " #include \"gpu_model_generated.h\"", "+#include \"serialization_base_generated.h\"", " ", " namespace tflite {", " namespace gpu {", "@@ -34,7 +41,7 @@ struct BinaryProgramBuilder;", " struct InferenceContext;", " struct InferenceContextBuilder;", " ", "-struct BinaryProgram FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct BinaryProgram FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef BinaryProgramBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_FINGERPRINT = 4,", "@@ -43,10 +50,10 @@ struct BinaryProgram FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   uint64_t fingerprint() const {", "     return GetField<uint64_t>(VT_FINGERPRINT, 0);", "   }", "-  const flatbuffers::Vector<uint8_t> *binary() const {", "-    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BINARY);", "+  const ::flatbuffers::Vector<uint8_t> *binary() const {", "+    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_BINARY);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<uint64_t>(verifier, VT_FINGERPRINT, 8) &&", "            VerifyOffset(verifier, VT_BINARY) &&", "@@ -57,37 +64,37 @@ struct BinaryProgram FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct BinaryProgramBuilder {", "   typedef BinaryProgram Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_fingerprint(uint64_t fingerprint) {", "     fbb_.AddElement<uint64_t>(BinaryProgram::VT_FINGERPRINT, fingerprint, 0);", "   }", "-  void add_binary(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> binary) {", "+  void add_binary(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> binary) {", "     fbb_.AddOffset(BinaryProgram::VT_BINARY, binary);", "   }", "-  explicit BinaryProgramBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit BinaryProgramBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<BinaryProgram> Finish() {", "+  ::flatbuffers::Offset<BinaryProgram> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<BinaryProgram>(end);", "+    auto o = ::flatbuffers::Offset<BinaryProgram>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<BinaryProgram> CreateBinaryProgram(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<BinaryProgram> CreateBinaryProgram(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     uint64_t fingerprint = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> binary = 0) {", "+    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> binary = 0) {", "   BinaryProgramBuilder builder_(_fbb);", "   builder_.add_fingerprint(fingerprint);", "   builder_.add_binary(binary);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<BinaryProgram> CreateBinaryProgramDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<BinaryProgram> CreateBinaryProgramDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     uint64_t fingerprint = 0,", "     const std::vector<uint8_t> *binary = nullptr) {", "   auto binary__ = binary ? _fbb.CreateVector<uint8_t>(*binary) : 0;", "@@ -97,7 +104,7 @@ inline flatbuffers::Offset<BinaryProgram> CreateBinaryProgramDirect(", "       binary__);", " }", " ", "-struct InferenceContext FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct InferenceContext FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef InferenceContextBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_GPU_MODEL = 4,", "@@ -109,19 +116,19 @@ struct InferenceContext FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   const tflite::gpu::data::GpuModel *gpu_model() const {", "     return GetPointer<const tflite::gpu::data::GpuModel *>(VT_GPU_MODEL);", "   }", "-  const flatbuffers::String *driver_version() const {", "-    return GetPointer<const flatbuffers::String *>(VT_DRIVER_VERSION);", "+  const ::flatbuffers::String *driver_version() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_DRIVER_VERSION);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::cl::data::BinaryProgram>> *binary_programs() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::cl::data::BinaryProgram>> *>(VT_BINARY_PROGRAMS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::cl::data::BinaryProgram>> *binary_programs() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::cl::data::BinaryProgram>> *>(VT_BINARY_PROGRAMS);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::Int3>> *tuned_work_group_sizes_per_node() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::Int3>> *>(VT_TUNED_WORK_GROUP_SIZES_PER_NODE);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::Int3>> *tuned_work_group_sizes_per_node() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::Int3>> *>(VT_TUNED_WORK_GROUP_SIZES_PER_NODE);", "   }", "-  const flatbuffers::Vector<uint64_t> *fingerprints_per_node() const {", "-    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_FINGERPRINTS_PER_NODE);", "+  const ::flatbuffers::Vector<uint64_t> *fingerprints_per_node() const {", "+    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_FINGERPRINTS_PER_NODE);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_GPU_MODEL) &&", "            verifier.VerifyTable(gpu_model()) &&", "@@ -141,41 +148,41 @@ struct InferenceContext FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct InferenceContextBuilder {", "   typedef InferenceContext Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_gpu_model(flatbuffers::Offset<tflite::gpu::data::GpuModel> gpu_model) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_gpu_model(::flatbuffers::Offset<tflite::gpu::data::GpuModel> gpu_model) {", "     fbb_.AddOffset(InferenceContext::VT_GPU_MODEL, gpu_model);", "   }", "-  void add_driver_version(flatbuffers::Offset<flatbuffers::String> driver_version) {", "+  void add_driver_version(::flatbuffers::Offset<::flatbuffers::String> driver_version) {", "     fbb_.AddOffset(InferenceContext::VT_DRIVER_VERSION, driver_version);", "   }", "-  void add_binary_programs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::cl::data::BinaryProgram>>> binary_programs) {", "+  void add_binary_programs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::cl::data::BinaryProgram>>> binary_programs) {", "     fbb_.AddOffset(InferenceContext::VT_BINARY_PROGRAMS, binary_programs);", "   }", "-  void add_tuned_work_group_sizes_per_node(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::Int3>>> tuned_work_group_sizes_per_node) {", "+  void add_tuned_work_group_sizes_per_node(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::Int3>>> tuned_work_group_sizes_per_node) {", "     fbb_.AddOffset(InferenceContext::VT_TUNED_WORK_GROUP_SIZES_PER_NODE, tuned_work_group_sizes_per_node);", "   }", "-  void add_fingerprints_per_node(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> fingerprints_per_node) {", "+  void add_fingerprints_per_node(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> fingerprints_per_node) {", "     fbb_.AddOffset(InferenceContext::VT_FINGERPRINTS_PER_NODE, fingerprints_per_node);", "   }", "-  explicit InferenceContextBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit InferenceContextBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<InferenceContext> Finish() {", "+  ::flatbuffers::Offset<InferenceContext> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<InferenceContext>(end);", "+    auto o = ::flatbuffers::Offset<InferenceContext>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<InferenceContext> CreateInferenceContext(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<tflite::gpu::data::GpuModel> gpu_model = 0,", "-    flatbuffers::Offset<flatbuffers::String> driver_version = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::cl::data::BinaryProgram>>> binary_programs = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::Int3>>> tuned_work_group_sizes_per_node = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> fingerprints_per_node = 0) {", "+inline ::flatbuffers::Offset<InferenceContext> CreateInferenceContext(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<tflite::gpu::data::GpuModel> gpu_model = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> driver_version = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::cl::data::BinaryProgram>>> binary_programs = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::Int3>>> tuned_work_group_sizes_per_node = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> fingerprints_per_node = 0) {", "   InferenceContextBuilder builder_(_fbb);", "   builder_.add_fingerprints_per_node(fingerprints_per_node);", "   builder_.add_tuned_work_group_sizes_per_node(tuned_work_group_sizes_per_node);", "@@ -185,16 +192,16 @@ inline flatbuffers::Offset<InferenceContext> CreateInferenceContext(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<InferenceContext> CreateInferenceContextDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<tflite::gpu::data::GpuModel> gpu_model = 0,", "+inline ::flatbuffers::Offset<InferenceContext> CreateInferenceContextDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<tflite::gpu::data::GpuModel> gpu_model = 0,", "     const char *driver_version = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::gpu::cl::data::BinaryProgram>> *binary_programs = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::gpu::data::Int3>> *tuned_work_group_sizes_per_node = nullptr,", "+    const std::vector<::flatbuffers::Offset<tflite::gpu::cl::data::BinaryProgram>> *binary_programs = nullptr,", "+    const std::vector<::flatbuffers::Offset<tflite::gpu::data::Int3>> *tuned_work_group_sizes_per_node = nullptr,", "     const std::vector<uint64_t> *fingerprints_per_node = nullptr) {", "   auto driver_version__ = driver_version ? _fbb.CreateString(driver_version) : 0;", "-  auto binary_programs__ = binary_programs ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::cl::data::BinaryProgram>>(*binary_programs) : 0;", "-  auto tuned_work_group_sizes_per_node__ = tuned_work_group_sizes_per_node ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::data::Int3>>(*tuned_work_group_sizes_per_node) : 0;", "+  auto binary_programs__ = binary_programs ? _fbb.CreateVector<::flatbuffers::Offset<tflite::gpu::cl::data::BinaryProgram>>(*binary_programs) : 0;", "+  auto tuned_work_group_sizes_per_node__ = tuned_work_group_sizes_per_node ? _fbb.CreateVector<::flatbuffers::Offset<tflite::gpu::data::Int3>>(*tuned_work_group_sizes_per_node) : 0;", "   auto fingerprints_per_node__ = fingerprints_per_node ? _fbb.CreateVector<uint64_t>(*fingerprints_per_node) : 0;", "   return tflite::gpu::cl::data::CreateInferenceContext(", "       _fbb,", "@@ -206,32 +213,32 @@ inline flatbuffers::Offset<InferenceContext> CreateInferenceContextDirect(", " }", " ", " inline const tflite::gpu::cl::data::InferenceContext *GetInferenceContext(const void *buf) {", "-  return flatbuffers::GetRoot<tflite::gpu::cl::data::InferenceContext>(buf);", "+  return ::flatbuffers::GetRoot<tflite::gpu::cl::data::InferenceContext>(buf);", " }", " ", " inline const tflite::gpu::cl::data::InferenceContext *GetSizePrefixedInferenceContext(const void *buf) {", "-  return flatbuffers::GetSizePrefixedRoot<tflite::gpu::cl::data::InferenceContext>(buf);", "+  return ::flatbuffers::GetSizePrefixedRoot<tflite::gpu::cl::data::InferenceContext>(buf);", " }", " ", " inline bool VerifyInferenceContextBuffer(", "-    flatbuffers::Verifier &verifier) {", "+    ::flatbuffers::Verifier &verifier) {", "   return verifier.VerifyBuffer<tflite::gpu::cl::data::InferenceContext>(nullptr);", " }", " ", " inline bool VerifySizePrefixedInferenceContextBuffer(", "-    flatbuffers::Verifier &verifier) {", "+    ::flatbuffers::Verifier &verifier) {", "   return verifier.VerifySizePrefixedBuffer<tflite::gpu::cl::data::InferenceContext>(nullptr);", " }", " ", " inline void FinishInferenceContextBuffer(", "-    flatbuffers::FlatBufferBuilder &fbb,", "-    flatbuffers::Offset<tflite::gpu::cl::data::InferenceContext> root) {", "+    ::flatbuffers::FlatBufferBuilder &fbb,", "+    ::flatbuffers::Offset<tflite::gpu::cl::data::InferenceContext> root) {", "   fbb.Finish(root);", " }", " ", " inline void FinishSizePrefixedInferenceContextBuffer(", "-    flatbuffers::FlatBufferBuilder &fbb,", "-    flatbuffers::Offset<tflite::gpu::cl::data::InferenceContext> root) {", "+    ::flatbuffers::FlatBufferBuilder &fbb,", "+    ::flatbuffers::Offset<tflite::gpu::cl::data::InferenceContext> root) {", "   fbb.FinishSizePrefixed(root);", " }", " ", "@@ -19,6 +19,13 @@ limitations under the License.", " ", " #include \"flatbuffers/flatbuffers.h\"", " ", "+// Ensure the included flatbuffers.h is the same version as when this file was", "+// generated, otherwise it may not be compatible.", "+static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&", "+              FLATBUFFERS_VERSION_MINOR == 1 &&", "+              FLATBUFFERS_VERSION_REVISION == 20,", "+             \"Non-compatible flatbuffers version included\");", "+", " #include \"serialization_base_generated.h\"", " ", " namespace tflite {", "@@ -37,7 +44,7 @@ struct GpuNodeBuilder;", " struct GpuModel;", " struct GpuModelBuilder;", " ", "-struct TensorDescWithId FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct TensorDescWithId FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef TensorDescWithIdBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_DESC = 4,", "@@ -49,7 +56,7 @@ struct TensorDescWithId FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t id() const {", "     return GetField<int32_t>(VT_ID, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_DESC) &&", "            verifier.VerifyTable(desc()) &&", "@@ -60,28 +67,28 @@ struct TensorDescWithId FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct TensorDescWithIdBuilder {", "   typedef TensorDescWithId Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_desc(flatbuffers::Offset<tflite::gpu::data::TensorDescriptor> desc) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_desc(::flatbuffers::Offset<tflite::gpu::data::TensorDescriptor> desc) {", "     fbb_.AddOffset(TensorDescWithId::VT_DESC, desc);", "   }", "   void add_id(int32_t id) {", "     fbb_.AddElement<int32_t>(TensorDescWithId::VT_ID, id, 0);", "   }", "-  explicit TensorDescWithIdBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit TensorDescWithIdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<TensorDescWithId> Finish() {", "+  ::flatbuffers::Offset<TensorDescWithId> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<TensorDescWithId>(end);", "+    auto o = ::flatbuffers::Offset<TensorDescWithId>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<TensorDescWithId> CreateTensorDescWithId(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<tflite::gpu::data::TensorDescriptor> desc = 0,", "+inline ::flatbuffers::Offset<TensorDescWithId> CreateTensorDescWithId(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<tflite::gpu::data::TensorDescriptor> desc = 0,", "     int32_t id = 0) {", "   TensorDescWithIdBuilder builder_(_fbb);", "   builder_.add_id(id);", "@@ -89,7 +96,7 @@ inline flatbuffers::Offset<TensorDescWithId> CreateTensorDescWithId(", "   return builder_.Finish();", " }", " ", "-struct PairOfValueIds FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct PairOfValueIds FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef PairOfValueIdsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_FIRST = 4,", "@@ -101,7 +108,7 @@ struct PairOfValueIds FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t second() const {", "     return GetField<int32_t>(VT_SECOND, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_FIRST, 4) &&", "            VerifyField<int32_t>(verifier, VT_SECOND, 4) &&", "@@ -111,27 +118,27 @@ struct PairOfValueIds FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct PairOfValueIdsBuilder {", "   typedef PairOfValueIds Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_first(int32_t first) {", "     fbb_.AddElement<int32_t>(PairOfValueIds::VT_FIRST, first, 0);", "   }", "   void add_second(int32_t second) {", "     fbb_.AddElement<int32_t>(PairOfValueIds::VT_SECOND, second, 0);", "   }", "-  explicit PairOfValueIdsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit PairOfValueIdsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<PairOfValueIds> Finish() {", "+  ::flatbuffers::Offset<PairOfValueIds> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<PairOfValueIds>(end);", "+    auto o = ::flatbuffers::Offset<PairOfValueIds>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<PairOfValueIds> CreatePairOfValueIds(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<PairOfValueIds> CreatePairOfValueIds(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t first = 0,", "     int32_t second = 0) {", "   PairOfValueIdsBuilder builder_(_fbb);", "@@ -140,7 +147,7 @@ inline flatbuffers::Offset<PairOfValueIds> CreatePairOfValueIds(", "   return builder_.Finish();", " }", " ", "-struct GpuNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct GpuNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef GpuNodeBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_GPU_OP = 4,", "@@ -151,16 +158,16 @@ struct GpuNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   const tflite::gpu::data::GPUOperation *gpu_op() const {", "     return GetPointer<const tflite::gpu::data::GPUOperation *>(VT_GPU_OP);", "   }", "-  const flatbuffers::Vector<int32_t> *input_ids() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUT_IDS);", "+  const ::flatbuffers::Vector<int32_t> *input_ids() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INPUT_IDS);", "   }", "-  const flatbuffers::Vector<int32_t> *output_ids() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUT_IDS);", "+  const ::flatbuffers::Vector<int32_t> *output_ids() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTPUT_IDS);", "   }", "-  const flatbuffers::String *name() const {", "-    return GetPointer<const flatbuffers::String *>(VT_NAME);", "+  const ::flatbuffers::String *name() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_NAME);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_GPU_OP) &&", "            verifier.VerifyTable(gpu_op()) &&", "@@ -176,37 +183,37 @@ struct GpuNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct GpuNodeBuilder {", "   typedef GpuNode Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_gpu_op(flatbuffers::Offset<tflite::gpu::data::GPUOperation> gpu_op) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_gpu_op(::flatbuffers::Offset<tflite::gpu::data::GPUOperation> gpu_op) {", "     fbb_.AddOffset(GpuNode::VT_GPU_OP, gpu_op);", "   }", "-  void add_input_ids(flatbuffers::Offset<flatbuffers::Vector<int32_t>> input_ids) {", "+  void add_input_ids(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> input_ids) {", "     fbb_.AddOffset(GpuNode::VT_INPUT_IDS, input_ids);", "   }", "-  void add_output_ids(flatbuffers::Offset<flatbuffers::Vector<int32_t>> output_ids) {", "+  void add_output_ids(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> output_ids) {", "     fbb_.AddOffset(GpuNode::VT_OUTPUT_IDS, output_ids);", "   }", "-  void add_name(flatbuffers::Offset<flatbuffers::String> name) {", "+  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {", "     fbb_.AddOffset(GpuNode::VT_NAME, name);", "   }", "-  explicit GpuNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit GpuNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<GpuNode> Finish() {", "+  ::flatbuffers::Offset<GpuNode> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<GpuNode>(end);", "+    auto o = ::flatbuffers::Offset<GpuNode>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<GpuNode> CreateGpuNode(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<tflite::gpu::data::GPUOperation> gpu_op = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> input_ids = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> output_ids = 0,", "-    flatbuffers::Offset<flatbuffers::String> name = 0) {", "+inline ::flatbuffers::Offset<GpuNode> CreateGpuNode(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<tflite::gpu::data::GPUOperation> gpu_op = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> input_ids = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> output_ids = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {", "   GpuNodeBuilder builder_(_fbb);", "   builder_.add_name(name);", "   builder_.add_output_ids(output_ids);", "@@ -215,9 +222,9 @@ inline flatbuffers::Offset<GpuNode> CreateGpuNode(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<GpuNode> CreateGpuNodeDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<tflite::gpu::data::GPUOperation> gpu_op = 0,", "+inline ::flatbuffers::Offset<GpuNode> CreateGpuNodeDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<tflite::gpu::data::GPUOperation> gpu_op = 0,", "     const std::vector<int32_t> *input_ids = nullptr,", "     const std::vector<int32_t> *output_ids = nullptr,", "     const char *name = nullptr) {", "@@ -232,7 +239,7 @@ inline flatbuffers::Offset<GpuNode> CreateGpuNodeDirect(", "       name__);", " }", " ", "-struct GpuModel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct GpuModel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef GpuModelBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_NODES = 4,", "@@ -244,31 +251,31 @@ struct GpuModel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "     VT_OUTPUT_REFS = 16,", "     VT_VARIABLE_IDS_AND_REFS = 18", "   };", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::GpuNode>> *nodes() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::GpuNode>> *>(VT_NODES);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::GpuNode>> *nodes() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::GpuNode>> *>(VT_NODES);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>> *tensors() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>> *>(VT_TENSORS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>> *tensors() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>> *>(VT_TENSORS);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>> *const_tensors() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>> *>(VT_CONST_TENSORS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>> *const_tensors() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>> *>(VT_CONST_TENSORS);", "   }", "-  const flatbuffers::Vector<int32_t> *input_ids() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUT_IDS);", "+  const ::flatbuffers::Vector<int32_t> *input_ids() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INPUT_IDS);", "   }", "-  const flatbuffers::Vector<int32_t> *output_ids() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUT_IDS);", "+  const ::flatbuffers::Vector<int32_t> *output_ids() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTPUT_IDS);", "   }", "-  const flatbuffers::Vector<int64_t> *input_refs() const {", "-    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_INPUT_REFS);", "+  const ::flatbuffers::Vector<int64_t> *input_refs() const {", "+    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_INPUT_REFS);", "   }", "-  const flatbuffers::Vector<int64_t> *output_refs() const {", "-    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_OUTPUT_REFS);", "+  const ::flatbuffers::Vector<int64_t> *output_refs() const {", "+    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_OUTPUT_REFS);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::PairOfValueIds>> *variable_ids_and_refs() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::PairOfValueIds>> *>(VT_VARIABLE_IDS_AND_REFS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::PairOfValueIds>> *variable_ids_and_refs() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::PairOfValueIds>> *>(VT_VARIABLE_IDS_AND_REFS);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_NODES) &&", "            verifier.VerifyVector(nodes()) &&", "@@ -296,53 +303,53 @@ struct GpuModel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct GpuModelBuilder {", "   typedef GpuModel Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::GpuNode>>> nodes) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_nodes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::GpuNode>>> nodes) {", "     fbb_.AddOffset(GpuModel::VT_NODES, nodes);", "   }", "-  void add_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>>> tensors) {", "+  void add_tensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>>> tensors) {", "     fbb_.AddOffset(GpuModel::VT_TENSORS, tensors);", "   }", "-  void add_const_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>>> const_tensors) {", "+  void add_const_tensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>>> const_tensors) {", "     fbb_.AddOffset(GpuModel::VT_CONST_TENSORS, const_tensors);", "   }", "-  void add_input_ids(flatbuffers::Offset<flatbuffers::Vector<int32_t>> input_ids) {", "+  void add_input_ids(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> input_ids) {", "     fbb_.AddOffset(GpuModel::VT_INPUT_IDS, input_ids);", "   }", "-  void add_output_ids(flatbuffers::Offset<flatbuffers::Vector<int32_t>> output_ids) {", "+  void add_output_ids(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> output_ids) {", "     fbb_.AddOffset(GpuModel::VT_OUTPUT_IDS, output_ids);", "   }", "-  void add_input_refs(flatbuffers::Offset<flatbuffers::Vector<int64_t>> input_refs) {", "+  void add_input_refs(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> input_refs) {", "     fbb_.AddOffset(GpuModel::VT_INPUT_REFS, input_refs);", "   }", "-  void add_output_refs(flatbuffers::Offset<flatbuffers::Vector<int64_t>> output_refs) {", "+  void add_output_refs(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> output_refs) {", "     fbb_.AddOffset(GpuModel::VT_OUTPUT_REFS, output_refs);", "   }", "-  void add_variable_ids_and_refs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::PairOfValueIds>>> variable_ids_and_refs) {", "+  void add_variable_ids_and_refs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::PairOfValueIds>>> variable_ids_and_refs) {", "     fbb_.AddOffset(GpuModel::VT_VARIABLE_IDS_AND_REFS, variable_ids_and_refs);", "   }", "-  explicit GpuModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit GpuModelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<GpuModel> Finish() {", "+  ::flatbuffers::Offset<GpuModel> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<GpuModel>(end);", "+    auto o = ::flatbuffers::Offset<GpuModel>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<GpuModel> CreateGpuModel(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::GpuNode>>> nodes = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>>> tensors = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>>> const_tensors = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> input_ids = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> output_ids = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<int64_t>> input_refs = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<int64_t>> output_refs = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::PairOfValueIds>>> variable_ids_and_refs = 0) {", "+inline ::flatbuffers::Offset<GpuModel> CreateGpuModel(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::GpuNode>>> nodes = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>>> tensors = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>>> const_tensors = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> input_ids = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> output_ids = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> input_refs = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> output_refs = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::PairOfValueIds>>> variable_ids_and_refs = 0) {", "   GpuModelBuilder builder_(_fbb);", "   builder_.add_variable_ids_and_refs(variable_ids_and_refs);", "   builder_.add_output_refs(output_refs);", "@@ -355,24 +362,24 @@ inline flatbuffers::Offset<GpuModel> CreateGpuModel(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<GpuModel> CreateGpuModelDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    const std::vector<flatbuffers::Offset<tflite::gpu::data::GpuNode>> *nodes = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>> *tensors = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>> *const_tensors = nullptr,", "+inline ::flatbuffers::Offset<GpuModel> CreateGpuModelDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    const std::vector<::flatbuffers::Offset<tflite::gpu::data::GpuNode>> *nodes = nullptr,", "+    const std::vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>> *tensors = nullptr,", "+    const std::vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>> *const_tensors = nullptr,", "     const std::vector<int32_t> *input_ids = nullptr,", "     const std::vector<int32_t> *output_ids = nullptr,", "     const std::vector<int64_t> *input_refs = nullptr,", "     const std::vector<int64_t> *output_refs = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::gpu::data::PairOfValueIds>> *variable_ids_and_refs = nullptr) {", "-  auto nodes__ = nodes ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::data::GpuNode>>(*nodes) : 0;", "-  auto tensors__ = tensors ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>>(*tensors) : 0;", "-  auto const_tensors__ = const_tensors ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>>(*const_tensors) : 0;", "+    const std::vector<::flatbuffers::Offset<tflite::gpu::data::PairOfValueIds>> *variable_ids_and_refs = nullptr) {", "+  auto nodes__ = nodes ? _fbb.CreateVector<::flatbuffers::Offset<tflite::gpu::data::GpuNode>>(*nodes) : 0;", "+  auto tensors__ = tensors ? _fbb.CreateVector<::flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>>(*tensors) : 0;", "+  auto const_tensors__ = const_tensors ? _fbb.CreateVector<::flatbuffers::Offset<tflite::gpu::data::TensorDescWithId>>(*const_tensors) : 0;", "   auto input_ids__ = input_ids ? _fbb.CreateVector<int32_t>(*input_ids) : 0;", "   auto output_ids__ = output_ids ? _fbb.CreateVector<int32_t>(*output_ids) : 0;", "   auto input_refs__ = input_refs ? _fbb.CreateVector<int64_t>(*input_refs) : 0;", "   auto output_refs__ = output_refs ? _fbb.CreateVector<int64_t>(*output_refs) : 0;", "-  auto variable_ids_and_refs__ = variable_ids_and_refs ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::data::PairOfValueIds>>(*variable_ids_and_refs) : 0;", "+  auto variable_ids_and_refs__ = variable_ids_and_refs ? _fbb.CreateVector<::flatbuffers::Offset<tflite::gpu::data::PairOfValueIds>>(*variable_ids_and_refs) : 0;", "   return tflite::gpu::data::CreateGpuModel(", "       _fbb,", "       nodes__,", "@@ -20,6 +20,13 @@ limitations under the License.", " ", " #include \"flatbuffers/flatbuffers.h\"", " ", "+// Ensure the included flatbuffers.h is the same version as when this file was", "+// generated, otherwise it may not be compatible.", "+static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&", "+              FLATBUFFERS_VERSION_MINOR == 1 &&", "+              FLATBUFFERS_VERSION_REVISION == 20,", "+             \"Non-compatible flatbuffers version included\");", "+", " namespace tflite {", " namespace gpu {", " namespace data {", "@@ -103,7 +110,7 @@ inline const char * const *EnumNamesAccessType() {", " }", " ", " inline const char *EnumNameAccessType(AccessType e) {", "-  if (flatbuffers::IsOutRange(e, AccessType::READ, AccessType::READ_WRITE)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, AccessType::READ, AccessType::READ_WRITE)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesAccessType()[index];", " }", "@@ -166,7 +173,7 @@ inline const char * const *EnumNamesDataType() {", " }", " ", " inline const char *EnumNameDataType(DataType e) {", "-  if (flatbuffers::IsOutRange(e, DataType::UNKNOWN, DataType::BOOL)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, DataType::UNKNOWN, DataType::BOOL)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesDataType()[index];", " }", "@@ -199,7 +206,7 @@ inline const char * const *EnumNamesMemoryType() {", " }", " ", " inline const char *EnumNameMemoryType(MemoryType e) {", "-  if (flatbuffers::IsOutRange(e, MemoryType::GLOBAL, MemoryType::LOCAL)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, MemoryType::GLOBAL, MemoryType::LOCAL)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesMemoryType()[index];", " }", "@@ -244,7 +251,7 @@ inline const char * const *EnumNamesTensorStorageType() {", " }", " ", " inline const char *EnumNameTensorStorageType(TensorStorageType e) {", "-  if (flatbuffers::IsOutRange(e, TensorStorageType::UNKNOWN, TensorStorageType::SINGLE_TEXTURE_2D)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, TensorStorageType::UNKNOWN, TensorStorageType::SINGLE_TEXTURE_2D)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesTensorStorageType()[index];", " }", "@@ -263,19 +270,33 @@ enum class Layout : int8_t {", " ", " inline const Layout (&EnumValuesLayout())[7] {", "   static const Layout values[] = {", "-      Layout::UNKNOWN, Layout::HWC,    Layout::BHWC, Layout::HWDC,", "-      Layout::BHWDC,   Layout::LINEAR, Layout::HW};", "+    Layout::UNKNOWN,", "+    Layout::HWC,", "+    Layout::BHWC,", "+    Layout::HWDC,", "+    Layout::BHWDC,", "+    Layout::LINEAR,", "+    Layout::HW", "+  };", "   return values;", " }", " ", " inline const char * const *EnumNamesLayout() {", "-  static const char *const names[8] = {\"UNKNOWN\", \"HWC\",    \"BHWC\", \"HWDC\",", "-                                       \"BHWDC\",   \"LINEAR\", \"HW\",   nullptr};", "+  static const char * const names[8] = {", "+    \"UNKNOWN\",", "+    \"HWC\",", "+    \"BHWC\",", "+    \"HWDC\",", "+    \"BHWDC\",", "+    \"LINEAR\",", "+    \"HW\",", "+    nullptr", "+  };", "   return names;", " }", " ", " inline const char *EnumNameLayout(Layout e) {", "-  if (flatbuffers::IsOutRange(e, Layout::UNKNOWN, Layout::HW)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, Layout::UNKNOWN, Layout::HW)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesLayout()[index];", " }", "@@ -308,7 +329,7 @@ inline const char * const *EnumNamesCalculationsPrecision() {", " }", " ", " inline const char *EnumNameCalculationsPrecision(CalculationsPrecision e) {", "-  if (flatbuffers::IsOutRange(e, CalculationsPrecision::F32, CalculationsPrecision::F16)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, CalculationsPrecision::F32, CalculationsPrecision::F16)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesCalculationsPrecision()[index];", " }", "@@ -347,7 +368,7 @@ inline const char * const *EnumNamesTensorToGrid() {", " }", " ", " inline const char *EnumNameTensorToGrid(TensorToGrid e) {", "-  if (flatbuffers::IsOutRange(e, TensorToGrid::CUSTOM, TensorToGrid::B_TO_X_Y_IS_1_Z_IS_1)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, TensorToGrid::CUSTOM, TensorToGrid::B_TO_X_Y_IS_1_Z_IS_1)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesTensorToGrid()[index];", " }", "@@ -389,12 +410,12 @@ inline const char * const *EnumNamesCompilerOptions() {", " }", " ", " inline const char *EnumNameCompilerOptions(CompilerOptions e) {", "-  if (flatbuffers::IsOutRange(e, CompilerOptions::ADRENO_FULL_SIMD_LINE, CompilerOptions::CL_3_0)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, CompilerOptions::ADRENO_FULL_SIMD_LINE, CompilerOptions::CL_3_0)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesCompilerOptions()[index];", " }", " ", "-struct Int4 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct Int4 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef Int4Builder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_X = 4,", "@@ -414,7 +435,7 @@ struct Int4 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t w() const {", "     return GetField<int32_t>(VT_W, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_X, 4) &&", "            VerifyField<int32_t>(verifier, VT_Y, 4) &&", "@@ -426,8 +447,8 @@ struct Int4 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct Int4Builder {", "   typedef Int4 Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_x(int32_t x) {", "     fbb_.AddElement<int32_t>(Int4::VT_X, x, 0);", "   }", "@@ -440,19 +461,19 @@ struct Int4Builder {", "   void add_w(int32_t w) {", "     fbb_.AddElement<int32_t>(Int4::VT_W, w, 0);", "   }", "-  explicit Int4Builder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit Int4Builder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<Int4> Finish() {", "+  ::flatbuffers::Offset<Int4> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<Int4>(end);", "+    auto o = ::flatbuffers::Offset<Int4>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<Int4> CreateInt4(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<Int4> CreateInt4(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t x = 0,", "     int32_t y = 0,", "     int32_t z = 0,", "@@ -465,7 +486,7 @@ inline flatbuffers::Offset<Int4> CreateInt4(", "   return builder_.Finish();", " }", " ", "-struct Int3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct Int3 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef Int3Builder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_X = 4,", "@@ -481,7 +502,7 @@ struct Int3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t z() const {", "     return GetField<int32_t>(VT_Z, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_X, 4) &&", "            VerifyField<int32_t>(verifier, VT_Y, 4) &&", "@@ -492,8 +513,8 @@ struct Int3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct Int3Builder {", "   typedef Int3 Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_x(int32_t x) {", "     fbb_.AddElement<int32_t>(Int3::VT_X, x, 0);", "   }", "@@ -503,19 +524,19 @@ struct Int3Builder {", "   void add_z(int32_t z) {", "     fbb_.AddElement<int32_t>(Int3::VT_Z, z, 0);", "   }", "-  explicit Int3Builder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit Int3Builder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<Int3> Finish() {", "+  ::flatbuffers::Offset<Int3> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<Int3>(end);", "+    auto o = ::flatbuffers::Offset<Int3>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<Int3> CreateInt3(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<Int3> CreateInt3(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t x = 0,", "     int32_t y = 0,", "     int32_t z = 0) {", "@@ -526,7 +547,7 @@ inline flatbuffers::Offset<Int3> CreateInt3(", "   return builder_.Finish();", " }", " ", "-struct Int2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct Int2 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef Int2Builder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_X = 4,", "@@ -538,7 +559,7 @@ struct Int2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t y() const {", "     return GetField<int32_t>(VT_Y, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_X, 4) &&", "            VerifyField<int32_t>(verifier, VT_Y, 4) &&", "@@ -548,27 +569,27 @@ struct Int2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct Int2Builder {", "   typedef Int2 Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_x(int32_t x) {", "     fbb_.AddElement<int32_t>(Int2::VT_X, x, 0);", "   }", "   void add_y(int32_t y) {", "     fbb_.AddElement<int32_t>(Int2::VT_Y, y, 0);", "   }", "-  explicit Int2Builder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit Int2Builder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<Int2> Finish() {", "+  ::flatbuffers::Offset<Int2> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<Int2>(end);", "+    auto o = ::flatbuffers::Offset<Int2>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<Int2> CreateInt2(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<Int2> CreateInt2(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t x = 0,", "     int32_t y = 0) {", "   Int2Builder builder_(_fbb);", "@@ -577,19 +598,19 @@ inline flatbuffers::Offset<Int2> CreateInt2(", "   return builder_.Finish();", " }", " ", "-struct StateVariable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct StateVariable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef StateVariableBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_KEY = 4,", "     VT_VALUE = 6", "   };", "-  const flatbuffers::String *key() const {", "-    return GetPointer<const flatbuffers::String *>(VT_KEY);", "+  const ::flatbuffers::String *key() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_KEY);", "   }", "-  const flatbuffers::String *value() const {", "-    return GetPointer<const flatbuffers::String *>(VT_VALUE);", "+  const ::flatbuffers::String *value() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_KEY) &&", "            verifier.VerifyString(key()) &&", "@@ -601,37 +622,37 @@ struct StateVariable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct StateVariableBuilder {", "   typedef StateVariable Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_key(flatbuffers::Offset<flatbuffers::String> key) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {", "     fbb_.AddOffset(StateVariable::VT_KEY, key);", "   }", "-  void add_value(flatbuffers::Offset<flatbuffers::String> value) {", "+  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {", "     fbb_.AddOffset(StateVariable::VT_VALUE, value);", "   }", "-  explicit StateVariableBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit StateVariableBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<StateVariable> Finish() {", "+  ::flatbuffers::Offset<StateVariable> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<StateVariable>(end);", "+    auto o = ::flatbuffers::Offset<StateVariable>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<StateVariable> CreateStateVariable(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::String> key = 0,", "-    flatbuffers::Offset<flatbuffers::String> value = 0) {", "+inline ::flatbuffers::Offset<StateVariable> CreateStateVariable(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::String> key = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {", "   StateVariableBuilder builder_(_fbb);", "   builder_.add_value(value);", "   builder_.add_key(key);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<StateVariable> CreateStateVariableDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<StateVariable> CreateStateVariableDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const char *key = nullptr,", "     const char *value = nullptr) {", "   auto key__ = key ? _fbb.CreateString(key) : 0;", "@@ -642,19 +663,19 @@ inline flatbuffers::Offset<StateVariable> CreateStateVariableDirect(", "       value__);", " }", " ", "-struct GPUObjectDescriptor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct GPUObjectDescriptor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef GPUObjectDescriptorBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_STATE_VARS = 4,", "     VT_ACCESS_TYPE = 6", "   };", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::StateVariable>> *state_vars() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::StateVariable>> *>(VT_STATE_VARS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::StateVariable>> *state_vars() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::StateVariable>> *>(VT_STATE_VARS);", "   }", "   tflite::gpu::data::AccessType access_type() const {", "     return static_cast<tflite::gpu::data::AccessType>(GetField<int8_t>(VT_ACCESS_TYPE, 0));", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_STATE_VARS) &&", "            verifier.VerifyVector(state_vars()) &&", "@@ -666,28 +687,28 @@ struct GPUObjectDescriptor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table", " ", " struct GPUObjectDescriptorBuilder {", "   typedef GPUObjectDescriptor Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_state_vars(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::StateVariable>>> state_vars) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_state_vars(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::StateVariable>>> state_vars) {", "     fbb_.AddOffset(GPUObjectDescriptor::VT_STATE_VARS, state_vars);", "   }", "   void add_access_type(tflite::gpu::data::AccessType access_type) {", "     fbb_.AddElement<int8_t>(GPUObjectDescriptor::VT_ACCESS_TYPE, static_cast<int8_t>(access_type), 0);", "   }", "-  explicit GPUObjectDescriptorBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit GPUObjectDescriptorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<GPUObjectDescriptor> Finish() {", "+  ::flatbuffers::Offset<GPUObjectDescriptor> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<GPUObjectDescriptor>(end);", "+    auto o = ::flatbuffers::Offset<GPUObjectDescriptor>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<GPUObjectDescriptor> CreateGPUObjectDescriptor(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::StateVariable>>> state_vars = 0,", "+inline ::flatbuffers::Offset<GPUObjectDescriptor> CreateGPUObjectDescriptor(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::StateVariable>>> state_vars = 0,", "     tflite::gpu::data::AccessType access_type = tflite::gpu::data::AccessType::READ) {", "   GPUObjectDescriptorBuilder builder_(_fbb);", "   builder_.add_state_vars(state_vars);", "@@ -695,26 +716,26 @@ inline flatbuffers::Offset<GPUObjectDescriptor> CreateGPUObjectDescriptor(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<GPUObjectDescriptor> CreateGPUObjectDescriptorDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    const std::vector<flatbuffers::Offset<tflite::gpu::data::StateVariable>> *state_vars = nullptr,", "+inline ::flatbuffers::Offset<GPUObjectDescriptor> CreateGPUObjectDescriptorDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    const std::vector<::flatbuffers::Offset<tflite::gpu::data::StateVariable>> *state_vars = nullptr,", "     tflite::gpu::data::AccessType access_type = tflite::gpu::data::AccessType::READ) {", "-  auto state_vars__ = state_vars ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::data::StateVariable>>(*state_vars) : 0;", "+  auto state_vars__ = state_vars ? _fbb.CreateVector<::flatbuffers::Offset<tflite::gpu::data::StateVariable>>(*state_vars) : 0;", "   return tflite::gpu::data::CreateGPUObjectDescriptor(", "       _fbb,", "       state_vars__,", "       access_type);", " }", " ", "-struct IntValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct IntValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef IntValueBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_NAME = 4,", "     VT_VALUE = 6,", "     VT_ACTIVE = 8", "   };", "-  const flatbuffers::String *name() const {", "-    return GetPointer<const flatbuffers::String *>(VT_NAME);", "+  const ::flatbuffers::String *name() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_NAME);", "   }", "   int32_t value() const {", "     return GetField<int32_t>(VT_VALUE, 0);", "@@ -722,7 +743,7 @@ struct IntValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool active() const {", "     return GetField<uint8_t>(VT_ACTIVE, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_NAME) &&", "            verifier.VerifyString(name()) &&", "@@ -734,9 +755,9 @@ struct IntValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct IntValueBuilder {", "   typedef IntValue Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_name(flatbuffers::Offset<flatbuffers::String> name) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {", "     fbb_.AddOffset(IntValue::VT_NAME, name);", "   }", "   void add_value(int32_t value) {", "@@ -745,20 +766,20 @@ struct IntValueBuilder {", "   void add_active(bool active) {", "     fbb_.AddElement<uint8_t>(IntValue::VT_ACTIVE, static_cast<uint8_t>(active), 0);", "   }", "-  explicit IntValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit IntValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<IntValue> Finish() {", "+  ::flatbuffers::Offset<IntValue> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<IntValue>(end);", "+    auto o = ::flatbuffers::Offset<IntValue>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<IntValue> CreateIntValue(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::String> name = 0,", "+inline ::flatbuffers::Offset<IntValue> CreateIntValue(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::String> name = 0,", "     int32_t value = 0,", "     bool active = false) {", "   IntValueBuilder builder_(_fbb);", "@@ -768,8 +789,8 @@ inline flatbuffers::Offset<IntValue> CreateIntValue(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<IntValue> CreateIntValueDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<IntValue> CreateIntValueDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const char *name = nullptr,", "     int32_t value = 0,", "     bool active = false) {", "@@ -781,15 +802,15 @@ inline flatbuffers::Offset<IntValue> CreateIntValueDirect(", "       active);", " }", " ", "-struct FloatValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct FloatValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef FloatValueBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_NAME = 4,", "     VT_VALUE = 6,", "     VT_ACTIVE = 8", "   };", "-  const flatbuffers::String *name() const {", "-    return GetPointer<const flatbuffers::String *>(VT_NAME);", "+  const ::flatbuffers::String *name() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_NAME);", "   }", "   float value() const {", "     return GetField<float>(VT_VALUE, 0.0f);", "@@ -797,7 +818,7 @@ struct FloatValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool active() const {", "     return GetField<uint8_t>(VT_ACTIVE, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_NAME) &&", "            verifier.VerifyString(name()) &&", "@@ -809,9 +830,9 @@ struct FloatValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct FloatValueBuilder {", "   typedef FloatValue Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_name(flatbuffers::Offset<flatbuffers::String> name) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {", "     fbb_.AddOffset(FloatValue::VT_NAME, name);", "   }", "   void add_value(float value) {", "@@ -820,20 +841,20 @@ struct FloatValueBuilder {", "   void add_active(bool active) {", "     fbb_.AddElement<uint8_t>(FloatValue::VT_ACTIVE, static_cast<uint8_t>(active), 0);", "   }", "-  explicit FloatValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit FloatValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<FloatValue> Finish() {", "+  ::flatbuffers::Offset<FloatValue> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<FloatValue>(end);", "+    auto o = ::flatbuffers::Offset<FloatValue>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<FloatValue> CreateFloatValue(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::String> name = 0,", "+inline ::flatbuffers::Offset<FloatValue> CreateFloatValue(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::String> name = 0,", "     float value = 0.0f,", "     bool active = false) {", "   FloatValueBuilder builder_(_fbb);", "@@ -843,8 +864,8 @@ inline flatbuffers::Offset<FloatValue> CreateFloatValue(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<FloatValue> CreateFloatValueDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<FloatValue> CreateFloatValueDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const char *name = nullptr,", "     float value = 0.0f,", "     bool active = false) {", "@@ -856,15 +877,15 @@ inline flatbuffers::Offset<FloatValue> CreateFloatValueDirect(", "       active);", " }", " ", "-struct HalfValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct HalfValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef HalfValueBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_NAME = 4,", "     VT_VALUE = 6,", "     VT_ACTIVE = 8", "   };", "-  const flatbuffers::String *name() const {", "-    return GetPointer<const flatbuffers::String *>(VT_NAME);", "+  const ::flatbuffers::String *name() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_NAME);", "   }", "   float value() const {", "     return GetField<float>(VT_VALUE, 0.0f);", "@@ -872,7 +893,7 @@ struct HalfValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool active() const {", "     return GetField<uint8_t>(VT_ACTIVE, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_NAME) &&", "            verifier.VerifyString(name()) &&", "@@ -884,9 +905,9 @@ struct HalfValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct HalfValueBuilder {", "   typedef HalfValue Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_name(flatbuffers::Offset<flatbuffers::String> name) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {", "     fbb_.AddOffset(HalfValue::VT_NAME, name);", "   }", "   void add_value(float value) {", "@@ -895,20 +916,20 @@ struct HalfValueBuilder {", "   void add_active(bool active) {", "     fbb_.AddElement<uint8_t>(HalfValue::VT_ACTIVE, static_cast<uint8_t>(active), 0);", "   }", "-  explicit HalfValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit HalfValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<HalfValue> Finish() {", "+  ::flatbuffers::Offset<HalfValue> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<HalfValue>(end);", "+    auto o = ::flatbuffers::Offset<HalfValue>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<HalfValue> CreateHalfValue(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::String> name = 0,", "+inline ::flatbuffers::Offset<HalfValue> CreateHalfValue(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::String> name = 0,", "     float value = 0.0f,", "     bool active = false) {", "   HalfValueBuilder builder_(_fbb);", "@@ -918,8 +939,8 @@ inline flatbuffers::Offset<HalfValue> CreateHalfValue(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<HalfValue> CreateHalfValueDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<HalfValue> CreateHalfValueDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const char *name = nullptr,", "     float value = 0.0f,", "     bool active = false) {", "@@ -931,7 +952,7 @@ inline flatbuffers::Offset<HalfValue> CreateHalfValueDirect(", "       active);", " }", " ", "-struct BufferDescriptor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct BufferDescriptor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef BufferDescriptorBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_BASE_OBJ = 4,", "@@ -954,16 +975,16 @@ struct BufferDescriptor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   tflite::gpu::data::MemoryType memory_type() const {", "     return static_cast<tflite::gpu::data::MemoryType>(GetField<int8_t>(VT_MEMORY_TYPE, 0));", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *attributes() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ATTRIBUTES);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *attributes() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ATTRIBUTES);", "   }", "   int32_t size() const {", "     return GetField<int32_t>(VT_SIZE, 0);", "   }", "-  const flatbuffers::Vector<uint8_t> *data() const {", "-    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);", "+  const ::flatbuffers::Vector<uint8_t> *data() const {", "+    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_BASE_OBJ) &&", "            verifier.VerifyTable(base_obj()) &&", "@@ -982,9 +1003,9 @@ struct BufferDescriptor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct BufferDescriptorBuilder {", "   typedef BufferDescriptor Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_base_obj(flatbuffers::Offset<tflite::gpu::data::GPUObjectDescriptor> base_obj) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_base_obj(::flatbuffers::Offset<tflite::gpu::data::GPUObjectDescriptor> base_obj) {", "     fbb_.AddOffset(BufferDescriptor::VT_BASE_OBJ, base_obj);", "   }", "   void add_element_type(tflite::gpu::data::DataType element_type) {", "@@ -996,35 +1017,35 @@ struct BufferDescriptorBuilder {", "   void add_memory_type(tflite::gpu::data::MemoryType memory_type) {", "     fbb_.AddElement<int8_t>(BufferDescriptor::VT_MEMORY_TYPE, static_cast<int8_t>(memory_type), 0);", "   }", "-  void add_attributes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> attributes) {", "+  void add_attributes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> attributes) {", "     fbb_.AddOffset(BufferDescriptor::VT_ATTRIBUTES, attributes);", "   }", "   void add_size(int32_t size) {", "     fbb_.AddElement<int32_t>(BufferDescriptor::VT_SIZE, size, 0);", "   }", "-  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {", "+  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {", "     fbb_.AddOffset(BufferDescriptor::VT_DATA, data);", "   }", "-  explicit BufferDescriptorBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit BufferDescriptorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<BufferDescriptor> Finish() {", "+  ::flatbuffers::Offset<BufferDescriptor> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<BufferDescriptor>(end);", "+    auto o = ::flatbuffers::Offset<BufferDescriptor>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<BufferDescriptor> CreateBufferDescriptor(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<tflite::gpu::data::GPUObjectDescriptor> base_obj = 0,", "+inline ::flatbuffers::Offset<BufferDescriptor> CreateBufferDescriptor(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<tflite::gpu::data::GPUObjectDescriptor> base_obj = 0,", "     tflite::gpu::data::DataType element_type = tflite::gpu::data::DataType::UNKNOWN,", "     int32_t element_size = 0,", "     tflite::gpu::data::MemoryType memory_type = tflite::gpu::data::MemoryType::GLOBAL,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> attributes = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> attributes = 0,", "     int32_t size = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {", "+    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {", "   BufferDescriptorBuilder builder_(_fbb);", "   builder_.add_data(data);", "   builder_.add_size(size);", "@@ -1036,16 +1057,16 @@ inline flatbuffers::Offset<BufferDescriptor> CreateBufferDescriptor(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<BufferDescriptor> CreateBufferDescriptorDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<tflite::gpu::data::GPUObjectDescriptor> base_obj = 0,", "+inline ::flatbuffers::Offset<BufferDescriptor> CreateBufferDescriptorDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<tflite::gpu::data::GPUObjectDescriptor> base_obj = 0,", "     tflite::gpu::data::DataType element_type = tflite::gpu::data::DataType::UNKNOWN,", "     int32_t element_size = 0,", "     tflite::gpu::data::MemoryType memory_type = tflite::gpu::data::MemoryType::GLOBAL,", "-    const std::vector<flatbuffers::Offset<flatbuffers::String>> *attributes = nullptr,", "+    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *attributes = nullptr,", "     int32_t size = 0,", "     const std::vector<uint8_t> *data = nullptr) {", "-  auto attributes__ = attributes ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*attributes) : 0;", "+  auto attributes__ = attributes ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*attributes) : 0;", "   auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;", "   return tflite::gpu::data::CreateBufferDescriptor(", "       _fbb,", "@@ -1058,7 +1079,7 @@ inline flatbuffers::Offset<BufferDescriptor> CreateBufferDescriptorDirect(", "       data__);", " }", " ", "-struct BHWDC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct BHWDC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef BHWDCBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_B = 4,", "@@ -1082,7 +1103,7 @@ struct BHWDC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t c() const {", "     return GetField<int32_t>(VT_C, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_B, 4) &&", "            VerifyField<int32_t>(verifier, VT_H, 4) &&", "@@ -1095,8 +1116,8 @@ struct BHWDC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct BHWDCBuilder {", "   typedef BHWDC Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_b(int32_t b) {", "     fbb_.AddElement<int32_t>(BHWDC::VT_B, b, 0);", "   }", "@@ -1112,19 +1133,19 @@ struct BHWDCBuilder {", "   void add_c(int32_t c) {", "     fbb_.AddElement<int32_t>(BHWDC::VT_C, c, 0);", "   }", "-  explicit BHWDCBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit BHWDCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<BHWDC> Finish() {", "+  ::flatbuffers::Offset<BHWDC> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<BHWDC>(end);", "+    auto o = ::flatbuffers::Offset<BHWDC>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<BHWDC> CreateBHWDC(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<BHWDC> CreateBHWDC(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t b = 0,", "     int32_t h = 0,", "     int32_t w = 0,", "@@ -1139,7 +1160,7 @@ inline flatbuffers::Offset<BHWDC> CreateBHWDC(", "   return builder_.Finish();", " }", " ", "-struct TensorDescriptor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct TensorDescriptor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef TensorDescriptorBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_BASE_OBJ = 4,", "@@ -1166,8 +1187,8 @@ struct TensorDescriptor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   const tflite::gpu::data::BHWDC *shape() const {", "     return GetPointer<const tflite::gpu::data::BHWDC *>(VT_SHAPE);", "   }", "-  const flatbuffers::Vector<uint8_t> *data() const {", "-    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);", "+  const ::flatbuffers::Vector<uint8_t> *data() const {", "+    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);", "   }", "   bool use_buffer_for_write_only_2d_texture() const {", "     return GetField<uint8_t>(VT_USE_BUFFER_FOR_WRITE_ONLY_2D_TEXTURE, 0) != 0;", "@@ -1175,7 +1196,7 @@ struct TensorDescriptor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool use_buffer_for_write_only_image_buffer() const {", "     return GetField<uint8_t>(VT_USE_BUFFER_FOR_WRITE_ONLY_IMAGE_BUFFER, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_BASE_OBJ) &&", "            verifier.VerifyTable(base_obj()) &&", "@@ -1194,9 +1215,9 @@ struct TensorDescriptor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct TensorDescriptorBuilder {", "   typedef TensorDescriptor Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_base_obj(flatbuffers::Offset<tflite::gpu::data::GPUObjectDescriptor> base_obj) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_base_obj(::flatbuffers::Offset<tflite::gpu::data::GPUObjectDescriptor> base_obj) {", "     fbb_.AddOffset(TensorDescriptor::VT_BASE_OBJ, base_obj);", "   }", "   void add_data_type(tflite::gpu::data::DataType data_type) {", "@@ -1208,10 +1229,10 @@ struct TensorDescriptorBuilder {", "   void add_layout(tflite::gpu::data::Layout layout) {", "     fbb_.AddElement<int8_t>(TensorDescriptor::VT_LAYOUT, static_cast<int8_t>(layout), 0);", "   }", "-  void add_shape(flatbuffers::Offset<tflite::gpu::data::BHWDC> shape) {", "+  void add_shape(::flatbuffers::Offset<tflite::gpu::data::BHWDC> shape) {", "     fbb_.AddOffset(TensorDescriptor::VT_SHAPE, shape);", "   }", "-  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {", "+  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {", "     fbb_.AddOffset(TensorDescriptor::VT_DATA, data);", "   }", "   void add_use_buffer_for_write_only_2d_texture(bool use_buffer_for_write_only_2d_texture) {", "@@ -1220,25 +1241,25 @@ struct TensorDescriptorBuilder {", "   void add_use_buffer_for_write_only_image_buffer(bool use_buffer_for_write_only_image_buffer) {", "     fbb_.AddElement<uint8_t>(TensorDescriptor::VT_USE_BUFFER_FOR_WRITE_ONLY_IMAGE_BUFFER, static_cast<uint8_t>(use_buffer_for_write_only_image_buffer), 0);", "   }", "-  explicit TensorDescriptorBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit TensorDescriptorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<TensorDescriptor> Finish() {", "+  ::flatbuffers::Offset<TensorDescriptor> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<TensorDescriptor>(end);", "+    auto o = ::flatbuffers::Offset<TensorDescriptor>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<TensorDescriptor> CreateTensorDescriptor(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<tflite::gpu::data::GPUObjectDescriptor> base_obj = 0,", "+inline ::flatbuffers::Offset<TensorDescriptor> CreateTensorDescriptor(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<tflite::gpu::data::GPUObjectDescriptor> base_obj = 0,", "     tflite::gpu::data::DataType data_type = tflite::gpu::data::DataType::UNKNOWN,", "     tflite::gpu::data::TensorStorageType storage_type = tflite::gpu::data::TensorStorageType::UNKNOWN,", "     tflite::gpu::data::Layout layout = tflite::gpu::data::Layout::UNKNOWN,", "-    flatbuffers::Offset<tflite::gpu::data::BHWDC> shape = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,", "+    ::flatbuffers::Offset<tflite::gpu::data::BHWDC> shape = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0,", "     bool use_buffer_for_write_only_2d_texture = false,", "     bool use_buffer_for_write_only_image_buffer = false) {", "   TensorDescriptorBuilder builder_(_fbb);", "@@ -1253,13 +1274,13 @@ inline flatbuffers::Offset<TensorDescriptor> CreateTensorDescriptor(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<TensorDescriptor> CreateTensorDescriptorDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<tflite::gpu::data::GPUObjectDescriptor> base_obj = 0,", "+inline ::flatbuffers::Offset<TensorDescriptor> CreateTensorDescriptorDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<tflite::gpu::data::GPUObjectDescriptor> base_obj = 0,", "     tflite::gpu::data::DataType data_type = tflite::gpu::data::DataType::UNKNOWN,", "     tflite::gpu::data::TensorStorageType storage_type = tflite::gpu::data::TensorStorageType::UNKNOWN,", "     tflite::gpu::data::Layout layout = tflite::gpu::data::Layout::UNKNOWN,", "-    flatbuffers::Offset<tflite::gpu::data::BHWDC> shape = 0,", "+    ::flatbuffers::Offset<tflite::gpu::data::BHWDC> shape = 0,", "     const std::vector<uint8_t> *data = nullptr,", "     bool use_buffer_for_write_only_2d_texture = false,", "     bool use_buffer_for_write_only_image_buffer = false) {", "@@ -1276,19 +1297,19 @@ inline flatbuffers::Offset<TensorDescriptor> CreateTensorDescriptorDirect(", "       use_buffer_for_write_only_image_buffer);", " }", " ", "-struct BufferDescriptorMapValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct BufferDescriptorMapValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef BufferDescriptorMapValueBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_KEY = 4,", "     VT_VALUE = 6", "   };", "-  const flatbuffers::String *key() const {", "-    return GetPointer<const flatbuffers::String *>(VT_KEY);", "+  const ::flatbuffers::String *key() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_KEY);", "   }", "   const tflite::gpu::data::BufferDescriptor *value() const {", "     return GetPointer<const tflite::gpu::data::BufferDescriptor *>(VT_VALUE);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_KEY) &&", "            verifier.VerifyString(key()) &&", "@@ -1300,39 +1321,39 @@ struct BufferDescriptorMapValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::T", " ", " struct BufferDescriptorMapValueBuilder {", "   typedef BufferDescriptorMapValue Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_key(flatbuffers::Offset<flatbuffers::String> key) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {", "     fbb_.AddOffset(BufferDescriptorMapValue::VT_KEY, key);", "   }", "-  void add_value(flatbuffers::Offset<tflite::gpu::data::BufferDescriptor> value) {", "+  void add_value(::flatbuffers::Offset<tflite::gpu::data::BufferDescriptor> value) {", "     fbb_.AddOffset(BufferDescriptorMapValue::VT_VALUE, value);", "   }", "-  explicit BufferDescriptorMapValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit BufferDescriptorMapValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<BufferDescriptorMapValue> Finish() {", "+  ::flatbuffers::Offset<BufferDescriptorMapValue> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<BufferDescriptorMapValue>(end);", "+    auto o = ::flatbuffers::Offset<BufferDescriptorMapValue>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<BufferDescriptorMapValue> CreateBufferDescriptorMapValue(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::String> key = 0,", "-    flatbuffers::Offset<tflite::gpu::data::BufferDescriptor> value = 0) {", "+inline ::flatbuffers::Offset<BufferDescriptorMapValue> CreateBufferDescriptorMapValue(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::String> key = 0,", "+    ::flatbuffers::Offset<tflite::gpu::data::BufferDescriptor> value = 0) {", "   BufferDescriptorMapValueBuilder builder_(_fbb);", "   builder_.add_value(value);", "   builder_.add_key(key);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<BufferDescriptorMapValue> CreateBufferDescriptorMapValueDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<BufferDescriptorMapValue> CreateBufferDescriptorMapValueDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const char *key = nullptr,", "-    flatbuffers::Offset<tflite::gpu::data::BufferDescriptor> value = 0) {", "+    ::flatbuffers::Offset<tflite::gpu::data::BufferDescriptor> value = 0) {", "   auto key__ = key ? _fbb.CreateString(key) : 0;", "   return tflite::gpu::data::CreateBufferDescriptorMapValue(", "       _fbb,", "@@ -1340,19 +1361,19 @@ inline flatbuffers::Offset<BufferDescriptorMapValue> CreateBufferDescriptorMapVa", "       value);", " }", " ", "-struct TensorDescriptorMapValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct TensorDescriptorMapValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef TensorDescriptorMapValueBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_KEY = 4,", "     VT_VALUE = 6", "   };", "-  const flatbuffers::String *key() const {", "-    return GetPointer<const flatbuffers::String *>(VT_KEY);", "+  const ::flatbuffers::String *key() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_KEY);", "   }", "   const tflite::gpu::data::TensorDescriptor *value() const {", "     return GetPointer<const tflite::gpu::data::TensorDescriptor *>(VT_VALUE);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_KEY) &&", "            verifier.VerifyString(key()) &&", "@@ -1364,39 +1385,39 @@ struct TensorDescriptorMapValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::T", " ", " struct TensorDescriptorMapValueBuilder {", "   typedef TensorDescriptorMapValue Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_key(flatbuffers::Offset<flatbuffers::String> key) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {", "     fbb_.AddOffset(TensorDescriptorMapValue::VT_KEY, key);", "   }", "-  void add_value(flatbuffers::Offset<tflite::gpu::data::TensorDescriptor> value) {", "+  void add_value(::flatbuffers::Offset<tflite::gpu::data::TensorDescriptor> value) {", "     fbb_.AddOffset(TensorDescriptorMapValue::VT_VALUE, value);", "   }", "-  explicit TensorDescriptorMapValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit TensorDescriptorMapValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<TensorDescriptorMapValue> Finish() {", "+  ::flatbuffers::Offset<TensorDescriptorMapValue> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<TensorDescriptorMapValue>(end);", "+    auto o = ::flatbuffers::Offset<TensorDescriptorMapValue>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<TensorDescriptorMapValue> CreateTensorDescriptorMapValue(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::String> key = 0,", "-    flatbuffers::Offset<tflite::gpu::data::TensorDescriptor> value = 0) {", "+inline ::flatbuffers::Offset<TensorDescriptorMapValue> CreateTensorDescriptorMapValue(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::String> key = 0,", "+    ::flatbuffers::Offset<tflite::gpu::data::TensorDescriptor> value = 0) {", "   TensorDescriptorMapValueBuilder builder_(_fbb);", "   builder_.add_value(value);", "   builder_.add_key(key);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<TensorDescriptorMapValue> CreateTensorDescriptorMapValueDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<TensorDescriptorMapValue> CreateTensorDescriptorMapValueDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const char *key = nullptr,", "-    flatbuffers::Offset<tflite::gpu::data::TensorDescriptor> value = 0) {", "+    ::flatbuffers::Offset<tflite::gpu::data::TensorDescriptor> value = 0) {", "   auto key__ = key ? _fbb.CreateString(key) : 0;", "   return tflite::gpu::data::CreateTensorDescriptorMapValue(", "       _fbb,", "@@ -1404,7 +1425,7 @@ inline flatbuffers::Offset<TensorDescriptorMapValue> CreateTensorDescriptorMapVa", "       value);", " }", " ", "-struct Arguments FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct Arguments FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ArgumentsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_INT_VALUES = 4,", "@@ -1415,28 +1436,28 @@ struct Arguments FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "     VT_BUFFER_OBJECTS = 14,", "     VT_TENSOR_OBJECTS = 16", "   };", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::IntValue>> *int_values() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::IntValue>> *>(VT_INT_VALUES);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::IntValue>> *int_values() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::IntValue>> *>(VT_INT_VALUES);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::FloatValue>> *float_values() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::FloatValue>> *>(VT_FLOAT_VALUES);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::FloatValue>> *float_values() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::FloatValue>> *>(VT_FLOAT_VALUES);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::HalfValue>> *half_values() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::HalfValue>> *>(VT_HALF_VALUES);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::HalfValue>> *half_values() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::HalfValue>> *>(VT_HALF_VALUES);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>> *buffer_refs() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>> *>(VT_BUFFER_REFS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>> *buffer_refs() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>> *>(VT_BUFFER_REFS);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>> *tensor_refs() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>> *>(VT_TENSOR_REFS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>> *tensor_refs() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>> *>(VT_TENSOR_REFS);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>> *buffer_objects() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>> *>(VT_BUFFER_OBJECTS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>> *buffer_objects() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>> *>(VT_BUFFER_OBJECTS);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>> *tensor_objects() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>> *>(VT_TENSOR_OBJECTS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>> *tensor_objects() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>> *>(VT_TENSOR_OBJECTS);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_INT_VALUES) &&", "            verifier.VerifyVector(int_values()) &&", "@@ -1465,49 +1486,49 @@ struct Arguments FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct ArgumentsBuilder {", "   typedef Arguments Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_int_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::IntValue>>> int_values) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_int_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::IntValue>>> int_values) {", "     fbb_.AddOffset(Arguments::VT_INT_VALUES, int_values);", "   }", "-  void add_float_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::FloatValue>>> float_values) {", "+  void add_float_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::FloatValue>>> float_values) {", "     fbb_.AddOffset(Arguments::VT_FLOAT_VALUES, float_values);", "   }", "-  void add_half_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::HalfValue>>> half_values) {", "+  void add_half_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::HalfValue>>> half_values) {", "     fbb_.AddOffset(Arguments::VT_HALF_VALUES, half_values);", "   }", "-  void add_buffer_refs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>>> buffer_refs) {", "+  void add_buffer_refs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>>> buffer_refs) {", "     fbb_.AddOffset(Arguments::VT_BUFFER_REFS, buffer_refs);", "   }", "-  void add_tensor_refs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>>> tensor_refs) {", "+  void add_tensor_refs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>>> tensor_refs) {", "     fbb_.AddOffset(Arguments::VT_TENSOR_REFS, tensor_refs);", "   }", "-  void add_buffer_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>>> buffer_objects) {", "+  void add_buffer_objects(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>>> buffer_objects) {", "     fbb_.AddOffset(Arguments::VT_BUFFER_OBJECTS, buffer_objects);", "   }", "-  void add_tensor_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>>> tensor_objects) {", "+  void add_tensor_objects(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>>> tensor_objects) {", "     fbb_.AddOffset(Arguments::VT_TENSOR_OBJECTS, tensor_objects);", "   }", "-  explicit ArgumentsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit ArgumentsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<Arguments> Finish() {", "+  ::flatbuffers::Offset<Arguments> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<Arguments>(end);", "+    auto o = ::flatbuffers::Offset<Arguments>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<Arguments> CreateArguments(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::IntValue>>> int_values = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::FloatValue>>> float_values = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::HalfValue>>> half_values = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>>> buffer_refs = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>>> tensor_refs = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>>> buffer_objects = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>>> tensor_objects = 0) {", "+inline ::flatbuffers::Offset<Arguments> CreateArguments(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::IntValue>>> int_values = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::FloatValue>>> float_values = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::HalfValue>>> half_values = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>>> buffer_refs = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>>> tensor_refs = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>>> buffer_objects = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>>> tensor_objects = 0) {", "   ArgumentsBuilder builder_(_fbb);", "   builder_.add_tensor_objects(tensor_objects);", "   builder_.add_buffer_objects(buffer_objects);", "@@ -1519,22 +1540,22 @@ inline flatbuffers::Offset<Arguments> CreateArguments(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<Arguments> CreateArgumentsDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    const std::vector<flatbuffers::Offset<tflite::gpu::data::IntValue>> *int_values = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::gpu::data::FloatValue>> *float_values = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::gpu::data::HalfValue>> *half_values = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>> *buffer_refs = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>> *tensor_refs = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>> *buffer_objects = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>> *tensor_objects = nullptr) {", "-  auto int_values__ = int_values ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::data::IntValue>>(*int_values) : 0;", "-  auto float_values__ = float_values ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::data::FloatValue>>(*float_values) : 0;", "-  auto half_values__ = half_values ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::data::HalfValue>>(*half_values) : 0;", "-  auto buffer_refs__ = buffer_refs ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>>(*buffer_refs) : 0;", "-  auto tensor_refs__ = tensor_refs ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>>(*tensor_refs) : 0;", "-  auto buffer_objects__ = buffer_objects ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>>(*buffer_objects) : 0;", "-  auto tensor_objects__ = tensor_objects ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>>(*tensor_objects) : 0;", "+inline ::flatbuffers::Offset<Arguments> CreateArgumentsDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    const std::vector<::flatbuffers::Offset<tflite::gpu::data::IntValue>> *int_values = nullptr,", "+    const std::vector<::flatbuffers::Offset<tflite::gpu::data::FloatValue>> *float_values = nullptr,", "+    const std::vector<::flatbuffers::Offset<tflite::gpu::data::HalfValue>> *half_values = nullptr,", "+    const std::vector<::flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>> *buffer_refs = nullptr,", "+    const std::vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>> *tensor_refs = nullptr,", "+    const std::vector<::flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>> *buffer_objects = nullptr,", "+    const std::vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>> *tensor_objects = nullptr) {", "+  auto int_values__ = int_values ? _fbb.CreateVector<::flatbuffers::Offset<tflite::gpu::data::IntValue>>(*int_values) : 0;", "+  auto float_values__ = float_values ? _fbb.CreateVector<::flatbuffers::Offset<tflite::gpu::data::FloatValue>>(*float_values) : 0;", "+  auto half_values__ = half_values ? _fbb.CreateVector<::flatbuffers::Offset<tflite::gpu::data::HalfValue>>(*half_values) : 0;", "+  auto buffer_refs__ = buffer_refs ? _fbb.CreateVector<::flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>>(*buffer_refs) : 0;", "+  auto tensor_refs__ = tensor_refs ? _fbb.CreateVector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>>(*tensor_refs) : 0;", "+  auto buffer_objects__ = buffer_objects ? _fbb.CreateVector<::flatbuffers::Offset<tflite::gpu::data::BufferDescriptorMapValue>>(*buffer_objects) : 0;", "+  auto tensor_objects__ = tensor_objects ? _fbb.CreateVector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptorMapValue>>(*tensor_objects) : 0;", "   return tflite::gpu::data::CreateArguments(", "       _fbb,", "       int_values__,", "@@ -1546,7 +1567,7 @@ inline flatbuffers::Offset<Arguments> CreateArgumentsDirect(", "       tensor_objects__);", " }", " ", "-struct OperationDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct OperationDef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef OperationDefBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_PRECISION = 4,", "@@ -1556,13 +1577,13 @@ struct OperationDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   tflite::gpu::data::CalculationsPrecision precision() const {", "     return static_cast<tflite::gpu::data::CalculationsPrecision>(GetField<int8_t>(VT_PRECISION, 0));", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>> *src_tensors() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>> *>(VT_SRC_TENSORS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>> *src_tensors() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>> *>(VT_SRC_TENSORS);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>> *dst_tensors() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>> *>(VT_DST_TENSORS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>> *dst_tensors() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>> *>(VT_DST_TENSORS);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_PRECISION, 1) &&", "            VerifyOffset(verifier, VT_SRC_TENSORS) &&", "@@ -1577,33 +1598,33 @@ struct OperationDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct OperationDefBuilder {", "   typedef OperationDef Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_precision(tflite::gpu::data::CalculationsPrecision precision) {", "     fbb_.AddElement<int8_t>(OperationDef::VT_PRECISION, static_cast<int8_t>(precision), 0);", "   }", "-  void add_src_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>>> src_tensors) {", "+  void add_src_tensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>>> src_tensors) {", "     fbb_.AddOffset(OperationDef::VT_SRC_TENSORS, src_tensors);", "   }", "-  void add_dst_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>>> dst_tensors) {", "+  void add_dst_tensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>>> dst_tensors) {", "     fbb_.AddOffset(OperationDef::VT_DST_TENSORS, dst_tensors);", "   }", "-  explicit OperationDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit OperationDefBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<OperationDef> Finish() {", "+  ::flatbuffers::Offset<OperationDef> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<OperationDef>(end);", "+    auto o = ::flatbuffers::Offset<OperationDef>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<OperationDef> CreateOperationDef(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<OperationDef> CreateOperationDef(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::gpu::data::CalculationsPrecision precision = tflite::gpu::data::CalculationsPrecision::F32,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>>> src_tensors = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>>> dst_tensors = 0) {", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>>> src_tensors = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>>> dst_tensors = 0) {", "   OperationDefBuilder builder_(_fbb);", "   builder_.add_dst_tensors(dst_tensors);", "   builder_.add_src_tensors(src_tensors);", "@@ -1611,13 +1632,13 @@ inline flatbuffers::Offset<OperationDef> CreateOperationDef(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<OperationDef> CreateOperationDefDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<OperationDef> CreateOperationDefDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::gpu::data::CalculationsPrecision precision = tflite::gpu::data::CalculationsPrecision::F32,", "-    const std::vector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>> *src_tensors = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>> *dst_tensors = nullptr) {", "-  auto src_tensors__ = src_tensors ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>>(*src_tensors) : 0;", "-  auto dst_tensors__ = dst_tensors ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>>(*dst_tensors) : 0;", "+    const std::vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>> *src_tensors = nullptr,", "+    const std::vector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>> *dst_tensors = nullptr) {", "+  auto src_tensors__ = src_tensors ? _fbb.CreateVector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>>(*src_tensors) : 0;", "+  auto dst_tensors__ = dst_tensors ? _fbb.CreateVector<::flatbuffers::Offset<tflite::gpu::data::TensorDescriptor>>(*dst_tensors) : 0;", "   return tflite::gpu::data::CreateOperationDef(", "       _fbb,", "       precision,", "@@ -1625,7 +1646,7 @@ inline flatbuffers::Offset<OperationDef> CreateOperationDefDirect(", "       dst_tensors__);", " }", " ", "-struct CompilerOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct CompilerOption FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef CompilerOptionBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_OPTION = 4", "@@ -1633,7 +1654,7 @@ struct CompilerOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   tflite::gpu::data::CompilerOptions option() const {", "     return static_cast<tflite::gpu::data::CompilerOptions>(GetField<int8_t>(VT_OPTION, 0));", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_OPTION, 1) &&", "            verifier.EndTable();", "@@ -1642,31 +1663,31 @@ struct CompilerOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct CompilerOptionBuilder {", "   typedef CompilerOption Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_option(tflite::gpu::data::CompilerOptions option) {", "     fbb_.AddElement<int8_t>(CompilerOption::VT_OPTION, static_cast<int8_t>(option), 0);", "   }", "-  explicit CompilerOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit CompilerOptionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<CompilerOption> Finish() {", "+  ::flatbuffers::Offset<CompilerOption> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<CompilerOption>(end);", "+    auto o = ::flatbuffers::Offset<CompilerOption>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<CompilerOption> CreateCompilerOption(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<CompilerOption> CreateCompilerOption(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::gpu::data::CompilerOptions option = tflite::gpu::data::CompilerOptions::ADRENO_FULL_SIMD_LINE) {", "   CompilerOptionBuilder builder_(_fbb);", "   builder_.add_option(option);", "   return builder_.Finish();", " }", " ", "-struct GPUOperation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct GPUOperation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef GPUOperationBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_ARGUMENTS = 4,", "@@ -1686,14 +1707,14 @@ struct GPUOperation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   const tflite::gpu::data::Arguments *arguments() const {", "     return GetPointer<const tflite::gpu::data::Arguments *>(VT_ARGUMENTS);", "   }", "-  const flatbuffers::String *code() const {", "-    return GetPointer<const flatbuffers::String *>(VT_CODE);", "+  const ::flatbuffers::String *code() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_CODE);", "   }", "   const tflite::gpu::data::Int3 *work_group_size() const {", "     return GetPointer<const tflite::gpu::data::Int3 *>(VT_WORK_GROUP_SIZE);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::CompilerOption>> *compiler_options() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::CompilerOption>> *>(VT_COMPILER_OPTIONS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::CompilerOption>> *compiler_options() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::CompilerOption>> *>(VT_COMPILER_OPTIONS);", "   }", "   tflite::gpu::data::TensorToGrid tensor_to_grid() const {", "     return static_cast<tflite::gpu::data::TensorToGrid>(GetField<int8_t>(VT_TENSOR_TO_GRID, 0));", "@@ -1713,16 +1734,16 @@ struct GPUOperation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   const tflite::gpu::data::Int3 *grid_size() const {", "     return GetPointer<const tflite::gpu::data::Int3 *>(VT_GRID_SIZE);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *src_tensors_names() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SRC_TENSORS_NAMES);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *src_tensors_names() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SRC_TENSORS_NAMES);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *dst_tensors_names() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DST_TENSORS_NAMES);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *dst_tensors_names() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DST_TENSORS_NAMES);", "   }", "   const tflite::gpu::data::Int3 *work_groups_count() const {", "     return GetPointer<const tflite::gpu::data::Int3 *>(VT_WORK_GROUPS_COUNT);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_ARGUMENTS) &&", "            verifier.VerifyTable(arguments()) &&", "@@ -1756,18 +1777,18 @@ struct GPUOperation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", " ", " struct GPUOperationBuilder {", "   typedef GPUOperation Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_arguments(flatbuffers::Offset<tflite::gpu::data::Arguments> arguments) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_arguments(::flatbuffers::Offset<tflite::gpu::data::Arguments> arguments) {", "     fbb_.AddOffset(GPUOperation::VT_ARGUMENTS, arguments);", "   }", "-  void add_code(flatbuffers::Offset<flatbuffers::String> code) {", "+  void add_code(::flatbuffers::Offset<::flatbuffers::String> code) {", "     fbb_.AddOffset(GPUOperation::VT_CODE, code);", "   }", "-  void add_work_group_size(flatbuffers::Offset<tflite::gpu::data::Int3> work_group_size) {", "+  void add_work_group_size(::flatbuffers::Offset<tflite::gpu::data::Int3> work_group_size) {", "     fbb_.AddOffset(GPUOperation::VT_WORK_GROUP_SIZE, work_group_size);", "   }", "-  void add_compiler_options(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::gpu::data::CompilerOption>>> compiler_options) {", "+  void add_compiler_options(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::CompilerOption>>> compiler_options) {", "     fbb_.AddOffset(GPUOperation::VT_COMPILER_OPTIONS, compiler_options);", "   }", "   void add_tensor_to_grid(tflite::gpu::data::TensorToGrid tensor_to_grid) {", "@@ -1776,60 +1797,53 @@ struct GPUOperationBuilder {", "   void add_flops(uint64_t flops) {", "     fbb_.AddElement<uint64_t>(GPUOperation::VT_FLOPS, flops, 0);", "   }", "-  void add_definition(flatbuffers::Offset<tflite::gpu::data::OperationDef> definition) {", "+  void add_definition(::flatbuffers::Offset<tflite::gpu::data::OperationDef> definition) {", "     fbb_.AddOffset(GPUOperation::VT_DEFINITION, definition);", "   }", "   void add_grid_dimension(int32_t grid_dimension) {", "     fbb_.AddElement<int32_t>(GPUOperation::VT_GRID_DIMENSION, grid_dimension, 0);", "   }", "-  void add_work_group_launch_order(flatbuffers::Offset<tflite::gpu::data::Int3> work_group_launch_order) {", "+  void add_work_group_launch_order(::flatbuffers::Offset<tflite::gpu::data::Int3> work_group_launch_order) {", "     fbb_.AddOffset(GPUOperation::VT_WORK_GROUP_LAUNCH_ORDER, work_group_launch_order);", "   }", "-  void add_grid_size(flatbuffers::Offset<tflite::gpu::data::Int3> grid_size) {", "+  void add_grid_size(::flatbuffers::Offset<tflite::gpu::data::Int3> grid_size) {", "     fbb_.AddOffset(GPUOperation::VT_GRID_SIZE, grid_size);", "   }", "-  void add_src_tensors_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> src_tensors_names) {", "+  void add_src_tensors_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> src_tensors_names) {", "     fbb_.AddOffset(GPUOperation::VT_SRC_TENSORS_NAMES, src_tensors_names);", "   }", "-  void add_dst_tensors_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> dst_tensors_names) {", "+  void add_dst_tensors_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> dst_tensors_names) {", "     fbb_.AddOffset(GPUOperation::VT_DST_TENSORS_NAMES, dst_tensors_names);", "   }", "-  void add_work_groups_count(flatbuffers::Offset<tflite::gpu::data::Int3> work_groups_count) {", "+  void add_work_groups_count(::flatbuffers::Offset<tflite::gpu::data::Int3> work_groups_count) {", "     fbb_.AddOffset(GPUOperation::VT_WORK_GROUPS_COUNT, work_groups_count);", "   }", "-  explicit GPUOperationBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit GPUOperationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<GPUOperation> Finish() {", "+  ::flatbuffers::Offset<GPUOperation> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<GPUOperation>(end);", "+    auto o = ::flatbuffers::Offset<GPUOperation>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<GPUOperation> CreateGPUOperation(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<tflite::gpu::data::Arguments> arguments = 0,", "-    flatbuffers::Offset<flatbuffers::String> code = 0,", "-    flatbuffers::Offset<tflite::gpu::data::Int3> work_group_size = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<", "-        flatbuffers::Offset<tflite::gpu::data::CompilerOption>>>", "-        compiler_options = 0,", "-    tflite::gpu::data::TensorToGrid tensor_to_grid =", "-        tflite::gpu::data::TensorToGrid::CUSTOM,", "+inline ::flatbuffers::Offset<GPUOperation> CreateGPUOperation(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<tflite::gpu::data::Arguments> arguments = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> code = 0,", "+    ::flatbuffers::Offset<tflite::gpu::data::Int3> work_group_size = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::gpu::data::CompilerOption>>> compiler_options = 0,", "+    tflite::gpu::data::TensorToGrid tensor_to_grid = tflite::gpu::data::TensorToGrid::CUSTOM,", "     uint64_t flops = 0,", "-    flatbuffers::Offset<tflite::gpu::data::OperationDef> definition = 0,", "+    ::flatbuffers::Offset<tflite::gpu::data::OperationDef> definition = 0,", "     int32_t grid_dimension = 0,", "-    flatbuffers::Offset<tflite::gpu::data::Int3> work_group_launch_order = 0,", "-    flatbuffers::Offset<tflite::gpu::data::Int3> grid_size = 0,", "-    flatbuffers::Offset<", "-        flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>>", "-        src_tensors_names = 0,", "-    flatbuffers::Offset<", "-        flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>>", "-        dst_tensors_names = 0,", "-    flatbuffers::Offset<tflite::gpu::data::Int3> work_groups_count = 0) {", "+    ::flatbuffers::Offset<tflite::gpu::data::Int3> work_group_launch_order = 0,", "+    ::flatbuffers::Offset<tflite::gpu::data::Int3> grid_size = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> src_tensors_names = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> dst_tensors_names = 0,", "+    ::flatbuffers::Offset<tflite::gpu::data::Int3> work_groups_count = 0) {", "   GPUOperationBuilder builder_(_fbb);", "   builder_.add_flops(flops);", "   builder_.add_work_groups_count(work_groups_count);", "@@ -1847,34 +1861,40 @@ inline flatbuffers::Offset<GPUOperation> CreateGPUOperation(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<GPUOperation> CreateGPUOperationDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<tflite::gpu::data::Arguments> arguments = 0,", "+inline ::flatbuffers::Offset<GPUOperation> CreateGPUOperationDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<tflite::gpu::data::Arguments> arguments = 0,", "     const char *code = nullptr,", "-    flatbuffers::Offset<tflite::gpu::data::Int3> work_group_size = 0,", "-    const std::vector<flatbuffers::Offset<tflite::gpu::data::CompilerOption>>", "-        *compiler_options = nullptr,", "-    tflite::gpu::data::TensorToGrid tensor_to_grid =", "-        tflite::gpu::data::TensorToGrid::CUSTOM,", "+    ::flatbuffers::Offset<tflite::gpu::data::Int3> work_group_size = 0,", "+    const std::vector<::flatbuffers::Offset<tflite::gpu::data::CompilerOption>> *compiler_options = nullptr,", "+    tflite::gpu::data::TensorToGrid tensor_to_grid = tflite::gpu::data::TensorToGrid::CUSTOM,", "     uint64_t flops = 0,", "-    flatbuffers::Offset<tflite::gpu::data::OperationDef> definition = 0,", "+    ::flatbuffers::Offset<tflite::gpu::data::OperationDef> definition = 0,", "     int32_t grid_dimension = 0,", "-    flatbuffers::Offset<tflite::gpu::data::Int3> work_group_launch_order = 0,", "-    flatbuffers::Offset<tflite::gpu::data::Int3> grid_size = 0,", "-    const std::vector<flatbuffers::Offset<flatbuffers::String>>", "-        *src_tensors_names = nullptr,", "-    const std::vector<flatbuffers::Offset<flatbuffers::String>>", "-        *dst_tensors_names = nullptr,", "-    flatbuffers::Offset<tflite::gpu::data::Int3> work_groups_count = 0) {", "+    ::flatbuffers::Offset<tflite::gpu::data::Int3> work_group_launch_order = 0,", "+    ::flatbuffers::Offset<tflite::gpu::data::Int3> grid_size = 0,", "+    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *src_tensors_names = nullptr,", "+    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *dst_tensors_names = nullptr,", "+    ::flatbuffers::Offset<tflite::gpu::data::Int3> work_groups_count = 0) {", "   auto code__ = code ? _fbb.CreateString(code) : 0;", "-  auto compiler_options__ = compiler_options ? _fbb.CreateVector<flatbuffers::Offset<tflite::gpu::data::CompilerOption>>(*compiler_options) : 0;", "-  auto src_tensors_names__ = src_tensors_names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*src_tensors_names) : 0;", "-  auto dst_tensors_names__ = dst_tensors_names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*dst_tensors_names) : 0;", "+  auto compiler_options__ = compiler_options ? _fbb.CreateVector<::flatbuffers::Offset<tflite::gpu::data::CompilerOption>>(*compiler_options) : 0;", "+  auto src_tensors_names__ = src_tensors_names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*src_tensors_names) : 0;", "+  auto dst_tensors_names__ = dst_tensors_names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*dst_tensors_names) : 0;", "   return tflite::gpu::data::CreateGPUOperation(", "-      _fbb, arguments, code__, work_group_size, compiler_options__,", "-      tensor_to_grid, flops, definition, grid_dimension,", "-      work_group_launch_order, grid_size, src_tensors_names__,", "-      dst_tensors_names__, work_groups_count);", "+      _fbb,", "+      arguments,", "+      code__,", "+      work_group_size,", "+      compiler_options__,", "+      tensor_to_grid,", "+      flops,", "+      definition,", "+      grid_dimension,", "+      work_group_launch_order,", "+      grid_size,", "+      src_tensors_names__,", "+      dst_tensors_names__,", "+      work_groups_count);", " }", " ", " }  // namespace data", "@@ -20,6 +20,13 @@ limitations under the License.", " ", " #include \"flatbuffers/flatbuffers.h\"", " ", "+// Ensure the included flatbuffers.h is the same version as when this file was", "+// generated, otherwise it may not be compatible.", "+static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&", "+              FLATBUFFERS_VERSION_MINOR == 1 &&", "+              FLATBUFFERS_VERSION_REVISION == 20,", "+             \"Non-compatible flatbuffers version included\");", "+", " namespace tflite {", " ", " struct ComputeSettings;", "@@ -248,7 +255,7 @@ inline const char * const *EnumNamesExecutionPreference() {", " }", " ", " inline const char *EnumNameExecutionPreference(ExecutionPreference e) {", "-  if (flatbuffers::IsOutRange(e, ExecutionPreference_ANY, ExecutionPreference_FORCE_CPU)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, ExecutionPreference_ANY, ExecutionPreference_FORCE_CPU)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesExecutionPreference()[index];", " }", "@@ -296,7 +303,7 @@ inline const char * const *EnumNamesDelegate() {", " }", " ", " inline const char *EnumNameDelegate(Delegate e) {", "-  if (flatbuffers::IsOutRange(e, Delegate_NONE, Delegate_CORE_ML)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, Delegate_NONE, Delegate_CORE_ML)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesDelegate()[index];", " }", "@@ -332,7 +339,7 @@ inline const char * const *EnumNamesNNAPIExecutionPreference() {", " }", " ", " inline const char *EnumNameNNAPIExecutionPreference(NNAPIExecutionPreference e) {", "-  if (flatbuffers::IsOutRange(e, NNAPIExecutionPreference_UNDEFINED, NNAPIExecutionPreference_NNAPI_SUSTAINED_SPEED)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, NNAPIExecutionPreference_UNDEFINED, NNAPIExecutionPreference_NNAPI_SUSTAINED_SPEED)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesNNAPIExecutionPreference()[index];", " }", "@@ -368,7 +375,7 @@ inline const char * const *EnumNamesNNAPIExecutionPriority() {", " }", " ", " inline const char *EnumNameNNAPIExecutionPriority(NNAPIExecutionPriority e) {", "-  if (flatbuffers::IsOutRange(e, NNAPIExecutionPriority_NNAPI_PRIORITY_UNDEFINED, NNAPIExecutionPriority_NNAPI_PRIORITY_HIGH)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, NNAPIExecutionPriority_NNAPI_PRIORITY_UNDEFINED, NNAPIExecutionPriority_NNAPI_PRIORITY_HIGH)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesNNAPIExecutionPriority()[index];", " }", "@@ -401,7 +408,7 @@ inline const char * const *EnumNamesGPUBackend() {", " }", " ", " inline const char *EnumNameGPUBackend(GPUBackend e) {", "-  if (flatbuffers::IsOutRange(e, GPUBackend_UNSET, GPUBackend_OPENGL)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, GPUBackend_UNSET, GPUBackend_OPENGL)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesGPUBackend()[index];", " }", "@@ -437,7 +444,7 @@ inline const char * const *EnumNamesGPUInferencePriority() {", " }", " ", " inline const char *EnumNameGPUInferencePriority(GPUInferencePriority e) {", "-  if (flatbuffers::IsOutRange(e, GPUInferencePriority_GPU_PRIORITY_AUTO, GPUInferencePriority_GPU_PRIORITY_MIN_MEMORY_USAGE)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, GPUInferencePriority_GPU_PRIORITY_AUTO, GPUInferencePriority_GPU_PRIORITY_MIN_MEMORY_USAGE)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesGPUInferencePriority()[index];", " }", "@@ -467,7 +474,7 @@ inline const char * const *EnumNamesGPUInferenceUsage() {", " }", " ", " inline const char *EnumNameGPUInferenceUsage(GPUInferenceUsage e) {", "-  if (flatbuffers::IsOutRange(e, GPUInferenceUsage_GPU_INFERENCE_PREFERENCE_FAST_SINGLE_ANSWER, GPUInferenceUsage_GPU_INFERENCE_PREFERENCE_SUSTAINED_SPEED)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, GPUInferenceUsage_GPU_INFERENCE_PREFERENCE_FAST_SINGLE_ANSWER, GPUInferenceUsage_GPU_INFERENCE_PREFERENCE_SUSTAINED_SPEED)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesGPUInferenceUsage()[index];", " }", "@@ -506,7 +513,7 @@ inline const char * const *EnumNamesXNNPackFlags() {", " }", " ", " inline const char *EnumNameXNNPackFlags(XNNPackFlags e) {", "-  if (flatbuffers::IsOutRange(e, XNNPackFlags_TFLITE_XNNPACK_DELEGATE_NO_FLAGS, XNNPackFlags_TFLITE_XNNPACK_DELEGATE_FLAG_FORCE_FP16)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, XNNPackFlags_TFLITE_XNNPACK_DELEGATE_NO_FLAGS, XNNPackFlags_TFLITE_XNNPACK_DELEGATE_FLAG_FORCE_FP16)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesXNNPackFlags()[index];", " }", "@@ -538,7 +545,7 @@ inline const char * const *EnumNamesEnabledDevices() {", " }", " ", " inline const char *EnumNameEnabledDevices(EnabledDevices e) {", "-  if (flatbuffers::IsOutRange(e, EnabledDevices_DEVICES_ALL, EnabledDevices_DEVICES_WITH_NEURAL_ENGINE)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, EnabledDevices_DEVICES_ALL, EnabledDevices_DEVICES_WITH_NEURAL_ENGINE)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesEnabledDevices()[index];", " }", "@@ -578,7 +585,7 @@ inline const char * const *EnumNamesPlatformType() {", " }", " ", " inline const char *EnumNamePlatformType(PlatformType e) {", "-  if (flatbuffers::IsOutRange(e, PlatformType_MMIO, PlatformType_REMOTE_SIMULATOR)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, PlatformType_MMIO, PlatformType_REMOTE_SIMULATOR)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesPlatformType()[index];", " }", "@@ -628,7 +635,7 @@ inline const char * const *EnumNamesEdgeTpuPowerState() {", " }", " ", " inline const char *EnumNameEdgeTpuPowerState(EdgeTpuPowerState e) {", "-  if (flatbuffers::IsOutRange(e, EdgeTpuPowerState_UNDEFINED_POWERSTATE, EdgeTpuPowerState_OVER_DRIVE)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, EdgeTpuPowerState_UNDEFINED_POWERSTATE, EdgeTpuPowerState_OVER_DRIVE)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesEdgeTpuPowerState()[index];", " }", "@@ -666,7 +673,7 @@ inline const char * const *EnumNamesFloatTruncationType() {", " }", " ", " inline const char *EnumNameFloatTruncationType(FloatTruncationType e) {", "-  if (flatbuffers::IsOutRange(e, FloatTruncationType_UNSPECIFIED, FloatTruncationType_HALF)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, FloatTruncationType_UNSPECIFIED, FloatTruncationType_HALF)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesFloatTruncationType()[index];", " }", "@@ -699,7 +706,7 @@ inline const char * const *EnumNamesQosClass() {", " }", " ", " inline const char *EnumNameQosClass(QosClass e) {", "-  if (flatbuffers::IsOutRange(e, QosClass_QOS_UNDEFINED, QosClass_REALTIME)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, QosClass_QOS_UNDEFINED, QosClass_REALTIME)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesQosClass()[index];", " }", "@@ -739,7 +746,7 @@ inline const char * const *EnumNamesPriority() {", " }", " ", " inline const char *EnumNamePriority(Priority e) {", "-  if (flatbuffers::IsOutRange(e, Priority_PRIORITY_UNDEFINED, Priority_PRIORITY_HIGH)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, Priority_PRIORITY_UNDEFINED, Priority_PRIORITY_HIGH)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesPriority()[index];", " }", "@@ -782,7 +789,7 @@ inline const char * const *EnumNamesPerformance() {", " }", " ", " inline const char *EnumNamePerformance(Performance e) {", "-  if (flatbuffers::IsOutRange(e, Performance_UNDEFINED, Performance_LOW)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, Performance_UNDEFINED, Performance_LOW)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesPerformance()[index];", " }", "@@ -826,7 +833,7 @@ inline const char * const *EnumNamesBenchmarkEventType() {", " }", " ", " inline const char *EnumNameBenchmarkEventType(BenchmarkEventType e) {", "-  if (flatbuffers::IsOutRange(e, BenchmarkEventType_UNDEFINED_BENCHMARK_EVENT_TYPE, BenchmarkEventType_RECOVERED_ERROR)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, BenchmarkEventType_UNDEFINED_BENCHMARK_EVENT_TYPE, BenchmarkEventType_RECOVERED_ERROR)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesBenchmarkEventType()[index];", " }", "@@ -859,12 +866,12 @@ inline const char * const *EnumNamesBenchmarkStage() {", " }", " ", " inline const char *EnumNameBenchmarkStage(BenchmarkStage e) {", "-  if (flatbuffers::IsOutRange(e, BenchmarkStage_UNKNOWN, BenchmarkStage_INFERENCE)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, BenchmarkStage_UNKNOWN, BenchmarkStage_INFERENCE)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesBenchmarkStage()[index];", " }", " ", "-struct ComputeSettingsT : public flatbuffers::NativeTable {", "+struct ComputeSettingsT : public ::flatbuffers::NativeTable {", "   typedef ComputeSettings TableType;", "   tflite::ExecutionPreference preference = tflite::ExecutionPreference_ANY;", "   std::unique_ptr<tflite::TFLiteSettingsT> tflite_settings{};", "@@ -877,7 +884,7 @@ struct ComputeSettingsT : public flatbuffers::NativeTable {", "   ComputeSettingsT &operator=(ComputeSettingsT o) FLATBUFFERS_NOEXCEPT;", " };", " ", "-struct ComputeSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ComputeSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ComputeSettingsT NativeTableType;", "   typedef ComputeSettingsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -893,16 +900,16 @@ struct ComputeSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   const tflite::TFLiteSettings *tflite_settings() const {", "     return GetPointer<const tflite::TFLiteSettings *>(VT_TFLITE_SETTINGS);", "   }", "-  const flatbuffers::String *model_namespace_for_statistics() const {", "-    return GetPointer<const flatbuffers::String *>(VT_MODEL_NAMESPACE_FOR_STATISTICS);", "+  const ::flatbuffers::String *model_namespace_for_statistics() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_MODEL_NAMESPACE_FOR_STATISTICS);", "   }", "-  const flatbuffers::String *model_identifier_for_statistics() const {", "-    return GetPointer<const flatbuffers::String *>(VT_MODEL_IDENTIFIER_FOR_STATISTICS);", "+  const ::flatbuffers::String *model_identifier_for_statistics() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_MODEL_IDENTIFIER_FOR_STATISTICS);", "   }", "   const tflite::MinibenchmarkSettings *settings_to_test_locally() const {", "     return GetPointer<const tflite::MinibenchmarkSettings *>(VT_SETTINGS_TO_TEST_LOCALLY);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_PREFERENCE, 4) &&", "            VerifyOffset(verifier, VT_TFLITE_SETTINGS) &&", "@@ -915,48 +922,48 @@ struct ComputeSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            verifier.VerifyTable(settings_to_test_locally()) &&", "            verifier.EndTable();", "   }", "-  ComputeSettingsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ComputeSettingsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ComputeSettings> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ComputeSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ComputeSettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ComputeSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ComputeSettings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ComputeSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ComputeSettingsBuilder {", "   typedef ComputeSettings Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_preference(tflite::ExecutionPreference preference) {", "     fbb_.AddElement<int32_t>(ComputeSettings::VT_PREFERENCE, static_cast<int32_t>(preference), 0);", "   }", "-  void add_tflite_settings(flatbuffers::Offset<tflite::TFLiteSettings> tflite_settings) {", "+  void add_tflite_settings(::flatbuffers::Offset<tflite::TFLiteSettings> tflite_settings) {", "     fbb_.AddOffset(ComputeSettings::VT_TFLITE_SETTINGS, tflite_settings);", "   }", "-  void add_model_namespace_for_statistics(flatbuffers::Offset<flatbuffers::String> model_namespace_for_statistics) {", "+  void add_model_namespace_for_statistics(::flatbuffers::Offset<::flatbuffers::String> model_namespace_for_statistics) {", "     fbb_.AddOffset(ComputeSettings::VT_MODEL_NAMESPACE_FOR_STATISTICS, model_namespace_for_statistics);", "   }", "-  void add_model_identifier_for_statistics(flatbuffers::Offset<flatbuffers::String> model_identifier_for_statistics) {", "+  void add_model_identifier_for_statistics(::flatbuffers::Offset<::flatbuffers::String> model_identifier_for_statistics) {", "     fbb_.AddOffset(ComputeSettings::VT_MODEL_IDENTIFIER_FOR_STATISTICS, model_identifier_for_statistics);", "   }", "-  void add_settings_to_test_locally(flatbuffers::Offset<tflite::MinibenchmarkSettings> settings_to_test_locally) {", "+  void add_settings_to_test_locally(::flatbuffers::Offset<tflite::MinibenchmarkSettings> settings_to_test_locally) {", "     fbb_.AddOffset(ComputeSettings::VT_SETTINGS_TO_TEST_LOCALLY, settings_to_test_locally);", "   }", "-  explicit ComputeSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit ComputeSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ComputeSettings> Finish() {", "+  ::flatbuffers::Offset<ComputeSettings> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ComputeSettings>(end);", "+    auto o = ::flatbuffers::Offset<ComputeSettings>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ComputeSettings> CreateComputeSettings(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<ComputeSettings> CreateComputeSettings(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::ExecutionPreference preference = tflite::ExecutionPreference_ANY,", "-    flatbuffers::Offset<tflite::TFLiteSettings> tflite_settings = 0,", "-    flatbuffers::Offset<flatbuffers::String> model_namespace_for_statistics = 0,", "-    flatbuffers::Offset<flatbuffers::String> model_identifier_for_statistics = 0,", "-    flatbuffers::Offset<tflite::MinibenchmarkSettings> settings_to_test_locally = 0) {", "+    ::flatbuffers::Offset<tflite::TFLiteSettings> tflite_settings = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> model_namespace_for_statistics = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> model_identifier_for_statistics = 0,", "+    ::flatbuffers::Offset<tflite::MinibenchmarkSettings> settings_to_test_locally = 0) {", "   ComputeSettingsBuilder builder_(_fbb);", "   builder_.add_settings_to_test_locally(settings_to_test_locally);", "   builder_.add_model_identifier_for_statistics(model_identifier_for_statistics);", "@@ -966,13 +973,13 @@ inline flatbuffers::Offset<ComputeSettings> CreateComputeSettings(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<ComputeSettings> CreateComputeSettingsDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<ComputeSettings> CreateComputeSettingsDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::ExecutionPreference preference = tflite::ExecutionPreference_ANY,", "-    flatbuffers::Offset<tflite::TFLiteSettings> tflite_settings = 0,", "+    ::flatbuffers::Offset<tflite::TFLiteSettings> tflite_settings = 0,", "     const char *model_namespace_for_statistics = nullptr,", "     const char *model_identifier_for_statistics = nullptr,", "-    flatbuffers::Offset<tflite::MinibenchmarkSettings> settings_to_test_locally = 0) {", "+    ::flatbuffers::Offset<tflite::MinibenchmarkSettings> settings_to_test_locally = 0) {", "   auto model_namespace_for_statistics__ = model_namespace_for_statistics ? _fbb.CreateString(model_namespace_for_statistics) : 0;", "   auto model_identifier_for_statistics__ = model_identifier_for_statistics ? _fbb.CreateString(model_identifier_for_statistics) : 0;", "   return tflite::CreateComputeSettings(", "@@ -984,9 +991,9 @@ inline flatbuffers::Offset<ComputeSettings> CreateComputeSettingsDirect(", "       settings_to_test_locally);", " }", " ", "-flatbuffers::Offset<ComputeSettings> CreateComputeSettings(flatbuffers::FlatBufferBuilder &_fbb, const ComputeSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ComputeSettings> CreateComputeSettings(::flatbuffers::FlatBufferBuilder &_fbb, const ComputeSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct NNAPISettingsT : public flatbuffers::NativeTable {", "+struct NNAPISettingsT : public ::flatbuffers::NativeTable {", "   typedef NNAPISettings TableType;", "   std::string accelerator_name{};", "   std::string cache_directory{};", "@@ -1006,7 +1013,7 @@ struct NNAPISettingsT : public flatbuffers::NativeTable {", "   NNAPISettingsT &operator=(NNAPISettingsT o) FLATBUFFERS_NOEXCEPT;", " };", " ", "-struct NNAPISettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct NNAPISettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef NNAPISettingsT NativeTableType;", "   typedef NNAPISettingsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -1023,14 +1030,14 @@ struct NNAPISettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "     VT_USE_BURST_COMPUTATION = 24,", "     VT_SUPPORT_LIBRARY_HANDLE = 26", "   };", "-  const flatbuffers::String *accelerator_name() const {", "-    return GetPointer<const flatbuffers::String *>(VT_ACCELERATOR_NAME);", "+  const ::flatbuffers::String *accelerator_name() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_ACCELERATOR_NAME);", "   }", "-  const flatbuffers::String *cache_directory() const {", "-    return GetPointer<const flatbuffers::String *>(VT_CACHE_DIRECTORY);", "+  const ::flatbuffers::String *cache_directory() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_CACHE_DIRECTORY);", "   }", "-  const flatbuffers::String *model_token() const {", "-    return GetPointer<const flatbuffers::String *>(VT_MODEL_TOKEN);", "+  const ::flatbuffers::String *model_token() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_MODEL_TOKEN);", "   }", "   tflite::NNAPIExecutionPreference execution_preference() const {", "     return static_cast<tflite::NNAPIExecutionPreference>(GetField<int32_t>(VT_EXECUTION_PREFERENCE, 0));", "@@ -1059,7 +1066,7 @@ struct NNAPISettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int64_t support_library_handle() const {", "     return GetField<int64_t>(VT_SUPPORT_LIBRARY_HANDLE, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_ACCELERATOR_NAME) &&", "            verifier.VerifyString(accelerator_name()) &&", "@@ -1079,22 +1086,22 @@ struct NNAPISettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            VerifyField<int64_t>(verifier, VT_SUPPORT_LIBRARY_HANDLE, 8) &&", "            verifier.EndTable();", "   }", "-  NNAPISettingsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(NNAPISettingsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<NNAPISettings> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NNAPISettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  NNAPISettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(NNAPISettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<NNAPISettings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NNAPISettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct NNAPISettingsBuilder {", "   typedef NNAPISettings Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_accelerator_name(flatbuffers::Offset<flatbuffers::String> accelerator_name) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_accelerator_name(::flatbuffers::Offset<::flatbuffers::String> accelerator_name) {", "     fbb_.AddOffset(NNAPISettings::VT_ACCELERATOR_NAME, accelerator_name);", "   }", "-  void add_cache_directory(flatbuffers::Offset<flatbuffers::String> cache_directory) {", "+  void add_cache_directory(::flatbuffers::Offset<::flatbuffers::String> cache_directory) {", "     fbb_.AddOffset(NNAPISettings::VT_CACHE_DIRECTORY, cache_directory);", "   }", "-  void add_model_token(flatbuffers::Offset<flatbuffers::String> model_token) {", "+  void add_model_token(::flatbuffers::Offset<::flatbuffers::String> model_token) {", "     fbb_.AddOffset(NNAPISettings::VT_MODEL_TOKEN, model_token);", "   }", "   void add_execution_preference(tflite::NNAPIExecutionPreference execution_preference) {", "@@ -1103,7 +1110,7 @@ struct NNAPISettingsBuilder {", "   void add_no_of_nnapi_instances_to_cache(int32_t no_of_nnapi_instances_to_cache) {", "     fbb_.AddElement<int32_t>(NNAPISettings::VT_NO_OF_NNAPI_INSTANCES_TO_CACHE, no_of_nnapi_instances_to_cache, 0);", "   }", "-  void add_fallback_settings(flatbuffers::Offset<tflite::FallbackSettings> fallback_settings) {", "+  void add_fallback_settings(::flatbuffers::Offset<tflite::FallbackSettings> fallback_settings) {", "     fbb_.AddOffset(NNAPISettings::VT_FALLBACK_SETTINGS, fallback_settings);", "   }", "   void add_allow_nnapi_cpu_on_android_10_plus(bool allow_nnapi_cpu_on_android_10_plus) {", "@@ -1124,25 +1131,25 @@ struct NNAPISettingsBuilder {", "   void add_support_library_handle(int64_t support_library_handle) {", "     fbb_.AddElement<int64_t>(NNAPISettings::VT_SUPPORT_LIBRARY_HANDLE, support_library_handle, 0);", "   }", "-  explicit NNAPISettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit NNAPISettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<NNAPISettings> Finish() {", "+  ::flatbuffers::Offset<NNAPISettings> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<NNAPISettings>(end);", "+    auto o = ::flatbuffers::Offset<NNAPISettings>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<NNAPISettings> CreateNNAPISettings(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::String> accelerator_name = 0,", "-    flatbuffers::Offset<flatbuffers::String> cache_directory = 0,", "-    flatbuffers::Offset<flatbuffers::String> model_token = 0,", "+inline ::flatbuffers::Offset<NNAPISettings> CreateNNAPISettings(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::String> accelerator_name = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> cache_directory = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> model_token = 0,", "     tflite::NNAPIExecutionPreference execution_preference = tflite::NNAPIExecutionPreference_UNDEFINED,", "     int32_t no_of_nnapi_instances_to_cache = 0,", "-    flatbuffers::Offset<tflite::FallbackSettings> fallback_settings = 0,", "+    ::flatbuffers::Offset<tflite::FallbackSettings> fallback_settings = 0,", "     bool allow_nnapi_cpu_on_android_10_plus = false,", "     tflite::NNAPIExecutionPriority execution_priority = tflite::NNAPIExecutionPriority_NNAPI_PRIORITY_UNDEFINED,", "     bool allow_dynamic_dimensions = false,", "@@ -1165,14 +1172,14 @@ inline flatbuffers::Offset<NNAPISettings> CreateNNAPISettings(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<NNAPISettings> CreateNNAPISettingsDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<NNAPISettings> CreateNNAPISettingsDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const char *accelerator_name = nullptr,", "     const char *cache_directory = nullptr,", "     const char *model_token = nullptr,", "     tflite::NNAPIExecutionPreference execution_preference = tflite::NNAPIExecutionPreference_UNDEFINED,", "     int32_t no_of_nnapi_instances_to_cache = 0,", "-    flatbuffers::Offset<tflite::FallbackSettings> fallback_settings = 0,", "+    ::flatbuffers::Offset<tflite::FallbackSettings> fallback_settings = 0,", "     bool allow_nnapi_cpu_on_android_10_plus = false,", "     tflite::NNAPIExecutionPriority execution_priority = tflite::NNAPIExecutionPriority_NNAPI_PRIORITY_UNDEFINED,", "     bool allow_dynamic_dimensions = false,", "@@ -1198,9 +1205,9 @@ inline flatbuffers::Offset<NNAPISettings> CreateNNAPISettingsDirect(", "       support_library_handle);", " }", " ", "-flatbuffers::Offset<NNAPISettings> CreateNNAPISettings(flatbuffers::FlatBufferBuilder &_fbb, const NNAPISettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<NNAPISettings> CreateNNAPISettings(::flatbuffers::FlatBufferBuilder &_fbb, const NNAPISettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct GPUSettingsT : public flatbuffers::NativeTable {", "+struct GPUSettingsT : public ::flatbuffers::NativeTable {", "   typedef GPUSettings TableType;", "   bool is_precision_loss_allowed = false;", "   bool enable_quantized_inference = true;", "@@ -1213,7 +1220,7 @@ struct GPUSettingsT : public flatbuffers::NativeTable {", "   std::string model_token{};", " };", " ", "-struct GPUSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct GPUSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef GPUSettingsT NativeTableType;", "   typedef GPUSettingsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -1248,13 +1255,13 @@ struct GPUSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   tflite::GPUInferenceUsage inference_preference() const {", "     return static_cast<tflite::GPUInferenceUsage>(GetField<int32_t>(VT_INFERENCE_PREFERENCE, 0));", "   }", "-  const flatbuffers::String *cache_directory() const {", "-    return GetPointer<const flatbuffers::String *>(VT_CACHE_DIRECTORY);", "+  const ::flatbuffers::String *cache_directory() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_CACHE_DIRECTORY);", "   }", "-  const flatbuffers::String *model_token() const {", "-    return GetPointer<const flatbuffers::String *>(VT_MODEL_TOKEN);", "+  const ::flatbuffers::String *model_token() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_MODEL_TOKEN);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<uint8_t>(verifier, VT_IS_PRECISION_LOSS_ALLOWED, 1) &&", "            VerifyField<uint8_t>(verifier, VT_ENABLE_QUANTIZED_INFERENCE, 1) &&", "@@ -1269,15 +1276,15 @@ struct GPUSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            verifier.VerifyString(model_token()) &&", "            verifier.EndTable();", "   }", "-  GPUSettingsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(GPUSettingsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<GPUSettings> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GPUSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  GPUSettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(GPUSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<GPUSettings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GPUSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct GPUSettingsBuilder {", "   typedef GPUSettings Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_is_precision_loss_allowed(bool is_precision_loss_allowed) {", "     fbb_.AddElement<uint8_t>(GPUSettings::VT_IS_PRECISION_LOSS_ALLOWED, static_cast<uint8_t>(is_precision_loss_allowed), 0);", "   }", "@@ -1299,25 +1306,25 @@ struct GPUSettingsBuilder {", "   void add_inference_preference(tflite::GPUInferenceUsage inference_preference) {", "     fbb_.AddElement<int32_t>(GPUSettings::VT_INFERENCE_PREFERENCE, static_cast<int32_t>(inference_preference), 0);", "   }", "-  void add_cache_directory(flatbuffers::Offset<flatbuffers::String> cache_directory) {", "+  void add_cache_directory(::flatbuffers::Offset<::flatbuffers::String> cache_directory) {", "     fbb_.AddOffset(GPUSettings::VT_CACHE_DIRECTORY, cache_directory);", "   }", "-  void add_model_token(flatbuffers::Offset<flatbuffers::String> model_token) {", "+  void add_model_token(::flatbuffers::Offset<::flatbuffers::String> model_token) {", "     fbb_.AddOffset(GPUSettings::VT_MODEL_TOKEN, model_token);", "   }", "-  explicit GPUSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit GPUSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<GPUSettings> Finish() {", "+  ::flatbuffers::Offset<GPUSettings> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<GPUSettings>(end);", "+    auto o = ::flatbuffers::Offset<GPUSettings>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<GPUSettings> CreateGPUSettings(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<GPUSettings> CreateGPUSettings(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     bool is_precision_loss_allowed = false,", "     bool enable_quantized_inference = true,", "     tflite::GPUBackend force_backend = tflite::GPUBackend_UNSET,", "@@ -1325,8 +1332,8 @@ inline flatbuffers::Offset<GPUSettings> CreateGPUSettings(", "     tflite::GPUInferencePriority inference_priority2 = tflite::GPUInferencePriority_GPU_PRIORITY_AUTO,", "     tflite::GPUInferencePriority inference_priority3 = tflite::GPUInferencePriority_GPU_PRIORITY_AUTO,", "     tflite::GPUInferenceUsage inference_preference = tflite::GPUInferenceUsage_GPU_INFERENCE_PREFERENCE_FAST_SINGLE_ANSWER,", "-    flatbuffers::Offset<flatbuffers::String> cache_directory = 0,", "-    flatbuffers::Offset<flatbuffers::String> model_token = 0) {", "+    ::flatbuffers::Offset<::flatbuffers::String> cache_directory = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> model_token = 0) {", "   GPUSettingsBuilder builder_(_fbb);", "   builder_.add_model_token(model_token);", "   builder_.add_cache_directory(cache_directory);", "@@ -1340,8 +1347,8 @@ inline flatbuffers::Offset<GPUSettings> CreateGPUSettings(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<GPUSettings> CreateGPUSettingsDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<GPUSettings> CreateGPUSettingsDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     bool is_precision_loss_allowed = false,", "     bool enable_quantized_inference = true,", "     tflite::GPUBackend force_backend = tflite::GPUBackend_UNSET,", "@@ -1366,9 +1373,9 @@ inline flatbuffers::Offset<GPUSettings> CreateGPUSettingsDirect(", "       model_token__);", " }", " ", "-flatbuffers::Offset<GPUSettings> CreateGPUSettings(flatbuffers::FlatBufferBuilder &_fbb, const GPUSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<GPUSettings> CreateGPUSettings(::flatbuffers::FlatBufferBuilder &_fbb, const GPUSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct HexagonSettingsT : public flatbuffers::NativeTable {", "+struct HexagonSettingsT : public ::flatbuffers::NativeTable {", "   typedef HexagonSettings TableType;", "   int32_t debug_level = 0;", "   int32_t powersave_level = 0;", "@@ -1376,7 +1383,7 @@ struct HexagonSettingsT : public flatbuffers::NativeTable {", "   bool print_graph_debug = false;", " };", " ", "-struct HexagonSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct HexagonSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef HexagonSettingsT NativeTableType;", "   typedef HexagonSettingsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -1397,7 +1404,7 @@ struct HexagonSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool print_graph_debug() const {", "     return GetField<uint8_t>(VT_PRINT_GRAPH_DEBUG, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_DEBUG_LEVEL, 4) &&", "            VerifyField<int32_t>(verifier, VT_POWERSAVE_LEVEL, 4) &&", "@@ -1405,15 +1412,15 @@ struct HexagonSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            VerifyField<uint8_t>(verifier, VT_PRINT_GRAPH_DEBUG, 1) &&", "            verifier.EndTable();", "   }", "-  HexagonSettingsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(HexagonSettingsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<HexagonSettings> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HexagonSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  HexagonSettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(HexagonSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<HexagonSettings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HexagonSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct HexagonSettingsBuilder {", "   typedef HexagonSettings Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_debug_level(int32_t debug_level) {", "     fbb_.AddElement<int32_t>(HexagonSettings::VT_DEBUG_LEVEL, debug_level, 0);", "   }", "@@ -1426,19 +1433,19 @@ struct HexagonSettingsBuilder {", "   void add_print_graph_debug(bool print_graph_debug) {", "     fbb_.AddElement<uint8_t>(HexagonSettings::VT_PRINT_GRAPH_DEBUG, static_cast<uint8_t>(print_graph_debug), 0);", "   }", "-  explicit HexagonSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit HexagonSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<HexagonSettings> Finish() {", "+  ::flatbuffers::Offset<HexagonSettings> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<HexagonSettings>(end);", "+    auto o = ::flatbuffers::Offset<HexagonSettings>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<HexagonSettings> CreateHexagonSettings(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<HexagonSettings> CreateHexagonSettings(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t debug_level = 0,", "     int32_t powersave_level = 0,", "     bool print_graph_profile = false,", "@@ -1451,15 +1458,15 @@ inline flatbuffers::Offset<HexagonSettings> CreateHexagonSettings(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<HexagonSettings> CreateHexagonSettings(flatbuffers::FlatBufferBuilder &_fbb, const HexagonSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<HexagonSettings> CreateHexagonSettings(::flatbuffers::FlatBufferBuilder &_fbb, const HexagonSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct XNNPackSettingsT : public flatbuffers::NativeTable {", "+struct XNNPackSettingsT : public ::flatbuffers::NativeTable {", "   typedef XNNPackSettings TableType;", "   int32_t num_threads = 0;", "   tflite::XNNPackFlags flags = tflite::XNNPackFlags_TFLITE_XNNPACK_DELEGATE_NO_FLAGS;", " };", " ", "-struct XNNPackSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct XNNPackSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef XNNPackSettingsT NativeTableType;", "   typedef XNNPackSettingsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -1472,40 +1479,40 @@ struct XNNPackSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   tflite::XNNPackFlags flags() const {", "     return static_cast<tflite::XNNPackFlags>(GetField<int32_t>(VT_FLAGS, 0));", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_NUM_THREADS, 4) &&", "            VerifyField<int32_t>(verifier, VT_FLAGS, 4) &&", "            verifier.EndTable();", "   }", "-  XNNPackSettingsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(XNNPackSettingsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<XNNPackSettings> Pack(flatbuffers::FlatBufferBuilder &_fbb, const XNNPackSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  XNNPackSettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(XNNPackSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<XNNPackSettings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const XNNPackSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct XNNPackSettingsBuilder {", "   typedef XNNPackSettings Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_num_threads(int32_t num_threads) {", "     fbb_.AddElement<int32_t>(XNNPackSettings::VT_NUM_THREADS, num_threads, 0);", "   }", "   void add_flags(tflite::XNNPackFlags flags) {", "     fbb_.AddElement<int32_t>(XNNPackSettings::VT_FLAGS, static_cast<int32_t>(flags), 0);", "   }", "-  explicit XNNPackSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit XNNPackSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<XNNPackSettings> Finish() {", "+  ::flatbuffers::Offset<XNNPackSettings> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<XNNPackSettings>(end);", "+    auto o = ::flatbuffers::Offset<XNNPackSettings>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<XNNPackSettings> CreateXNNPackSettings(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<XNNPackSettings> CreateXNNPackSettings(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t num_threads = 0,", "     tflite::XNNPackFlags flags = tflite::XNNPackFlags_TFLITE_XNNPACK_DELEGATE_NO_FLAGS) {", "   XNNPackSettingsBuilder builder_(_fbb);", "@@ -1514,9 +1521,9 @@ inline flatbuffers::Offset<XNNPackSettings> CreateXNNPackSettings(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<XNNPackSettings> CreateXNNPackSettings(flatbuffers::FlatBufferBuilder &_fbb, const XNNPackSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<XNNPackSettings> CreateXNNPackSettings(::flatbuffers::FlatBufferBuilder &_fbb, const XNNPackSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct CoreMLSettingsT : public flatbuffers::NativeTable {", "+struct CoreMLSettingsT : public ::flatbuffers::NativeTable {", "   typedef CoreMLSettings TableType;", "   tflite::CoreMLSettings_::EnabledDevices enabled_devices = tflite::CoreMLSettings_::EnabledDevices_DEVICES_ALL;", "   int32_t coreml_version = 0;", "@@ -1524,7 +1531,7 @@ struct CoreMLSettingsT : public flatbuffers::NativeTable {", "   int32_t min_nodes_per_partition = 2;", " };", " ", "-struct CoreMLSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct CoreMLSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef CoreMLSettingsT NativeTableType;", "   typedef CoreMLSettingsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -1545,7 +1552,7 @@ struct CoreMLSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t min_nodes_per_partition() const {", "     return GetField<int32_t>(VT_MIN_NODES_PER_PARTITION, 2);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_ENABLED_DEVICES, 4) &&", "            VerifyField<int32_t>(verifier, VT_COREML_VERSION, 4) &&", "@@ -1553,15 +1560,15 @@ struct CoreMLSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            VerifyField<int32_t>(verifier, VT_MIN_NODES_PER_PARTITION, 4) &&", "            verifier.EndTable();", "   }", "-  CoreMLSettingsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(CoreMLSettingsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<CoreMLSettings> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CoreMLSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  CoreMLSettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(CoreMLSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<CoreMLSettings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CoreMLSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct CoreMLSettingsBuilder {", "   typedef CoreMLSettings Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_enabled_devices(tflite::CoreMLSettings_::EnabledDevices enabled_devices) {", "     fbb_.AddElement<int32_t>(CoreMLSettings::VT_ENABLED_DEVICES, static_cast<int32_t>(enabled_devices), 0);", "   }", "@@ -1574,19 +1581,19 @@ struct CoreMLSettingsBuilder {", "   void add_min_nodes_per_partition(int32_t min_nodes_per_partition) {", "     fbb_.AddElement<int32_t>(CoreMLSettings::VT_MIN_NODES_PER_PARTITION, min_nodes_per_partition, 2);", "   }", "-  explicit CoreMLSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit CoreMLSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<CoreMLSettings> Finish() {", "+  ::flatbuffers::Offset<CoreMLSettings> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<CoreMLSettings>(end);", "+    auto o = ::flatbuffers::Offset<CoreMLSettings>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<CoreMLSettings> CreateCoreMLSettings(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<CoreMLSettings> CreateCoreMLSettings(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::CoreMLSettings_::EnabledDevices enabled_devices = tflite::CoreMLSettings_::EnabledDevices_DEVICES_ALL,", "     int32_t coreml_version = 0,", "     int32_t max_delegated_partitions = 0,", "@@ -1599,61 +1606,61 @@ inline flatbuffers::Offset<CoreMLSettings> CreateCoreMLSettings(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<CoreMLSettings> CreateCoreMLSettings(flatbuffers::FlatBufferBuilder &_fbb, const CoreMLSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<CoreMLSettings> CreateCoreMLSettings(::flatbuffers::FlatBufferBuilder &_fbb, const CoreMLSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct StableDelegateLoaderSettingsT : public flatbuffers::NativeTable {", "+struct StableDelegateLoaderSettingsT : public ::flatbuffers::NativeTable {", "   typedef StableDelegateLoaderSettings TableType;", "   std::string delegate_path{};", " };", " ", "-struct StableDelegateLoaderSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct StableDelegateLoaderSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef StableDelegateLoaderSettingsT NativeTableType;", "   typedef StableDelegateLoaderSettingsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_DELEGATE_PATH = 4", "   };", "-  const flatbuffers::String *delegate_path() const {", "-    return GetPointer<const flatbuffers::String *>(VT_DELEGATE_PATH);", "+  const ::flatbuffers::String *delegate_path() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_DELEGATE_PATH);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_DELEGATE_PATH) &&", "            verifier.VerifyString(delegate_path()) &&", "            verifier.EndTable();", "   }", "-  StableDelegateLoaderSettingsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(StableDelegateLoaderSettingsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<StableDelegateLoaderSettings> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StableDelegateLoaderSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  StableDelegateLoaderSettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(StableDelegateLoaderSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<StableDelegateLoaderSettings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StableDelegateLoaderSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct StableDelegateLoaderSettingsBuilder {", "   typedef StableDelegateLoaderSettings Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_delegate_path(flatbuffers::Offset<flatbuffers::String> delegate_path) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_delegate_path(::flatbuffers::Offset<::flatbuffers::String> delegate_path) {", "     fbb_.AddOffset(StableDelegateLoaderSettings::VT_DELEGATE_PATH, delegate_path);", "   }", "-  explicit StableDelegateLoaderSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit StableDelegateLoaderSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<StableDelegateLoaderSettings> Finish() {", "+  ::flatbuffers::Offset<StableDelegateLoaderSettings> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<StableDelegateLoaderSettings>(end);", "+    auto o = ::flatbuffers::Offset<StableDelegateLoaderSettings>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<StableDelegateLoaderSettings> CreateStableDelegateLoaderSettings(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::String> delegate_path = 0) {", "+inline ::flatbuffers::Offset<StableDelegateLoaderSettings> CreateStableDelegateLoaderSettings(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::String> delegate_path = 0) {", "   StableDelegateLoaderSettingsBuilder builder_(_fbb);", "   builder_.add_delegate_path(delegate_path);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<StableDelegateLoaderSettings> CreateStableDelegateLoaderSettingsDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<StableDelegateLoaderSettings> CreateStableDelegateLoaderSettingsDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const char *delegate_path = nullptr) {", "   auto delegate_path__ = delegate_path ? _fbb.CreateString(delegate_path) : 0;", "   return tflite::CreateStableDelegateLoaderSettings(", "@@ -1661,28 +1668,28 @@ inline flatbuffers::Offset<StableDelegateLoaderSettings> CreateStableDelegateLoa", "       delegate_path__);", " }", " ", "-flatbuffers::Offset<StableDelegateLoaderSettings> CreateStableDelegateLoaderSettings(flatbuffers::FlatBufferBuilder &_fbb, const StableDelegateLoaderSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<StableDelegateLoaderSettings> CreateStableDelegateLoaderSettings(::flatbuffers::FlatBufferBuilder &_fbb, const StableDelegateLoaderSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct CompilationCachingSettingsT : public flatbuffers::NativeTable {", "+struct CompilationCachingSettingsT : public ::flatbuffers::NativeTable {", "   typedef CompilationCachingSettings TableType;", "   std::string cache_dir{};", "   std::string model_token{};", " };", " ", "-struct CompilationCachingSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct CompilationCachingSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef CompilationCachingSettingsT NativeTableType;", "   typedef CompilationCachingSettingsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_CACHE_DIR = 4,", "     VT_MODEL_TOKEN = 6", "   };", "-  const flatbuffers::String *cache_dir() const {", "-    return GetPointer<const flatbuffers::String *>(VT_CACHE_DIR);", "+  const ::flatbuffers::String *cache_dir() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_CACHE_DIR);", "   }", "-  const flatbuffers::String *model_token() const {", "-    return GetPointer<const flatbuffers::String *>(VT_MODEL_TOKEN);", "+  const ::flatbuffers::String *model_token() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_MODEL_TOKEN);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_CACHE_DIR) &&", "            verifier.VerifyString(cache_dir()) &&", "@@ -1690,44 +1697,44 @@ struct CompilationCachingSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers:", "            verifier.VerifyString(model_token()) &&", "            verifier.EndTable();", "   }", "-  CompilationCachingSettingsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(CompilationCachingSettingsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<CompilationCachingSettings> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CompilationCachingSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  CompilationCachingSettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(CompilationCachingSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<CompilationCachingSettings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CompilationCachingSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct CompilationCachingSettingsBuilder {", "   typedef CompilationCachingSettings Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_cache_dir(flatbuffers::Offset<flatbuffers::String> cache_dir) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_cache_dir(::flatbuffers::Offset<::flatbuffers::String> cache_dir) {", "     fbb_.AddOffset(CompilationCachingSettings::VT_CACHE_DIR, cache_dir);", "   }", "-  void add_model_token(flatbuffers::Offset<flatbuffers::String> model_token) {", "+  void add_model_token(::flatbuffers::Offset<::flatbuffers::String> model_token) {", "     fbb_.AddOffset(CompilationCachingSettings::VT_MODEL_TOKEN, model_token);", "   }", "-  explicit CompilationCachingSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit CompilationCachingSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<CompilationCachingSettings> Finish() {", "+  ::flatbuffers::Offset<CompilationCachingSettings> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<CompilationCachingSettings>(end);", "+    auto o = ::flatbuffers::Offset<CompilationCachingSettings>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<CompilationCachingSettings> CreateCompilationCachingSettings(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::String> cache_dir = 0,", "-    flatbuffers::Offset<flatbuffers::String> model_token = 0) {", "+inline ::flatbuffers::Offset<CompilationCachingSettings> CreateCompilationCachingSettings(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::String> cache_dir = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> model_token = 0) {", "   CompilationCachingSettingsBuilder builder_(_fbb);", "   builder_.add_model_token(model_token);", "   builder_.add_cache_dir(cache_dir);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<CompilationCachingSettings> CreateCompilationCachingSettingsDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<CompilationCachingSettings> CreateCompilationCachingSettingsDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const char *cache_dir = nullptr,", "     const char *model_token = nullptr) {", "   auto cache_dir__ = cache_dir ? _fbb.CreateString(cache_dir) : 0;", "@@ -1738,9 +1745,9 @@ inline flatbuffers::Offset<CompilationCachingSettings> CreateCompilationCachingS", "       model_token__);", " }", " ", "-flatbuffers::Offset<CompilationCachingSettings> CreateCompilationCachingSettings(flatbuffers::FlatBufferBuilder &_fbb, const CompilationCachingSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<CompilationCachingSettings> CreateCompilationCachingSettings(::flatbuffers::FlatBufferBuilder &_fbb, const CompilationCachingSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct EdgeTpuDeviceSpecT : public flatbuffers::NativeTable {", "+struct EdgeTpuDeviceSpecT : public ::flatbuffers::NativeTable {", "   typedef EdgeTpuDeviceSpec TableType;", "   tflite::EdgeTpuDeviceSpec_::PlatformType platform_type = tflite::EdgeTpuDeviceSpec_::PlatformType_MMIO;", "   int32_t num_chips = 0;", "@@ -1748,7 +1755,7 @@ struct EdgeTpuDeviceSpecT : public flatbuffers::NativeTable {", "   int32_t chip_family = 0;", " };", " ", "-struct EdgeTpuDeviceSpec FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct EdgeTpuDeviceSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef EdgeTpuDeviceSpecT NativeTableType;", "   typedef EdgeTpuDeviceSpecBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -1763,13 +1770,13 @@ struct EdgeTpuDeviceSpec FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t num_chips() const {", "     return GetField<int32_t>(VT_NUM_CHIPS, 0);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *device_paths() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DEVICE_PATHS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *device_paths() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DEVICE_PATHS);", "   }", "   int32_t chip_family() const {", "     return GetField<int32_t>(VT_CHIP_FAMILY, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_PLATFORM_TYPE, 4) &&", "            VerifyField<int32_t>(verifier, VT_NUM_CHIPS, 4) &&", "@@ -1779,43 +1786,43 @@ struct EdgeTpuDeviceSpec FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            VerifyField<int32_t>(verifier, VT_CHIP_FAMILY, 4) &&", "            verifier.EndTable();", "   }", "-  EdgeTpuDeviceSpecT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(EdgeTpuDeviceSpecT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<EdgeTpuDeviceSpec> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuDeviceSpecT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  EdgeTpuDeviceSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(EdgeTpuDeviceSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<EdgeTpuDeviceSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuDeviceSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct EdgeTpuDeviceSpecBuilder {", "   typedef EdgeTpuDeviceSpec Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_platform_type(tflite::EdgeTpuDeviceSpec_::PlatformType platform_type) {", "     fbb_.AddElement<int32_t>(EdgeTpuDeviceSpec::VT_PLATFORM_TYPE, static_cast<int32_t>(platform_type), 0);", "   }", "   void add_num_chips(int32_t num_chips) {", "     fbb_.AddElement<int32_t>(EdgeTpuDeviceSpec::VT_NUM_CHIPS, num_chips, 0);", "   }", "-  void add_device_paths(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> device_paths) {", "+  void add_device_paths(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> device_paths) {", "     fbb_.AddOffset(EdgeTpuDeviceSpec::VT_DEVICE_PATHS, device_paths);", "   }", "   void add_chip_family(int32_t chip_family) {", "     fbb_.AddElement<int32_t>(EdgeTpuDeviceSpec::VT_CHIP_FAMILY, chip_family, 0);", "   }", "-  explicit EdgeTpuDeviceSpecBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit EdgeTpuDeviceSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<EdgeTpuDeviceSpec> Finish() {", "+  ::flatbuffers::Offset<EdgeTpuDeviceSpec> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<EdgeTpuDeviceSpec>(end);", "+    auto o = ::flatbuffers::Offset<EdgeTpuDeviceSpec>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<EdgeTpuDeviceSpec> CreateEdgeTpuDeviceSpec(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<EdgeTpuDeviceSpec> CreateEdgeTpuDeviceSpec(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::EdgeTpuDeviceSpec_::PlatformType platform_type = tflite::EdgeTpuDeviceSpec_::PlatformType_MMIO,", "     int32_t num_chips = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> device_paths = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> device_paths = 0,", "     int32_t chip_family = 0) {", "   EdgeTpuDeviceSpecBuilder builder_(_fbb);", "   builder_.add_chip_family(chip_family);", "@@ -1825,13 +1832,13 @@ inline flatbuffers::Offset<EdgeTpuDeviceSpec> CreateEdgeTpuDeviceSpec(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<EdgeTpuDeviceSpec> CreateEdgeTpuDeviceSpecDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<EdgeTpuDeviceSpec> CreateEdgeTpuDeviceSpecDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::EdgeTpuDeviceSpec_::PlatformType platform_type = tflite::EdgeTpuDeviceSpec_::PlatformType_MMIO,", "     int32_t num_chips = 0,", "-    const std::vector<flatbuffers::Offset<flatbuffers::String>> *device_paths = nullptr,", "+    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *device_paths = nullptr,", "     int32_t chip_family = 0) {", "-  auto device_paths__ = device_paths ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*device_paths) : 0;", "+  auto device_paths__ = device_paths ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*device_paths) : 0;", "   return tflite::CreateEdgeTpuDeviceSpec(", "       _fbb,", "       platform_type,", "@@ -1840,15 +1847,15 @@ inline flatbuffers::Offset<EdgeTpuDeviceSpec> CreateEdgeTpuDeviceSpecDirect(", "       chip_family);", " }", " ", "-flatbuffers::Offset<EdgeTpuDeviceSpec> CreateEdgeTpuDeviceSpec(flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuDeviceSpecT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<EdgeTpuDeviceSpec> CreateEdgeTpuDeviceSpec(::flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuDeviceSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct EdgeTpuInactivePowerConfigT : public flatbuffers::NativeTable {", "+struct EdgeTpuInactivePowerConfigT : public ::flatbuffers::NativeTable {", "   typedef EdgeTpuInactivePowerConfig TableType;", "   tflite::EdgeTpuPowerState inactive_power_state = tflite::EdgeTpuPowerState_UNDEFINED_POWERSTATE;", "   int64_t inactive_timeout_us = 0;", " };", " ", "-struct EdgeTpuInactivePowerConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct EdgeTpuInactivePowerConfig FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef EdgeTpuInactivePowerConfigT NativeTableType;", "   typedef EdgeTpuInactivePowerConfigBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -1861,40 +1868,40 @@ struct EdgeTpuInactivePowerConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers:", "   int64_t inactive_timeout_us() const {", "     return GetField<int64_t>(VT_INACTIVE_TIMEOUT_US, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_INACTIVE_POWER_STATE, 4) &&", "            VerifyField<int64_t>(verifier, VT_INACTIVE_TIMEOUT_US, 8) &&", "            verifier.EndTable();", "   }", "-  EdgeTpuInactivePowerConfigT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(EdgeTpuInactivePowerConfigT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<EdgeTpuInactivePowerConfig> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuInactivePowerConfigT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  EdgeTpuInactivePowerConfigT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(EdgeTpuInactivePowerConfigT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<EdgeTpuInactivePowerConfig> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuInactivePowerConfigT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct EdgeTpuInactivePowerConfigBuilder {", "   typedef EdgeTpuInactivePowerConfig Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_inactive_power_state(tflite::EdgeTpuPowerState inactive_power_state) {", "     fbb_.AddElement<int32_t>(EdgeTpuInactivePowerConfig::VT_INACTIVE_POWER_STATE, static_cast<int32_t>(inactive_power_state), 0);", "   }", "   void add_inactive_timeout_us(int64_t inactive_timeout_us) {", "     fbb_.AddElement<int64_t>(EdgeTpuInactivePowerConfig::VT_INACTIVE_TIMEOUT_US, inactive_timeout_us, 0);", "   }", "-  explicit EdgeTpuInactivePowerConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit EdgeTpuInactivePowerConfigBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<EdgeTpuInactivePowerConfig> Finish() {", "+  ::flatbuffers::Offset<EdgeTpuInactivePowerConfig> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<EdgeTpuInactivePowerConfig>(end);", "+    auto o = ::flatbuffers::Offset<EdgeTpuInactivePowerConfig>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<EdgeTpuInactivePowerConfig> CreateEdgeTpuInactivePowerConfig(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<EdgeTpuInactivePowerConfig> CreateEdgeTpuInactivePowerConfig(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::EdgeTpuPowerState inactive_power_state = tflite::EdgeTpuPowerState_UNDEFINED_POWERSTATE,", "     int64_t inactive_timeout_us = 0) {", "   EdgeTpuInactivePowerConfigBuilder builder_(_fbb);", "@@ -1903,9 +1910,9 @@ inline flatbuffers::Offset<EdgeTpuInactivePowerConfig> CreateEdgeTpuInactivePowe", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<EdgeTpuInactivePowerConfig> CreateEdgeTpuInactivePowerConfig(flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuInactivePowerConfigT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<EdgeTpuInactivePowerConfig> CreateEdgeTpuInactivePowerConfig(::flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuInactivePowerConfigT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct EdgeTpuSettingsT : public flatbuffers::NativeTable {", "+struct EdgeTpuSettingsT : public ::flatbuffers::NativeTable {", "   typedef EdgeTpuSettings TableType;", "   tflite::EdgeTpuPowerState inference_power_state = tflite::EdgeTpuPowerState_UNDEFINED_POWERSTATE;", "   std::vector<std::unique_ptr<tflite::EdgeTpuInactivePowerConfigT>> inactive_power_configs{};", "@@ -1922,7 +1929,7 @@ struct EdgeTpuSettingsT : public flatbuffers::NativeTable {", "   EdgeTpuSettingsT &operator=(EdgeTpuSettingsT o) FLATBUFFERS_NOEXCEPT;", " };", " ", "-struct EdgeTpuSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct EdgeTpuSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef EdgeTpuSettingsT NativeTableType;", "   typedef EdgeTpuSettingsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -1939,8 +1946,8 @@ struct EdgeTpuSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   tflite::EdgeTpuPowerState inference_power_state() const {", "     return static_cast<tflite::EdgeTpuPowerState>(GetField<int32_t>(VT_INFERENCE_POWER_STATE, 0));", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::EdgeTpuInactivePowerConfig>> *inactive_power_configs() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::EdgeTpuInactivePowerConfig>> *>(VT_INACTIVE_POWER_CONFIGS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::EdgeTpuInactivePowerConfig>> *inactive_power_configs() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::EdgeTpuInactivePowerConfig>> *>(VT_INACTIVE_POWER_CONFIGS);", "   }", "   int32_t inference_priority() const {", "     return GetField<int32_t>(VT_INFERENCE_PRIORITY, -1);", "@@ -1948,8 +1955,8 @@ struct EdgeTpuSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   const tflite::EdgeTpuDeviceSpec *edgetpu_device_spec() const {", "     return GetPointer<const tflite::EdgeTpuDeviceSpec *>(VT_EDGETPU_DEVICE_SPEC);", "   }", "-  const flatbuffers::String *model_token() const {", "-    return GetPointer<const flatbuffers::String *>(VT_MODEL_TOKEN);", "+  const ::flatbuffers::String *model_token() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_MODEL_TOKEN);", "   }", "   tflite::EdgeTpuSettings_::FloatTruncationType float_truncation_type() const {", "     return static_cast<tflite::EdgeTpuSettings_::FloatTruncationType>(GetField<int32_t>(VT_FLOAT_TRUNCATION_TYPE, 0));", "@@ -1957,13 +1964,13 @@ struct EdgeTpuSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   tflite::EdgeTpuSettings_::QosClass qos_class() const {", "     return static_cast<tflite::EdgeTpuSettings_::QosClass>(GetField<int32_t>(VT_QOS_CLASS, 0));", "   }", "-  const flatbuffers::Vector<int32_t> *hardware_cluster_ids() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_HARDWARE_CLUSTER_IDS);", "+  const ::flatbuffers::Vector<int32_t> *hardware_cluster_ids() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_HARDWARE_CLUSTER_IDS);", "   }", "-  const flatbuffers::String *public_model_id() const {", "-    return GetPointer<const flatbuffers::String *>(VT_PUBLIC_MODEL_ID);", "+  const ::flatbuffers::String *public_model_id() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_PUBLIC_MODEL_ID);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_INFERENCE_POWER_STATE, 4) &&", "            VerifyOffset(verifier, VT_INACTIVE_POWER_CONFIGS) &&", "@@ -1982,28 +1989,28 @@ struct EdgeTpuSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            verifier.VerifyString(public_model_id()) &&", "            verifier.EndTable();", "   }", "-  EdgeTpuSettingsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(EdgeTpuSettingsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<EdgeTpuSettings> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  EdgeTpuSettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(EdgeTpuSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<EdgeTpuSettings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct EdgeTpuSettingsBuilder {", "   typedef EdgeTpuSettings Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_inference_power_state(tflite::EdgeTpuPowerState inference_power_state) {", "     fbb_.AddElement<int32_t>(EdgeTpuSettings::VT_INFERENCE_POWER_STATE, static_cast<int32_t>(inference_power_state), 0);", "   }", "-  void add_inactive_power_configs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::EdgeTpuInactivePowerConfig>>> inactive_power_configs) {", "+  void add_inactive_power_configs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::EdgeTpuInactivePowerConfig>>> inactive_power_configs) {", "     fbb_.AddOffset(EdgeTpuSettings::VT_INACTIVE_POWER_CONFIGS, inactive_power_configs);", "   }", "   void add_inference_priority(int32_t inference_priority) {", "     fbb_.AddElement<int32_t>(EdgeTpuSettings::VT_INFERENCE_PRIORITY, inference_priority, -1);", "   }", "-  void add_edgetpu_device_spec(flatbuffers::Offset<tflite::EdgeTpuDeviceSpec> edgetpu_device_spec) {", "+  void add_edgetpu_device_spec(::flatbuffers::Offset<tflite::EdgeTpuDeviceSpec> edgetpu_device_spec) {", "     fbb_.AddOffset(EdgeTpuSettings::VT_EDGETPU_DEVICE_SPEC, edgetpu_device_spec);", "   }", "-  void add_model_token(flatbuffers::Offset<flatbuffers::String> model_token) {", "+  void add_model_token(::flatbuffers::Offset<::flatbuffers::String> model_token) {", "     fbb_.AddOffset(EdgeTpuSettings::VT_MODEL_TOKEN, model_token);", "   }", "   void add_float_truncation_type(tflite::EdgeTpuSettings_::FloatTruncationType float_truncation_type) {", "@@ -2012,34 +2019,34 @@ struct EdgeTpuSettingsBuilder {", "   void add_qos_class(tflite::EdgeTpuSettings_::QosClass qos_class) {", "     fbb_.AddElement<int32_t>(EdgeTpuSettings::VT_QOS_CLASS, static_cast<int32_t>(qos_class), 0);", "   }", "-  void add_hardware_cluster_ids(flatbuffers::Offset<flatbuffers::Vector<int32_t>> hardware_cluster_ids) {", "+  void add_hardware_cluster_ids(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> hardware_cluster_ids) {", "     fbb_.AddOffset(EdgeTpuSettings::VT_HARDWARE_CLUSTER_IDS, hardware_cluster_ids);", "   }", "-  void add_public_model_id(flatbuffers::Offset<flatbuffers::String> public_model_id) {", "+  void add_public_model_id(::flatbuffers::Offset<::flatbuffers::String> public_model_id) {", "     fbb_.AddOffset(EdgeTpuSettings::VT_PUBLIC_MODEL_ID, public_model_id);", "   }", "-  explicit EdgeTpuSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit EdgeTpuSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<EdgeTpuSettings> Finish() {", "+  ::flatbuffers::Offset<EdgeTpuSettings> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<EdgeTpuSettings>(end);", "+    auto o = ::flatbuffers::Offset<EdgeTpuSettings>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<EdgeTpuSettings> CreateEdgeTpuSettings(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<EdgeTpuSettings> CreateEdgeTpuSettings(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::EdgeTpuPowerState inference_power_state = tflite::EdgeTpuPowerState_UNDEFINED_POWERSTATE,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::EdgeTpuInactivePowerConfig>>> inactive_power_configs = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::EdgeTpuInactivePowerConfig>>> inactive_power_configs = 0,", "     int32_t inference_priority = -1,", "-    flatbuffers::Offset<tflite::EdgeTpuDeviceSpec> edgetpu_device_spec = 0,", "-    flatbuffers::Offset<flatbuffers::String> model_token = 0,", "+    ::flatbuffers::Offset<tflite::EdgeTpuDeviceSpec> edgetpu_device_spec = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> model_token = 0,", "     tflite::EdgeTpuSettings_::FloatTruncationType float_truncation_type = tflite::EdgeTpuSettings_::FloatTruncationType_UNSPECIFIED,", "     tflite::EdgeTpuSettings_::QosClass qos_class = tflite::EdgeTpuSettings_::QosClass_QOS_UNDEFINED,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> hardware_cluster_ids = 0,", "-    flatbuffers::Offset<flatbuffers::String> public_model_id = 0) {", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> hardware_cluster_ids = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> public_model_id = 0) {", "   EdgeTpuSettingsBuilder builder_(_fbb);", "   builder_.add_public_model_id(public_model_id);", "   builder_.add_hardware_cluster_ids(hardware_cluster_ids);", "@@ -2053,18 +2060,18 @@ inline flatbuffers::Offset<EdgeTpuSettings> CreateEdgeTpuSettings(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<EdgeTpuSettings> CreateEdgeTpuSettingsDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<EdgeTpuSettings> CreateEdgeTpuSettingsDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::EdgeTpuPowerState inference_power_state = tflite::EdgeTpuPowerState_UNDEFINED_POWERSTATE,", "-    const std::vector<flatbuffers::Offset<tflite::EdgeTpuInactivePowerConfig>> *inactive_power_configs = nullptr,", "+    const std::vector<::flatbuffers::Offset<tflite::EdgeTpuInactivePowerConfig>> *inactive_power_configs = nullptr,", "     int32_t inference_priority = -1,", "-    flatbuffers::Offset<tflite::EdgeTpuDeviceSpec> edgetpu_device_spec = 0,", "+    ::flatbuffers::Offset<tflite::EdgeTpuDeviceSpec> edgetpu_device_spec = 0,", "     const char *model_token = nullptr,", "     tflite::EdgeTpuSettings_::FloatTruncationType float_truncation_type = tflite::EdgeTpuSettings_::FloatTruncationType_UNSPECIFIED,", "     tflite::EdgeTpuSettings_::QosClass qos_class = tflite::EdgeTpuSettings_::QosClass_QOS_UNDEFINED,", "     const std::vector<int32_t> *hardware_cluster_ids = nullptr,", "     const char *public_model_id = nullptr) {", "-  auto inactive_power_configs__ = inactive_power_configs ? _fbb.CreateVector<flatbuffers::Offset<tflite::EdgeTpuInactivePowerConfig>>(*inactive_power_configs) : 0;", "+  auto inactive_power_configs__ = inactive_power_configs ? _fbb.CreateVector<::flatbuffers::Offset<tflite::EdgeTpuInactivePowerConfig>>(*inactive_power_configs) : 0;", "   auto model_token__ = model_token ? _fbb.CreateString(model_token) : 0;", "   auto hardware_cluster_ids__ = hardware_cluster_ids ? _fbb.CreateVector<int32_t>(*hardware_cluster_ids) : 0;", "   auto public_model_id__ = public_model_id ? _fbb.CreateString(public_model_id) : 0;", "@@ -2081,9 +2088,9 @@ inline flatbuffers::Offset<EdgeTpuSettings> CreateEdgeTpuSettingsDirect(", "       public_model_id__);", " }", " ", "-flatbuffers::Offset<EdgeTpuSettings> CreateEdgeTpuSettings(flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<EdgeTpuSettings> CreateEdgeTpuSettings(::flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct GoogleEdgeTpuSettingsT : public flatbuffers::NativeTable {", "+struct GoogleEdgeTpuSettingsT : public ::flatbuffers::NativeTable {", "   typedef GoogleEdgeTpuSettings TableType;", "   int32_t log_verbosity = -1;", "   bool enable_tracing = false;", "@@ -2092,7 +2099,7 @@ struct GoogleEdgeTpuSettingsT : public flatbuffers::NativeTable {", "   std::string model_identifier{};", " };", " ", "-struct GoogleEdgeTpuSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct GoogleEdgeTpuSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef GoogleEdgeTpuSettingsT NativeTableType;", "   typedef GoogleEdgeTpuSettingsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -2111,13 +2118,13 @@ struct GoogleEdgeTpuSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tabl", "   tflite::GoogleEdgeTpuSettings_::Priority priority() const {", "     return static_cast<tflite::GoogleEdgeTpuSettings_::Priority>(GetField<int32_t>(VT_PRIORITY, 0));", "   }", "-  const flatbuffers::Vector<uint8_t> *extension_data() const {", "-    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_EXTENSION_DATA);", "+  const ::flatbuffers::Vector<uint8_t> *extension_data() const {", "+    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_EXTENSION_DATA);", "   }", "-  const flatbuffers::String *model_identifier() const {", "-    return GetPointer<const flatbuffers::String *>(VT_MODEL_IDENTIFIER);", "+  const ::flatbuffers::String *model_identifier() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_MODEL_IDENTIFIER);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_LOG_VERBOSITY, 4) &&", "            VerifyField<uint8_t>(verifier, VT_ENABLE_TRACING, 1) &&", "@@ -2128,15 +2135,15 @@ struct GoogleEdgeTpuSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tabl", "            verifier.VerifyString(model_identifier()) &&", "            verifier.EndTable();", "   }", "-  GoogleEdgeTpuSettingsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(GoogleEdgeTpuSettingsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<GoogleEdgeTpuSettings> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GoogleEdgeTpuSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  GoogleEdgeTpuSettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(GoogleEdgeTpuSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<GoogleEdgeTpuSettings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GoogleEdgeTpuSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct GoogleEdgeTpuSettingsBuilder {", "   typedef GoogleEdgeTpuSettings Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_log_verbosity(int32_t log_verbosity) {", "     fbb_.AddElement<int32_t>(GoogleEdgeTpuSettings::VT_LOG_VERBOSITY, log_verbosity, -1);", "   }", "@@ -2146,30 +2153,30 @@ struct GoogleEdgeTpuSettingsBuilder {", "   void add_priority(tflite::GoogleEdgeTpuSettings_::Priority priority) {", "     fbb_.AddElement<int32_t>(GoogleEdgeTpuSettings::VT_PRIORITY, static_cast<int32_t>(priority), 0);", "   }", "-  void add_extension_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extension_data) {", "+  void add_extension_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> extension_data) {", "     fbb_.AddOffset(GoogleEdgeTpuSettings::VT_EXTENSION_DATA, extension_data);", "   }", "-  void add_model_identifier(flatbuffers::Offset<flatbuffers::String> model_identifier) {", "+  void add_model_identifier(::flatbuffers::Offset<::flatbuffers::String> model_identifier) {", "     fbb_.AddOffset(GoogleEdgeTpuSettings::VT_MODEL_IDENTIFIER, model_identifier);", "   }", "-  explicit GoogleEdgeTpuSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit GoogleEdgeTpuSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<GoogleEdgeTpuSettings> Finish() {", "+  ::flatbuffers::Offset<GoogleEdgeTpuSettings> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<GoogleEdgeTpuSettings>(end);", "+    auto o = ::flatbuffers::Offset<GoogleEdgeTpuSettings>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<GoogleEdgeTpuSettings> CreateGoogleEdgeTpuSettings(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<GoogleEdgeTpuSettings> CreateGoogleEdgeTpuSettings(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t log_verbosity = -1,", "     bool enable_tracing = false,", "     tflite::GoogleEdgeTpuSettings_::Priority priority = tflite::GoogleEdgeTpuSettings_::Priority_PRIORITY_UNDEFINED,", "-    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> extension_data = 0,", "-    flatbuffers::Offset<flatbuffers::String> model_identifier = 0) {", "+    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> extension_data = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> model_identifier = 0) {", "   GoogleEdgeTpuSettingsBuilder builder_(_fbb);", "   builder_.add_model_identifier(model_identifier);", "   builder_.add_extension_data(extension_data);", "@@ -2179,8 +2186,8 @@ inline flatbuffers::Offset<GoogleEdgeTpuSettings> CreateGoogleEdgeTpuSettings(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<GoogleEdgeTpuSettings> CreateGoogleEdgeTpuSettingsDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<GoogleEdgeTpuSettings> CreateGoogleEdgeTpuSettingsDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t log_verbosity = -1,", "     bool enable_tracing = false,", "     tflite::GoogleEdgeTpuSettings_::Priority priority = tflite::GoogleEdgeTpuSettings_::Priority_PRIORITY_UNDEFINED,", "@@ -2197,9 +2204,9 @@ inline flatbuffers::Offset<GoogleEdgeTpuSettings> CreateGoogleEdgeTpuSettingsDir", "       model_identifier__);", " }", " ", "-flatbuffers::Offset<GoogleEdgeTpuSettings> CreateGoogleEdgeTpuSettings(flatbuffers::FlatBufferBuilder &_fbb, const GoogleEdgeTpuSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<GoogleEdgeTpuSettings> CreateGoogleEdgeTpuSettings(::flatbuffers::FlatBufferBuilder &_fbb, const GoogleEdgeTpuSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct CoralSettingsT : public flatbuffers::NativeTable {", "+struct CoralSettingsT : public ::flatbuffers::NativeTable {", "   typedef CoralSettings TableType;", "   std::string device{};", "   tflite::CoralSettings_::Performance performance = tflite::CoralSettings_::Performance_UNDEFINED;", "@@ -2207,7 +2214,7 @@ struct CoralSettingsT : public flatbuffers::NativeTable {", "   int32_t usb_max_bulk_in_queue_length = 0;", " };", " ", "-struct CoralSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct CoralSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef CoralSettingsT NativeTableType;", "   typedef CoralSettingsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -2216,8 +2223,8 @@ struct CoralSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "     VT_USB_ALWAYS_DFU = 8,", "     VT_USB_MAX_BULK_IN_QUEUE_LENGTH = 10", "   };", "-  const flatbuffers::String *device() const {", "-    return GetPointer<const flatbuffers::String *>(VT_DEVICE);", "+  const ::flatbuffers::String *device() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_DEVICE);", "   }", "   tflite::CoralSettings_::Performance performance() const {", "     return static_cast<tflite::CoralSettings_::Performance>(GetField<int32_t>(VT_PERFORMANCE, 0));", "@@ -2228,7 +2235,7 @@ struct CoralSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t usb_max_bulk_in_queue_length() const {", "     return GetField<int32_t>(VT_USB_MAX_BULK_IN_QUEUE_LENGTH, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_DEVICE) &&", "            verifier.VerifyString(device()) &&", "@@ -2237,16 +2244,16 @@ struct CoralSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            VerifyField<int32_t>(verifier, VT_USB_MAX_BULK_IN_QUEUE_LENGTH, 4) &&", "            verifier.EndTable();", "   }", "-  CoralSettingsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(CoralSettingsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<CoralSettings> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CoralSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  CoralSettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(CoralSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<CoralSettings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CoralSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct CoralSettingsBuilder {", "   typedef CoralSettings Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_device(flatbuffers::Offset<flatbuffers::String> device) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_device(::flatbuffers::Offset<::flatbuffers::String> device) {", "     fbb_.AddOffset(CoralSettings::VT_DEVICE, device);", "   }", "   void add_performance(tflite::CoralSettings_::Performance performance) {", "@@ -2258,20 +2265,20 @@ struct CoralSettingsBuilder {", "   void add_usb_max_bulk_in_queue_length(int32_t usb_max_bulk_in_queue_length) {", "     fbb_.AddElement<int32_t>(CoralSettings::VT_USB_MAX_BULK_IN_QUEUE_LENGTH, usb_max_bulk_in_queue_length, 0);", "   }", "-  explicit CoralSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit CoralSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<CoralSettings> Finish() {", "+  ::flatbuffers::Offset<CoralSettings> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<CoralSettings>(end);", "+    auto o = ::flatbuffers::Offset<CoralSettings>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<CoralSettings> CreateCoralSettings(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::String> device = 0,", "+inline ::flatbuffers::Offset<CoralSettings> CreateCoralSettings(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::String> device = 0,", "     tflite::CoralSettings_::Performance performance = tflite::CoralSettings_::Performance_UNDEFINED,", "     bool usb_always_dfu = false,", "     int32_t usb_max_bulk_in_queue_length = 0) {", "@@ -2283,8 +2290,8 @@ inline flatbuffers::Offset<CoralSettings> CreateCoralSettings(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<CoralSettings> CreateCoralSettingsDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<CoralSettings> CreateCoralSettingsDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const char *device = nullptr,", "     tflite::CoralSettings_::Performance performance = tflite::CoralSettings_::Performance_UNDEFINED,", "     bool usb_always_dfu = false,", "@@ -2298,14 +2305,14 @@ inline flatbuffers::Offset<CoralSettings> CreateCoralSettingsDirect(", "       usb_max_bulk_in_queue_length);", " }", " ", "-flatbuffers::Offset<CoralSettings> CreateCoralSettings(flatbuffers::FlatBufferBuilder &_fbb, const CoralSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<CoralSettings> CreateCoralSettings(::flatbuffers::FlatBufferBuilder &_fbb, const CoralSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct CPUSettingsT : public flatbuffers::NativeTable {", "+struct CPUSettingsT : public ::flatbuffers::NativeTable {", "   typedef CPUSettings TableType;", "   int32_t num_threads = -1;", " };", " ", "-struct CPUSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct CPUSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef CPUSettingsT NativeTableType;", "   typedef CPUSettingsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -2314,45 +2321,45 @@ struct CPUSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t num_threads() const {", "     return GetField<int32_t>(VT_NUM_THREADS, -1);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_NUM_THREADS, 4) &&", "            verifier.EndTable();", "   }", "-  CPUSettingsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(CPUSettingsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<CPUSettings> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CPUSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  CPUSettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(CPUSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<CPUSettings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CPUSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct CPUSettingsBuilder {", "   typedef CPUSettings Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_num_threads(int32_t num_threads) {", "     fbb_.AddElement<int32_t>(CPUSettings::VT_NUM_THREADS, num_threads, -1);", "   }", "-  explicit CPUSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit CPUSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<CPUSettings> Finish() {", "+  ::flatbuffers::Offset<CPUSettings> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<CPUSettings>(end);", "+    auto o = ::flatbuffers::Offset<CPUSettings>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<CPUSettings> CreateCPUSettings(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<CPUSettings> CreateCPUSettings(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t num_threads = -1) {", "   CPUSettingsBuilder builder_(_fbb);", "   builder_.add_num_threads(num_threads);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<CPUSettings> CreateCPUSettings(flatbuffers::FlatBufferBuilder &_fbb, const CPUSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<CPUSettings> CreateCPUSettings(::flatbuffers::FlatBufferBuilder &_fbb, const CPUSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct TFLiteSettingsT : public flatbuffers::NativeTable {", "+struct TFLiteSettingsT : public ::flatbuffers::NativeTable {", "   typedef TFLiteSettings TableType;", "   tflite::Delegate delegate = tflite::Delegate_NONE;", "   std::unique_ptr<tflite::NNAPISettingsT> nnapi_settings{};", "@@ -2375,7 +2382,7 @@ struct TFLiteSettingsT : public flatbuffers::NativeTable {", "   TFLiteSettingsT &operator=(TFLiteSettingsT o) FLATBUFFERS_NOEXCEPT;", " };", " ", "-struct TFLiteSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct TFLiteSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef TFLiteSettingsT NativeTableType;", "   typedef TFLiteSettingsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -2440,7 +2447,7 @@ struct TFLiteSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   const tflite::CompilationCachingSettings *compilation_caching_settings() const {", "     return GetPointer<const tflite::CompilationCachingSettings *>(VT_COMPILATION_CACHING_SETTINGS);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_DELEGATE, 4) &&", "            VerifyOffset(verifier, VT_NNAPI_SETTINGS) &&", "@@ -2471,88 +2478,88 @@ struct TFLiteSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            verifier.VerifyTable(compilation_caching_settings()) &&", "            verifier.EndTable();", "   }", "-  TFLiteSettingsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(TFLiteSettingsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<TFLiteSettings> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TFLiteSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  TFLiteSettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(TFLiteSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<TFLiteSettings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TFLiteSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct TFLiteSettingsBuilder {", "   typedef TFLiteSettings Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_delegate(tflite::Delegate delegate) {", "     fbb_.AddElement<int32_t>(TFLiteSettings::VT_DELEGATE, static_cast<int32_t>(delegate), 0);", "   }", "-  void add_nnapi_settings(flatbuffers::Offset<tflite::NNAPISettings> nnapi_settings) {", "+  void add_nnapi_settings(::flatbuffers::Offset<tflite::NNAPISettings> nnapi_settings) {", "     fbb_.AddOffset(TFLiteSettings::VT_NNAPI_SETTINGS, nnapi_settings);", "   }", "-  void add_gpu_settings(flatbuffers::Offset<tflite::GPUSettings> gpu_settings) {", "+  void add_gpu_settings(::flatbuffers::Offset<tflite::GPUSettings> gpu_settings) {", "     fbb_.AddOffset(TFLiteSettings::VT_GPU_SETTINGS, gpu_settings);", "   }", "-  void add_hexagon_settings(flatbuffers::Offset<tflite::HexagonSettings> hexagon_settings) {", "+  void add_hexagon_settings(::flatbuffers::Offset<tflite::HexagonSettings> hexagon_settings) {", "     fbb_.AddOffset(TFLiteSettings::VT_HEXAGON_SETTINGS, hexagon_settings);", "   }", "-  void add_xnnpack_settings(flatbuffers::Offset<tflite::XNNPackSettings> xnnpack_settings) {", "+  void add_xnnpack_settings(::flatbuffers::Offset<tflite::XNNPackSettings> xnnpack_settings) {", "     fbb_.AddOffset(TFLiteSettings::VT_XNNPACK_SETTINGS, xnnpack_settings);", "   }", "-  void add_coreml_settings(flatbuffers::Offset<tflite::CoreMLSettings> coreml_settings) {", "+  void add_coreml_settings(::flatbuffers::Offset<tflite::CoreMLSettings> coreml_settings) {", "     fbb_.AddOffset(TFLiteSettings::VT_COREML_SETTINGS, coreml_settings);", "   }", "-  void add_cpu_settings(flatbuffers::Offset<tflite::CPUSettings> cpu_settings) {", "+  void add_cpu_settings(::flatbuffers::Offset<tflite::CPUSettings> cpu_settings) {", "     fbb_.AddOffset(TFLiteSettings::VT_CPU_SETTINGS, cpu_settings);", "   }", "   void add_max_delegated_partitions(int32_t max_delegated_partitions) {", "     fbb_.AddElement<int32_t>(TFLiteSettings::VT_MAX_DELEGATED_PARTITIONS, max_delegated_partitions, 0);", "   }", "-  void add_edgetpu_settings(flatbuffers::Offset<tflite::EdgeTpuSettings> edgetpu_settings) {", "+  void add_edgetpu_settings(::flatbuffers::Offset<tflite::EdgeTpuSettings> edgetpu_settings) {", "     fbb_.AddOffset(TFLiteSettings::VT_EDGETPU_SETTINGS, edgetpu_settings);", "   }", "-  void add_coral_settings(flatbuffers::Offset<tflite::CoralSettings> coral_settings) {", "+  void add_coral_settings(::flatbuffers::Offset<tflite::CoralSettings> coral_settings) {", "     fbb_.AddOffset(TFLiteSettings::VT_CORAL_SETTINGS, coral_settings);", "   }", "-  void add_fallback_settings(flatbuffers::Offset<tflite::FallbackSettings> fallback_settings) {", "+  void add_fallback_settings(::flatbuffers::Offset<tflite::FallbackSettings> fallback_settings) {", "     fbb_.AddOffset(TFLiteSettings::VT_FALLBACK_SETTINGS, fallback_settings);", "   }", "   void add_disable_default_delegates(bool disable_default_delegates) {", "     fbb_.AddElement<uint8_t>(TFLiteSettings::VT_DISABLE_DEFAULT_DELEGATES, static_cast<uint8_t>(disable_default_delegates), 0);", "   }", "-  void add_stable_delegate_loader_settings(flatbuffers::Offset<tflite::StableDelegateLoaderSettings> stable_delegate_loader_settings) {", "+  void add_stable_delegate_loader_settings(::flatbuffers::Offset<tflite::StableDelegateLoaderSettings> stable_delegate_loader_settings) {", "     fbb_.AddOffset(TFLiteSettings::VT_STABLE_DELEGATE_LOADER_SETTINGS, stable_delegate_loader_settings);", "   }", "-  void add_google_edgetpu_settings(flatbuffers::Offset<tflite::GoogleEdgeTpuSettings> google_edgetpu_settings) {", "+  void add_google_edgetpu_settings(::flatbuffers::Offset<tflite::GoogleEdgeTpuSettings> google_edgetpu_settings) {", "     fbb_.AddOffset(TFLiteSettings::VT_GOOGLE_EDGETPU_SETTINGS, google_edgetpu_settings);", "   }", "-  void add_compilation_caching_settings(flatbuffers::Offset<tflite::CompilationCachingSettings> compilation_caching_settings) {", "+  void add_compilation_caching_settings(::flatbuffers::Offset<tflite::CompilationCachingSettings> compilation_caching_settings) {", "     fbb_.AddOffset(TFLiteSettings::VT_COMPILATION_CACHING_SETTINGS, compilation_caching_settings);", "   }", "-  explicit TFLiteSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit TFLiteSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<TFLiteSettings> Finish() {", "+  ::flatbuffers::Offset<TFLiteSettings> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<TFLiteSettings>(end);", "+    auto o = ::flatbuffers::Offset<TFLiteSettings>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<TFLiteSettings> CreateTFLiteSettings(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<TFLiteSettings> CreateTFLiteSettings(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::Delegate delegate = tflite::Delegate_NONE,", "-    flatbuffers::Offset<tflite::NNAPISettings> nnapi_settings = 0,", "-    flatbuffers::Offset<tflite::GPUSettings> gpu_settings = 0,", "-    flatbuffers::Offset<tflite::HexagonSettings> hexagon_settings = 0,", "-    flatbuffers::Offset<tflite::XNNPackSettings> xnnpack_settings = 0,", "-    flatbuffers::Offset<tflite::CoreMLSettings> coreml_settings = 0,", "-    flatbuffers::Offset<tflite::CPUSettings> cpu_settings = 0,", "+    ::flatbuffers::Offset<tflite::NNAPISettings> nnapi_settings = 0,", "+    ::flatbuffers::Offset<tflite::GPUSettings> gpu_settings = 0,", "+    ::flatbuffers::Offset<tflite::HexagonSettings> hexagon_settings = 0,", "+    ::flatbuffers::Offset<tflite::XNNPackSettings> xnnpack_settings = 0,", "+    ::flatbuffers::Offset<tflite::CoreMLSettings> coreml_settings = 0,", "+    ::flatbuffers::Offset<tflite::CPUSettings> cpu_settings = 0,", "     int32_t max_delegated_partitions = 0,", "-    flatbuffers::Offset<tflite::EdgeTpuSettings> edgetpu_settings = 0,", "-    flatbuffers::Offset<tflite::CoralSettings> coral_settings = 0,", "-    flatbuffers::Offset<tflite::FallbackSettings> fallback_settings = 0,", "+    ::flatbuffers::Offset<tflite::EdgeTpuSettings> edgetpu_settings = 0,", "+    ::flatbuffers::Offset<tflite::CoralSettings> coral_settings = 0,", "+    ::flatbuffers::Offset<tflite::FallbackSettings> fallback_settings = 0,", "     bool disable_default_delegates = false,", "-    flatbuffers::Offset<tflite::StableDelegateLoaderSettings> stable_delegate_loader_settings = 0,", "-    flatbuffers::Offset<tflite::GoogleEdgeTpuSettings> google_edgetpu_settings = 0,", "-    flatbuffers::Offset<tflite::CompilationCachingSettings> compilation_caching_settings = 0) {", "+    ::flatbuffers::Offset<tflite::StableDelegateLoaderSettings> stable_delegate_loader_settings = 0,", "+    ::flatbuffers::Offset<tflite::GoogleEdgeTpuSettings> google_edgetpu_settings = 0,", "+    ::flatbuffers::Offset<tflite::CompilationCachingSettings> compilation_caching_settings = 0) {", "   TFLiteSettingsBuilder builder_(_fbb);", "   builder_.add_compilation_caching_settings(compilation_caching_settings);", "   builder_.add_google_edgetpu_settings(google_edgetpu_settings);", "@@ -2572,15 +2579,15 @@ inline flatbuffers::Offset<TFLiteSettings> CreateTFLiteSettings(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<TFLiteSettings> CreateTFLiteSettings(flatbuffers::FlatBufferBuilder &_fbb, const TFLiteSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<TFLiteSettings> CreateTFLiteSettings(::flatbuffers::FlatBufferBuilder &_fbb, const TFLiteSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct FallbackSettingsT : public flatbuffers::NativeTable {", "+struct FallbackSettingsT : public ::flatbuffers::NativeTable {", "   typedef FallbackSettings TableType;", "   bool allow_automatic_fallback_on_compilation_error = false;", "   bool allow_automatic_fallback_on_execution_error = false;", " };", " ", "-struct FallbackSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct FallbackSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef FallbackSettingsT NativeTableType;", "   typedef FallbackSettingsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -2593,40 +2600,40 @@ struct FallbackSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool allow_automatic_fallback_on_execution_error() const {", "     return GetField<uint8_t>(VT_ALLOW_AUTOMATIC_FALLBACK_ON_EXECUTION_ERROR, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<uint8_t>(verifier, VT_ALLOW_AUTOMATIC_FALLBACK_ON_COMPILATION_ERROR, 1) &&", "            VerifyField<uint8_t>(verifier, VT_ALLOW_AUTOMATIC_FALLBACK_ON_EXECUTION_ERROR, 1) &&", "            verifier.EndTable();", "   }", "-  FallbackSettingsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(FallbackSettingsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<FallbackSettings> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FallbackSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  FallbackSettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(FallbackSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<FallbackSettings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FallbackSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct FallbackSettingsBuilder {", "   typedef FallbackSettings Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_allow_automatic_fallback_on_compilation_error(bool allow_automatic_fallback_on_compilation_error) {", "     fbb_.AddElement<uint8_t>(FallbackSettings::VT_ALLOW_AUTOMATIC_FALLBACK_ON_COMPILATION_ERROR, static_cast<uint8_t>(allow_automatic_fallback_on_compilation_error), 0);", "   }", "   void add_allow_automatic_fallback_on_execution_error(bool allow_automatic_fallback_on_execution_error) {", "     fbb_.AddElement<uint8_t>(FallbackSettings::VT_ALLOW_AUTOMATIC_FALLBACK_ON_EXECUTION_ERROR, static_cast<uint8_t>(allow_automatic_fallback_on_execution_error), 0);", "   }", "-  explicit FallbackSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit FallbackSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<FallbackSettings> Finish() {", "+  ::flatbuffers::Offset<FallbackSettings> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<FallbackSettings>(end);", "+    auto o = ::flatbuffers::Offset<FallbackSettings>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<FallbackSettings> CreateFallbackSettings(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<FallbackSettings> CreateFallbackSettings(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     bool allow_automatic_fallback_on_compilation_error = false,", "     bool allow_automatic_fallback_on_execution_error = false) {", "   FallbackSettingsBuilder builder_(_fbb);", "@@ -2635,28 +2642,28 @@ inline flatbuffers::Offset<FallbackSettings> CreateFallbackSettings(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<FallbackSettings> CreateFallbackSettings(flatbuffers::FlatBufferBuilder &_fbb, const FallbackSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<FallbackSettings> CreateFallbackSettings(::flatbuffers::FlatBufferBuilder &_fbb, const FallbackSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct BenchmarkMetricT : public flatbuffers::NativeTable {", "+struct BenchmarkMetricT : public ::flatbuffers::NativeTable {", "   typedef BenchmarkMetric TableType;", "   std::string name{};", "   std::vector<float> values{};", " };", " ", "-struct BenchmarkMetric FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct BenchmarkMetric FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef BenchmarkMetricT NativeTableType;", "   typedef BenchmarkMetricBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_NAME = 4,", "     VT_VALUES = 6", "   };", "-  const flatbuffers::String *name() const {", "-    return GetPointer<const flatbuffers::String *>(VT_NAME);", "+  const ::flatbuffers::String *name() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_NAME);", "   }", "-  const flatbuffers::Vector<float> *values() const {", "-    return GetPointer<const flatbuffers::Vector<float> *>(VT_VALUES);", "+  const ::flatbuffers::Vector<float> *values() const {", "+    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_VALUES);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_NAME) &&", "            verifier.VerifyString(name()) &&", "@@ -2664,44 +2671,44 @@ struct BenchmarkMetric FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            verifier.VerifyVector(values()) &&", "            verifier.EndTable();", "   }", "-  BenchmarkMetricT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(BenchmarkMetricT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<BenchmarkMetric> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkMetricT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  BenchmarkMetricT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(BenchmarkMetricT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<BenchmarkMetric> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkMetricT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct BenchmarkMetricBuilder {", "   typedef BenchmarkMetric Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_name(flatbuffers::Offset<flatbuffers::String> name) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {", "     fbb_.AddOffset(BenchmarkMetric::VT_NAME, name);", "   }", "-  void add_values(flatbuffers::Offset<flatbuffers::Vector<float>> values) {", "+  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<float>> values) {", "     fbb_.AddOffset(BenchmarkMetric::VT_VALUES, values);", "   }", "-  explicit BenchmarkMetricBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit BenchmarkMetricBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<BenchmarkMetric> Finish() {", "+  ::flatbuffers::Offset<BenchmarkMetric> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<BenchmarkMetric>(end);", "+    auto o = ::flatbuffers::Offset<BenchmarkMetric>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<BenchmarkMetric> CreateBenchmarkMetric(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::String> name = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<float>> values = 0) {", "+inline ::flatbuffers::Offset<BenchmarkMetric> CreateBenchmarkMetric(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::String> name = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<float>> values = 0) {", "   BenchmarkMetricBuilder builder_(_fbb);", "   builder_.add_values(values);", "   builder_.add_name(name);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<BenchmarkMetric> CreateBenchmarkMetricDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<BenchmarkMetric> CreateBenchmarkMetricDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const char *name = nullptr,", "     const std::vector<float> *values = nullptr) {", "   auto name__ = name ? _fbb.CreateString(name) : 0;", "@@ -2712,9 +2719,9 @@ inline flatbuffers::Offset<BenchmarkMetric> CreateBenchmarkMetricDirect(", "       values__);", " }", " ", "-flatbuffers::Offset<BenchmarkMetric> CreateBenchmarkMetric(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkMetricT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<BenchmarkMetric> CreateBenchmarkMetric(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkMetricT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct BenchmarkResultT : public flatbuffers::NativeTable {", "+struct BenchmarkResultT : public ::flatbuffers::NativeTable {", "   typedef BenchmarkResult TableType;", "   std::vector<int64_t> initialization_time_us{};", "   std::vector<int64_t> inference_time_us{};", "@@ -2728,7 +2735,7 @@ struct BenchmarkResultT : public flatbuffers::NativeTable {", "   BenchmarkResultT &operator=(BenchmarkResultT o) FLATBUFFERS_NOEXCEPT;", " };", " ", "-struct BenchmarkResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct BenchmarkResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef BenchmarkResultT NativeTableType;", "   typedef BenchmarkResultBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -2739,11 +2746,11 @@ struct BenchmarkResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "     VT_METRICS = 12,", "     VT_ACTUAL_OUTPUT = 14", "   };", "-  const flatbuffers::Vector<int64_t> *initialization_time_us() const {", "-    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_INITIALIZATION_TIME_US);", "+  const ::flatbuffers::Vector<int64_t> *initialization_time_us() const {", "+    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_INITIALIZATION_TIME_US);", "   }", "-  const flatbuffers::Vector<int64_t> *inference_time_us() const {", "-    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_INFERENCE_TIME_US);", "+  const ::flatbuffers::Vector<int64_t> *inference_time_us() const {", "+    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_INFERENCE_TIME_US);", "   }", "   int32_t max_memory_kb() const {", "     return GetField<int32_t>(VT_MAX_MEMORY_KB, 0);", "@@ -2751,13 +2758,13 @@ struct BenchmarkResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool ok() const {", "     return GetField<uint8_t>(VT_OK, 0) != 0;", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::BenchmarkMetric>> *metrics() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::BenchmarkMetric>> *>(VT_METRICS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::BenchmarkMetric>> *metrics() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::BenchmarkMetric>> *>(VT_METRICS);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::BenchmarkResult_::InferenceOutput>> *actual_output() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::BenchmarkResult_::InferenceOutput>> *>(VT_ACTUAL_OUTPUT);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::BenchmarkResult_::InferenceOutput>> *actual_output() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::BenchmarkResult_::InferenceOutput>> *>(VT_ACTUAL_OUTPUT);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_INITIALIZATION_TIME_US) &&", "            verifier.VerifyVector(initialization_time_us()) &&", "@@ -2773,19 +2780,19 @@ struct BenchmarkResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            verifier.VerifyVectorOfTables(actual_output()) &&", "            verifier.EndTable();", "   }", "-  BenchmarkResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(BenchmarkResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<BenchmarkResult> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkResultT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  BenchmarkResultT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(BenchmarkResultT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<BenchmarkResult> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkResultT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct BenchmarkResultBuilder {", "   typedef BenchmarkResult Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_initialization_time_us(flatbuffers::Offset<flatbuffers::Vector<int64_t>> initialization_time_us) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_initialization_time_us(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> initialization_time_us) {", "     fbb_.AddOffset(BenchmarkResult::VT_INITIALIZATION_TIME_US, initialization_time_us);", "   }", "-  void add_inference_time_us(flatbuffers::Offset<flatbuffers::Vector<int64_t>> inference_time_us) {", "+  void add_inference_time_us(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> inference_time_us) {", "     fbb_.AddOffset(BenchmarkResult::VT_INFERENCE_TIME_US, inference_time_us);", "   }", "   void add_max_memory_kb(int32_t max_memory_kb) {", "@@ -2794,31 +2801,31 @@ struct BenchmarkResultBuilder {", "   void add_ok(bool ok) {", "     fbb_.AddElement<uint8_t>(BenchmarkResult::VT_OK, static_cast<uint8_t>(ok), 0);", "   }", "-  void add_metrics(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::BenchmarkMetric>>> metrics) {", "+  void add_metrics(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::BenchmarkMetric>>> metrics) {", "     fbb_.AddOffset(BenchmarkResult::VT_METRICS, metrics);", "   }", "-  void add_actual_output(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::BenchmarkResult_::InferenceOutput>>> actual_output) {", "+  void add_actual_output(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::BenchmarkResult_::InferenceOutput>>> actual_output) {", "     fbb_.AddOffset(BenchmarkResult::VT_ACTUAL_OUTPUT, actual_output);", "   }", "-  explicit BenchmarkResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit BenchmarkResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<BenchmarkResult> Finish() {", "+  ::flatbuffers::Offset<BenchmarkResult> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<BenchmarkResult>(end);", "+    auto o = ::flatbuffers::Offset<BenchmarkResult>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<BenchmarkResult> CreateBenchmarkResult(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<int64_t>> initialization_time_us = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<int64_t>> inference_time_us = 0,", "+inline ::flatbuffers::Offset<BenchmarkResult> CreateBenchmarkResult(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> initialization_time_us = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> inference_time_us = 0,", "     int32_t max_memory_kb = 0,", "     bool ok = false,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::BenchmarkMetric>>> metrics = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::BenchmarkResult_::InferenceOutput>>> actual_output = 0) {", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::BenchmarkMetric>>> metrics = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::BenchmarkResult_::InferenceOutput>>> actual_output = 0) {", "   BenchmarkResultBuilder builder_(_fbb);", "   builder_.add_actual_output(actual_output);", "   builder_.add_metrics(metrics);", "@@ -2829,18 +2836,18 @@ inline flatbuffers::Offset<BenchmarkResult> CreateBenchmarkResult(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<BenchmarkResult> CreateBenchmarkResultDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<BenchmarkResult> CreateBenchmarkResultDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const std::vector<int64_t> *initialization_time_us = nullptr,", "     const std::vector<int64_t> *inference_time_us = nullptr,", "     int32_t max_memory_kb = 0,", "     bool ok = false,", "-    const std::vector<flatbuffers::Offset<tflite::BenchmarkMetric>> *metrics = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::BenchmarkResult_::InferenceOutput>> *actual_output = nullptr) {", "+    const std::vector<::flatbuffers::Offset<tflite::BenchmarkMetric>> *metrics = nullptr,", "+    const std::vector<::flatbuffers::Offset<tflite::BenchmarkResult_::InferenceOutput>> *actual_output = nullptr) {", "   auto initialization_time_us__ = initialization_time_us ? _fbb.CreateVector<int64_t>(*initialization_time_us) : 0;", "   auto inference_time_us__ = inference_time_us ? _fbb.CreateVector<int64_t>(*inference_time_us) : 0;", "-  auto metrics__ = metrics ? _fbb.CreateVector<flatbuffers::Offset<tflite::BenchmarkMetric>>(*metrics) : 0;", "-  auto actual_output__ = actual_output ? _fbb.CreateVector<flatbuffers::Offset<tflite::BenchmarkResult_::InferenceOutput>>(*actual_output) : 0;", "+  auto metrics__ = metrics ? _fbb.CreateVector<::flatbuffers::Offset<tflite::BenchmarkMetric>>(*metrics) : 0;", "+  auto actual_output__ = actual_output ? _fbb.CreateVector<::flatbuffers::Offset<tflite::BenchmarkResult_::InferenceOutput>>(*actual_output) : 0;", "   return tflite::CreateBenchmarkResult(", "       _fbb,", "       initialization_time_us__,", "@@ -2851,63 +2858,63 @@ inline flatbuffers::Offset<BenchmarkResult> CreateBenchmarkResultDirect(", "       actual_output__);", " }", " ", "-flatbuffers::Offset<BenchmarkResult> CreateBenchmarkResult(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<BenchmarkResult> CreateBenchmarkResult(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkResultT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", " namespace BenchmarkResult_ {", " ", "-struct InferenceOutputT : public flatbuffers::NativeTable {", "+struct InferenceOutputT : public ::flatbuffers::NativeTable {", "   typedef InferenceOutput TableType;", "   std::vector<uint8_t> value{};", " };", " ", "-struct InferenceOutput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct InferenceOutput FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef InferenceOutputT NativeTableType;", "   typedef InferenceOutputBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_VALUE = 4", "   };", "-  const flatbuffers::Vector<uint8_t> *value() const {", "-    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);", "+  const ::flatbuffers::Vector<uint8_t> *value() const {", "+    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VALUE);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_VALUE) &&", "            verifier.VerifyVector(value()) &&", "            verifier.EndTable();", "   }", "-  InferenceOutputT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(InferenceOutputT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<InferenceOutput> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InferenceOutputT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  InferenceOutputT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(InferenceOutputT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<InferenceOutput> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InferenceOutputT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct InferenceOutputBuilder {", "   typedef InferenceOutput Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> value) {", "     fbb_.AddOffset(InferenceOutput::VT_VALUE, value);", "   }", "-  explicit InferenceOutputBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit InferenceOutputBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<InferenceOutput> Finish() {", "+  ::flatbuffers::Offset<InferenceOutput> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<InferenceOutput>(end);", "+    auto o = ::flatbuffers::Offset<InferenceOutput>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<InferenceOutput> CreateInferenceOutput(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {", "+inline ::flatbuffers::Offset<InferenceOutput> CreateInferenceOutput(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> value = 0) {", "   InferenceOutputBuilder builder_(_fbb);", "   builder_.add_value(value);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<InferenceOutput> CreateInferenceOutputDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<InferenceOutput> CreateInferenceOutputDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const std::vector<uint8_t> *value = nullptr) {", "   auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;", "   return tflite::BenchmarkResult_::CreateInferenceOutput(", "@@ -2915,18 +2922,18 @@ inline flatbuffers::Offset<InferenceOutput> CreateInferenceOutputDirect(", "       value__);", " }", " ", "-flatbuffers::Offset<InferenceOutput> CreateInferenceOutput(flatbuffers::FlatBufferBuilder &_fbb, const InferenceOutputT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<InferenceOutput> CreateInferenceOutput(::flatbuffers::FlatBufferBuilder &_fbb, const InferenceOutputT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", " }  // namespace BenchmarkResult_", " ", "-struct ErrorCodeT : public flatbuffers::NativeTable {", "+struct ErrorCodeT : public ::flatbuffers::NativeTable {", "   typedef ErrorCode TableType;", "   tflite::Delegate source = tflite::Delegate_NONE;", "   int32_t tflite_error = 0;", "   int64_t underlying_api_error = 0;", " };", " ", "-struct ErrorCode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ErrorCode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ErrorCodeT NativeTableType;", "   typedef ErrorCodeBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -2943,22 +2950,22 @@ struct ErrorCode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int64_t underlying_api_error() const {", "     return GetField<int64_t>(VT_UNDERLYING_API_ERROR, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_SOURCE, 4) &&", "            VerifyField<int32_t>(verifier, VT_TFLITE_ERROR, 4) &&", "            VerifyField<int64_t>(verifier, VT_UNDERLYING_API_ERROR, 8) &&", "            verifier.EndTable();", "   }", "-  ErrorCodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ErrorCodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ErrorCode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorCodeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ErrorCodeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ErrorCodeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ErrorCode> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorCodeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ErrorCodeBuilder {", "   typedef ErrorCode Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_source(tflite::Delegate source) {", "     fbb_.AddElement<int32_t>(ErrorCode::VT_SOURCE, static_cast<int32_t>(source), 0);", "   }", "@@ -2968,19 +2975,19 @@ struct ErrorCodeBuilder {", "   void add_underlying_api_error(int64_t underlying_api_error) {", "     fbb_.AddElement<int64_t>(ErrorCode::VT_UNDERLYING_API_ERROR, underlying_api_error, 0);", "   }", "-  explicit ErrorCodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit ErrorCodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ErrorCode> Finish() {", "+  ::flatbuffers::Offset<ErrorCode> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ErrorCode>(end);", "+    auto o = ::flatbuffers::Offset<ErrorCode>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ErrorCode> CreateErrorCode(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<ErrorCode> CreateErrorCode(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::Delegate source = tflite::Delegate_NONE,", "     int32_t tflite_error = 0,", "     int64_t underlying_api_error = 0) {", "@@ -2991,9 +2998,9 @@ inline flatbuffers::Offset<ErrorCode> CreateErrorCode(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<ErrorCode> CreateErrorCode(flatbuffers::FlatBufferBuilder &_fbb, const ErrorCodeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ErrorCode> CreateErrorCode(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorCodeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct BenchmarkErrorT : public flatbuffers::NativeTable {", "+struct BenchmarkErrorT : public ::flatbuffers::NativeTable {", "   typedef BenchmarkError TableType;", "   tflite::BenchmarkStage stage = tflite::BenchmarkStage_UNKNOWN;", "   int32_t exit_code = 0;", "@@ -3006,7 +3013,7 @@ struct BenchmarkErrorT : public flatbuffers::NativeTable {", "   BenchmarkErrorT &operator=(BenchmarkErrorT o) FLATBUFFERS_NOEXCEPT;", " };", " ", "-struct BenchmarkError FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct BenchmarkError FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef BenchmarkErrorT NativeTableType;", "   typedef BenchmarkErrorBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -3025,13 +3032,13 @@ struct BenchmarkError FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t signal() const {", "     return GetField<int32_t>(VT_SIGNAL, 0);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::ErrorCode>> *error_code() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::ErrorCode>> *>(VT_ERROR_CODE);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::ErrorCode>> *error_code() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::ErrorCode>> *>(VT_ERROR_CODE);", "   }", "   int32_t mini_benchmark_error_code() const {", "     return GetField<int32_t>(VT_MINI_BENCHMARK_ERROR_CODE, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_STAGE, 4) &&", "            VerifyField<int32_t>(verifier, VT_EXIT_CODE, 4) &&", "@@ -3042,15 +3049,15 @@ struct BenchmarkError FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            VerifyField<int32_t>(verifier, VT_MINI_BENCHMARK_ERROR_CODE, 4) &&", "            verifier.EndTable();", "   }", "-  BenchmarkErrorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(BenchmarkErrorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<BenchmarkError> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  BenchmarkErrorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(BenchmarkErrorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<BenchmarkError> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkErrorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct BenchmarkErrorBuilder {", "   typedef BenchmarkError Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_stage(tflite::BenchmarkStage stage) {", "     fbb_.AddElement<int32_t>(BenchmarkError::VT_STAGE, static_cast<int32_t>(stage), 0);", "   }", "@@ -3060,29 +3067,29 @@ struct BenchmarkErrorBuilder {", "   void add_signal(int32_t signal) {", "     fbb_.AddElement<int32_t>(BenchmarkError::VT_SIGNAL, signal, 0);", "   }", "-  void add_error_code(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::ErrorCode>>> error_code) {", "+  void add_error_code(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::ErrorCode>>> error_code) {", "     fbb_.AddOffset(BenchmarkError::VT_ERROR_CODE, error_code);", "   }", "   void add_mini_benchmark_error_code(int32_t mini_benchmark_error_code) {", "     fbb_.AddElement<int32_t>(BenchmarkError::VT_MINI_BENCHMARK_ERROR_CODE, mini_benchmark_error_code, 0);", "   }", "-  explicit BenchmarkErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit BenchmarkErrorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<BenchmarkError> Finish() {", "+  ::flatbuffers::Offset<BenchmarkError> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<BenchmarkError>(end);", "+    auto o = ::flatbuffers::Offset<BenchmarkError>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<BenchmarkError> CreateBenchmarkError(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<BenchmarkError> CreateBenchmarkError(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::BenchmarkStage stage = tflite::BenchmarkStage_UNKNOWN,", "     int32_t exit_code = 0,", "     int32_t signal = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::ErrorCode>>> error_code = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::ErrorCode>>> error_code = 0,", "     int32_t mini_benchmark_error_code = 0) {", "   BenchmarkErrorBuilder builder_(_fbb);", "   builder_.add_mini_benchmark_error_code(mini_benchmark_error_code);", "@@ -3093,14 +3100,14 @@ inline flatbuffers::Offset<BenchmarkError> CreateBenchmarkError(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<BenchmarkError> CreateBenchmarkErrorDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<BenchmarkError> CreateBenchmarkErrorDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::BenchmarkStage stage = tflite::BenchmarkStage_UNKNOWN,", "     int32_t exit_code = 0,", "     int32_t signal = 0,", "-    const std::vector<flatbuffers::Offset<tflite::ErrorCode>> *error_code = nullptr,", "+    const std::vector<::flatbuffers::Offset<tflite::ErrorCode>> *error_code = nullptr,", "     int32_t mini_benchmark_error_code = 0) {", "-  auto error_code__ = error_code ? _fbb.CreateVector<flatbuffers::Offset<tflite::ErrorCode>>(*error_code) : 0;", "+  auto error_code__ = error_code ? _fbb.CreateVector<::flatbuffers::Offset<tflite::ErrorCode>>(*error_code) : 0;", "   return tflite::CreateBenchmarkError(", "       _fbb,", "       stage,", "@@ -3110,9 +3117,9 @@ inline flatbuffers::Offset<BenchmarkError> CreateBenchmarkErrorDirect(", "       mini_benchmark_error_code);", " }", " ", "-flatbuffers::Offset<BenchmarkError> CreateBenchmarkError(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<BenchmarkError> CreateBenchmarkError(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkErrorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct BenchmarkEventT : public flatbuffers::NativeTable {", "+struct BenchmarkEventT : public ::flatbuffers::NativeTable {", "   typedef BenchmarkEvent TableType;", "   std::unique_ptr<tflite::TFLiteSettingsT> tflite_settings{};", "   tflite::BenchmarkEventType event_type = tflite::BenchmarkEventType_UNDEFINED_BENCHMARK_EVENT_TYPE;", "@@ -3126,7 +3133,7 @@ struct BenchmarkEventT : public flatbuffers::NativeTable {", "   BenchmarkEventT &operator=(BenchmarkEventT o) FLATBUFFERS_NOEXCEPT;", " };", " ", "-struct BenchmarkEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct BenchmarkEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef BenchmarkEventT NativeTableType;", "   typedef BenchmarkEventBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -3155,7 +3162,7 @@ struct BenchmarkEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int64_t wallclock_us() const {", "     return GetField<int64_t>(VT_WALLCLOCK_US, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_TFLITE_SETTINGS) &&", "            verifier.VerifyTable(tflite_settings()) &&", "@@ -3168,25 +3175,25 @@ struct BenchmarkEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            VerifyField<int64_t>(verifier, VT_WALLCLOCK_US, 8) &&", "            verifier.EndTable();", "   }", "-  BenchmarkEventT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(BenchmarkEventT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<BenchmarkEvent> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkEventT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  BenchmarkEventT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(BenchmarkEventT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<BenchmarkEvent> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct BenchmarkEventBuilder {", "   typedef BenchmarkEvent Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_tflite_settings(flatbuffers::Offset<tflite::TFLiteSettings> tflite_settings) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_tflite_settings(::flatbuffers::Offset<tflite::TFLiteSettings> tflite_settings) {", "     fbb_.AddOffset(BenchmarkEvent::VT_TFLITE_SETTINGS, tflite_settings);", "   }", "   void add_event_type(tflite::BenchmarkEventType event_type) {", "     fbb_.AddElement<int32_t>(BenchmarkEvent::VT_EVENT_TYPE, static_cast<int32_t>(event_type), 0);", "   }", "-  void add_result(flatbuffers::Offset<tflite::BenchmarkResult> result) {", "+  void add_result(::flatbuffers::Offset<tflite::BenchmarkResult> result) {", "     fbb_.AddOffset(BenchmarkEvent::VT_RESULT, result);", "   }", "-  void add_error(flatbuffers::Offset<tflite::BenchmarkError> error) {", "+  void add_error(::flatbuffers::Offset<tflite::BenchmarkError> error) {", "     fbb_.AddOffset(BenchmarkEvent::VT_ERROR, error);", "   }", "   void add_boottime_us(int64_t boottime_us) {", "@@ -3195,23 +3202,23 @@ struct BenchmarkEventBuilder {", "   void add_wallclock_us(int64_t wallclock_us) {", "     fbb_.AddElement<int64_t>(BenchmarkEvent::VT_WALLCLOCK_US, wallclock_us, 0);", "   }", "-  explicit BenchmarkEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit BenchmarkEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<BenchmarkEvent> Finish() {", "+  ::flatbuffers::Offset<BenchmarkEvent> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<BenchmarkEvent>(end);", "+    auto o = ::flatbuffers::Offset<BenchmarkEvent>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<BenchmarkEvent> CreateBenchmarkEvent(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<tflite::TFLiteSettings> tflite_settings = 0,", "+inline ::flatbuffers::Offset<BenchmarkEvent> CreateBenchmarkEvent(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<tflite::TFLiteSettings> tflite_settings = 0,", "     tflite::BenchmarkEventType event_type = tflite::BenchmarkEventType_UNDEFINED_BENCHMARK_EVENT_TYPE,", "-    flatbuffers::Offset<tflite::BenchmarkResult> result = 0,", "-    flatbuffers::Offset<tflite::BenchmarkError> error = 0,", "+    ::flatbuffers::Offset<tflite::BenchmarkResult> result = 0,", "+    ::flatbuffers::Offset<tflite::BenchmarkError> error = 0,", "     int64_t boottime_us = 0,", "     int64_t wallclock_us = 0) {", "   BenchmarkEventBuilder builder_(_fbb);", "@@ -3224,9 +3231,9 @@ inline flatbuffers::Offset<BenchmarkEvent> CreateBenchmarkEvent(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<BenchmarkEvent> CreateBenchmarkEvent(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkEventT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<BenchmarkEvent> CreateBenchmarkEvent(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct BestAccelerationDecisionT : public flatbuffers::NativeTable {", "+struct BestAccelerationDecisionT : public ::flatbuffers::NativeTable {", "   typedef BestAccelerationDecision TableType;", "   int32_t number_of_source_events = 0;", "   std::unique_ptr<tflite::BenchmarkEventT> min_latency_event{};", "@@ -3237,7 +3244,7 @@ struct BestAccelerationDecisionT : public flatbuffers::NativeTable {", "   BestAccelerationDecisionT &operator=(BestAccelerationDecisionT o) FLATBUFFERS_NOEXCEPT;", " };", " ", "-struct BestAccelerationDecision FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct BestAccelerationDecision FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef BestAccelerationDecisionT NativeTableType;", "   typedef BestAccelerationDecisionBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -3254,7 +3261,7 @@ struct BestAccelerationDecision FLATBUFFERS_FINAL_CLASS : private flatbuffers::T", "   int64_t min_inference_time_us() const {", "     return GetField<int64_t>(VT_MIN_INFERENCE_TIME_US, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_NUMBER_OF_SOURCE_EVENTS, 4) &&", "            VerifyOffset(verifier, VT_MIN_LATENCY_EVENT) &&", "@@ -3262,39 +3269,39 @@ struct BestAccelerationDecision FLATBUFFERS_FINAL_CLASS : private flatbuffers::T", "            VerifyField<int64_t>(verifier, VT_MIN_INFERENCE_TIME_US, 8) &&", "            verifier.EndTable();", "   }", "-  BestAccelerationDecisionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(BestAccelerationDecisionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<BestAccelerationDecision> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BestAccelerationDecisionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  BestAccelerationDecisionT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(BestAccelerationDecisionT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<BestAccelerationDecision> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BestAccelerationDecisionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct BestAccelerationDecisionBuilder {", "   typedef BestAccelerationDecision Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_number_of_source_events(int32_t number_of_source_events) {", "     fbb_.AddElement<int32_t>(BestAccelerationDecision::VT_NUMBER_OF_SOURCE_EVENTS, number_of_source_events, 0);", "   }", "-  void add_min_latency_event(flatbuffers::Offset<tflite::BenchmarkEvent> min_latency_event) {", "+  void add_min_latency_event(::flatbuffers::Offset<tflite::BenchmarkEvent> min_latency_event) {", "     fbb_.AddOffset(BestAccelerationDecision::VT_MIN_LATENCY_EVENT, min_latency_event);", "   }", "   void add_min_inference_time_us(int64_t min_inference_time_us) {", "     fbb_.AddElement<int64_t>(BestAccelerationDecision::VT_MIN_INFERENCE_TIME_US, min_inference_time_us, 0);", "   }", "-  explicit BestAccelerationDecisionBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit BestAccelerationDecisionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<BestAccelerationDecision> Finish() {", "+  ::flatbuffers::Offset<BestAccelerationDecision> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<BestAccelerationDecision>(end);", "+    auto o = ::flatbuffers::Offset<BestAccelerationDecision>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<BestAccelerationDecision> CreateBestAccelerationDecision(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<BestAccelerationDecision> CreateBestAccelerationDecision(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t number_of_source_events = 0,", "-    flatbuffers::Offset<tflite::BenchmarkEvent> min_latency_event = 0,", "+    ::flatbuffers::Offset<tflite::BenchmarkEvent> min_latency_event = 0,", "     int64_t min_inference_time_us = 0) {", "   BestAccelerationDecisionBuilder builder_(_fbb);", "   builder_.add_min_inference_time_us(min_inference_time_us);", "@@ -3303,14 +3310,14 @@ inline flatbuffers::Offset<BestAccelerationDecision> CreateBestAccelerationDecis", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<BestAccelerationDecision> CreateBestAccelerationDecision(flatbuffers::FlatBufferBuilder &_fbb, const BestAccelerationDecisionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<BestAccelerationDecision> CreateBestAccelerationDecision(::flatbuffers::FlatBufferBuilder &_fbb, const BestAccelerationDecisionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct BenchmarkInitializationFailureT : public flatbuffers::NativeTable {", "+struct BenchmarkInitializationFailureT : public ::flatbuffers::NativeTable {", "   typedef BenchmarkInitializationFailure TableType;", "   int32_t initialization_status = 0;", " };", " ", "-struct BenchmarkInitializationFailure FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct BenchmarkInitializationFailure FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef BenchmarkInitializationFailureT NativeTableType;", "   typedef BenchmarkInitializationFailureBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -3319,45 +3326,45 @@ struct BenchmarkInitializationFailure FLATBUFFERS_FINAL_CLASS : private flatbuff", "   int32_t initialization_status() const {", "     return GetField<int32_t>(VT_INITIALIZATION_STATUS, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_INITIALIZATION_STATUS, 4) &&", "            verifier.EndTable();", "   }", "-  BenchmarkInitializationFailureT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(BenchmarkInitializationFailureT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<BenchmarkInitializationFailure> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkInitializationFailureT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  BenchmarkInitializationFailureT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(BenchmarkInitializationFailureT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<BenchmarkInitializationFailure> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkInitializationFailureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct BenchmarkInitializationFailureBuilder {", "   typedef BenchmarkInitializationFailure Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_initialization_status(int32_t initialization_status) {", "     fbb_.AddElement<int32_t>(BenchmarkInitializationFailure::VT_INITIALIZATION_STATUS, initialization_status, 0);", "   }", "-  explicit BenchmarkInitializationFailureBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit BenchmarkInitializationFailureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<BenchmarkInitializationFailure> Finish() {", "+  ::flatbuffers::Offset<BenchmarkInitializationFailure> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<BenchmarkInitializationFailure>(end);", "+    auto o = ::flatbuffers::Offset<BenchmarkInitializationFailure>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<BenchmarkInitializationFailure> CreateBenchmarkInitializationFailure(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<BenchmarkInitializationFailure> CreateBenchmarkInitializationFailure(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t initialization_status = 0) {", "   BenchmarkInitializationFailureBuilder builder_(_fbb);", "   builder_.add_initialization_status(initialization_status);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<BenchmarkInitializationFailure> CreateBenchmarkInitializationFailure(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkInitializationFailureT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<BenchmarkInitializationFailure> CreateBenchmarkInitializationFailure(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkInitializationFailureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct MiniBenchmarkEventT : public flatbuffers::NativeTable {", "+struct MiniBenchmarkEventT : public ::flatbuffers::NativeTable {", "   typedef MiniBenchmarkEvent TableType;", "   bool is_log_flushing_event = false;", "   std::unique_ptr<tflite::BestAccelerationDecisionT> best_acceleration_decision{};", "@@ -3369,7 +3376,7 @@ struct MiniBenchmarkEventT : public flatbuffers::NativeTable {", "   MiniBenchmarkEventT &operator=(MiniBenchmarkEventT o) FLATBUFFERS_NOEXCEPT;", " };", " ", "-struct MiniBenchmarkEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct MiniBenchmarkEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef MiniBenchmarkEventT NativeTableType;", "   typedef MiniBenchmarkEventBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -3390,7 +3397,7 @@ struct MiniBenchmarkEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   const tflite::BenchmarkEvent *benchmark_event() const {", "     return GetPointer<const tflite::BenchmarkEvent *>(VT_BENCHMARK_EVENT);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<uint8_t>(verifier, VT_IS_LOG_FLUSHING_EVENT, 1) &&", "            VerifyOffset(verifier, VT_BEST_ACCELERATION_DECISION) &&", "@@ -3401,44 +3408,44 @@ struct MiniBenchmarkEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            verifier.VerifyTable(benchmark_event()) &&", "            verifier.EndTable();", "   }", "-  MiniBenchmarkEventT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(MiniBenchmarkEventT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<MiniBenchmarkEvent> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MiniBenchmarkEventT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  MiniBenchmarkEventT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(MiniBenchmarkEventT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<MiniBenchmarkEvent> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MiniBenchmarkEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct MiniBenchmarkEventBuilder {", "   typedef MiniBenchmarkEvent Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_is_log_flushing_event(bool is_log_flushing_event) {", "     fbb_.AddElement<uint8_t>(MiniBenchmarkEvent::VT_IS_LOG_FLUSHING_EVENT, static_cast<uint8_t>(is_log_flushing_event), 0);", "   }", "-  void add_best_acceleration_decision(flatbuffers::Offset<tflite::BestAccelerationDecision> best_acceleration_decision) {", "+  void add_best_acceleration_decision(::flatbuffers::Offset<tflite::BestAccelerationDecision> best_acceleration_decision) {", "     fbb_.AddOffset(MiniBenchmarkEvent::VT_BEST_ACCELERATION_DECISION, best_acceleration_decision);", "   }", "-  void add_initialization_failure(flatbuffers::Offset<tflite::BenchmarkInitializationFailure> initialization_failure) {", "+  void add_initialization_failure(::flatbuffers::Offset<tflite::BenchmarkInitializationFailure> initialization_failure) {", "     fbb_.AddOffset(MiniBenchmarkEvent::VT_INITIALIZATION_FAILURE, initialization_failure);", "   }", "-  void add_benchmark_event(flatbuffers::Offset<tflite::BenchmarkEvent> benchmark_event) {", "+  void add_benchmark_event(::flatbuffers::Offset<tflite::BenchmarkEvent> benchmark_event) {", "     fbb_.AddOffset(MiniBenchmarkEvent::VT_BENCHMARK_EVENT, benchmark_event);", "   }", "-  explicit MiniBenchmarkEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit MiniBenchmarkEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<MiniBenchmarkEvent> Finish() {", "+  ::flatbuffers::Offset<MiniBenchmarkEvent> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<MiniBenchmarkEvent>(end);", "+    auto o = ::flatbuffers::Offset<MiniBenchmarkEvent>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<MiniBenchmarkEvent> CreateMiniBenchmarkEvent(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<MiniBenchmarkEvent> CreateMiniBenchmarkEvent(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     bool is_log_flushing_event = false,", "-    flatbuffers::Offset<tflite::BestAccelerationDecision> best_acceleration_decision = 0,", "-    flatbuffers::Offset<tflite::BenchmarkInitializationFailure> initialization_failure = 0,", "-    flatbuffers::Offset<tflite::BenchmarkEvent> benchmark_event = 0) {", "+    ::flatbuffers::Offset<tflite::BestAccelerationDecision> best_acceleration_decision = 0,", "+    ::flatbuffers::Offset<tflite::BenchmarkInitializationFailure> initialization_failure = 0,", "+    ::flatbuffers::Offset<tflite::BenchmarkEvent> benchmark_event = 0) {", "   MiniBenchmarkEventBuilder builder_(_fbb);", "   builder_.add_benchmark_event(benchmark_event);", "   builder_.add_initialization_failure(initialization_failure);", "@@ -3447,9 +3454,9 @@ inline flatbuffers::Offset<MiniBenchmarkEvent> CreateMiniBenchmarkEvent(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<MiniBenchmarkEvent> CreateMiniBenchmarkEvent(flatbuffers::FlatBufferBuilder &_fbb, const MiniBenchmarkEventT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<MiniBenchmarkEvent> CreateMiniBenchmarkEvent(::flatbuffers::FlatBufferBuilder &_fbb, const MiniBenchmarkEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ModelFileT : public flatbuffers::NativeTable {", "+struct ModelFileT : public ::flatbuffers::NativeTable {", "   typedef ModelFile TableType;", "   std::string filename{};", "   int64_t fd = 0;", "@@ -3463,7 +3470,7 @@ struct ModelFileT : public flatbuffers::NativeTable {", "   ModelFileT &operator=(ModelFileT o) FLATBUFFERS_NOEXCEPT;", " };", " ", "-struct ModelFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ModelFile FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ModelFileT NativeTableType;", "   typedef ModelFileBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -3474,8 +3481,8 @@ struct ModelFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "     VT_MODEL_ID_GROUP = 12,", "     VT_BUFFER_HANDLE = 14", "   };", "-  const flatbuffers::String *filename() const {", "-    return GetPointer<const flatbuffers::String *>(VT_FILENAME);", "+  const ::flatbuffers::String *filename() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);", "   }", "   int64_t fd() const {", "     return GetField<int64_t>(VT_FD, 0);", "@@ -3492,7 +3499,7 @@ struct ModelFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int64_t buffer_handle() const {", "     return GetField<int64_t>(VT_BUFFER_HANDLE, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_FILENAME) &&", "            verifier.VerifyString(filename()) &&", "@@ -3504,16 +3511,16 @@ struct ModelFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            VerifyField<int64_t>(verifier, VT_BUFFER_HANDLE, 8) &&", "            verifier.EndTable();", "   }", "-  ModelFileT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ModelFileT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ModelFile> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelFileT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ModelFileT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ModelFileT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ModelFile> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ModelFileT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ModelFileBuilder {", "   typedef ModelFile Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_filename(flatbuffers::Offset<flatbuffers::String> filename) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {", "     fbb_.AddOffset(ModelFile::VT_FILENAME, filename);", "   }", "   void add_fd(int64_t fd) {", "@@ -3525,30 +3532,30 @@ struct ModelFileBuilder {", "   void add_length(int64_t length) {", "     fbb_.AddElement<int64_t>(ModelFile::VT_LENGTH, length, 0);", "   }", "-  void add_model_id_group(flatbuffers::Offset<tflite::ModelIdGroup> model_id_group) {", "+  void add_model_id_group(::flatbuffers::Offset<tflite::ModelIdGroup> model_id_group) {", "     fbb_.AddOffset(ModelFile::VT_MODEL_ID_GROUP, model_id_group);", "   }", "   void add_buffer_handle(int64_t buffer_handle) {", "     fbb_.AddElement<int64_t>(ModelFile::VT_BUFFER_HANDLE, buffer_handle, 0);", "   }", "-  explicit ModelFileBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit ModelFileBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ModelFile> Finish() {", "+  ::flatbuffers::Offset<ModelFile> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ModelFile>(end);", "+    auto o = ::flatbuffers::Offset<ModelFile>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ModelFile> CreateModelFile(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::String> filename = 0,", "+inline ::flatbuffers::Offset<ModelFile> CreateModelFile(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::String> filename = 0,", "     int64_t fd = 0,", "     int64_t offset = 0,", "     int64_t length = 0,", "-    flatbuffers::Offset<tflite::ModelIdGroup> model_id_group = 0,", "+    ::flatbuffers::Offset<tflite::ModelIdGroup> model_id_group = 0,", "     int64_t buffer_handle = 0) {", "   ModelFileBuilder builder_(_fbb);", "   builder_.add_buffer_handle(buffer_handle);", "@@ -3560,13 +3567,13 @@ inline flatbuffers::Offset<ModelFile> CreateModelFile(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<ModelFile> CreateModelFileDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<ModelFile> CreateModelFileDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const char *filename = nullptr,", "     int64_t fd = 0,", "     int64_t offset = 0,", "     int64_t length = 0,", "-    flatbuffers::Offset<tflite::ModelIdGroup> model_id_group = 0,", "+    ::flatbuffers::Offset<tflite::ModelIdGroup> model_id_group = 0,", "     int64_t buffer_handle = 0) {", "   auto filename__ = filename ? _fbb.CreateString(filename) : 0;", "   return tflite::CreateModelFile(", "@@ -3579,28 +3586,28 @@ inline flatbuffers::Offset<ModelFile> CreateModelFileDirect(", "       buffer_handle);", " }", " ", "-flatbuffers::Offset<ModelFile> CreateModelFile(flatbuffers::FlatBufferBuilder &_fbb, const ModelFileT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ModelFile> CreateModelFile(::flatbuffers::FlatBufferBuilder &_fbb, const ModelFileT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ModelIdGroupT : public flatbuffers::NativeTable {", "+struct ModelIdGroupT : public ::flatbuffers::NativeTable {", "   typedef ModelIdGroup TableType;", "   std::string model_namespace{};", "   std::string model_id{};", " };", " ", "-struct ModelIdGroup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ModelIdGroup FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ModelIdGroupT NativeTableType;", "   typedef ModelIdGroupBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_MODEL_NAMESPACE = 4,", "     VT_MODEL_ID = 6", "   };", "-  const flatbuffers::String *model_namespace() const {", "-    return GetPointer<const flatbuffers::String *>(VT_MODEL_NAMESPACE);", "+  const ::flatbuffers::String *model_namespace() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_MODEL_NAMESPACE);", "   }", "-  const flatbuffers::String *model_id() const {", "-    return GetPointer<const flatbuffers::String *>(VT_MODEL_ID);", "+  const ::flatbuffers::String *model_id() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_MODEL_ID);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_MODEL_NAMESPACE) &&", "            verifier.VerifyString(model_namespace()) &&", "@@ -3608,44 +3615,44 @@ struct ModelIdGroup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            verifier.VerifyString(model_id()) &&", "            verifier.EndTable();", "   }", "-  ModelIdGroupT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ModelIdGroupT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ModelIdGroup> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelIdGroupT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ModelIdGroupT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ModelIdGroupT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ModelIdGroup> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ModelIdGroupT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ModelIdGroupBuilder {", "   typedef ModelIdGroup Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_model_namespace(flatbuffers::Offset<flatbuffers::String> model_namespace) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_model_namespace(::flatbuffers::Offset<::flatbuffers::String> model_namespace) {", "     fbb_.AddOffset(ModelIdGroup::VT_MODEL_NAMESPACE, model_namespace);", "   }", "-  void add_model_id(flatbuffers::Offset<flatbuffers::String> model_id) {", "+  void add_model_id(::flatbuffers::Offset<::flatbuffers::String> model_id) {", "     fbb_.AddOffset(ModelIdGroup::VT_MODEL_ID, model_id);", "   }", "-  explicit ModelIdGroupBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit ModelIdGroupBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ModelIdGroup> Finish() {", "+  ::flatbuffers::Offset<ModelIdGroup> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ModelIdGroup>(end);", "+    auto o = ::flatbuffers::Offset<ModelIdGroup>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ModelIdGroup> CreateModelIdGroup(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::String> model_namespace = 0,", "-    flatbuffers::Offset<flatbuffers::String> model_id = 0) {", "+inline ::flatbuffers::Offset<ModelIdGroup> CreateModelIdGroup(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::String> model_namespace = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> model_id = 0) {", "   ModelIdGroupBuilder builder_(_fbb);", "   builder_.add_model_id(model_id);", "   builder_.add_model_namespace(model_namespace);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<ModelIdGroup> CreateModelIdGroupDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<ModelIdGroup> CreateModelIdGroupDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const char *model_namespace = nullptr,", "     const char *model_id = nullptr) {", "   auto model_namespace__ = model_namespace ? _fbb.CreateString(model_namespace) : 0;", "@@ -3656,28 +3663,28 @@ inline flatbuffers::Offset<ModelIdGroup> CreateModelIdGroupDirect(", "       model_id__);", " }", " ", "-flatbuffers::Offset<ModelIdGroup> CreateModelIdGroup(flatbuffers::FlatBufferBuilder &_fbb, const ModelIdGroupT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ModelIdGroup> CreateModelIdGroup(::flatbuffers::FlatBufferBuilder &_fbb, const ModelIdGroupT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct BenchmarkStoragePathsT : public flatbuffers::NativeTable {", "+struct BenchmarkStoragePathsT : public ::flatbuffers::NativeTable {", "   typedef BenchmarkStoragePaths TableType;", "   std::string storage_file_path{};", "   std::string data_directory_path{};", " };", " ", "-struct BenchmarkStoragePaths FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct BenchmarkStoragePaths FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef BenchmarkStoragePathsT NativeTableType;", "   typedef BenchmarkStoragePathsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_STORAGE_FILE_PATH = 4,", "     VT_DATA_DIRECTORY_PATH = 6", "   };", "-  const flatbuffers::String *storage_file_path() const {", "-    return GetPointer<const flatbuffers::String *>(VT_STORAGE_FILE_PATH);", "+  const ::flatbuffers::String *storage_file_path() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_STORAGE_FILE_PATH);", "   }", "-  const flatbuffers::String *data_directory_path() const {", "-    return GetPointer<const flatbuffers::String *>(VT_DATA_DIRECTORY_PATH);", "+  const ::flatbuffers::String *data_directory_path() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_DATA_DIRECTORY_PATH);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_STORAGE_FILE_PATH) &&", "            verifier.VerifyString(storage_file_path()) &&", "@@ -3685,44 +3692,44 @@ struct BenchmarkStoragePaths FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tabl", "            verifier.VerifyString(data_directory_path()) &&", "            verifier.EndTable();", "   }", "-  BenchmarkStoragePathsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(BenchmarkStoragePathsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<BenchmarkStoragePaths> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkStoragePathsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  BenchmarkStoragePathsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(BenchmarkStoragePathsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<BenchmarkStoragePaths> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkStoragePathsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct BenchmarkStoragePathsBuilder {", "   typedef BenchmarkStoragePaths Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_storage_file_path(flatbuffers::Offset<flatbuffers::String> storage_file_path) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_storage_file_path(::flatbuffers::Offset<::flatbuffers::String> storage_file_path) {", "     fbb_.AddOffset(BenchmarkStoragePaths::VT_STORAGE_FILE_PATH, storage_file_path);", "   }", "-  void add_data_directory_path(flatbuffers::Offset<flatbuffers::String> data_directory_path) {", "+  void add_data_directory_path(::flatbuffers::Offset<::flatbuffers::String> data_directory_path) {", "     fbb_.AddOffset(BenchmarkStoragePaths::VT_DATA_DIRECTORY_PATH, data_directory_path);", "   }", "-  explicit BenchmarkStoragePathsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit BenchmarkStoragePathsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<BenchmarkStoragePaths> Finish() {", "+  ::flatbuffers::Offset<BenchmarkStoragePaths> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<BenchmarkStoragePaths>(end);", "+    auto o = ::flatbuffers::Offset<BenchmarkStoragePaths>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<BenchmarkStoragePaths> CreateBenchmarkStoragePaths(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::String> storage_file_path = 0,", "-    flatbuffers::Offset<flatbuffers::String> data_directory_path = 0) {", "+inline ::flatbuffers::Offset<BenchmarkStoragePaths> CreateBenchmarkStoragePaths(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::String> storage_file_path = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> data_directory_path = 0) {", "   BenchmarkStoragePathsBuilder builder_(_fbb);", "   builder_.add_data_directory_path(data_directory_path);", "   builder_.add_storage_file_path(storage_file_path);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<BenchmarkStoragePaths> CreateBenchmarkStoragePathsDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<BenchmarkStoragePaths> CreateBenchmarkStoragePathsDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const char *storage_file_path = nullptr,", "     const char *data_directory_path = nullptr) {", "   auto storage_file_path__ = storage_file_path ? _fbb.CreateString(storage_file_path) : 0;", "@@ -3733,14 +3740,14 @@ inline flatbuffers::Offset<BenchmarkStoragePaths> CreateBenchmarkStoragePathsDir", "       data_directory_path__);", " }", " ", "-flatbuffers::Offset<BenchmarkStoragePaths> CreateBenchmarkStoragePaths(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkStoragePathsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<BenchmarkStoragePaths> CreateBenchmarkStoragePaths(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkStoragePathsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ValidationSettingsT : public flatbuffers::NativeTable {", "+struct ValidationSettingsT : public ::flatbuffers::NativeTable {", "   typedef ValidationSettings TableType;", "   int64_t per_test_timeout_ms = 0;", " };", " ", "-struct ValidationSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ValidationSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ValidationSettingsT NativeTableType;", "   typedef ValidationSettingsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -3749,45 +3756,45 @@ struct ValidationSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int64_t per_test_timeout_ms() const {", "     return GetField<int64_t>(VT_PER_TEST_TIMEOUT_MS, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int64_t>(verifier, VT_PER_TEST_TIMEOUT_MS, 8) &&", "            verifier.EndTable();", "   }", "-  ValidationSettingsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ValidationSettingsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ValidationSettings> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ValidationSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ValidationSettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ValidationSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ValidationSettings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ValidationSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ValidationSettingsBuilder {", "   typedef ValidationSettings Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_per_test_timeout_ms(int64_t per_test_timeout_ms) {", "     fbb_.AddElement<int64_t>(ValidationSettings::VT_PER_TEST_TIMEOUT_MS, per_test_timeout_ms, 0);", "   }", "-  explicit ValidationSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit ValidationSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ValidationSettings> Finish() {", "+  ::flatbuffers::Offset<ValidationSettings> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ValidationSettings>(end);", "+    auto o = ::flatbuffers::Offset<ValidationSettings>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ValidationSettings> CreateValidationSettings(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<ValidationSettings> CreateValidationSettings(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int64_t per_test_timeout_ms = 0) {", "   ValidationSettingsBuilder builder_(_fbb);", "   builder_.add_per_test_timeout_ms(per_test_timeout_ms);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<ValidationSettings> CreateValidationSettings(flatbuffers::FlatBufferBuilder &_fbb, const ValidationSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ValidationSettings> CreateValidationSettings(::flatbuffers::FlatBufferBuilder &_fbb, const ValidationSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct MinibenchmarkSettingsT : public flatbuffers::NativeTable {", "+struct MinibenchmarkSettingsT : public ::flatbuffers::NativeTable {", "   typedef MinibenchmarkSettings TableType;", "   std::vector<std::unique_ptr<tflite::TFLiteSettingsT>> settings_to_test{};", "   std::unique_ptr<tflite::ModelFileT> model_file{};", "@@ -3799,7 +3806,7 @@ struct MinibenchmarkSettingsT : public flatbuffers::NativeTable {", "   MinibenchmarkSettingsT &operator=(MinibenchmarkSettingsT o) FLATBUFFERS_NOEXCEPT;", " };", " ", "-struct MinibenchmarkSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct MinibenchmarkSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef MinibenchmarkSettingsT NativeTableType;", "   typedef MinibenchmarkSettingsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -3808,8 +3815,8 @@ struct MinibenchmarkSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tabl", "     VT_STORAGE_PATHS = 8,", "     VT_VALIDATION_SETTINGS = 10", "   };", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::TFLiteSettings>> *settings_to_test() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::TFLiteSettings>> *>(VT_SETTINGS_TO_TEST);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::TFLiteSettings>> *settings_to_test() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::TFLiteSettings>> *>(VT_SETTINGS_TO_TEST);", "   }", "   const tflite::ModelFile *model_file() const {", "     return GetPointer<const tflite::ModelFile *>(VT_MODEL_FILE);", "@@ -3820,7 +3827,7 @@ struct MinibenchmarkSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tabl", "   const tflite::ValidationSettings *validation_settings() const {", "     return GetPointer<const tflite::ValidationSettings *>(VT_VALIDATION_SETTINGS);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_SETTINGS_TO_TEST) &&", "            verifier.VerifyVector(settings_to_test()) &&", "@@ -3833,44 +3840,44 @@ struct MinibenchmarkSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tabl", "            verifier.VerifyTable(validation_settings()) &&", "            verifier.EndTable();", "   }", "-  MinibenchmarkSettingsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(MinibenchmarkSettingsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<MinibenchmarkSettings> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinibenchmarkSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  MinibenchmarkSettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(MinibenchmarkSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<MinibenchmarkSettings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MinibenchmarkSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct MinibenchmarkSettingsBuilder {", "   typedef MinibenchmarkSettings Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_settings_to_test(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::TFLiteSettings>>> settings_to_test) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_settings_to_test(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::TFLiteSettings>>> settings_to_test) {", "     fbb_.AddOffset(MinibenchmarkSettings::VT_SETTINGS_TO_TEST, settings_to_test);", "   }", "-  void add_model_file(flatbuffers::Offset<tflite::ModelFile> model_file) {", "+  void add_model_file(::flatbuffers::Offset<tflite::ModelFile> model_file) {", "     fbb_.AddOffset(MinibenchmarkSettings::VT_MODEL_FILE, model_file);", "   }", "-  void add_storage_paths(flatbuffers::Offset<tflite::BenchmarkStoragePaths> storage_paths) {", "+  void add_storage_paths(::flatbuffers::Offset<tflite::BenchmarkStoragePaths> storage_paths) {", "     fbb_.AddOffset(MinibenchmarkSettings::VT_STORAGE_PATHS, storage_paths);", "   }", "-  void add_validation_settings(flatbuffers::Offset<tflite::ValidationSettings> validation_settings) {", "+  void add_validation_settings(::flatbuffers::Offset<tflite::ValidationSettings> validation_settings) {", "     fbb_.AddOffset(MinibenchmarkSettings::VT_VALIDATION_SETTINGS, validation_settings);", "   }", "-  explicit MinibenchmarkSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit MinibenchmarkSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<MinibenchmarkSettings> Finish() {", "+  ::flatbuffers::Offset<MinibenchmarkSettings> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<MinibenchmarkSettings>(end);", "+    auto o = ::flatbuffers::Offset<MinibenchmarkSettings>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<MinibenchmarkSettings> CreateMinibenchmarkSettings(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::TFLiteSettings>>> settings_to_test = 0,", "-    flatbuffers::Offset<tflite::ModelFile> model_file = 0,", "-    flatbuffers::Offset<tflite::BenchmarkStoragePaths> storage_paths = 0,", "-    flatbuffers::Offset<tflite::ValidationSettings> validation_settings = 0) {", "+inline ::flatbuffers::Offset<MinibenchmarkSettings> CreateMinibenchmarkSettings(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::TFLiteSettings>>> settings_to_test = 0,", "+    ::flatbuffers::Offset<tflite::ModelFile> model_file = 0,", "+    ::flatbuffers::Offset<tflite::BenchmarkStoragePaths> storage_paths = 0,", "+    ::flatbuffers::Offset<tflite::ValidationSettings> validation_settings = 0) {", "   MinibenchmarkSettingsBuilder builder_(_fbb);", "   builder_.add_validation_settings(validation_settings);", "   builder_.add_storage_paths(storage_paths);", "@@ -3879,13 +3886,13 @@ inline flatbuffers::Offset<MinibenchmarkSettings> CreateMinibenchmarkSettings(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<MinibenchmarkSettings> CreateMinibenchmarkSettingsDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    const std::vector<flatbuffers::Offset<tflite::TFLiteSettings>> *settings_to_test = nullptr,", "-    flatbuffers::Offset<tflite::ModelFile> model_file = 0,", "-    flatbuffers::Offset<tflite::BenchmarkStoragePaths> storage_paths = 0,", "-    flatbuffers::Offset<tflite::ValidationSettings> validation_settings = 0) {", "-  auto settings_to_test__ = settings_to_test ? _fbb.CreateVector<flatbuffers::Offset<tflite::TFLiteSettings>>(*settings_to_test) : 0;", "+inline ::flatbuffers::Offset<MinibenchmarkSettings> CreateMinibenchmarkSettingsDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    const std::vector<::flatbuffers::Offset<tflite::TFLiteSettings>> *settings_to_test = nullptr,", "+    ::flatbuffers::Offset<tflite::ModelFile> model_file = 0,", "+    ::flatbuffers::Offset<tflite::BenchmarkStoragePaths> storage_paths = 0,", "+    ::flatbuffers::Offset<tflite::ValidationSettings> validation_settings = 0) {", "+  auto settings_to_test__ = settings_to_test ? _fbb.CreateVector<::flatbuffers::Offset<tflite::TFLiteSettings>>(*settings_to_test) : 0;", "   return tflite::CreateMinibenchmarkSettings(", "       _fbb,", "       settings_to_test__,", "@@ -3894,9 +3901,9 @@ inline flatbuffers::Offset<MinibenchmarkSettings> CreateMinibenchmarkSettingsDir", "       validation_settings);", " }", " ", "-flatbuffers::Offset<MinibenchmarkSettings> CreateMinibenchmarkSettings(flatbuffers::FlatBufferBuilder &_fbb, const MinibenchmarkSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<MinibenchmarkSettings> CreateMinibenchmarkSettings(::flatbuffers::FlatBufferBuilder &_fbb, const MinibenchmarkSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct BenchmarkEventStorageT : public flatbuffers::NativeTable {", "+struct BenchmarkEventStorageT : public ::flatbuffers::NativeTable {", "   typedef BenchmarkEventStorage TableType;", "   std::unique_ptr<tflite::ModelIdGroupT> model_id_group{};", "   std::unique_ptr<tflite::BenchmarkEventT> benchmark_event{};", "@@ -3906,7 +3913,7 @@ struct BenchmarkEventStorageT : public flatbuffers::NativeTable {", "   BenchmarkEventStorageT &operator=(BenchmarkEventStorageT o) FLATBUFFERS_NOEXCEPT;", " };", " ", "-struct BenchmarkEventStorage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct BenchmarkEventStorage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef BenchmarkEventStorageT NativeTableType;", "   typedef BenchmarkEventStorageBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -3919,7 +3926,7 @@ struct BenchmarkEventStorage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tabl", "   const tflite::BenchmarkEvent *benchmark_event() const {", "     return GetPointer<const tflite::BenchmarkEvent *>(VT_BENCHMARK_EVENT);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_MODEL_ID_GROUP) &&", "            verifier.VerifyTable(model_id_group()) &&", "@@ -3927,43 +3934,43 @@ struct BenchmarkEventStorage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tabl", "            verifier.VerifyTable(benchmark_event()) &&", "            verifier.EndTable();", "   }", "-  BenchmarkEventStorageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(BenchmarkEventStorageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<BenchmarkEventStorage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkEventStorageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  BenchmarkEventStorageT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(BenchmarkEventStorageT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<BenchmarkEventStorage> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkEventStorageT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct BenchmarkEventStorageBuilder {", "   typedef BenchmarkEventStorage Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_model_id_group(flatbuffers::Offset<tflite::ModelIdGroup> model_id_group) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_model_id_group(::flatbuffers::Offset<tflite::ModelIdGroup> model_id_group) {", "     fbb_.AddOffset(BenchmarkEventStorage::VT_MODEL_ID_GROUP, model_id_group);", "   }", "-  void add_benchmark_event(flatbuffers::Offset<tflite::BenchmarkEvent> benchmark_event) {", "+  void add_benchmark_event(::flatbuffers::Offset<tflite::BenchmarkEvent> benchmark_event) {", "     fbb_.AddOffset(BenchmarkEventStorage::VT_BENCHMARK_EVENT, benchmark_event);", "   }", "-  explicit BenchmarkEventStorageBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit BenchmarkEventStorageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<BenchmarkEventStorage> Finish() {", "+  ::flatbuffers::Offset<BenchmarkEventStorage> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<BenchmarkEventStorage>(end);", "+    auto o = ::flatbuffers::Offset<BenchmarkEventStorage>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<BenchmarkEventStorage> CreateBenchmarkEventStorage(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<tflite::ModelIdGroup> model_id_group = 0,", "-    flatbuffers::Offset<tflite::BenchmarkEvent> benchmark_event = 0) {", "+inline ::flatbuffers::Offset<BenchmarkEventStorage> CreateBenchmarkEventStorage(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<tflite::ModelIdGroup> model_id_group = 0,", "+    ::flatbuffers::Offset<tflite::BenchmarkEvent> benchmark_event = 0) {", "   BenchmarkEventStorageBuilder builder_(_fbb);", "   builder_.add_benchmark_event(benchmark_event);", "   builder_.add_model_id_group(model_id_group);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<BenchmarkEventStorage> CreateBenchmarkEventStorage(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkEventStorageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<BenchmarkEventStorage> CreateBenchmarkEventStorage(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkEventStorageT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", " ", " inline bool operator==(const ComputeSettingsT &lhs, const ComputeSettingsT &rhs) {", "@@ -3997,30 +4004,30 @@ inline ComputeSettingsT &ComputeSettingsT::operator=(ComputeSettingsT o) FLATBUF", "   return *this;", " }", " ", "-inline ComputeSettingsT *ComputeSettings::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ComputeSettingsT *ComputeSettings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ComputeSettingsT>(new ComputeSettingsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ComputeSettings::UnPackTo(ComputeSettingsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ComputeSettings::UnPackTo(ComputeSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = preference(); _o->preference = _e; }", "-  { auto _e = tflite_settings(); if (_e) { if(_o->tflite_settings) { _e->UnPackTo(_o->tflite_settings.get(), _resolver); } else { _o->tflite_settings = std::unique_ptr<tflite::TFLiteSettingsT>(_e->UnPack(_resolver)); } } }", "+  { auto _e = tflite_settings(); if (_e) { if(_o->tflite_settings) { _e->UnPackTo(_o->tflite_settings.get(), _resolver); } else { _o->tflite_settings = std::unique_ptr<tflite::TFLiteSettingsT>(_e->UnPack(_resolver)); } } else if (_o->tflite_settings) { _o->tflite_settings.reset(); } }", "   { auto _e = model_namespace_for_statistics(); if (_e) _o->model_namespace_for_statistics = _e->str(); }", "   { auto _e = model_identifier_for_statistics(); if (_e) _o->model_identifier_for_statistics = _e->str(); }", "-  { auto _e = settings_to_test_locally(); if (_e) { if(_o->settings_to_test_locally) { _e->UnPackTo(_o->settings_to_test_locally.get(), _resolver); } else { _o->settings_to_test_locally = std::unique_ptr<tflite::MinibenchmarkSettingsT>(_e->UnPack(_resolver)); } } }", "+  { auto _e = settings_to_test_locally(); if (_e) { if(_o->settings_to_test_locally) { _e->UnPackTo(_o->settings_to_test_locally.get(), _resolver); } else { _o->settings_to_test_locally = std::unique_ptr<tflite::MinibenchmarkSettingsT>(_e->UnPack(_resolver)); } } else if (_o->settings_to_test_locally) { _o->settings_to_test_locally.reset(); } }", " }", " ", "-inline flatbuffers::Offset<ComputeSettings> ComputeSettings::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ComputeSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ComputeSettings> ComputeSettings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ComputeSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateComputeSettings(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ComputeSettings> CreateComputeSettings(flatbuffers::FlatBufferBuilder &_fbb, const ComputeSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ComputeSettings> CreateComputeSettings(::flatbuffers::FlatBufferBuilder &_fbb, const ComputeSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ComputeSettingsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ComputeSettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _preference = _o->preference;", "   auto _tflite_settings = _o->tflite_settings ? CreateTFLiteSettings(_fbb, _o->tflite_settings.get(), _rehasher) : 0;", "   auto _model_namespace_for_statistics = _o->model_namespace_for_statistics.empty() ? 0 : _fbb.CreateString(_o->model_namespace_for_statistics);", "@@ -4088,13 +4095,13 @@ inline NNAPISettingsT &NNAPISettingsT::operator=(NNAPISettingsT o) FLATBUFFERS_N", "   return *this;", " }", " ", "-inline NNAPISettingsT *NNAPISettings::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline NNAPISettingsT *NNAPISettings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<NNAPISettingsT>(new NNAPISettingsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void NNAPISettings::UnPackTo(NNAPISettingsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void NNAPISettings::UnPackTo(NNAPISettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = accelerator_name(); if (_e) _o->accelerator_name = _e->str(); }", "@@ -4102,7 +4109,7 @@ inline void NNAPISettings::UnPackTo(NNAPISettingsT *_o, const flatbuffers::resol", "   { auto _e = model_token(); if (_e) _o->model_token = _e->str(); }", "   { auto _e = execution_preference(); _o->execution_preference = _e; }", "   { auto _e = no_of_nnapi_instances_to_cache(); _o->no_of_nnapi_instances_to_cache = _e; }", "-  { auto _e = fallback_settings(); if (_e) { if(_o->fallback_settings) { _e->UnPackTo(_o->fallback_settings.get(), _resolver); } else { _o->fallback_settings = std::unique_ptr<tflite::FallbackSettingsT>(_e->UnPack(_resolver)); } } }", "+  { auto _e = fallback_settings(); if (_e) { if(_o->fallback_settings) { _e->UnPackTo(_o->fallback_settings.get(), _resolver); } else { _o->fallback_settings = std::unique_ptr<tflite::FallbackSettingsT>(_e->UnPack(_resolver)); } } else if (_o->fallback_settings) { _o->fallback_settings.reset(); } }", "   { auto _e = allow_nnapi_cpu_on_android_10_plus(); _o->allow_nnapi_cpu_on_android_10_plus = _e; }", "   { auto _e = execution_priority(); _o->execution_priority = _e; }", "   { auto _e = allow_dynamic_dimensions(); _o->allow_dynamic_dimensions = _e; }", "@@ -4111,14 +4118,14 @@ inline void NNAPISettings::UnPackTo(NNAPISettingsT *_o, const flatbuffers::resol", "   { auto _e = support_library_handle(); _o->support_library_handle = _e; }", " }", " ", "-inline flatbuffers::Offset<NNAPISettings> NNAPISettings::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NNAPISettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<NNAPISettings> NNAPISettings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NNAPISettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateNNAPISettings(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<NNAPISettings> CreateNNAPISettings(flatbuffers::FlatBufferBuilder &_fbb, const NNAPISettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<NNAPISettings> CreateNNAPISettings(::flatbuffers::FlatBufferBuilder &_fbb, const NNAPISettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NNAPISettingsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NNAPISettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _accelerator_name = _o->accelerator_name.empty() ? 0 : _fbb.CreateString(_o->accelerator_name);", "   auto _cache_directory = _o->cache_directory.empty() ? 0 : _fbb.CreateString(_o->cache_directory);", "   auto _model_token = _o->model_token.empty() ? 0 : _fbb.CreateString(_o->model_token);", "@@ -4166,13 +4173,13 @@ inline bool operator!=(const GPUSettingsT &lhs, const GPUSettingsT &rhs) {", " }", " ", " ", "-inline GPUSettingsT *GPUSettings::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline GPUSettingsT *GPUSettings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<GPUSettingsT>(new GPUSettingsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void GPUSettings::UnPackTo(GPUSettingsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void GPUSettings::UnPackTo(GPUSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = is_precision_loss_allowed(); _o->is_precision_loss_allowed = _e; }", "@@ -4186,14 +4193,14 @@ inline void GPUSettings::UnPackTo(GPUSettingsT *_o, const flatbuffers::resolver_", "   { auto _e = model_token(); if (_e) _o->model_token = _e->str(); }", " }", " ", "-inline flatbuffers::Offset<GPUSettings> GPUSettings::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GPUSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<GPUSettings> GPUSettings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GPUSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateGPUSettings(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<GPUSettings> CreateGPUSettings(flatbuffers::FlatBufferBuilder &_fbb, const GPUSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<GPUSettings> CreateGPUSettings(::flatbuffers::FlatBufferBuilder &_fbb, const GPUSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GPUSettingsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GPUSettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _is_precision_loss_allowed = _o->is_precision_loss_allowed;", "   auto _enable_quantized_inference = _o->enable_quantized_inference;", "   auto _force_backend = _o->force_backend;", "@@ -4230,13 +4237,13 @@ inline bool operator!=(const HexagonSettingsT &lhs, const HexagonSettingsT &rhs)", " }", " ", " ", "-inline HexagonSettingsT *HexagonSettings::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline HexagonSettingsT *HexagonSettings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<HexagonSettingsT>(new HexagonSettingsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void HexagonSettings::UnPackTo(HexagonSettingsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void HexagonSettings::UnPackTo(HexagonSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = debug_level(); _o->debug_level = _e; }", "@@ -4245,14 +4252,14 @@ inline void HexagonSettings::UnPackTo(HexagonSettingsT *_o, const flatbuffers::r", "   { auto _e = print_graph_debug(); _o->print_graph_debug = _e; }", " }", " ", "-inline flatbuffers::Offset<HexagonSettings> HexagonSettings::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HexagonSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<HexagonSettings> HexagonSettings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HexagonSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateHexagonSettings(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<HexagonSettings> CreateHexagonSettings(flatbuffers::FlatBufferBuilder &_fbb, const HexagonSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<HexagonSettings> CreateHexagonSettings(::flatbuffers::FlatBufferBuilder &_fbb, const HexagonSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HexagonSettingsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const HexagonSettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _debug_level = _o->debug_level;", "   auto _powersave_level = _o->powersave_level;", "   auto _print_graph_profile = _o->print_graph_profile;", "@@ -4277,27 +4284,27 @@ inline bool operator!=(const XNNPackSettingsT &lhs, const XNNPackSettingsT &rhs)", " }", " ", " ", "-inline XNNPackSettingsT *XNNPackSettings::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline XNNPackSettingsT *XNNPackSettings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<XNNPackSettingsT>(new XNNPackSettingsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void XNNPackSettings::UnPackTo(XNNPackSettingsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void XNNPackSettings::UnPackTo(XNNPackSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = num_threads(); _o->num_threads = _e; }", "   { auto _e = flags(); _o->flags = _e; }", " }", " ", "-inline flatbuffers::Offset<XNNPackSettings> XNNPackSettings::Pack(flatbuffers::FlatBufferBuilder &_fbb, const XNNPackSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<XNNPackSettings> XNNPackSettings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const XNNPackSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateXNNPackSettings(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<XNNPackSettings> CreateXNNPackSettings(flatbuffers::FlatBufferBuilder &_fbb, const XNNPackSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<XNNPackSettings> CreateXNNPackSettings(::flatbuffers::FlatBufferBuilder &_fbb, const XNNPackSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const XNNPackSettingsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const XNNPackSettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _num_threads = _o->num_threads;", "   auto _flags = _o->flags;", "   return tflite::CreateXNNPackSettings(", "@@ -4320,13 +4327,13 @@ inline bool operator!=(const CoreMLSettingsT &lhs, const CoreMLSettingsT &rhs) {", " }", " ", " ", "-inline CoreMLSettingsT *CoreMLSettings::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline CoreMLSettingsT *CoreMLSettings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<CoreMLSettingsT>(new CoreMLSettingsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void CoreMLSettings::UnPackTo(CoreMLSettingsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void CoreMLSettings::UnPackTo(CoreMLSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = enabled_devices(); _o->enabled_devices = _e; }", "@@ -4335,14 +4342,14 @@ inline void CoreMLSettings::UnPackTo(CoreMLSettingsT *_o, const flatbuffers::res", "   { auto _e = min_nodes_per_partition(); _o->min_nodes_per_partition = _e; }", " }", " ", "-inline flatbuffers::Offset<CoreMLSettings> CoreMLSettings::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CoreMLSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<CoreMLSettings> CoreMLSettings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CoreMLSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateCoreMLSettings(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<CoreMLSettings> CreateCoreMLSettings(flatbuffers::FlatBufferBuilder &_fbb, const CoreMLSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<CoreMLSettings> CreateCoreMLSettings(::flatbuffers::FlatBufferBuilder &_fbb, const CoreMLSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CoreMLSettingsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CoreMLSettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _enabled_devices = _o->enabled_devices;", "   auto _coreml_version = _o->coreml_version;", "   auto _max_delegated_partitions = _o->max_delegated_partitions;", "@@ -4366,26 +4373,26 @@ inline bool operator!=(const StableDelegateLoaderSettingsT &lhs, const StableDel", " }", " ", " ", "-inline StableDelegateLoaderSettingsT *StableDelegateLoaderSettings::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline StableDelegateLoaderSettingsT *StableDelegateLoaderSettings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<StableDelegateLoaderSettingsT>(new StableDelegateLoaderSettingsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void StableDelegateLoaderSettings::UnPackTo(StableDelegateLoaderSettingsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void StableDelegateLoaderSettings::UnPackTo(StableDelegateLoaderSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = delegate_path(); if (_e) _o->delegate_path = _e->str(); }", " }", " ", "-inline flatbuffers::Offset<StableDelegateLoaderSettings> StableDelegateLoaderSettings::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StableDelegateLoaderSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<StableDelegateLoaderSettings> StableDelegateLoaderSettings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StableDelegateLoaderSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateStableDelegateLoaderSettings(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<StableDelegateLoaderSettings> CreateStableDelegateLoaderSettings(flatbuffers::FlatBufferBuilder &_fbb, const StableDelegateLoaderSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<StableDelegateLoaderSettings> CreateStableDelegateLoaderSettings(::flatbuffers::FlatBufferBuilder &_fbb, const StableDelegateLoaderSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StableDelegateLoaderSettingsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StableDelegateLoaderSettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _delegate_path = _o->delegate_path.empty() ? 0 : _fbb.CreateString(_o->delegate_path);", "   return tflite::CreateStableDelegateLoaderSettings(", "       _fbb,", "@@ -4404,27 +4411,27 @@ inline bool operator!=(const CompilationCachingSettingsT &lhs, const Compilation", " }", " ", " ", "-inline CompilationCachingSettingsT *CompilationCachingSettings::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline CompilationCachingSettingsT *CompilationCachingSettings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<CompilationCachingSettingsT>(new CompilationCachingSettingsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void CompilationCachingSettings::UnPackTo(CompilationCachingSettingsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void CompilationCachingSettings::UnPackTo(CompilationCachingSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = cache_dir(); if (_e) _o->cache_dir = _e->str(); }", "   { auto _e = model_token(); if (_e) _o->model_token = _e->str(); }", " }", " ", "-inline flatbuffers::Offset<CompilationCachingSettings> CompilationCachingSettings::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CompilationCachingSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<CompilationCachingSettings> CompilationCachingSettings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CompilationCachingSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateCompilationCachingSettings(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<CompilationCachingSettings> CreateCompilationCachingSettings(flatbuffers::FlatBufferBuilder &_fbb, const CompilationCachingSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<CompilationCachingSettings> CreateCompilationCachingSettings(::flatbuffers::FlatBufferBuilder &_fbb, const CompilationCachingSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CompilationCachingSettingsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CompilationCachingSettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _cache_dir = _o->cache_dir.empty() ? 0 : _fbb.CreateString(_o->cache_dir);", "   auto _model_token = _o->model_token.empty() ? 0 : _fbb.CreateString(_o->model_token);", "   return tflite::CreateCompilationCachingSettings(", "@@ -4447,29 +4454,29 @@ inline bool operator!=(const EdgeTpuDeviceSpecT &lhs, const EdgeTpuDeviceSpecT &", " }", " ", " ", "-inline EdgeTpuDeviceSpecT *EdgeTpuDeviceSpec::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline EdgeTpuDeviceSpecT *EdgeTpuDeviceSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<EdgeTpuDeviceSpecT>(new EdgeTpuDeviceSpecT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void EdgeTpuDeviceSpec::UnPackTo(EdgeTpuDeviceSpecT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void EdgeTpuDeviceSpec::UnPackTo(EdgeTpuDeviceSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = platform_type(); _o->platform_type = _e; }", "   { auto _e = num_chips(); _o->num_chips = _e; }", "-  { auto _e = device_paths(); if (_e) { _o->device_paths.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->device_paths[_i] = _e->Get(_i)->str(); } } }", "+  { auto _e = device_paths(); if (_e) { _o->device_paths.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->device_paths[_i] = _e->Get(_i)->str(); } } else { _o->device_paths.resize(0); } }", "   { auto _e = chip_family(); _o->chip_family = _e; }", " }", " ", "-inline flatbuffers::Offset<EdgeTpuDeviceSpec> EdgeTpuDeviceSpec::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuDeviceSpecT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<EdgeTpuDeviceSpec> EdgeTpuDeviceSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuDeviceSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateEdgeTpuDeviceSpec(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<EdgeTpuDeviceSpec> CreateEdgeTpuDeviceSpec(flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuDeviceSpecT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<EdgeTpuDeviceSpec> CreateEdgeTpuDeviceSpec(::flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuDeviceSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EdgeTpuDeviceSpecT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EdgeTpuDeviceSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _platform_type = _o->platform_type;", "   auto _num_chips = _o->num_chips;", "   auto _device_paths = _o->device_paths.size() ? _fbb.CreateVectorOfStrings(_o->device_paths) : 0;", "@@ -4494,27 +4501,27 @@ inline bool operator!=(const EdgeTpuInactivePowerConfigT &lhs, const EdgeTpuInac", " }", " ", " ", "-inline EdgeTpuInactivePowerConfigT *EdgeTpuInactivePowerConfig::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline EdgeTpuInactivePowerConfigT *EdgeTpuInactivePowerConfig::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<EdgeTpuInactivePowerConfigT>(new EdgeTpuInactivePowerConfigT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void EdgeTpuInactivePowerConfig::UnPackTo(EdgeTpuInactivePowerConfigT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void EdgeTpuInactivePowerConfig::UnPackTo(EdgeTpuInactivePowerConfigT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = inactive_power_state(); _o->inactive_power_state = _e; }", "   { auto _e = inactive_timeout_us(); _o->inactive_timeout_us = _e; }", " }", " ", "-inline flatbuffers::Offset<EdgeTpuInactivePowerConfig> EdgeTpuInactivePowerConfig::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuInactivePowerConfigT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<EdgeTpuInactivePowerConfig> EdgeTpuInactivePowerConfig::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuInactivePowerConfigT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateEdgeTpuInactivePowerConfig(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<EdgeTpuInactivePowerConfig> CreateEdgeTpuInactivePowerConfig(flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuInactivePowerConfigT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<EdgeTpuInactivePowerConfig> CreateEdgeTpuInactivePowerConfig(::flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuInactivePowerConfigT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EdgeTpuInactivePowerConfigT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EdgeTpuInactivePowerConfigT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _inactive_power_state = _o->inactive_power_state;", "   auto _inactive_timeout_us = _o->inactive_timeout_us;", "   return tflite::CreateEdgeTpuInactivePowerConfig(", "@@ -4527,7 +4534,7 @@ inline flatbuffers::Offset<EdgeTpuInactivePowerConfig> CreateEdgeTpuInactivePowe", " inline bool operator==(const EdgeTpuSettingsT &lhs, const EdgeTpuSettingsT &rhs) {", "   return", "       (lhs.inference_power_state == rhs.inference_power_state) &&", "-      (lhs.inactive_power_configs == rhs.inactive_power_configs) &&", "+      (lhs.inactive_power_configs.size() == rhs.inactive_power_configs.size() && std::equal(lhs.inactive_power_configs.cbegin(), lhs.inactive_power_configs.cend(), rhs.inactive_power_configs.cbegin(), [](std::unique_ptr<tflite::EdgeTpuInactivePowerConfigT> const &a, std::unique_ptr<tflite::EdgeTpuInactivePowerConfigT> const &b) { return (a == b) || (a && b && *a == *b); })) &&", "       (lhs.inference_priority == rhs.inference_priority) &&", "       ((lhs.edgetpu_device_spec == rhs.edgetpu_device_spec) || (lhs.edgetpu_device_spec && rhs.edgetpu_device_spec && *lhs.edgetpu_device_spec == *rhs.edgetpu_device_spec)) &&", "       (lhs.model_token == rhs.model_token) &&", "@@ -4552,7 +4559,7 @@ inline EdgeTpuSettingsT::EdgeTpuSettingsT(const EdgeTpuSettingsT &o)", "         hardware_cluster_ids(o.hardware_cluster_ids),", "         public_model_id(o.public_model_id) {", "   inactive_power_configs.reserve(o.inactive_power_configs.size());", "-  for (const auto &v : o.inactive_power_configs) { inactive_power_configs.emplace_back((v) ? new tflite::EdgeTpuInactivePowerConfigT(*v) : nullptr); }", "+  for (const auto &inactive_power_configs_ : o.inactive_power_configs) { inactive_power_configs.emplace_back((inactive_power_configs_) ? new tflite::EdgeTpuInactivePowerConfigT(*inactive_power_configs_) : nullptr); }", " }", " ", " inline EdgeTpuSettingsT &EdgeTpuSettingsT::operator=(EdgeTpuSettingsT o) FLATBUFFERS_NOEXCEPT {", "@@ -4568,36 +4575,36 @@ inline EdgeTpuSettingsT &EdgeTpuSettingsT::operator=(EdgeTpuSettingsT o) FLATBUF", "   return *this;", " }", " ", "-inline EdgeTpuSettingsT *EdgeTpuSettings::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline EdgeTpuSettingsT *EdgeTpuSettings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<EdgeTpuSettingsT>(new EdgeTpuSettingsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void EdgeTpuSettings::UnPackTo(EdgeTpuSettingsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void EdgeTpuSettings::UnPackTo(EdgeTpuSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = inference_power_state(); _o->inference_power_state = _e; }", "-  { auto _e = inactive_power_configs(); if (_e) { _o->inactive_power_configs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->inactive_power_configs[_i]) { _e->Get(_i)->UnPackTo(_o->inactive_power_configs[_i].get(), _resolver); } else { _o->inactive_power_configs[_i] = std::unique_ptr<tflite::EdgeTpuInactivePowerConfigT>(_e->Get(_i)->UnPack(_resolver)); }; } } }", "+  { auto _e = inactive_power_configs(); if (_e) { _o->inactive_power_configs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->inactive_power_configs[_i]) { _e->Get(_i)->UnPackTo(_o->inactive_power_configs[_i].get(), _resolver); } else { _o->inactive_power_configs[_i] = std::unique_ptr<tflite::EdgeTpuInactivePowerConfigT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->inactive_power_configs.resize(0); } }", "   { auto _e = inference_priority(); _o->inference_priority = _e; }", "-  { auto _e = edgetpu_device_spec(); if (_e) { if(_o->edgetpu_device_spec) { _e->UnPackTo(_o->edgetpu_device_spec.get(), _resolver); } else { _o->edgetpu_device_spec = std::unique_ptr<tflite::EdgeTpuDeviceSpecT>(_e->UnPack(_resolver)); } } }", "+  { auto _e = edgetpu_device_spec(); if (_e) { if(_o->edgetpu_device_spec) { _e->UnPackTo(_o->edgetpu_device_spec.get(), _resolver); } else { _o->edgetpu_device_spec = std::unique_ptr<tflite::EdgeTpuDeviceSpecT>(_e->UnPack(_resolver)); } } else if (_o->edgetpu_device_spec) { _o->edgetpu_device_spec.reset(); } }", "   { auto _e = model_token(); if (_e) _o->model_token = _e->str(); }", "   { auto _e = float_truncation_type(); _o->float_truncation_type = _e; }", "   { auto _e = qos_class(); _o->qos_class = _e; }", "-  { auto _e = hardware_cluster_ids(); if (_e) { _o->hardware_cluster_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->hardware_cluster_ids[_i] = _e->Get(_i); } } }", "+  { auto _e = hardware_cluster_ids(); if (_e) { _o->hardware_cluster_ids.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->hardware_cluster_ids[_i] = _e->Get(_i); } } else { _o->hardware_cluster_ids.resize(0); } }", "   { auto _e = public_model_id(); if (_e) _o->public_model_id = _e->str(); }", " }", " ", "-inline flatbuffers::Offset<EdgeTpuSettings> EdgeTpuSettings::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<EdgeTpuSettings> EdgeTpuSettings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateEdgeTpuSettings(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<EdgeTpuSettings> CreateEdgeTpuSettings(flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<EdgeTpuSettings> CreateEdgeTpuSettings(::flatbuffers::FlatBufferBuilder &_fbb, const EdgeTpuSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EdgeTpuSettingsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EdgeTpuSettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _inference_power_state = _o->inference_power_state;", "-  auto _inactive_power_configs = _o->inactive_power_configs.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::EdgeTpuInactivePowerConfig>> (_o->inactive_power_configs.size(), [](size_t i, _VectorArgs *__va) { return CreateEdgeTpuInactivePowerConfig(*__va->__fbb, __va->__o->inactive_power_configs[i].get(), __va->__rehasher); }, &_va ) : 0;", "+  auto _inactive_power_configs = _o->inactive_power_configs.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::EdgeTpuInactivePowerConfig>> (_o->inactive_power_configs.size(), [](size_t i, _VectorArgs *__va) { return CreateEdgeTpuInactivePowerConfig(*__va->__fbb, __va->__o->inactive_power_configs[i].get(), __va->__rehasher); }, &_va ) : 0;", "   auto _inference_priority = _o->inference_priority;", "   auto _edgetpu_device_spec = _o->edgetpu_device_spec ? CreateEdgeTpuDeviceSpec(_fbb, _o->edgetpu_device_spec.get(), _rehasher) : 0;", "   auto _model_token = _o->model_token.empty() ? 0 : _fbb.CreateString(_o->model_token);", "@@ -4633,13 +4640,13 @@ inline bool operator!=(const GoogleEdgeTpuSettingsT &lhs, const GoogleEdgeTpuSet", " }", " ", " ", "-inline GoogleEdgeTpuSettingsT *GoogleEdgeTpuSettings::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline GoogleEdgeTpuSettingsT *GoogleEdgeTpuSettings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<GoogleEdgeTpuSettingsT>(new GoogleEdgeTpuSettingsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void GoogleEdgeTpuSettings::UnPackTo(GoogleEdgeTpuSettingsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void GoogleEdgeTpuSettings::UnPackTo(GoogleEdgeTpuSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = log_verbosity(); _o->log_verbosity = _e; }", "@@ -4649,14 +4656,14 @@ inline void GoogleEdgeTpuSettings::UnPackTo(GoogleEdgeTpuSettingsT *_o, const fl", "   { auto _e = model_identifier(); if (_e) _o->model_identifier = _e->str(); }", " }", " ", "-inline flatbuffers::Offset<GoogleEdgeTpuSettings> GoogleEdgeTpuSettings::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GoogleEdgeTpuSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<GoogleEdgeTpuSettings> GoogleEdgeTpuSettings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GoogleEdgeTpuSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateGoogleEdgeTpuSettings(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<GoogleEdgeTpuSettings> CreateGoogleEdgeTpuSettings(flatbuffers::FlatBufferBuilder &_fbb, const GoogleEdgeTpuSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<GoogleEdgeTpuSettings> CreateGoogleEdgeTpuSettings(::flatbuffers::FlatBufferBuilder &_fbb, const GoogleEdgeTpuSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GoogleEdgeTpuSettingsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GoogleEdgeTpuSettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _log_verbosity = _o->log_verbosity;", "   auto _enable_tracing = _o->enable_tracing;", "   auto _priority = _o->priority;", "@@ -4685,13 +4692,13 @@ inline bool operator!=(const CoralSettingsT &lhs, const CoralSettingsT &rhs) {", " }", " ", " ", "-inline CoralSettingsT *CoralSettings::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline CoralSettingsT *CoralSettings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<CoralSettingsT>(new CoralSettingsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void CoralSettings::UnPackTo(CoralSettingsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void CoralSettings::UnPackTo(CoralSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = device(); if (_e) _o->device = _e->str(); }", "@@ -4700,14 +4707,14 @@ inline void CoralSettings::UnPackTo(CoralSettingsT *_o, const flatbuffers::resol", "   { auto _e = usb_max_bulk_in_queue_length(); _o->usb_max_bulk_in_queue_length = _e; }", " }", " ", "-inline flatbuffers::Offset<CoralSettings> CoralSettings::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CoralSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<CoralSettings> CoralSettings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CoralSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateCoralSettings(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<CoralSettings> CreateCoralSettings(flatbuffers::FlatBufferBuilder &_fbb, const CoralSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<CoralSettings> CreateCoralSettings(::flatbuffers::FlatBufferBuilder &_fbb, const CoralSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CoralSettingsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CoralSettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _device = _o->device.empty() ? 0 : _fbb.CreateString(_o->device);", "   auto _performance = _o->performance;", "   auto _usb_always_dfu = _o->usb_always_dfu;", "@@ -4731,26 +4738,26 @@ inline bool operator!=(const CPUSettingsT &lhs, const CPUSettingsT &rhs) {", " }", " ", " ", "-inline CPUSettingsT *CPUSettings::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline CPUSettingsT *CPUSettings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<CPUSettingsT>(new CPUSettingsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void CPUSettings::UnPackTo(CPUSettingsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void CPUSettings::UnPackTo(CPUSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = num_threads(); _o->num_threads = _e; }", " }", " ", "-inline flatbuffers::Offset<CPUSettings> CPUSettings::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CPUSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<CPUSettings> CPUSettings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CPUSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateCPUSettings(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<CPUSettings> CreateCPUSettings(flatbuffers::FlatBufferBuilder &_fbb, const CPUSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<CPUSettings> CreateCPUSettings(::flatbuffers::FlatBufferBuilder &_fbb, const CPUSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CPUSettingsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CPUSettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _num_threads = _o->num_threads;", "   return tflite::CreateCPUSettings(", "       _fbb,", "@@ -4819,40 +4826,40 @@ inline TFLiteSettingsT &TFLiteSettingsT::operator=(TFLiteSettingsT o) FLATBUFFER", "   return *this;", " }", " ", "-inline TFLiteSettingsT *TFLiteSettings::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline TFLiteSettingsT *TFLiteSettings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<TFLiteSettingsT>(new TFLiteSettingsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void TFLiteSettings::UnPackTo(TFLiteSettingsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void TFLiteSettings::UnPackTo(TFLiteSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = delegate(); _o->delegate = _e; }", "-  { auto _e = nnapi_settings(); if (_e) { if(_o->nnapi_settings) { _e->UnPackTo(_o->nnapi_settings.get(), _resolver); } else { _o->nnapi_settings = std::unique_ptr<tflite::NNAPISettingsT>(_e->UnPack(_resolver)); } } }", "-  { auto _e = gpu_settings(); if (_e) { if(_o->gpu_settings) { _e->UnPackTo(_o->gpu_settings.get(), _resolver); } else { _o->gpu_settings = std::unique_ptr<tflite::GPUSettingsT>(_e->UnPack(_resolver)); } } }", "-  { auto _e = hexagon_settings(); if (_e) { if(_o->hexagon_settings) { _e->UnPackTo(_o->hexagon_settings.get(), _resolver); } else { _o->hexagon_settings = std::unique_ptr<tflite::HexagonSettingsT>(_e->UnPack(_resolver)); } } }", "-  { auto _e = xnnpack_settings(); if (_e) { if(_o->xnnpack_settings) { _e->UnPackTo(_o->xnnpack_settings.get(), _resolver); } else { _o->xnnpack_settings = std::unique_ptr<tflite::XNNPackSettingsT>(_e->UnPack(_resolver)); } } }", "-  { auto _e = coreml_settings(); if (_e) { if(_o->coreml_settings) { _e->UnPackTo(_o->coreml_settings.get(), _resolver); } else { _o->coreml_settings = std::unique_ptr<tflite::CoreMLSettingsT>(_e->UnPack(_resolver)); } } }", "-  { auto _e = cpu_settings(); if (_e) { if(_o->cpu_settings) { _e->UnPackTo(_o->cpu_settings.get(), _resolver); } else { _o->cpu_settings = std::unique_ptr<tflite::CPUSettingsT>(_e->UnPack(_resolver)); } } }", "+  { auto _e = nnapi_settings(); if (_e) { if(_o->nnapi_settings) { _e->UnPackTo(_o->nnapi_settings.get(), _resolver); } else { _o->nnapi_settings = std::unique_ptr<tflite::NNAPISettingsT>(_e->UnPack(_resolver)); } } else if (_o->nnapi_settings) { _o->nnapi_settings.reset(); } }", "+  { auto _e = gpu_settings(); if (_e) { if(_o->gpu_settings) { _e->UnPackTo(_o->gpu_settings.get(), _resolver); } else { _o->gpu_settings = std::unique_ptr<tflite::GPUSettingsT>(_e->UnPack(_resolver)); } } else if (_o->gpu_settings) { _o->gpu_settings.reset(); } }", "+  { auto _e = hexagon_settings(); if (_e) { if(_o->hexagon_settings) { _e->UnPackTo(_o->hexagon_settings.get(), _resolver); } else { _o->hexagon_settings = std::unique_ptr<tflite::HexagonSettingsT>(_e->UnPack(_resolver)); } } else if (_o->hexagon_settings) { _o->hexagon_settings.reset(); } }", "+  { auto _e = xnnpack_settings(); if (_e) { if(_o->xnnpack_settings) { _e->UnPackTo(_o->xnnpack_settings.get(), _resolver); } else { _o->xnnpack_settings = std::unique_ptr<tflite::XNNPackSettingsT>(_e->UnPack(_resolver)); } } else if (_o->xnnpack_settings) { _o->xnnpack_settings.reset(); } }", "+  { auto _e = coreml_settings(); if (_e) { if(_o->coreml_settings) { _e->UnPackTo(_o->coreml_settings.get(), _resolver); } else { _o->coreml_settings = std::unique_ptr<tflite::CoreMLSettingsT>(_e->UnPack(_resolver)); } } else if (_o->coreml_settings) { _o->coreml_settings.reset(); } }", "+  { auto _e = cpu_settings(); if (_e) { if(_o->cpu_settings) { _e->UnPackTo(_o->cpu_settings.get(), _resolver); } else { _o->cpu_settings = std::unique_ptr<tflite::CPUSettingsT>(_e->UnPack(_resolver)); } } else if (_o->cpu_settings) { _o->cpu_settings.reset(); } }", "   { auto _e = max_delegated_partitions(); _o->max_delegated_partitions = _e; }", "-  { auto _e = edgetpu_settings(); if (_e) { if(_o->edgetpu_settings) { _e->UnPackTo(_o->edgetpu_settings.get(), _resolver); } else { _o->edgetpu_settings = std::unique_ptr<tflite::EdgeTpuSettingsT>(_e->UnPack(_resolver)); } } }", "-  { auto _e = coral_settings(); if (_e) { if(_o->coral_settings) { _e->UnPackTo(_o->coral_settings.get(), _resolver); } else { _o->coral_settings = std::unique_ptr<tflite::CoralSettingsT>(_e->UnPack(_resolver)); } } }", "-  { auto _e = fallback_settings(); if (_e) { if(_o->fallback_settings) { _e->UnPackTo(_o->fallback_settings.get(), _resolver); } else { _o->fallback_settings = std::unique_ptr<tflite::FallbackSettingsT>(_e->UnPack(_resolver)); } } }", "+  { auto _e = edgetpu_settings(); if (_e) { if(_o->edgetpu_settings) { _e->UnPackTo(_o->edgetpu_settings.get(), _resolver); } else { _o->edgetpu_settings = std::unique_ptr<tflite::EdgeTpuSettingsT>(_e->UnPack(_resolver)); } } else if (_o->edgetpu_settings) { _o->edgetpu_settings.reset(); } }", "+  { auto _e = coral_settings(); if (_e) { if(_o->coral_settings) { _e->UnPackTo(_o->coral_settings.get(), _resolver); } else { _o->coral_settings = std::unique_ptr<tflite::CoralSettingsT>(_e->UnPack(_resolver)); } } else if (_o->coral_settings) { _o->coral_settings.reset(); } }", "+  { auto _e = fallback_settings(); if (_e) { if(_o->fallback_settings) { _e->UnPackTo(_o->fallback_settings.get(), _resolver); } else { _o->fallback_settings = std::unique_ptr<tflite::FallbackSettingsT>(_e->UnPack(_resolver)); } } else if (_o->fallback_settings) { _o->fallback_settings.reset(); } }", "   { auto _e = disable_default_delegates(); _o->disable_default_delegates = _e; }", "-  { auto _e = stable_delegate_loader_settings(); if (_e) { if(_o->stable_delegate_loader_settings) { _e->UnPackTo(_o->stable_delegate_loader_settings.get(), _resolver); } else { _o->stable_delegate_loader_settings = std::unique_ptr<tflite::StableDelegateLoaderSettingsT>(_e->UnPack(_resolver)); } } }", "-  { auto _e = google_edgetpu_settings(); if (_e) { if(_o->google_edgetpu_settings) { _e->UnPackTo(_o->google_edgetpu_settings.get(), _resolver); } else { _o->google_edgetpu_settings = std::unique_ptr<tflite::GoogleEdgeTpuSettingsT>(_e->UnPack(_resolver)); } } }", "-  { auto _e = compilation_caching_settings(); if (_e) { if(_o->compilation_caching_settings) { _e->UnPackTo(_o->compilation_caching_settings.get(), _resolver); } else { _o->compilation_caching_settings = std::unique_ptr<tflite::CompilationCachingSettingsT>(_e->UnPack(_resolver)); } } }", "+  { auto _e = stable_delegate_loader_settings(); if (_e) { if(_o->stable_delegate_loader_settings) { _e->UnPackTo(_o->stable_delegate_loader_settings.get(), _resolver); } else { _o->stable_delegate_loader_settings = std::unique_ptr<tflite::StableDelegateLoaderSettingsT>(_e->UnPack(_resolver)); } } else if (_o->stable_delegate_loader_settings) { _o->stable_delegate_loader_settings.reset(); } }", "+  { auto _e = google_edgetpu_settings(); if (_e) { if(_o->google_edgetpu_settings) { _e->UnPackTo(_o->google_edgetpu_settings.get(), _resolver); } else { _o->google_edgetpu_settings = std::unique_ptr<tflite::GoogleEdgeTpuSettingsT>(_e->UnPack(_resolver)); } } else if (_o->google_edgetpu_settings) { _o->google_edgetpu_settings.reset(); } }", "+  { auto _e = compilation_caching_settings(); if (_e) { if(_o->compilation_caching_settings) { _e->UnPackTo(_o->compilation_caching_settings.get(), _resolver); } else { _o->compilation_caching_settings = std::unique_ptr<tflite::CompilationCachingSettingsT>(_e->UnPack(_resolver)); } } else if (_o->compilation_caching_settings) { _o->compilation_caching_settings.reset(); } }", " }", " ", "-inline flatbuffers::Offset<TFLiteSettings> TFLiteSettings::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TFLiteSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<TFLiteSettings> TFLiteSettings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TFLiteSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateTFLiteSettings(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<TFLiteSettings> CreateTFLiteSettings(flatbuffers::FlatBufferBuilder &_fbb, const TFLiteSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<TFLiteSettings> CreateTFLiteSettings(::flatbuffers::FlatBufferBuilder &_fbb, const TFLiteSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TFLiteSettingsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TFLiteSettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _delegate = _o->delegate;", "   auto _nnapi_settings = _o->nnapi_settings ? CreateNNAPISettings(_fbb, _o->nnapi_settings.get(), _rehasher) : 0;", "   auto _gpu_settings = _o->gpu_settings ? CreateGPUSettings(_fbb, _o->gpu_settings.get(), _rehasher) : 0;", "@@ -4899,27 +4906,27 @@ inline bool operator!=(const FallbackSettingsT &lhs, const FallbackSettingsT &rh", " }", " ", " ", "-inline FallbackSettingsT *FallbackSettings::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline FallbackSettingsT *FallbackSettings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<FallbackSettingsT>(new FallbackSettingsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void FallbackSettings::UnPackTo(FallbackSettingsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void FallbackSettings::UnPackTo(FallbackSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = allow_automatic_fallback_on_compilation_error(); _o->allow_automatic_fallback_on_compilation_error = _e; }", "   { auto _e = allow_automatic_fallback_on_execution_error(); _o->allow_automatic_fallback_on_execution_error = _e; }", " }", " ", "-inline flatbuffers::Offset<FallbackSettings> FallbackSettings::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FallbackSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<FallbackSettings> FallbackSettings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FallbackSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateFallbackSettings(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<FallbackSettings> CreateFallbackSettings(flatbuffers::FlatBufferBuilder &_fbb, const FallbackSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<FallbackSettings> CreateFallbackSettings(::flatbuffers::FlatBufferBuilder &_fbb, const FallbackSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FallbackSettingsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FallbackSettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _allow_automatic_fallback_on_compilation_error = _o->allow_automatic_fallback_on_compilation_error;", "   auto _allow_automatic_fallback_on_execution_error = _o->allow_automatic_fallback_on_execution_error;", "   return tflite::CreateFallbackSettings(", "@@ -4940,27 +4947,27 @@ inline bool operator!=(const BenchmarkMetricT &lhs, const BenchmarkMetricT &rhs)", " }", " ", " ", "-inline BenchmarkMetricT *BenchmarkMetric::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline BenchmarkMetricT *BenchmarkMetric::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<BenchmarkMetricT>(new BenchmarkMetricT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void BenchmarkMetric::UnPackTo(BenchmarkMetricT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void BenchmarkMetric::UnPackTo(BenchmarkMetricT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = name(); if (_e) _o->name = _e->str(); }", "-  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } }", "+  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } else { _o->values.resize(0); } }", " }", " ", "-inline flatbuffers::Offset<BenchmarkMetric> BenchmarkMetric::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkMetricT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BenchmarkMetric> BenchmarkMetric::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkMetricT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateBenchmarkMetric(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<BenchmarkMetric> CreateBenchmarkMetric(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkMetricT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BenchmarkMetric> CreateBenchmarkMetric(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkMetricT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BenchmarkMetricT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BenchmarkMetricT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);", "   auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;", "   return tflite::CreateBenchmarkMetric(", "@@ -4976,8 +4983,8 @@ inline bool operator==(const BenchmarkResultT &lhs, const BenchmarkResultT &rhs)", "       (lhs.inference_time_us == rhs.inference_time_us) &&", "       (lhs.max_memory_kb == rhs.max_memory_kb) &&", "       (lhs.ok == rhs.ok) &&", "-      (lhs.metrics == rhs.metrics) &&", "-      (lhs.actual_output == rhs.actual_output);", "+      (lhs.metrics.size() == rhs.metrics.size() && std::equal(lhs.metrics.cbegin(), lhs.metrics.cend(), rhs.metrics.cbegin(), [](std::unique_ptr<tflite::BenchmarkMetricT> const &a, std::unique_ptr<tflite::BenchmarkMetricT> const &b) { return (a == b) || (a && b && *a == *b); })) &&", "+      (lhs.actual_output.size() == rhs.actual_output.size() && std::equal(lhs.actual_output.cbegin(), lhs.actual_output.cend(), rhs.actual_output.cbegin(), [](std::unique_ptr<tflite::BenchmarkResult_::InferenceOutputT> const &a, std::unique_ptr<tflite::BenchmarkResult_::InferenceOutputT> const &b) { return (a == b) || (a && b && *a == *b); }));", " }", " ", " inline bool operator!=(const BenchmarkResultT &lhs, const BenchmarkResultT &rhs) {", "@@ -4991,9 +4998,9 @@ inline BenchmarkResultT::BenchmarkResultT(const BenchmarkResultT &o)", "         max_memory_kb(o.max_memory_kb),", "         ok(o.ok) {", "   metrics.reserve(o.metrics.size());", "-  for (const auto &v : o.metrics) { metrics.emplace_back((v) ? new tflite::BenchmarkMetricT(*v) : nullptr); }", "+  for (const auto &metrics_ : o.metrics) { metrics.emplace_back((metrics_) ? new tflite::BenchmarkMetricT(*metrics_) : nullptr); }", "   actual_output.reserve(o.actual_output.size());", "-  for (const auto &v : o.actual_output) { actual_output.emplace_back((v) ? new tflite::BenchmarkResult_::InferenceOutputT(*v) : nullptr); }", "+  for (const auto &actual_output_ : o.actual_output) { actual_output.emplace_back((actual_output_) ? new tflite::BenchmarkResult_::InferenceOutputT(*actual_output_) : nullptr); }", " }", " ", " inline BenchmarkResultT &BenchmarkResultT::operator=(BenchmarkResultT o) FLATBUFFERS_NOEXCEPT {", "@@ -5006,37 +5013,37 @@ inline BenchmarkResultT &BenchmarkResultT::operator=(BenchmarkResultT o) FLATBUF", "   return *this;", " }", " ", "-inline BenchmarkResultT *BenchmarkResult::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline BenchmarkResultT *BenchmarkResult::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<BenchmarkResultT>(new BenchmarkResultT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void BenchmarkResult::UnPackTo(BenchmarkResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void BenchmarkResult::UnPackTo(BenchmarkResultT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "-  { auto _e = initialization_time_us(); if (_e) { _o->initialization_time_us.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->initialization_time_us[_i] = _e->Get(_i); } } }", "-  { auto _e = inference_time_us(); if (_e) { _o->inference_time_us.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inference_time_us[_i] = _e->Get(_i); } } }", "+  { auto _e = initialization_time_us(); if (_e) { _o->initialization_time_us.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->initialization_time_us[_i] = _e->Get(_i); } } else { _o->initialization_time_us.resize(0); } }", "+  { auto _e = inference_time_us(); if (_e) { _o->inference_time_us.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inference_time_us[_i] = _e->Get(_i); } } else { _o->inference_time_us.resize(0); } }", "   { auto _e = max_memory_kb(); _o->max_memory_kb = _e; }", "   { auto _e = ok(); _o->ok = _e; }", "-  { auto _e = metrics(); if (_e) { _o->metrics.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->metrics[_i]) { _e->Get(_i)->UnPackTo(_o->metrics[_i].get(), _resolver); } else { _o->metrics[_i] = std::unique_ptr<tflite::BenchmarkMetricT>(_e->Get(_i)->UnPack(_resolver)); }; } } }", "-  { auto _e = actual_output(); if (_e) { _o->actual_output.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->actual_output[_i]) { _e->Get(_i)->UnPackTo(_o->actual_output[_i].get(), _resolver); } else { _o->actual_output[_i] = std::unique_ptr<tflite::BenchmarkResult_::InferenceOutputT>(_e->Get(_i)->UnPack(_resolver)); }; } } }", "+  { auto _e = metrics(); if (_e) { _o->metrics.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->metrics[_i]) { _e->Get(_i)->UnPackTo(_o->metrics[_i].get(), _resolver); } else { _o->metrics[_i] = std::unique_ptr<tflite::BenchmarkMetricT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->metrics.resize(0); } }", "+  { auto _e = actual_output(); if (_e) { _o->actual_output.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->actual_output[_i]) { _e->Get(_i)->UnPackTo(_o->actual_output[_i].get(), _resolver); } else { _o->actual_output[_i] = std::unique_ptr<tflite::BenchmarkResult_::InferenceOutputT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->actual_output.resize(0); } }", " }", " ", "-inline flatbuffers::Offset<BenchmarkResult> BenchmarkResult::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkResultT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BenchmarkResult> BenchmarkResult::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkResultT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateBenchmarkResult(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<BenchmarkResult> CreateBenchmarkResult(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BenchmarkResult> CreateBenchmarkResult(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkResultT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BenchmarkResultT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BenchmarkResultT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _initialization_time_us = _o->initialization_time_us.size() ? _fbb.CreateVector(_o->initialization_time_us) : 0;", "   auto _inference_time_us = _o->inference_time_us.size() ? _fbb.CreateVector(_o->inference_time_us) : 0;", "   auto _max_memory_kb = _o->max_memory_kb;", "   auto _ok = _o->ok;", "-  auto _metrics = _o->metrics.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::BenchmarkMetric>> (_o->metrics.size(), [](size_t i, _VectorArgs *__va) { return CreateBenchmarkMetric(*__va->__fbb, __va->__o->metrics[i].get(), __va->__rehasher); }, &_va ) : 0;", "-  auto _actual_output = _o->actual_output.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::BenchmarkResult_::InferenceOutput>> (_o->actual_output.size(), [](size_t i, _VectorArgs *__va) { return CreateInferenceOutput(*__va->__fbb, __va->__o->actual_output[i].get(), __va->__rehasher); }, &_va ) : 0;", "+  auto _metrics = _o->metrics.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::BenchmarkMetric>> (_o->metrics.size(), [](size_t i, _VectorArgs *__va) { return CreateBenchmarkMetric(*__va->__fbb, __va->__o->metrics[i].get(), __va->__rehasher); }, &_va ) : 0;", "+  auto _actual_output = _o->actual_output.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::BenchmarkResult_::InferenceOutput>> (_o->actual_output.size(), [](size_t i, _VectorArgs *__va) { return CreateInferenceOutput(*__va->__fbb, __va->__o->actual_output[i].get(), __va->__rehasher); }, &_va ) : 0;", "   return tflite::CreateBenchmarkResult(", "       _fbb,", "       _initialization_time_us,", "@@ -5060,26 +5067,26 @@ inline bool operator!=(const InferenceOutputT &lhs, const InferenceOutputT &rhs)", " }", " ", " ", "-inline InferenceOutputT *InferenceOutput::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline InferenceOutputT *InferenceOutput::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<InferenceOutputT>(new InferenceOutputT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void InferenceOutput::UnPackTo(InferenceOutputT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void InferenceOutput::UnPackTo(InferenceOutputT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = value(); if (_e) { _o->value.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->value.begin()); } }", " }", " ", "-inline flatbuffers::Offset<InferenceOutput> InferenceOutput::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InferenceOutputT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<InferenceOutput> InferenceOutput::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InferenceOutputT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateInferenceOutput(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<InferenceOutput> CreateInferenceOutput(flatbuffers::FlatBufferBuilder &_fbb, const InferenceOutputT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<InferenceOutput> CreateInferenceOutput(::flatbuffers::FlatBufferBuilder &_fbb, const InferenceOutputT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InferenceOutputT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const InferenceOutputT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;", "   return tflite::BenchmarkResult_::CreateInferenceOutput(", "       _fbb,", "@@ -5101,13 +5108,13 @@ inline bool operator!=(const ErrorCodeT &lhs, const ErrorCodeT &rhs) {", " }", " ", " ", "-inline ErrorCodeT *ErrorCode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ErrorCodeT *ErrorCode::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ErrorCodeT>(new ErrorCodeT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ErrorCode::UnPackTo(ErrorCodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ErrorCode::UnPackTo(ErrorCodeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = source(); _o->source = _e; }", "@@ -5115,14 +5122,14 @@ inline void ErrorCode::UnPackTo(ErrorCodeT *_o, const flatbuffers::resolver_func", "   { auto _e = underlying_api_error(); _o->underlying_api_error = _e; }", " }", " ", "-inline flatbuffers::Offset<ErrorCode> ErrorCode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorCodeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ErrorCode> ErrorCode::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorCodeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateErrorCode(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ErrorCode> CreateErrorCode(flatbuffers::FlatBufferBuilder &_fbb, const ErrorCodeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ErrorCode> CreateErrorCode(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorCodeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ErrorCodeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ErrorCodeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _source = _o->source;", "   auto _tflite_error = _o->tflite_error;", "   auto _underlying_api_error = _o->underlying_api_error;", "@@ -5139,7 +5146,7 @@ inline bool operator==(const BenchmarkErrorT &lhs, const BenchmarkErrorT &rhs) {", "       (lhs.stage == rhs.stage) &&", "       (lhs.exit_code == rhs.exit_code) &&", "       (lhs.signal == rhs.signal) &&", "-      (lhs.error_code == rhs.error_code) &&", "+      (lhs.error_code.size() == rhs.error_code.size() && std::equal(lhs.error_code.cbegin(), lhs.error_code.cend(), rhs.error_code.cbegin(), [](std::unique_ptr<tflite::ErrorCodeT> const &a, std::unique_ptr<tflite::ErrorCodeT> const &b) { return (a == b) || (a && b && *a == *b); })) &&", "       (lhs.mini_benchmark_error_code == rhs.mini_benchmark_error_code);", " }", " ", "@@ -5154,7 +5161,7 @@ inline BenchmarkErrorT::BenchmarkErrorT(const BenchmarkErrorT &o)", "         signal(o.signal),", "         mini_benchmark_error_code(o.mini_benchmark_error_code) {", "   error_code.reserve(o.error_code.size());", "-  for (const auto &v : o.error_code) { error_code.emplace_back((v) ? new tflite::ErrorCodeT(*v) : nullptr); }", "+  for (const auto &error_code_ : o.error_code) { error_code.emplace_back((error_code_) ? new tflite::ErrorCodeT(*error_code_) : nullptr); }", " }", " ", " inline BenchmarkErrorT &BenchmarkErrorT::operator=(BenchmarkErrorT o) FLATBUFFERS_NOEXCEPT {", "@@ -5166,34 +5173,34 @@ inline BenchmarkErrorT &BenchmarkErrorT::operator=(BenchmarkErrorT o) FLATBUFFER", "   return *this;", " }", " ", "-inline BenchmarkErrorT *BenchmarkError::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline BenchmarkErrorT *BenchmarkError::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<BenchmarkErrorT>(new BenchmarkErrorT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void BenchmarkError::UnPackTo(BenchmarkErrorT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void BenchmarkError::UnPackTo(BenchmarkErrorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = stage(); _o->stage = _e; }", "   { auto _e = exit_code(); _o->exit_code = _e; }", "   { auto _e = signal(); _o->signal = _e; }", "-  { auto _e = error_code(); if (_e) { _o->error_code.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->error_code[_i]) { _e->Get(_i)->UnPackTo(_o->error_code[_i].get(), _resolver); } else { _o->error_code[_i] = std::unique_ptr<tflite::ErrorCodeT>(_e->Get(_i)->UnPack(_resolver)); }; } } }", "+  { auto _e = error_code(); if (_e) { _o->error_code.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->error_code[_i]) { _e->Get(_i)->UnPackTo(_o->error_code[_i].get(), _resolver); } else { _o->error_code[_i] = std::unique_ptr<tflite::ErrorCodeT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->error_code.resize(0); } }", "   { auto _e = mini_benchmark_error_code(); _o->mini_benchmark_error_code = _e; }", " }", " ", "-inline flatbuffers::Offset<BenchmarkError> BenchmarkError::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BenchmarkError> BenchmarkError::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkErrorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateBenchmarkError(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<BenchmarkError> CreateBenchmarkError(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BenchmarkError> CreateBenchmarkError(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkErrorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BenchmarkErrorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BenchmarkErrorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _stage = _o->stage;", "   auto _exit_code = _o->exit_code;", "   auto _signal = _o->signal;", "-  auto _error_code = _o->error_code.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::ErrorCode>> (_o->error_code.size(), [](size_t i, _VectorArgs *__va) { return CreateErrorCode(*__va->__fbb, __va->__o->error_code[i].get(), __va->__rehasher); }, &_va ) : 0;", "+  auto _error_code = _o->error_code.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::ErrorCode>> (_o->error_code.size(), [](size_t i, _VectorArgs *__va) { return CreateErrorCode(*__va->__fbb, __va->__o->error_code[i].get(), __va->__rehasher); }, &_va ) : 0;", "   auto _mini_benchmark_error_code = _o->mini_benchmark_error_code;", "   return tflite::CreateBenchmarkError(", "       _fbb,", "@@ -5239,31 +5246,31 @@ inline BenchmarkEventT &BenchmarkEventT::operator=(BenchmarkEventT o) FLATBUFFER", "   return *this;", " }", " ", "-inline BenchmarkEventT *BenchmarkEvent::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline BenchmarkEventT *BenchmarkEvent::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<BenchmarkEventT>(new BenchmarkEventT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void BenchmarkEvent::UnPackTo(BenchmarkEventT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void BenchmarkEvent::UnPackTo(BenchmarkEventT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "-  { auto _e = tflite_settings(); if (_e) { if(_o->tflite_settings) { _e->UnPackTo(_o->tflite_settings.get(), _resolver); } else { _o->tflite_settings = std::unique_ptr<tflite::TFLiteSettingsT>(_e->UnPack(_resolver)); } } }", "+  { auto _e = tflite_settings(); if (_e) { if(_o->tflite_settings) { _e->UnPackTo(_o->tflite_settings.get(), _resolver); } else { _o->tflite_settings = std::unique_ptr<tflite::TFLiteSettingsT>(_e->UnPack(_resolver)); } } else if (_o->tflite_settings) { _o->tflite_settings.reset(); } }", "   { auto _e = event_type(); _o->event_type = _e; }", "-  { auto _e = result(); if (_e) { if(_o->result) { _e->UnPackTo(_o->result.get(), _resolver); } else { _o->result = std::unique_ptr<tflite::BenchmarkResultT>(_e->UnPack(_resolver)); } } }", "-  { auto _e = error(); if (_e) { if(_o->error) { _e->UnPackTo(_o->error.get(), _resolver); } else { _o->error = std::unique_ptr<tflite::BenchmarkErrorT>(_e->UnPack(_resolver)); } } }", "+  { auto _e = result(); if (_e) { if(_o->result) { _e->UnPackTo(_o->result.get(), _resolver); } else { _o->result = std::unique_ptr<tflite::BenchmarkResultT>(_e->UnPack(_resolver)); } } else if (_o->result) { _o->result.reset(); } }", "+  { auto _e = error(); if (_e) { if(_o->error) { _e->UnPackTo(_o->error.get(), _resolver); } else { _o->error = std::unique_ptr<tflite::BenchmarkErrorT>(_e->UnPack(_resolver)); } } else if (_o->error) { _o->error.reset(); } }", "   { auto _e = boottime_us(); _o->boottime_us = _e; }", "   { auto _e = wallclock_us(); _o->wallclock_us = _e; }", " }", " ", "-inline flatbuffers::Offset<BenchmarkEvent> BenchmarkEvent::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkEventT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BenchmarkEvent> BenchmarkEvent::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateBenchmarkEvent(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<BenchmarkEvent> CreateBenchmarkEvent(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkEventT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BenchmarkEvent> CreateBenchmarkEvent(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BenchmarkEventT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BenchmarkEventT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _tflite_settings = _o->tflite_settings ? CreateTFLiteSettings(_fbb, _o->tflite_settings.get(), _rehasher) : 0;", "   auto _event_type = _o->event_type;", "   auto _result = _o->result ? CreateBenchmarkResult(_fbb, _o->result.get(), _rehasher) : 0;", "@@ -5306,28 +5313,28 @@ inline BestAccelerationDecisionT &BestAccelerationDecisionT::operator=(BestAccel", "   return *this;", " }", " ", "-inline BestAccelerationDecisionT *BestAccelerationDecision::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline BestAccelerationDecisionT *BestAccelerationDecision::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<BestAccelerationDecisionT>(new BestAccelerationDecisionT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void BestAccelerationDecision::UnPackTo(BestAccelerationDecisionT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void BestAccelerationDecision::UnPackTo(BestAccelerationDecisionT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = number_of_source_events(); _o->number_of_source_events = _e; }", "-  { auto _e = min_latency_event(); if (_e) { if(_o->min_latency_event) { _e->UnPackTo(_o->min_latency_event.get(), _resolver); } else { _o->min_latency_event = std::unique_ptr<tflite::BenchmarkEventT>(_e->UnPack(_resolver)); } } }", "+  { auto _e = min_latency_event(); if (_e) { if(_o->min_latency_event) { _e->UnPackTo(_o->min_latency_event.get(), _resolver); } else { _o->min_latency_event = std::unique_ptr<tflite::BenchmarkEventT>(_e->UnPack(_resolver)); } } else if (_o->min_latency_event) { _o->min_latency_event.reset(); } }", "   { auto _e = min_inference_time_us(); _o->min_inference_time_us = _e; }", " }", " ", "-inline flatbuffers::Offset<BestAccelerationDecision> BestAccelerationDecision::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BestAccelerationDecisionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BestAccelerationDecision> BestAccelerationDecision::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BestAccelerationDecisionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateBestAccelerationDecision(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<BestAccelerationDecision> CreateBestAccelerationDecision(flatbuffers::FlatBufferBuilder &_fbb, const BestAccelerationDecisionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BestAccelerationDecision> CreateBestAccelerationDecision(::flatbuffers::FlatBufferBuilder &_fbb, const BestAccelerationDecisionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BestAccelerationDecisionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BestAccelerationDecisionT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _number_of_source_events = _o->number_of_source_events;", "   auto _min_latency_event = _o->min_latency_event ? CreateBenchmarkEvent(_fbb, _o->min_latency_event.get(), _rehasher) : 0;", "   auto _min_inference_time_us = _o->min_inference_time_us;", "@@ -5349,26 +5356,26 @@ inline bool operator!=(const BenchmarkInitializationFailureT &lhs, const Benchma", " }", " ", " ", "-inline BenchmarkInitializationFailureT *BenchmarkInitializationFailure::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline BenchmarkInitializationFailureT *BenchmarkInitializationFailure::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<BenchmarkInitializationFailureT>(new BenchmarkInitializationFailureT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void BenchmarkInitializationFailure::UnPackTo(BenchmarkInitializationFailureT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void BenchmarkInitializationFailure::UnPackTo(BenchmarkInitializationFailureT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = initialization_status(); _o->initialization_status = _e; }", " }", " ", "-inline flatbuffers::Offset<BenchmarkInitializationFailure> BenchmarkInitializationFailure::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkInitializationFailureT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BenchmarkInitializationFailure> BenchmarkInitializationFailure::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkInitializationFailureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateBenchmarkInitializationFailure(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<BenchmarkInitializationFailure> CreateBenchmarkInitializationFailure(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkInitializationFailureT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BenchmarkInitializationFailure> CreateBenchmarkInitializationFailure(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkInitializationFailureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BenchmarkInitializationFailureT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BenchmarkInitializationFailureT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _initialization_status = _o->initialization_status;", "   return tflite::CreateBenchmarkInitializationFailure(", "       _fbb,", "@@ -5404,29 +5411,29 @@ inline MiniBenchmarkEventT &MiniBenchmarkEventT::operator=(MiniBenchmarkEventT o", "   return *this;", " }", " ", "-inline MiniBenchmarkEventT *MiniBenchmarkEvent::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline MiniBenchmarkEventT *MiniBenchmarkEvent::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<MiniBenchmarkEventT>(new MiniBenchmarkEventT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void MiniBenchmarkEvent::UnPackTo(MiniBenchmarkEventT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void MiniBenchmarkEvent::UnPackTo(MiniBenchmarkEventT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = is_log_flushing_event(); _o->is_log_flushing_event = _e; }", "-  { auto _e = best_acceleration_decision(); if (_e) { if(_o->best_acceleration_decision) { _e->UnPackTo(_o->best_acceleration_decision.get(), _resolver); } else { _o->best_acceleration_decision = std::unique_ptr<tflite::BestAccelerationDecisionT>(_e->UnPack(_resolver)); } } }", "-  { auto _e = initialization_failure(); if (_e) { if(_o->initialization_failure) { _e->UnPackTo(_o->initialization_failure.get(), _resolver); } else { _o->initialization_failure = std::unique_ptr<tflite::BenchmarkInitializationFailureT>(_e->UnPack(_resolver)); } } }", "-  { auto _e = benchmark_event(); if (_e) { if(_o->benchmark_event) { _e->UnPackTo(_o->benchmark_event.get(), _resolver); } else { _o->benchmark_event = std::unique_ptr<tflite::BenchmarkEventT>(_e->UnPack(_resolver)); } } }", "+  { auto _e = best_acceleration_decision(); if (_e) { if(_o->best_acceleration_decision) { _e->UnPackTo(_o->best_acceleration_decision.get(), _resolver); } else { _o->best_acceleration_decision = std::unique_ptr<tflite::BestAccelerationDecisionT>(_e->UnPack(_resolver)); } } else if (_o->best_acceleration_decision) { _o->best_acceleration_decision.reset(); } }", "+  { auto _e = initialization_failure(); if (_e) { if(_o->initialization_failure) { _e->UnPackTo(_o->initialization_failure.get(), _resolver); } else { _o->initialization_failure = std::unique_ptr<tflite::BenchmarkInitializationFailureT>(_e->UnPack(_resolver)); } } else if (_o->initialization_failure) { _o->initialization_failure.reset(); } }", "+  { auto _e = benchmark_event(); if (_e) { if(_o->benchmark_event) { _e->UnPackTo(_o->benchmark_event.get(), _resolver); } else { _o->benchmark_event = std::unique_ptr<tflite::BenchmarkEventT>(_e->UnPack(_resolver)); } } else if (_o->benchmark_event) { _o->benchmark_event.reset(); } }", " }", " ", "-inline flatbuffers::Offset<MiniBenchmarkEvent> MiniBenchmarkEvent::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MiniBenchmarkEventT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<MiniBenchmarkEvent> MiniBenchmarkEvent::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MiniBenchmarkEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateMiniBenchmarkEvent(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<MiniBenchmarkEvent> CreateMiniBenchmarkEvent(flatbuffers::FlatBufferBuilder &_fbb, const MiniBenchmarkEventT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<MiniBenchmarkEvent> CreateMiniBenchmarkEvent(::flatbuffers::FlatBufferBuilder &_fbb, const MiniBenchmarkEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MiniBenchmarkEventT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MiniBenchmarkEventT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _is_log_flushing_event = _o->is_log_flushing_event;", "   auto _best_acceleration_decision = _o->best_acceleration_decision ? CreateBestAccelerationDecision(_fbb, _o->best_acceleration_decision.get(), _rehasher) : 0;", "   auto _initialization_failure = _o->initialization_failure ? CreateBenchmarkInitializationFailure(_fbb, _o->initialization_failure.get(), _rehasher) : 0;", "@@ -5474,31 +5481,31 @@ inline ModelFileT &ModelFileT::operator=(ModelFileT o) FLATBUFFERS_NOEXCEPT {", "   return *this;", " }", " ", "-inline ModelFileT *ModelFile::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ModelFileT *ModelFile::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ModelFileT>(new ModelFileT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ModelFile::UnPackTo(ModelFileT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ModelFile::UnPackTo(ModelFileT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = filename(); if (_e) _o->filename = _e->str(); }", "   { auto _e = fd(); _o->fd = _e; }", "   { auto _e = offset(); _o->offset = _e; }", "   { auto _e = length(); _o->length = _e; }", "-  { auto _e = model_id_group(); if (_e) { if(_o->model_id_group) { _e->UnPackTo(_o->model_id_group.get(), _resolver); } else { _o->model_id_group = std::unique_ptr<tflite::ModelIdGroupT>(_e->UnPack(_resolver)); } } }", "+  { auto _e = model_id_group(); if (_e) { if(_o->model_id_group) { _e->UnPackTo(_o->model_id_group.get(), _resolver); } else { _o->model_id_group = std::unique_ptr<tflite::ModelIdGroupT>(_e->UnPack(_resolver)); } } else if (_o->model_id_group) { _o->model_id_group.reset(); } }", "   { auto _e = buffer_handle(); _o->buffer_handle = _e; }", " }", " ", "-inline flatbuffers::Offset<ModelFile> ModelFile::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelFileT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ModelFile> ModelFile::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ModelFileT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateModelFile(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ModelFile> CreateModelFile(flatbuffers::FlatBufferBuilder &_fbb, const ModelFileT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ModelFile> CreateModelFile(::flatbuffers::FlatBufferBuilder &_fbb, const ModelFileT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ModelFileT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ModelFileT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _filename = _o->filename.empty() ? 0 : _fbb.CreateString(_o->filename);", "   auto _fd = _o->fd;", "   auto _offset = _o->offset;", "@@ -5527,27 +5534,27 @@ inline bool operator!=(const ModelIdGroupT &lhs, const ModelIdGroupT &rhs) {", " }", " ", " ", "-inline ModelIdGroupT *ModelIdGroup::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ModelIdGroupT *ModelIdGroup::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ModelIdGroupT>(new ModelIdGroupT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ModelIdGroup::UnPackTo(ModelIdGroupT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ModelIdGroup::UnPackTo(ModelIdGroupT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = model_namespace(); if (_e) _o->model_namespace = _e->str(); }", "   { auto _e = model_id(); if (_e) _o->model_id = _e->str(); }", " }", " ", "-inline flatbuffers::Offset<ModelIdGroup> ModelIdGroup::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelIdGroupT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ModelIdGroup> ModelIdGroup::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ModelIdGroupT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateModelIdGroup(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ModelIdGroup> CreateModelIdGroup(flatbuffers::FlatBufferBuilder &_fbb, const ModelIdGroupT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ModelIdGroup> CreateModelIdGroup(::flatbuffers::FlatBufferBuilder &_fbb, const ModelIdGroupT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ModelIdGroupT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ModelIdGroupT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _model_namespace = _o->model_namespace.empty() ? 0 : _fbb.CreateString(_o->model_namespace);", "   auto _model_id = _o->model_id.empty() ? 0 : _fbb.CreateString(_o->model_id);", "   return tflite::CreateModelIdGroup(", "@@ -5568,27 +5575,27 @@ inline bool operator!=(const BenchmarkStoragePathsT &lhs, const BenchmarkStorage", " }", " ", " ", "-inline BenchmarkStoragePathsT *BenchmarkStoragePaths::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline BenchmarkStoragePathsT *BenchmarkStoragePaths::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<BenchmarkStoragePathsT>(new BenchmarkStoragePathsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void BenchmarkStoragePaths::UnPackTo(BenchmarkStoragePathsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void BenchmarkStoragePaths::UnPackTo(BenchmarkStoragePathsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = storage_file_path(); if (_e) _o->storage_file_path = _e->str(); }", "   { auto _e = data_directory_path(); if (_e) _o->data_directory_path = _e->str(); }", " }", " ", "-inline flatbuffers::Offset<BenchmarkStoragePaths> BenchmarkStoragePaths::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkStoragePathsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BenchmarkStoragePaths> BenchmarkStoragePaths::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkStoragePathsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateBenchmarkStoragePaths(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<BenchmarkStoragePaths> CreateBenchmarkStoragePaths(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkStoragePathsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BenchmarkStoragePaths> CreateBenchmarkStoragePaths(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkStoragePathsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BenchmarkStoragePathsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BenchmarkStoragePathsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _storage_file_path = _o->storage_file_path.empty() ? 0 : _fbb.CreateString(_o->storage_file_path);", "   auto _data_directory_path = _o->data_directory_path.empty() ? 0 : _fbb.CreateString(_o->data_directory_path);", "   return tflite::CreateBenchmarkStoragePaths(", "@@ -5608,26 +5615,26 @@ inline bool operator!=(const ValidationSettingsT &lhs, const ValidationSettingsT", " }", " ", " ", "-inline ValidationSettingsT *ValidationSettings::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ValidationSettingsT *ValidationSettings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ValidationSettingsT>(new ValidationSettingsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ValidationSettings::UnPackTo(ValidationSettingsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ValidationSettings::UnPackTo(ValidationSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = per_test_timeout_ms(); _o->per_test_timeout_ms = _e; }", " }", " ", "-inline flatbuffers::Offset<ValidationSettings> ValidationSettings::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ValidationSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ValidationSettings> ValidationSettings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ValidationSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateValidationSettings(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ValidationSettings> CreateValidationSettings(flatbuffers::FlatBufferBuilder &_fbb, const ValidationSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ValidationSettings> CreateValidationSettings(::flatbuffers::FlatBufferBuilder &_fbb, const ValidationSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ValidationSettingsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ValidationSettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _per_test_timeout_ms = _o->per_test_timeout_ms;", "   return tflite::CreateValidationSettings(", "       _fbb,", "@@ -5637,7 +5644,7 @@ inline flatbuffers::Offset<ValidationSettings> CreateValidationSettings(flatbuff", " ", " inline bool operator==(const MinibenchmarkSettingsT &lhs, const MinibenchmarkSettingsT &rhs) {", "   return", "-      (lhs.settings_to_test == rhs.settings_to_test) &&", "+      (lhs.settings_to_test.size() == rhs.settings_to_test.size() && std::equal(lhs.settings_to_test.cbegin(), lhs.settings_to_test.cend(), rhs.settings_to_test.cbegin(), [](std::unique_ptr<tflite::TFLiteSettingsT> const &a, std::unique_ptr<tflite::TFLiteSettingsT> const &b) { return (a == b) || (a && b && *a == *b); })) &&", "       ((lhs.model_file == rhs.model_file) || (lhs.model_file && rhs.model_file && *lhs.model_file == *rhs.model_file)) &&", "       ((lhs.storage_paths == rhs.storage_paths) || (lhs.storage_paths && rhs.storage_paths && *lhs.storage_paths == *rhs.storage_paths)) &&", "       ((lhs.validation_settings == rhs.validation_settings) || (lhs.validation_settings && rhs.validation_settings && *lhs.validation_settings == *rhs.validation_settings));", "@@ -5653,7 +5660,7 @@ inline MinibenchmarkSettingsT::MinibenchmarkSettingsT(const MinibenchmarkSetting", "         storage_paths((o.storage_paths) ? new tflite::BenchmarkStoragePathsT(*o.storage_paths) : nullptr),", "         validation_settings((o.validation_settings) ? new tflite::ValidationSettingsT(*o.validation_settings) : nullptr) {", "   settings_to_test.reserve(o.settings_to_test.size());", "-  for (const auto &v : o.settings_to_test) { settings_to_test.emplace_back((v) ? new tflite::TFLiteSettingsT(*v) : nullptr); }", "+  for (const auto &settings_to_test_ : o.settings_to_test) { settings_to_test.emplace_back((settings_to_test_) ? new tflite::TFLiteSettingsT(*settings_to_test_) : nullptr); }", " }", " ", " inline MinibenchmarkSettingsT &MinibenchmarkSettingsT::operator=(MinibenchmarkSettingsT o) FLATBUFFERS_NOEXCEPT {", "@@ -5664,30 +5671,30 @@ inline MinibenchmarkSettingsT &MinibenchmarkSettingsT::operator=(MinibenchmarkSe", "   return *this;", " }", " ", "-inline MinibenchmarkSettingsT *MinibenchmarkSettings::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline MinibenchmarkSettingsT *MinibenchmarkSettings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<MinibenchmarkSettingsT>(new MinibenchmarkSettingsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void MinibenchmarkSettings::UnPackTo(MinibenchmarkSettingsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void MinibenchmarkSettings::UnPackTo(MinibenchmarkSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "-  { auto _e = settings_to_test(); if (_e) { _o->settings_to_test.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->settings_to_test[_i]) { _e->Get(_i)->UnPackTo(_o->settings_to_test[_i].get(), _resolver); } else { _o->settings_to_test[_i] = std::unique_ptr<tflite::TFLiteSettingsT>(_e->Get(_i)->UnPack(_resolver)); }; } } }", "-  { auto _e = model_file(); if (_e) { if(_o->model_file) { _e->UnPackTo(_o->model_file.get(), _resolver); } else { _o->model_file = std::unique_ptr<tflite::ModelFileT>(_e->UnPack(_resolver)); } } }", "-  { auto _e = storage_paths(); if (_e) { if(_o->storage_paths) { _e->UnPackTo(_o->storage_paths.get(), _resolver); } else { _o->storage_paths = std::unique_ptr<tflite::BenchmarkStoragePathsT>(_e->UnPack(_resolver)); } } }", "-  { auto _e = validation_settings(); if (_e) { if(_o->validation_settings) { _e->UnPackTo(_o->validation_settings.get(), _resolver); } else { _o->validation_settings = std::unique_ptr<tflite::ValidationSettingsT>(_e->UnPack(_resolver)); } } }", "+  { auto _e = settings_to_test(); if (_e) { _o->settings_to_test.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->settings_to_test[_i]) { _e->Get(_i)->UnPackTo(_o->settings_to_test[_i].get(), _resolver); } else { _o->settings_to_test[_i] = std::unique_ptr<tflite::TFLiteSettingsT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->settings_to_test.resize(0); } }", "+  { auto _e = model_file(); if (_e) { if(_o->model_file) { _e->UnPackTo(_o->model_file.get(), _resolver); } else { _o->model_file = std::unique_ptr<tflite::ModelFileT>(_e->UnPack(_resolver)); } } else if (_o->model_file) { _o->model_file.reset(); } }", "+  { auto _e = storage_paths(); if (_e) { if(_o->storage_paths) { _e->UnPackTo(_o->storage_paths.get(), _resolver); } else { _o->storage_paths = std::unique_ptr<tflite::BenchmarkStoragePathsT>(_e->UnPack(_resolver)); } } else if (_o->storage_paths) { _o->storage_paths.reset(); } }", "+  { auto _e = validation_settings(); if (_e) { if(_o->validation_settings) { _e->UnPackTo(_o->validation_settings.get(), _resolver); } else { _o->validation_settings = std::unique_ptr<tflite::ValidationSettingsT>(_e->UnPack(_resolver)); } } else if (_o->validation_settings) { _o->validation_settings.reset(); } }", " }", " ", "-inline flatbuffers::Offset<MinibenchmarkSettings> MinibenchmarkSettings::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinibenchmarkSettingsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<MinibenchmarkSettings> MinibenchmarkSettings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MinibenchmarkSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateMinibenchmarkSettings(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<MinibenchmarkSettings> CreateMinibenchmarkSettings(flatbuffers::FlatBufferBuilder &_fbb, const MinibenchmarkSettingsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<MinibenchmarkSettings> CreateMinibenchmarkSettings(::flatbuffers::FlatBufferBuilder &_fbb, const MinibenchmarkSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MinibenchmarkSettingsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "-  auto _settings_to_test = _o->settings_to_test.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::TFLiteSettings>> (_o->settings_to_test.size(), [](size_t i, _VectorArgs *__va) { return CreateTFLiteSettings(*__va->__fbb, __va->__o->settings_to_test[i].get(), __va->__rehasher); }, &_va ) : 0;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MinibenchmarkSettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  auto _settings_to_test = _o->settings_to_test.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::TFLiteSettings>> (_o->settings_to_test.size(), [](size_t i, _VectorArgs *__va) { return CreateTFLiteSettings(*__va->__fbb, __va->__o->settings_to_test[i].get(), __va->__rehasher); }, &_va ) : 0;", "   auto _model_file = _o->model_file ? CreateModelFile(_fbb, _o->model_file.get(), _rehasher) : 0;", "   auto _storage_paths = _o->storage_paths ? CreateBenchmarkStoragePaths(_fbb, _o->storage_paths.get(), _rehasher) : 0;", "   auto _validation_settings = _o->validation_settings ? CreateValidationSettings(_fbb, _o->validation_settings.get(), _rehasher) : 0;", "@@ -5722,27 +5729,27 @@ inline BenchmarkEventStorageT &BenchmarkEventStorageT::operator=(BenchmarkEventS", "   return *this;", " }", " ", "-inline BenchmarkEventStorageT *BenchmarkEventStorage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline BenchmarkEventStorageT *BenchmarkEventStorage::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<BenchmarkEventStorageT>(new BenchmarkEventStorageT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void BenchmarkEventStorage::UnPackTo(BenchmarkEventStorageT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void BenchmarkEventStorage::UnPackTo(BenchmarkEventStorageT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "-  { auto _e = model_id_group(); if (_e) { if(_o->model_id_group) { _e->UnPackTo(_o->model_id_group.get(), _resolver); } else { _o->model_id_group = std::unique_ptr<tflite::ModelIdGroupT>(_e->UnPack(_resolver)); } } }", "-  { auto _e = benchmark_event(); if (_e) { if(_o->benchmark_event) { _e->UnPackTo(_o->benchmark_event.get(), _resolver); } else { _o->benchmark_event = std::unique_ptr<tflite::BenchmarkEventT>(_e->UnPack(_resolver)); } } }", "+  { auto _e = model_id_group(); if (_e) { if(_o->model_id_group) { _e->UnPackTo(_o->model_id_group.get(), _resolver); } else { _o->model_id_group = std::unique_ptr<tflite::ModelIdGroupT>(_e->UnPack(_resolver)); } } else if (_o->model_id_group) { _o->model_id_group.reset(); } }", "+  { auto _e = benchmark_event(); if (_e) { if(_o->benchmark_event) { _e->UnPackTo(_o->benchmark_event.get(), _resolver); } else { _o->benchmark_event = std::unique_ptr<tflite::BenchmarkEventT>(_e->UnPack(_resolver)); } } else if (_o->benchmark_event) { _o->benchmark_event.reset(); } }", " }", " ", "-inline flatbuffers::Offset<BenchmarkEventStorage> BenchmarkEventStorage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkEventStorageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BenchmarkEventStorage> BenchmarkEventStorage::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkEventStorageT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateBenchmarkEventStorage(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<BenchmarkEventStorage> CreateBenchmarkEventStorage(flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkEventStorageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BenchmarkEventStorage> CreateBenchmarkEventStorage(::flatbuffers::FlatBufferBuilder &_fbb, const BenchmarkEventStorageT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BenchmarkEventStorageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BenchmarkEventStorageT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _model_id_group = _o->model_id_group ? CreateModelIdGroup(_fbb, _o->model_id_group.get(), _rehasher) : 0;", "   auto _benchmark_event = _o->benchmark_event ? CreateBenchmarkEvent(_fbb, _o->benchmark_event.get(), _rehasher) : 0;", "   return tflite::CreateBenchmarkEventStorage(", "@@ -1,4 +1,4 @@", "-/* Copyright 2023 The TensorFlow Authors. All Rights Reserved.", "+/* Copyright 2021 The TensorFlow Authors. All Rights Reserved.", " ", " Licensed under the Apache License, Version 2.0 (the \"License\");", " you may not use this file except in compliance with the License.", "@@ -20,6 +20,13 @@ limitations under the License.", " ", " #include \"flatbuffers/flatbuffers.h\"", " ", "+// Ensure the included flatbuffers.h is the same version as when this file was", "+// generated, otherwise it may not be compatible.", "+static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&", "+              FLATBUFFERS_VERSION_MINOR == 1 &&", "+              FLATBUFFERS_VERSION_REVISION == 20,", "+             \"Non-compatible flatbuffers version included\");", "+", " namespace tflite {", " ", " struct Environment;", "@@ -78,7 +85,7 @@ inline const char * const *EnumNamesModelType() {", " }", " ", " inline const char *EnumNameModelType(ModelType e) {", "-  if (flatbuffers::IsOutRange(e, ModelType_NONE, ModelType_JAX)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, ModelType_NONE, ModelType_JAX)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesModelType()[index];", " }", "@@ -124,14 +131,14 @@ inline const char *EnumNameModelOptimizationMode(ModelOptimizationMode e) {", "   }", " }", " ", "-struct EnvironmentT : public flatbuffers::NativeTable {", "+struct EnvironmentT : public ::flatbuffers::NativeTable {", "   typedef Environment TableType;", "   std::string tensorflow_version{};", "   uint32_t api_version = 0;", "   tflite::ModelType model_type = tflite::ModelType_NONE;", " };", " ", "-struct Environment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct Environment FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef EnvironmentT NativeTableType;", "   typedef EnvironmentBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -139,8 +146,8 @@ struct Environment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "     VT_API_VERSION = 6,", "     VT_MODEL_TYPE = 8", "   };", "-  const flatbuffers::String *tensorflow_version() const {", "-    return GetPointer<const flatbuffers::String *>(VT_TENSORFLOW_VERSION);", "+  const ::flatbuffers::String *tensorflow_version() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_TENSORFLOW_VERSION);", "   }", "   uint32_t api_version() const {", "     return GetField<uint32_t>(VT_API_VERSION, 0);", "@@ -148,7 +155,7 @@ struct Environment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   tflite::ModelType model_type() const {", "     return static_cast<tflite::ModelType>(GetField<int32_t>(VT_MODEL_TYPE, 0));", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_TENSORFLOW_VERSION) &&", "            verifier.VerifyString(tensorflow_version()) &&", "@@ -156,16 +163,16 @@ struct Environment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            VerifyField<int32_t>(verifier, VT_MODEL_TYPE, 4) &&", "            verifier.EndTable();", "   }", "-  EnvironmentT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(EnvironmentT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<Environment> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnvironmentT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  EnvironmentT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(EnvironmentT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<Environment> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EnvironmentT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct EnvironmentBuilder {", "   typedef Environment Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_tensorflow_version(flatbuffers::Offset<flatbuffers::String> tensorflow_version) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_tensorflow_version(::flatbuffers::Offset<::flatbuffers::String> tensorflow_version) {", "     fbb_.AddOffset(Environment::VT_TENSORFLOW_VERSION, tensorflow_version);", "   }", "   void add_api_version(uint32_t api_version) {", "@@ -174,20 +181,20 @@ struct EnvironmentBuilder {", "   void add_model_type(tflite::ModelType model_type) {", "     fbb_.AddElement<int32_t>(Environment::VT_MODEL_TYPE, static_cast<int32_t>(model_type), 0);", "   }", "-  explicit EnvironmentBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit EnvironmentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<Environment> Finish() {", "+  ::flatbuffers::Offset<Environment> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<Environment>(end);", "+    auto o = ::flatbuffers::Offset<Environment>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<Environment> CreateEnvironment(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::String> tensorflow_version = 0,", "+inline ::flatbuffers::Offset<Environment> CreateEnvironment(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::String> tensorflow_version = 0,", "     uint32_t api_version = 0,", "     tflite::ModelType model_type = tflite::ModelType_NONE) {", "   EnvironmentBuilder builder_(_fbb);", "@@ -197,8 +204,8 @@ inline flatbuffers::Offset<Environment> CreateEnvironment(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<Environment> CreateEnvironmentDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<Environment> CreateEnvironmentDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const char *tensorflow_version = nullptr,", "     uint32_t api_version = 0,", "     tflite::ModelType model_type = tflite::ModelType_NONE) {", "@@ -210,61 +217,61 @@ inline flatbuffers::Offset<Environment> CreateEnvironmentDirect(", "       model_type);", " }", " ", "-flatbuffers::Offset<Environment> CreateEnvironment(flatbuffers::FlatBufferBuilder &_fbb, const EnvironmentT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<Environment> CreateEnvironment(::flatbuffers::FlatBufferBuilder &_fbb, const EnvironmentT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SparsityBlockSizeT : public flatbuffers::NativeTable {", "+struct SparsityBlockSizeT : public ::flatbuffers::NativeTable {", "   typedef SparsityBlockSize TableType;", "   std::vector<uint32_t> values{};", " };", " ", "-struct SparsityBlockSize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SparsityBlockSize FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SparsityBlockSizeT NativeTableType;", "   typedef SparsityBlockSizeBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_VALUES = 4", "   };", "-  const flatbuffers::Vector<uint32_t> *values() const {", "-    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_VALUES);", "+  const ::flatbuffers::Vector<uint32_t> *values() const {", "+    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_VALUES);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_VALUES) &&", "            verifier.VerifyVector(values()) &&", "            verifier.EndTable();", "   }", "-  SparsityBlockSizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SparsityBlockSizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SparsityBlockSize> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparsityBlockSizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SparsityBlockSizeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SparsityBlockSizeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SparsityBlockSize> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SparsityBlockSizeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SparsityBlockSizeBuilder {", "   typedef SparsityBlockSize Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_values(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> values) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> values) {", "     fbb_.AddOffset(SparsityBlockSize::VT_VALUES, values);", "   }", "-  explicit SparsityBlockSizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit SparsityBlockSizeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SparsityBlockSize> Finish() {", "+  ::flatbuffers::Offset<SparsityBlockSize> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SparsityBlockSize>(end);", "+    auto o = ::flatbuffers::Offset<SparsityBlockSize>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SparsityBlockSize> CreateSparsityBlockSize(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> values = 0) {", "+inline ::flatbuffers::Offset<SparsityBlockSize> CreateSparsityBlockSize(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> values = 0) {", "   SparsityBlockSizeBuilder builder_(_fbb);", "   builder_.add_values(values);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<SparsityBlockSize> CreateSparsityBlockSizeDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<SparsityBlockSize> CreateSparsityBlockSizeDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const std::vector<uint32_t> *values = nullptr) {", "   auto values__ = values ? _fbb.CreateVector<uint32_t>(*values) : 0;", "   return tflite::CreateSparsityBlockSize(", "@@ -272,9 +279,9 @@ inline flatbuffers::Offset<SparsityBlockSize> CreateSparsityBlockSizeDirect(", "       values__);", " }", " ", "-flatbuffers::Offset<SparsityBlockSize> CreateSparsityBlockSize(flatbuffers::FlatBufferBuilder &_fbb, const SparsityBlockSizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SparsityBlockSize> CreateSparsityBlockSize(::flatbuffers::FlatBufferBuilder &_fbb, const SparsityBlockSizeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ConversionOptionsT : public flatbuffers::NativeTable {", "+struct ConversionOptionsT : public ::flatbuffers::NativeTable {", "   typedef ConversionOptions TableType;", "   std::vector<tflite::ModelOptimizationMode> model_optimization_modes{};", "   bool allow_custom_ops = false;", "@@ -287,7 +294,7 @@ struct ConversionOptionsT : public flatbuffers::NativeTable {", "   ConversionOptionsT &operator=(ConversionOptionsT o) FLATBUFFERS_NOEXCEPT;", " };", " ", "-struct ConversionOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ConversionOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ConversionOptionsT NativeTableType;", "   typedef ConversionOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -297,8 +304,8 @@ struct ConversionOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "     VT_FORCE_SELECT_TF_OPS = 10,", "     VT_SPARSITY_BLOCK_SIZES = 12", "   };", "-  const flatbuffers::Vector<int32_t> *model_optimization_modes() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MODEL_OPTIMIZATION_MODES);", "+  const ::flatbuffers::Vector<int32_t> *model_optimization_modes() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_MODEL_OPTIMIZATION_MODES);", "   }", "   bool allow_custom_ops() const {", "     return GetField<uint8_t>(VT_ALLOW_CUSTOM_OPS, 0) != 0;", "@@ -309,10 +316,10 @@ struct ConversionOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool force_select_tf_ops() const {", "     return GetField<uint8_t>(VT_FORCE_SELECT_TF_OPS, 0) != 0;", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::SparsityBlockSize>> *sparsity_block_sizes() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::SparsityBlockSize>> *>(VT_SPARSITY_BLOCK_SIZES);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::SparsityBlockSize>> *sparsity_block_sizes() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::SparsityBlockSize>> *>(VT_SPARSITY_BLOCK_SIZES);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_MODEL_OPTIMIZATION_MODES) &&", "            verifier.VerifyVector(model_optimization_modes()) &&", "@@ -324,16 +331,16 @@ struct ConversionOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            verifier.VerifyVectorOfTables(sparsity_block_sizes()) &&", "            verifier.EndTable();", "   }", "-  ConversionOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ConversionOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ConversionOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConversionOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ConversionOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ConversionOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ConversionOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConversionOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ConversionOptionsBuilder {", "   typedef ConversionOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_model_optimization_modes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> model_optimization_modes) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_model_optimization_modes(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> model_optimization_modes) {", "     fbb_.AddOffset(ConversionOptions::VT_MODEL_OPTIMIZATION_MODES, model_optimization_modes);", "   }", "   void add_allow_custom_ops(bool allow_custom_ops) {", "@@ -345,27 +352,27 @@ struct ConversionOptionsBuilder {", "   void add_force_select_tf_ops(bool force_select_tf_ops) {", "     fbb_.AddElement<uint8_t>(ConversionOptions::VT_FORCE_SELECT_TF_OPS, static_cast<uint8_t>(force_select_tf_ops), 0);", "   }", "-  void add_sparsity_block_sizes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::SparsityBlockSize>>> sparsity_block_sizes) {", "+  void add_sparsity_block_sizes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::SparsityBlockSize>>> sparsity_block_sizes) {", "     fbb_.AddOffset(ConversionOptions::VT_SPARSITY_BLOCK_SIZES, sparsity_block_sizes);", "   }", "-  explicit ConversionOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit ConversionOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ConversionOptions> Finish() {", "+  ::flatbuffers::Offset<ConversionOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ConversionOptions>(end);", "+    auto o = ::flatbuffers::Offset<ConversionOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ConversionOptions> CreateConversionOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> model_optimization_modes = 0,", "+inline ::flatbuffers::Offset<ConversionOptions> CreateConversionOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> model_optimization_modes = 0,", "     bool allow_custom_ops = false,", "     bool enable_select_tf_ops = false,", "     bool force_select_tf_ops = false,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::SparsityBlockSize>>> sparsity_block_sizes = 0) {", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::SparsityBlockSize>>> sparsity_block_sizes = 0) {", "   ConversionOptionsBuilder builder_(_fbb);", "   builder_.add_sparsity_block_sizes(sparsity_block_sizes);", "   builder_.add_model_optimization_modes(model_optimization_modes);", "@@ -375,15 +382,15 @@ inline flatbuffers::Offset<ConversionOptions> CreateConversionOptions(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<ConversionOptions> CreateConversionOptionsDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<ConversionOptions> CreateConversionOptionsDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const std::vector<int32_t> *model_optimization_modes = nullptr,", "     bool allow_custom_ops = false,", "     bool enable_select_tf_ops = false,", "     bool force_select_tf_ops = false,", "-    const std::vector<flatbuffers::Offset<tflite::SparsityBlockSize>> *sparsity_block_sizes = nullptr) {", "+    const std::vector<::flatbuffers::Offset<tflite::SparsityBlockSize>> *sparsity_block_sizes = nullptr) {", "   auto model_optimization_modes__ = model_optimization_modes ? _fbb.CreateVector<int32_t>(*model_optimization_modes) : 0;", "-  auto sparsity_block_sizes__ = sparsity_block_sizes ? _fbb.CreateVector<flatbuffers::Offset<tflite::SparsityBlockSize>>(*sparsity_block_sizes) : 0;", "+  auto sparsity_block_sizes__ = sparsity_block_sizes ? _fbb.CreateVector<::flatbuffers::Offset<tflite::SparsityBlockSize>>(*sparsity_block_sizes) : 0;", "   return tflite::CreateConversionOptions(", "       _fbb,", "       model_optimization_modes__,", "@@ -393,9 +400,9 @@ inline flatbuffers::Offset<ConversionOptions> CreateConversionOptionsDirect(", "       sparsity_block_sizes__);", " }", " ", "-flatbuffers::Offset<ConversionOptions> CreateConversionOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConversionOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ConversionOptions> CreateConversionOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ConversionOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ConversionMetadataT : public flatbuffers::NativeTable {", "+struct ConversionMetadataT : public ::flatbuffers::NativeTable {", "   typedef ConversionMetadata TableType;", "   std::unique_ptr<tflite::EnvironmentT> environment{};", "   std::unique_ptr<tflite::ConversionOptionsT> options{};", "@@ -405,7 +412,7 @@ struct ConversionMetadataT : public flatbuffers::NativeTable {", "   ConversionMetadataT &operator=(ConversionMetadataT o) FLATBUFFERS_NOEXCEPT;", " };", " ", "-struct ConversionMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ConversionMetadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ConversionMetadataT NativeTableType;", "   typedef ConversionMetadataBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -418,7 +425,7 @@ struct ConversionMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   const tflite::ConversionOptions *options() const {", "     return GetPointer<const tflite::ConversionOptions *>(VT_OPTIONS);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_ENVIRONMENT) &&", "            verifier.VerifyTable(environment()) &&", "@@ -426,51 +433,51 @@ struct ConversionMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            verifier.VerifyTable(options()) &&", "            verifier.EndTable();", "   }", "-  ConversionMetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ConversionMetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ConversionMetadata> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConversionMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ConversionMetadataT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ConversionMetadataT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ConversionMetadata> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConversionMetadataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ConversionMetadataBuilder {", "   typedef ConversionMetadata Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_environment(flatbuffers::Offset<tflite::Environment> environment) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_environment(::flatbuffers::Offset<tflite::Environment> environment) {", "     fbb_.AddOffset(ConversionMetadata::VT_ENVIRONMENT, environment);", "   }", "-  void add_options(flatbuffers::Offset<tflite::ConversionOptions> options) {", "+  void add_options(::flatbuffers::Offset<tflite::ConversionOptions> options) {", "     fbb_.AddOffset(ConversionMetadata::VT_OPTIONS, options);", "   }", "-  explicit ConversionMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit ConversionMetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ConversionMetadata> Finish() {", "+  ::flatbuffers::Offset<ConversionMetadata> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ConversionMetadata>(end);", "+    auto o = ::flatbuffers::Offset<ConversionMetadata>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ConversionMetadata> CreateConversionMetadata(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<tflite::Environment> environment = 0,", "-    flatbuffers::Offset<tflite::ConversionOptions> options = 0) {", "+inline ::flatbuffers::Offset<ConversionMetadata> CreateConversionMetadata(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<tflite::Environment> environment = 0,", "+    ::flatbuffers::Offset<tflite::ConversionOptions> options = 0) {", "   ConversionMetadataBuilder builder_(_fbb);", "   builder_.add_options(options);", "   builder_.add_environment(environment);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<ConversionMetadata> CreateConversionMetadata(flatbuffers::FlatBufferBuilder &_fbb, const ConversionMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ConversionMetadata> CreateConversionMetadata(::flatbuffers::FlatBufferBuilder &_fbb, const ConversionMetadataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-inline EnvironmentT *Environment::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline EnvironmentT *Environment::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<EnvironmentT>(new EnvironmentT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void Environment::UnPackTo(EnvironmentT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void Environment::UnPackTo(EnvironmentT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = tensorflow_version(); if (_e) _o->tensorflow_version = _e->str(); }", "@@ -478,14 +485,14 @@ inline void Environment::UnPackTo(EnvironmentT *_o, const flatbuffers::resolver_", "   { auto _e = model_type(); _o->model_type = _e; }", " }", " ", "-inline flatbuffers::Offset<Environment> Environment::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnvironmentT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Environment> Environment::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EnvironmentT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateEnvironment(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<Environment> CreateEnvironment(flatbuffers::FlatBufferBuilder &_fbb, const EnvironmentT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Environment> CreateEnvironment(::flatbuffers::FlatBufferBuilder &_fbb, const EnvironmentT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EnvironmentT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EnvironmentT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _tensorflow_version = _o->tensorflow_version.empty() ? 0 : _fbb.CreateString(_o->tensorflow_version);", "   auto _api_version = _o->api_version;", "   auto _model_type = _o->model_type;", "@@ -496,26 +503,26 @@ inline flatbuffers::Offset<Environment> CreateEnvironment(flatbuffers::FlatBuffe", "       _model_type);", " }", " ", "-inline SparsityBlockSizeT *SparsityBlockSize::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SparsityBlockSizeT *SparsityBlockSize::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SparsityBlockSizeT>(new SparsityBlockSizeT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SparsityBlockSize::UnPackTo(SparsityBlockSizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SparsityBlockSize::UnPackTo(SparsityBlockSizeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "-  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } }", "+  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } else { _o->values.resize(0); } }", " }", " ", "-inline flatbuffers::Offset<SparsityBlockSize> SparsityBlockSize::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparsityBlockSizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SparsityBlockSize> SparsityBlockSize::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SparsityBlockSizeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSparsityBlockSize(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SparsityBlockSize> CreateSparsityBlockSize(flatbuffers::FlatBufferBuilder &_fbb, const SparsityBlockSizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SparsityBlockSize> CreateSparsityBlockSize(::flatbuffers::FlatBufferBuilder &_fbb, const SparsityBlockSizeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SparsityBlockSizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SparsityBlockSizeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;", "   return tflite::CreateSparsityBlockSize(", "       _fbb,", "@@ -528,7 +535,7 @@ inline ConversionOptionsT::ConversionOptionsT(const ConversionOptionsT &o)", "         enable_select_tf_ops(o.enable_select_tf_ops),", "         force_select_tf_ops(o.force_select_tf_ops) {", "   sparsity_block_sizes.reserve(o.sparsity_block_sizes.size());", "-  for (const auto &v : o.sparsity_block_sizes) { sparsity_block_sizes.emplace_back((v) ? new tflite::SparsityBlockSizeT(*v) : nullptr); }", "+  for (const auto &sparsity_block_sizes_ : o.sparsity_block_sizes) { sparsity_block_sizes.emplace_back((sparsity_block_sizes_) ? new tflite::SparsityBlockSizeT(*sparsity_block_sizes_) : nullptr); }", " }", " ", " inline ConversionOptionsT &ConversionOptionsT::operator=(ConversionOptionsT o) FLATBUFFERS_NOEXCEPT {", "@@ -540,35 +547,35 @@ inline ConversionOptionsT &ConversionOptionsT::operator=(ConversionOptionsT o) F", "   return *this;", " }", " ", "-inline ConversionOptionsT *ConversionOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ConversionOptionsT *ConversionOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ConversionOptionsT>(new ConversionOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ConversionOptions::UnPackTo(ConversionOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ConversionOptions::UnPackTo(ConversionOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "-  { auto _e = model_optimization_modes(); if (_e) { _o->model_optimization_modes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->model_optimization_modes[_i] = static_cast<tflite::ModelOptimizationMode>(_e->Get(_i)); } } }", "+  { auto _e = model_optimization_modes(); if (_e) { _o->model_optimization_modes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->model_optimization_modes[_i] = static_cast<tflite::ModelOptimizationMode>(_e->Get(_i)); } } else { _o->model_optimization_modes.resize(0); } }", "   { auto _e = allow_custom_ops(); _o->allow_custom_ops = _e; }", "   { auto _e = enable_select_tf_ops(); _o->enable_select_tf_ops = _e; }", "   { auto _e = force_select_tf_ops(); _o->force_select_tf_ops = _e; }", "-  { auto _e = sparsity_block_sizes(); if (_e) { _o->sparsity_block_sizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->sparsity_block_sizes[_i]) { _e->Get(_i)->UnPackTo(_o->sparsity_block_sizes[_i].get(), _resolver); } else { _o->sparsity_block_sizes[_i] = std::unique_ptr<tflite::SparsityBlockSizeT>(_e->Get(_i)->UnPack(_resolver)); }; } } }", "+  { auto _e = sparsity_block_sizes(); if (_e) { _o->sparsity_block_sizes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->sparsity_block_sizes[_i]) { _e->Get(_i)->UnPackTo(_o->sparsity_block_sizes[_i].get(), _resolver); } else { _o->sparsity_block_sizes[_i] = std::unique_ptr<tflite::SparsityBlockSizeT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->sparsity_block_sizes.resize(0); } }", " }", " ", "-inline flatbuffers::Offset<ConversionOptions> ConversionOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConversionOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ConversionOptions> ConversionOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConversionOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateConversionOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ConversionOptions> CreateConversionOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConversionOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ConversionOptions> CreateConversionOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ConversionOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConversionOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "-  auto _model_optimization_modes = _o->model_optimization_modes.size() ? _fbb.CreateVectorScalarCast<int32_t>(flatbuffers::data(_o->model_optimization_modes), _o->model_optimization_modes.size()) : 0;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ConversionOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  auto _model_optimization_modes = _o->model_optimization_modes.size() ? _fbb.CreateVectorScalarCast<int32_t>(::flatbuffers::data(_o->model_optimization_modes), _o->model_optimization_modes.size()) : 0;", "   auto _allow_custom_ops = _o->allow_custom_ops;", "   auto _enable_select_tf_ops = _o->enable_select_tf_ops;", "   auto _force_select_tf_ops = _o->force_select_tf_ops;", "-  auto _sparsity_block_sizes = _o->sparsity_block_sizes.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::SparsityBlockSize>> (_o->sparsity_block_sizes.size(), [](size_t i, _VectorArgs *__va) { return CreateSparsityBlockSize(*__va->__fbb, __va->__o->sparsity_block_sizes[i].get(), __va->__rehasher); }, &_va ) : 0;", "+  auto _sparsity_block_sizes = _o->sparsity_block_sizes.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::SparsityBlockSize>> (_o->sparsity_block_sizes.size(), [](size_t i, _VectorArgs *__va) { return CreateSparsityBlockSize(*__va->__fbb, __va->__o->sparsity_block_sizes[i].get(), __va->__rehasher); }, &_va ) : 0;", "   return tflite::CreateConversionOptions(", "       _fbb,", "       _model_optimization_modes,", "@@ -589,27 +596,27 @@ inline ConversionMetadataT &ConversionMetadataT::operator=(ConversionMetadataT o", "   return *this;", " }", " ", "-inline ConversionMetadataT *ConversionMetadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ConversionMetadataT *ConversionMetadata::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ConversionMetadataT>(new ConversionMetadataT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ConversionMetadata::UnPackTo(ConversionMetadataT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ConversionMetadata::UnPackTo(ConversionMetadataT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "-  { auto _e = environment(); if (_e) { if(_o->environment) { _e->UnPackTo(_o->environment.get(), _resolver); } else { _o->environment = std::unique_ptr<tflite::EnvironmentT>(_e->UnPack(_resolver)); } } }", "-  { auto _e = options(); if (_e) { if(_o->options) { _e->UnPackTo(_o->options.get(), _resolver); } else { _o->options = std::unique_ptr<tflite::ConversionOptionsT>(_e->UnPack(_resolver)); } } }", "+  { auto _e = environment(); if (_e) { if(_o->environment) { _e->UnPackTo(_o->environment.get(), _resolver); } else { _o->environment = std::unique_ptr<tflite::EnvironmentT>(_e->UnPack(_resolver)); } } else if (_o->environment) { _o->environment.reset(); } }", "+  { auto _e = options(); if (_e) { if(_o->options) { _e->UnPackTo(_o->options.get(), _resolver); } else { _o->options = std::unique_ptr<tflite::ConversionOptionsT>(_e->UnPack(_resolver)); } } else if (_o->options) { _o->options.reset(); } }", " }", " ", "-inline flatbuffers::Offset<ConversionMetadata> ConversionMetadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConversionMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ConversionMetadata> ConversionMetadata::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConversionMetadataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateConversionMetadata(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ConversionMetadata> CreateConversionMetadata(flatbuffers::FlatBufferBuilder &_fbb, const ConversionMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ConversionMetadata> CreateConversionMetadata(::flatbuffers::FlatBufferBuilder &_fbb, const ConversionMetadataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConversionMetadataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ConversionMetadataT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _environment = _o->environment ? CreateEnvironment(_fbb, _o->environment.get(), _rehasher) : 0;", "   auto _options = _o->options ? CreateConversionOptions(_fbb, _o->options.get(), _rehasher) : 0;", "   return tflite::CreateConversionMetadata(", "@@ -619,44 +626,44 @@ inline flatbuffers::Offset<ConversionMetadata> CreateConversionMetadata(flatbuff", " }", " ", " inline const tflite::ConversionMetadata *GetConversionMetadata(const void *buf) {", "-  return flatbuffers::GetRoot<tflite::ConversionMetadata>(buf);", "+  return ::flatbuffers::GetRoot<tflite::ConversionMetadata>(buf);", " }", " ", " inline const tflite::ConversionMetadata *GetSizePrefixedConversionMetadata(const void *buf) {", "-  return flatbuffers::GetSizePrefixedRoot<tflite::ConversionMetadata>(buf);", "+  return ::flatbuffers::GetSizePrefixedRoot<tflite::ConversionMetadata>(buf);", " }", " ", " inline bool VerifyConversionMetadataBuffer(", "-    flatbuffers::Verifier &verifier) {", "+    ::flatbuffers::Verifier &verifier) {", "   return verifier.VerifyBuffer<tflite::ConversionMetadata>(nullptr);", " }", " ", " inline bool VerifySizePrefixedConversionMetadataBuffer(", "-    flatbuffers::Verifier &verifier) {", "+    ::flatbuffers::Verifier &verifier) {", "   return verifier.VerifySizePrefixedBuffer<tflite::ConversionMetadata>(nullptr);", " }", " ", " inline void FinishConversionMetadataBuffer(", "-    flatbuffers::FlatBufferBuilder &fbb,", "-    flatbuffers::Offset<tflite::ConversionMetadata> root) {", "+    ::flatbuffers::FlatBufferBuilder &fbb,", "+    ::flatbuffers::Offset<tflite::ConversionMetadata> root) {", "   fbb.Finish(root);", " }", " ", " inline void FinishSizePrefixedConversionMetadataBuffer(", "-    flatbuffers::FlatBufferBuilder &fbb,", "-    flatbuffers::Offset<tflite::ConversionMetadata> root) {", "+    ::flatbuffers::FlatBufferBuilder &fbb,", "+    ::flatbuffers::Offset<tflite::ConversionMetadata> root) {", "   fbb.FinishSizePrefixed(root);", " }", " ", " inline std::unique_ptr<tflite::ConversionMetadataT> UnPackConversionMetadata(", "     const void *buf,", "-    const flatbuffers::resolver_function_t *res = nullptr) {", "+    const ::flatbuffers::resolver_function_t *res = nullptr) {", "   return std::unique_ptr<tflite::ConversionMetadataT>(GetConversionMetadata(buf)->UnPack(res));", " }", " ", " inline std::unique_ptr<tflite::ConversionMetadataT> UnPackSizePrefixedConversionMetadata(", "     const void *buf,", "-    const flatbuffers::resolver_function_t *res = nullptr) {", "+    const ::flatbuffers::resolver_function_t *res = nullptr) {", "   return std::unique_ptr<tflite::ConversionMetadataT>(GetSizePrefixedConversionMetadata(buf)->UnPack(res));", " }", " ", "@@ -1,4 +1,4 @@", "-/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.", "+/* Copyright 2023 The TensorFlow Authors. All Rights Reserved.", " ", " Licensed under the Apache License, Version 2.0 (the \"License\");", " you may not use this file except in compliance with the License.", "@@ -20,6 +20,13 @@ limitations under the License.", " ", " #include \"flatbuffers/flatbuffers.h\"", " ", "+// Ensure the included flatbuffers.h is the same version as when this file was", "+// generated, otherwise it may not be compatible.", "+static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&", "+              FLATBUFFERS_VERSION_MINOR == 1 &&", "+              FLATBUFFERS_VERSION_REVISION == 20,", "+             \"Non-compatible flatbuffers version included\");", "+", " namespace tflite {", " ", " struct CustomQuantization;", "@@ -659,7 +666,7 @@ inline const char * const *EnumNamesTensorType() {", " }", " ", " inline const char *EnumNameTensorType(TensorType e) {", "-  if (flatbuffers::IsOutRange(e, TensorType_FLOAT32, TensorType_INT4)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, TensorType_FLOAT32, TensorType_INT4)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesTensorType()[index];", " }", "@@ -689,7 +696,7 @@ inline const char * const *EnumNamesQuantizationDetails() {", " }", " ", " inline const char *EnumNameQuantizationDetails(QuantizationDetails e) {", "-  if (flatbuffers::IsOutRange(e, QuantizationDetails_NONE, QuantizationDetails_CustomQuantization)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, QuantizationDetails_NONE, QuantizationDetails_CustomQuantization)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesQuantizationDetails()[index];", " }", "@@ -737,8 +744,8 @@ struct QuantizationDetailsUnion {", "     }", "   }", " ", "-  static void *UnPack(const void *obj, QuantizationDetails type, const flatbuffers::resolver_function_t *resolver);", "-  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;", "+  static void *UnPack(const void *obj, QuantizationDetails type, const ::flatbuffers::resolver_function_t *resolver);", "+  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;", " ", "   tflite::CustomQuantizationT *AsCustomQuantization() {", "     return type == QuantizationDetails_CustomQuantization ?", "@@ -750,8 +757,8 @@ struct QuantizationDetailsUnion {", "   }", " };", " ", "-bool VerifyQuantizationDetails(flatbuffers::Verifier &verifier, const void *obj, QuantizationDetails type);", "-bool VerifyQuantizationDetailsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);", "+bool VerifyQuantizationDetails(::flatbuffers::Verifier &verifier, const void *obj, QuantizationDetails type);", "+bool VerifyQuantizationDetailsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);", " ", " enum DimensionType : int8_t {", "   DimensionType_DENSE = 0,", "@@ -778,7 +785,7 @@ inline const char * const *EnumNamesDimensionType() {", " }", " ", " inline const char *EnumNameDimensionType(DimensionType e) {", "-  if (flatbuffers::IsOutRange(e, DimensionType_DENSE, DimensionType_SPARSE_CSR)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, DimensionType_DENSE, DimensionType_SPARSE_CSR)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesDimensionType()[index];", " }", "@@ -814,7 +821,7 @@ inline const char * const *EnumNamesSparseIndexVector() {", " }", " ", " inline const char *EnumNameSparseIndexVector(SparseIndexVector e) {", "-  if (flatbuffers::IsOutRange(e, SparseIndexVector_NONE, SparseIndexVector_Uint8Vector)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, SparseIndexVector_NONE, SparseIndexVector_Uint8Vector)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesSparseIndexVector()[index];", " }", "@@ -878,8 +885,8 @@ struct SparseIndexVectorUnion {", "     }", "   }", " ", "-  static void *UnPack(const void *obj, SparseIndexVector type, const flatbuffers::resolver_function_t *resolver);", "-  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;", "+  static void *UnPack(const void *obj, SparseIndexVector type, const ::flatbuffers::resolver_function_t *resolver);", "+  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;", " ", "   tflite::Int32VectorT *AsInt32Vector() {", "     return type == SparseIndexVector_Int32Vector ?", "@@ -907,8 +914,8 @@ struct SparseIndexVectorUnion {", "   }", " };", " ", "-bool VerifySparseIndexVector(flatbuffers::Verifier &verifier, const void *obj, SparseIndexVector type);", "-bool VerifySparseIndexVectorVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);", "+bool VerifySparseIndexVector(::flatbuffers::Verifier &verifier, const void *obj, SparseIndexVector type);", "+bool VerifySparseIndexVectorVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);", " ", " enum BuiltinOperator : int32_t {", "   BuiltinOperator_ADD = 0,", "@@ -1409,7 +1416,7 @@ inline const char * const *EnumNamesBuiltinOperator() {", " }", " ", " inline const char *EnumNameBuiltinOperator(BuiltinOperator e) {", "-  if (flatbuffers::IsOutRange(e, BuiltinOperator_ADD, BuiltinOperator_BITCAST)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, BuiltinOperator_ADD, BuiltinOperator_BITCAST)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesBuiltinOperator()[index];", " }", "@@ -1808,7 +1815,7 @@ inline const char * const *EnumNamesBuiltinOptions() {", " }", " ", " inline const char *EnumNameBuiltinOptions(BuiltinOptions e) {", "-  if (flatbuffers::IsOutRange(e, BuiltinOptions_NONE, BuiltinOptions_BitcastOptions)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, BuiltinOptions_NONE, BuiltinOptions_BitcastOptions)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesBuiltinOptions()[index];", " }", "@@ -2840,8 +2847,8 @@ struct BuiltinOptionsUnion {", "     }", "   }", " ", "-  static void *UnPack(const void *obj, BuiltinOptions type, const flatbuffers::resolver_function_t *resolver);", "-  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;", "+  static void *UnPack(const void *obj, BuiltinOptions type, const ::flatbuffers::resolver_function_t *resolver);", "+  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;", " ", "   tflite::Conv2DOptionsT *AsConv2DOptions() {", "     return type == BuiltinOptions_Conv2DOptions ?", "@@ -3837,8 +3844,8 @@ struct BuiltinOptionsUnion {", "   }", " };", " ", "-bool VerifyBuiltinOptions(flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type);", "-bool VerifyBuiltinOptionsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);", "+bool VerifyBuiltinOptions(::flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type);", "+bool VerifyBuiltinOptionsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);", " ", " enum Padding : int8_t {", "   Padding_SAME = 0,", "@@ -3865,7 +3872,7 @@ inline const char * const *EnumNamesPadding() {", " }", " ", " inline const char *EnumNamePadding(Padding e) {", "-  if (flatbuffers::IsOutRange(e, Padding_SAME, Padding_VALID)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, Padding_SAME, Padding_VALID)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesPadding()[index];", " }", "@@ -3907,7 +3914,7 @@ inline const char * const *EnumNamesActivationFunctionType() {", " }", " ", " inline const char *EnumNameActivationFunctionType(ActivationFunctionType e) {", "-  if (flatbuffers::IsOutRange(e, ActivationFunctionType_NONE, ActivationFunctionType_SIGN_BIT)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, ActivationFunctionType_NONE, ActivationFunctionType_SIGN_BIT)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesActivationFunctionType()[index];", " }", "@@ -3940,7 +3947,7 @@ inline const char * const *EnumNamesLSHProjectionType() {", " }", " ", " inline const char *EnumNameLSHProjectionType(LSHProjectionType e) {", "-  if (flatbuffers::IsOutRange(e, LSHProjectionType_UNKNOWN, LSHProjectionType_DENSE)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, LSHProjectionType_UNKNOWN, LSHProjectionType_DENSE)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesLSHProjectionType()[index];", " }", "@@ -3970,7 +3977,7 @@ inline const char * const *EnumNamesFullyConnectedOptionsWeightsFormat() {", " }", " ", " inline const char *EnumNameFullyConnectedOptionsWeightsFormat(FullyConnectedOptionsWeightsFormat e) {", "-  if (flatbuffers::IsOutRange(e, FullyConnectedOptionsWeightsFormat_DEFAULT, FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, FullyConnectedOptionsWeightsFormat_DEFAULT, FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesFullyConnectedOptionsWeightsFormat()[index];", " }", "@@ -4000,7 +4007,7 @@ inline const char * const *EnumNamesLSTMKernelType() {", " }", " ", " inline const char *EnumNameLSTMKernelType(LSTMKernelType e) {", "-  if (flatbuffers::IsOutRange(e, LSTMKernelType_FULL, LSTMKernelType_BASIC)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, LSTMKernelType_FULL, LSTMKernelType_BASIC)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesLSTMKernelType()[index];", " }", "@@ -4033,7 +4040,7 @@ inline const char * const *EnumNamesCombinerType() {", " }", " ", " inline const char *EnumNameCombinerType(CombinerType e) {", "-  if (flatbuffers::IsOutRange(e, CombinerType_SUM, CombinerType_SQRTN)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, CombinerType_SUM, CombinerType_SQRTN)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesCombinerType()[index];", " }", "@@ -4063,7 +4070,7 @@ inline const char * const *EnumNamesMirrorPadMode() {", " }", " ", " inline const char *EnumNameMirrorPadMode(MirrorPadMode e) {", "-  if (flatbuffers::IsOutRange(e, MirrorPadMode_REFLECT, MirrorPadMode_SYMMETRIC)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, MirrorPadMode_REFLECT, MirrorPadMode_SYMMETRIC)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesMirrorPadMode()[index];", " }", "@@ -4090,64 +4097,64 @@ inline const char * const *EnumNamesCustomOptionsFormat() {", " }", " ", " inline const char *EnumNameCustomOptionsFormat(CustomOptionsFormat e) {", "-  if (flatbuffers::IsOutRange(e, CustomOptionsFormat_FLEXBUFFERS, CustomOptionsFormat_FLEXBUFFERS)) return \"\";", "+  if (::flatbuffers::IsOutRange(e, CustomOptionsFormat_FLEXBUFFERS, CustomOptionsFormat_FLEXBUFFERS)) return \"\";", "   const size_t index = static_cast<size_t>(e);", "   return EnumNamesCustomOptionsFormat()[index];", " }", " ", "-struct CustomQuantizationT : public flatbuffers::NativeTable {", "+struct CustomQuantizationT : public ::flatbuffers::NativeTable {", "   typedef CustomQuantization TableType;", "   std::vector<uint8_t> custom{};", " };", " ", "-struct CustomQuantization FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct CustomQuantization FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef CustomQuantizationT NativeTableType;", "   typedef CustomQuantizationBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_CUSTOM = 4", "   };", "-  const flatbuffers::Vector<uint8_t> *custom() const {", "-    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CUSTOM);", "+  const ::flatbuffers::Vector<uint8_t> *custom() const {", "+    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CUSTOM);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_CUSTOM) &&", "            verifier.VerifyVector(custom()) &&", "            verifier.EndTable();", "   }", "-  CustomQuantizationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(CustomQuantizationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<CustomQuantization> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  CustomQuantizationT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(CustomQuantizationT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<CustomQuantization> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct CustomQuantizationBuilder {", "   typedef CustomQuantization Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_custom(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_custom(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> custom) {", "     fbb_.AddOffset(CustomQuantization::VT_CUSTOM, custom);", "   }", "-  explicit CustomQuantizationBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit CustomQuantizationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<CustomQuantization> Finish() {", "+  ::flatbuffers::Offset<CustomQuantization> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<CustomQuantization>(end);", "+    auto o = ::flatbuffers::Offset<CustomQuantization>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom = 0) {", "+inline ::flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> custom = 0) {", "   CustomQuantizationBuilder builder_(_fbb);", "   builder_.add_custom(custom);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantizationDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<CustomQuantization> CreateCustomQuantizationDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const std::vector<uint8_t> *custom = nullptr) {", "   if (custom) { _fbb.ForceVectorAlignment(custom->size(), sizeof(uint8_t), 16); }", "   auto custom__ = custom ? _fbb.CreateVector<uint8_t>(*custom) : 0;", "@@ -4156,9 +4163,9 @@ inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantizationDirect(", "       custom__);", " }", " ", "-flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(::flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct QuantizationParametersT : public flatbuffers::NativeTable {", "+struct QuantizationParametersT : public ::flatbuffers::NativeTable {", "   typedef QuantizationParameters TableType;", "   std::vector<float> min{};", "   std::vector<float> max{};", "@@ -4168,7 +4175,7 @@ struct QuantizationParametersT : public flatbuffers::NativeTable {", "   int32_t quantized_dimension = 0;", " };", " ", "-struct QuantizationParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct QuantizationParameters FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef QuantizationParametersT NativeTableType;", "   typedef QuantizationParametersBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -4180,17 +4187,17 @@ struct QuantizationParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tab", "     VT_DETAILS = 14,", "     VT_QUANTIZED_DIMENSION = 16", "   };", "-  const flatbuffers::Vector<float> *min() const {", "-    return GetPointer<const flatbuffers::Vector<float> *>(VT_MIN);", "+  const ::flatbuffers::Vector<float> *min() const {", "+    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_MIN);", "   }", "-  const flatbuffers::Vector<float> *max() const {", "-    return GetPointer<const flatbuffers::Vector<float> *>(VT_MAX);", "+  const ::flatbuffers::Vector<float> *max() const {", "+    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_MAX);", "   }", "-  const flatbuffers::Vector<float> *scale() const {", "-    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);", "+  const ::flatbuffers::Vector<float> *scale() const {", "+    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_SCALE);", "   }", "-  const flatbuffers::Vector<int64_t> *zero_point() const {", "-    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ZERO_POINT);", "+  const ::flatbuffers::Vector<int64_t> *zero_point() const {", "+    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_ZERO_POINT);", "   }", "   tflite::QuantizationDetails details_type() const {", "     return static_cast<tflite::QuantizationDetails>(GetField<uint8_t>(VT_DETAILS_TYPE, 0));", "@@ -4205,7 +4212,7 @@ struct QuantizationParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tab", "   int32_t quantized_dimension() const {", "     return GetField<int32_t>(VT_QUANTIZED_DIMENSION, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_MIN) &&", "            verifier.VerifyVector(min()) &&", "@@ -4221,9 +4228,9 @@ struct QuantizationParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tab", "            VerifyField<int32_t>(verifier, VT_QUANTIZED_DIMENSION, 4) &&", "            verifier.EndTable();", "   }", "-  QuantizationParametersT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(QuantizationParametersT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<QuantizationParameters> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  QuantizationParametersT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(QuantizationParametersT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<QuantizationParameters> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " template<> inline const tflite::CustomQuantization *QuantizationParameters::details_as<tflite::CustomQuantization>() const {", "@@ -4232,48 +4239,48 @@ template<> inline const tflite::CustomQuantization *QuantizationParameters::deta", " ", " struct QuantizationParametersBuilder {", "   typedef QuantizationParameters Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_min(flatbuffers::Offset<flatbuffers::Vector<float>> min) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_min(::flatbuffers::Offset<::flatbuffers::Vector<float>> min) {", "     fbb_.AddOffset(QuantizationParameters::VT_MIN, min);", "   }", "-  void add_max(flatbuffers::Offset<flatbuffers::Vector<float>> max) {", "+  void add_max(::flatbuffers::Offset<::flatbuffers::Vector<float>> max) {", "     fbb_.AddOffset(QuantizationParameters::VT_MAX, max);", "   }", "-  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {", "+  void add_scale(::flatbuffers::Offset<::flatbuffers::Vector<float>> scale) {", "     fbb_.AddOffset(QuantizationParameters::VT_SCALE, scale);", "   }", "-  void add_zero_point(flatbuffers::Offset<flatbuffers::Vector<int64_t>> zero_point) {", "+  void add_zero_point(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> zero_point) {", "     fbb_.AddOffset(QuantizationParameters::VT_ZERO_POINT, zero_point);", "   }", "   void add_details_type(tflite::QuantizationDetails details_type) {", "     fbb_.AddElement<uint8_t>(QuantizationParameters::VT_DETAILS_TYPE, static_cast<uint8_t>(details_type), 0);", "   }", "-  void add_details(flatbuffers::Offset<void> details) {", "+  void add_details(::flatbuffers::Offset<void> details) {", "     fbb_.AddOffset(QuantizationParameters::VT_DETAILS, details);", "   }", "   void add_quantized_dimension(int32_t quantized_dimension) {", "     fbb_.AddElement<int32_t>(QuantizationParameters::VT_QUANTIZED_DIMENSION, quantized_dimension, 0);", "   }", "-  explicit QuantizationParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit QuantizationParametersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<QuantizationParameters> Finish() {", "+  ::flatbuffers::Offset<QuantizationParameters> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<QuantizationParameters>(end);", "+    auto o = ::flatbuffers::Offset<QuantizationParameters>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<float>> min = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<float>> max = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<int64_t>> zero_point = 0,", "+inline ::flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<float>> min = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<float>> max = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<float>> scale = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> zero_point = 0,", "     tflite::QuantizationDetails details_type = tflite::QuantizationDetails_NONE,", "-    flatbuffers::Offset<void> details = 0,", "+    ::flatbuffers::Offset<void> details = 0,", "     int32_t quantized_dimension = 0) {", "   QuantizationParametersBuilder builder_(_fbb);", "   builder_.add_quantized_dimension(quantized_dimension);", "@@ -4286,14 +4293,14 @@ inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParametersDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<QuantizationParameters> CreateQuantizationParametersDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const std::vector<float> *min = nullptr,", "     const std::vector<float> *max = nullptr,", "     const std::vector<float> *scale = nullptr,", "     const std::vector<int64_t> *zero_point = nullptr,", "     tflite::QuantizationDetails details_type = tflite::QuantizationDetails_NONE,", "-    flatbuffers::Offset<void> details = 0,", "+    ::flatbuffers::Offset<void> details = 0,", "     int32_t quantized_dimension = 0) {", "   auto min__ = min ? _fbb.CreateVector<float>(*min) : 0;", "   auto max__ = max ? _fbb.CreateVector<float>(*max) : 0;", "@@ -4310,61 +4317,61 @@ inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParametersD", "       quantized_dimension);", " }", " ", "-flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(::flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct Int32VectorT : public flatbuffers::NativeTable {", "+struct Int32VectorT : public ::flatbuffers::NativeTable {", "   typedef Int32Vector TableType;", "   std::vector<int32_t> values{};", " };", " ", "-struct Int32Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct Int32Vector FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef Int32VectorT NativeTableType;", "   typedef Int32VectorBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_VALUES = 4", "   };", "-  const flatbuffers::Vector<int32_t> *values() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VALUES);", "+  const ::flatbuffers::Vector<int32_t> *values() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_VALUES);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_VALUES) &&", "            verifier.VerifyVector(values()) &&", "            verifier.EndTable();", "   }", "-  Int32VectorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(Int32VectorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<Int32Vector> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  Int32VectorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(Int32VectorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<Int32Vector> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct Int32VectorBuilder {", "   typedef Int32Vector Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_values(flatbuffers::Offset<flatbuffers::Vector<int32_t>> values) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> values) {", "     fbb_.AddOffset(Int32Vector::VT_VALUES, values);", "   }", "-  explicit Int32VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit Int32VectorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<Int32Vector> Finish() {", "+  ::flatbuffers::Offset<Int32Vector> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<Int32Vector>(end);", "+    auto o = ::flatbuffers::Offset<Int32Vector>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<Int32Vector> CreateInt32Vector(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> values = 0) {", "+inline ::flatbuffers::Offset<Int32Vector> CreateInt32Vector(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> values = 0) {", "   Int32VectorBuilder builder_(_fbb);", "   builder_.add_values(values);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<Int32Vector> CreateInt32VectorDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<Int32Vector> CreateInt32VectorDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const std::vector<int32_t> *values = nullptr) {", "   auto values__ = values ? _fbb.CreateVector<int32_t>(*values) : 0;", "   return tflite::CreateInt32Vector(", "@@ -4372,61 +4379,61 @@ inline flatbuffers::Offset<Int32Vector> CreateInt32VectorDirect(", "       values__);", " }", " ", "-flatbuffers::Offset<Int32Vector> CreateInt32Vector(flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<Int32Vector> CreateInt32Vector(::flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct Uint16VectorT : public flatbuffers::NativeTable {", "+struct Uint16VectorT : public ::flatbuffers::NativeTable {", "   typedef Uint16Vector TableType;", "   std::vector<uint16_t> values{};", " };", " ", "-struct Uint16Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct Uint16Vector FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef Uint16VectorT NativeTableType;", "   typedef Uint16VectorBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_VALUES = 4", "   };", "-  const flatbuffers::Vector<uint16_t> *values() const {", "-    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_VALUES);", "+  const ::flatbuffers::Vector<uint16_t> *values() const {", "+    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_VALUES);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_VALUES) &&", "            verifier.VerifyVector(values()) &&", "            verifier.EndTable();", "   }", "-  Uint16VectorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(Uint16VectorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<Uint16Vector> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  Uint16VectorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(Uint16VectorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<Uint16Vector> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct Uint16VectorBuilder {", "   typedef Uint16Vector Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_values(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> values) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> values) {", "     fbb_.AddOffset(Uint16Vector::VT_VALUES, values);", "   }", "-  explicit Uint16VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit Uint16VectorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<Uint16Vector> Finish() {", "+  ::flatbuffers::Offset<Uint16Vector> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<Uint16Vector>(end);", "+    auto o = ::flatbuffers::Offset<Uint16Vector>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<Uint16Vector> CreateUint16Vector(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> values = 0) {", "+inline ::flatbuffers::Offset<Uint16Vector> CreateUint16Vector(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> values = 0) {", "   Uint16VectorBuilder builder_(_fbb);", "   builder_.add_values(values);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<Uint16Vector> CreateUint16VectorDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<Uint16Vector> CreateUint16VectorDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const std::vector<uint16_t> *values = nullptr) {", "   if (values) { _fbb.ForceVectorAlignment(values->size(), sizeof(uint16_t), 4); }", "   auto values__ = values ? _fbb.CreateVector<uint16_t>(*values) : 0;", "@@ -4435,61 +4442,61 @@ inline flatbuffers::Offset<Uint16Vector> CreateUint16VectorDirect(", "       values__);", " }", " ", "-flatbuffers::Offset<Uint16Vector> CreateUint16Vector(flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<Uint16Vector> CreateUint16Vector(::flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct Uint8VectorT : public flatbuffers::NativeTable {", "+struct Uint8VectorT : public ::flatbuffers::NativeTable {", "   typedef Uint8Vector TableType;", "   std::vector<uint8_t> values{};", " };", " ", "-struct Uint8Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct Uint8Vector FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef Uint8VectorT NativeTableType;", "   typedef Uint8VectorBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_VALUES = 4", "   };", "-  const flatbuffers::Vector<uint8_t> *values() const {", "-    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUES);", "+  const ::flatbuffers::Vector<uint8_t> *values() const {", "+    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VALUES);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_VALUES) &&", "            verifier.VerifyVector(values()) &&", "            verifier.EndTable();", "   }", "-  Uint8VectorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(Uint8VectorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<Uint8Vector> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  Uint8VectorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(Uint8VectorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<Uint8Vector> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct Uint8VectorBuilder {", "   typedef Uint8Vector Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_values(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> values) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> values) {", "     fbb_.AddOffset(Uint8Vector::VT_VALUES, values);", "   }", "-  explicit Uint8VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit Uint8VectorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<Uint8Vector> Finish() {", "+  ::flatbuffers::Offset<Uint8Vector> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<Uint8Vector>(end);", "+    auto o = ::flatbuffers::Offset<Uint8Vector>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<Uint8Vector> CreateUint8Vector(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> values = 0) {", "+inline ::flatbuffers::Offset<Uint8Vector> CreateUint8Vector(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> values = 0) {", "   Uint8VectorBuilder builder_(_fbb);", "   builder_.add_values(values);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<Uint8Vector> CreateUint8VectorDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<Uint8Vector> CreateUint8VectorDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const std::vector<uint8_t> *values = nullptr) {", "   if (values) { _fbb.ForceVectorAlignment(values->size(), sizeof(uint8_t), 4); }", "   auto values__ = values ? _fbb.CreateVector<uint8_t>(*values) : 0;", "@@ -4498,9 +4505,9 @@ inline flatbuffers::Offset<Uint8Vector> CreateUint8VectorDirect(", "       values__);", " }", " ", "-flatbuffers::Offset<Uint8Vector> CreateUint8Vector(flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<Uint8Vector> CreateUint8Vector(::flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct DimensionMetadataT : public flatbuffers::NativeTable {", "+struct DimensionMetadataT : public ::flatbuffers::NativeTable {", "   typedef DimensionMetadata TableType;", "   tflite::DimensionType format = tflite::DimensionType_DENSE;", "   int32_t dense_size = 0;", "@@ -4508,7 +4515,7 @@ struct DimensionMetadataT : public flatbuffers::NativeTable {", "   tflite::SparseIndexVectorUnion array_indices{};", " };", " ", "-struct DimensionMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct DimensionMetadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef DimensionMetadataT NativeTableType;", "   typedef DimensionMetadataBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -4557,7 +4564,7 @@ struct DimensionMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   const tflite::Uint8Vector *array_indices_as_Uint8Vector() const {", "     return array_indices_type() == tflite::SparseIndexVector_Uint8Vector ? static_cast<const tflite::Uint8Vector *>(array_indices()) : nullptr;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_FORMAT, 1) &&", "            VerifyField<int32_t>(verifier, VT_DENSE_SIZE, 4) &&", "@@ -4569,9 +4576,9 @@ struct DimensionMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            VerifySparseIndexVector(verifier, array_indices(), array_indices_type()) &&", "            verifier.EndTable();", "   }", "-  DimensionMetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(DimensionMetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<DimensionMetadata> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  DimensionMetadataT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(DimensionMetadataT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<DimensionMetadata> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " template<> inline const tflite::Int32Vector *DimensionMetadata::array_segments_as<tflite::Int32Vector>() const {", "@@ -4600,8 +4607,8 @@ template<> inline const tflite::Uint8Vector *DimensionMetadata::array_indices_as", " ", " struct DimensionMetadataBuilder {", "   typedef DimensionMetadata Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_format(tflite::DimensionType format) {", "     fbb_.AddElement<int8_t>(DimensionMetadata::VT_FORMAT, static_cast<int8_t>(format), 0);", "   }", "@@ -4611,34 +4618,34 @@ struct DimensionMetadataBuilder {", "   void add_array_segments_type(tflite::SparseIndexVector array_segments_type) {", "     fbb_.AddElement<uint8_t>(DimensionMetadata::VT_ARRAY_SEGMENTS_TYPE, static_cast<uint8_t>(array_segments_type), 0);", "   }", "-  void add_array_segments(flatbuffers::Offset<void> array_segments) {", "+  void add_array_segments(::flatbuffers::Offset<void> array_segments) {", "     fbb_.AddOffset(DimensionMetadata::VT_ARRAY_SEGMENTS, array_segments);", "   }", "   void add_array_indices_type(tflite::SparseIndexVector array_indices_type) {", "     fbb_.AddElement<uint8_t>(DimensionMetadata::VT_ARRAY_INDICES_TYPE, static_cast<uint8_t>(array_indices_type), 0);", "   }", "-  void add_array_indices(flatbuffers::Offset<void> array_indices) {", "+  void add_array_indices(::flatbuffers::Offset<void> array_indices) {", "     fbb_.AddOffset(DimensionMetadata::VT_ARRAY_INDICES, array_indices);", "   }", "-  explicit DimensionMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit DimensionMetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<DimensionMetadata> Finish() {", "+  ::flatbuffers::Offset<DimensionMetadata> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<DimensionMetadata>(end);", "+    auto o = ::flatbuffers::Offset<DimensionMetadata>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::DimensionType format = tflite::DimensionType_DENSE,", "     int32_t dense_size = 0,", "     tflite::SparseIndexVector array_segments_type = tflite::SparseIndexVector_NONE,", "-    flatbuffers::Offset<void> array_segments = 0,", "+    ::flatbuffers::Offset<void> array_segments = 0,", "     tflite::SparseIndexVector array_indices_type = tflite::SparseIndexVector_NONE,", "-    flatbuffers::Offset<void> array_indices = 0) {", "+    ::flatbuffers::Offset<void> array_indices = 0) {", "   DimensionMetadataBuilder builder_(_fbb);", "   builder_.add_array_indices(array_indices);", "   builder_.add_array_segments(array_segments);", "@@ -4649,9 +4656,9 @@ inline flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(::flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SparsityParametersT : public flatbuffers::NativeTable {", "+struct SparsityParametersT : public ::flatbuffers::NativeTable {", "   typedef SparsityParameters TableType;", "   std::vector<int32_t> traversal_order{};", "   std::vector<int32_t> block_map{};", "@@ -4662,7 +4669,7 @@ struct SparsityParametersT : public flatbuffers::NativeTable {", "   SparsityParametersT &operator=(SparsityParametersT o) FLATBUFFERS_NOEXCEPT;", " };", " ", "-struct SparsityParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SparsityParameters FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SparsityParametersT NativeTableType;", "   typedef SparsityParametersBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -4670,16 +4677,16 @@ struct SparsityParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "     VT_BLOCK_MAP = 6,", "     VT_DIM_METADATA = 8", "   };", "-  const flatbuffers::Vector<int32_t> *traversal_order() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TRAVERSAL_ORDER);", "+  const ::flatbuffers::Vector<int32_t> *traversal_order() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_TRAVERSAL_ORDER);", "   }", "-  const flatbuffers::Vector<int32_t> *block_map() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCK_MAP);", "+  const ::flatbuffers::Vector<int32_t> *block_map() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_BLOCK_MAP);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::DimensionMetadata>> *dim_metadata() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::DimensionMetadata>> *>(VT_DIM_METADATA);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::DimensionMetadata>> *dim_metadata() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::DimensionMetadata>> *>(VT_DIM_METADATA);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_TRAVERSAL_ORDER) &&", "            verifier.VerifyVector(traversal_order()) &&", "@@ -4690,40 +4697,40 @@ struct SparsityParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            verifier.VerifyVectorOfTables(dim_metadata()) &&", "            verifier.EndTable();", "   }", "-  SparsityParametersT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SparsityParametersT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SparsityParameters> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SparsityParametersT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SparsityParametersT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SparsityParameters> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SparsityParametersBuilder {", "   typedef SparsityParameters Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_traversal_order(flatbuffers::Offset<flatbuffers::Vector<int32_t>> traversal_order) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_traversal_order(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> traversal_order) {", "     fbb_.AddOffset(SparsityParameters::VT_TRAVERSAL_ORDER, traversal_order);", "   }", "-  void add_block_map(flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_map) {", "+  void add_block_map(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> block_map) {", "     fbb_.AddOffset(SparsityParameters::VT_BLOCK_MAP, block_map);", "   }", "-  void add_dim_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::DimensionMetadata>>> dim_metadata) {", "+  void add_dim_metadata(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::DimensionMetadata>>> dim_metadata) {", "     fbb_.AddOffset(SparsityParameters::VT_DIM_METADATA, dim_metadata);", "   }", "-  explicit SparsityParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit SparsityParametersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SparsityParameters> Finish() {", "+  ::flatbuffers::Offset<SparsityParameters> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SparsityParameters>(end);", "+    auto o = ::flatbuffers::Offset<SparsityParameters>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> traversal_order = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_map = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::DimensionMetadata>>> dim_metadata = 0) {", "+inline ::flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> traversal_order = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> block_map = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::DimensionMetadata>>> dim_metadata = 0) {", "   SparsityParametersBuilder builder_(_fbb);", "   builder_.add_dim_metadata(dim_metadata);", "   builder_.add_block_map(block_map);", "@@ -4731,14 +4738,14 @@ inline flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<SparsityParameters> CreateSparsityParametersDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<SparsityParameters> CreateSparsityParametersDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const std::vector<int32_t> *traversal_order = nullptr,", "     const std::vector<int32_t> *block_map = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::DimensionMetadata>> *dim_metadata = nullptr) {", "+    const std::vector<::flatbuffers::Offset<tflite::DimensionMetadata>> *dim_metadata = nullptr) {", "   auto traversal_order__ = traversal_order ? _fbb.CreateVector<int32_t>(*traversal_order) : 0;", "   auto block_map__ = block_map ? _fbb.CreateVector<int32_t>(*block_map) : 0;", "-  auto dim_metadata__ = dim_metadata ? _fbb.CreateVector<flatbuffers::Offset<tflite::DimensionMetadata>>(*dim_metadata) : 0;", "+  auto dim_metadata__ = dim_metadata ? _fbb.CreateVector<::flatbuffers::Offset<tflite::DimensionMetadata>>(*dim_metadata) : 0;", "   return tflite::CreateSparsityParameters(", "       _fbb,", "       traversal_order__,", "@@ -4746,16 +4753,16 @@ inline flatbuffers::Offset<SparsityParameters> CreateSparsityParametersDirect(", "       dim_metadata__);", " }", " ", "-flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(::flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct VariantSubTypeT : public flatbuffers::NativeTable {", "+struct VariantSubTypeT : public ::flatbuffers::NativeTable {", "   typedef VariantSubType TableType;", "   std::vector<int32_t> shape{};", "   tflite::TensorType type = tflite::TensorType_FLOAT32;", "   bool has_rank = false;", " };", " ", "-struct VariantSubType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct VariantSubType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef VariantSubTypeT NativeTableType;", "   typedef VariantSubTypeBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -4763,8 +4770,8 @@ struct VariantSubType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "     VT_TYPE = 6,", "     VT_HAS_RANK = 8", "   };", "-  const flatbuffers::Vector<int32_t> *shape() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE);", "+  const ::flatbuffers::Vector<int32_t> *shape() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHAPE);", "   }", "   tflite::TensorType type() const {", "     return static_cast<tflite::TensorType>(GetField<int8_t>(VT_TYPE, 0));", "@@ -4772,7 +4779,7 @@ struct VariantSubType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool has_rank() const {", "     return GetField<uint8_t>(VT_HAS_RANK, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_SHAPE) &&", "            verifier.VerifyVector(shape()) &&", "@@ -4780,16 +4787,16 @@ struct VariantSubType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            VerifyField<uint8_t>(verifier, VT_HAS_RANK, 1) &&", "            verifier.EndTable();", "   }", "-  VariantSubTypeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(VariantSubTypeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<VariantSubType> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VariantSubTypeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  VariantSubTypeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(VariantSubTypeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<VariantSubType> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VariantSubTypeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct VariantSubTypeBuilder {", "   typedef VariantSubType Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape) {", "     fbb_.AddOffset(VariantSubType::VT_SHAPE, shape);", "   }", "   void add_type(tflite::TensorType type) {", "@@ -4798,20 +4805,20 @@ struct VariantSubTypeBuilder {", "   void add_has_rank(bool has_rank) {", "     fbb_.AddElement<uint8_t>(VariantSubType::VT_HAS_RANK, static_cast<uint8_t>(has_rank), 0);", "   }", "-  explicit VariantSubTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit VariantSubTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<VariantSubType> Finish() {", "+  ::flatbuffers::Offset<VariantSubType> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<VariantSubType>(end);", "+    auto o = ::flatbuffers::Offset<VariantSubType>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<VariantSubType> CreateVariantSubType(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0,", "+inline ::flatbuffers::Offset<VariantSubType> CreateVariantSubType(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape = 0,", "     tflite::TensorType type = tflite::TensorType_FLOAT32,", "     bool has_rank = false) {", "   VariantSubTypeBuilder builder_(_fbb);", "@@ -4821,8 +4828,8 @@ inline flatbuffers::Offset<VariantSubType> CreateVariantSubType(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<VariantSubType> CreateVariantSubTypeDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<VariantSubType> CreateVariantSubTypeDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const std::vector<int32_t> *shape = nullptr,", "     tflite::TensorType type = tflite::TensorType_FLOAT32,", "     bool has_rank = false) {", "@@ -4834,9 +4841,9 @@ inline flatbuffers::Offset<VariantSubType> CreateVariantSubTypeDirect(", "       has_rank);", " }", " ", "-flatbuffers::Offset<VariantSubType> CreateVariantSubType(flatbuffers::FlatBufferBuilder &_fbb, const VariantSubTypeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<VariantSubType> CreateVariantSubType(::flatbuffers::FlatBufferBuilder &_fbb, const VariantSubTypeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct TensorT : public flatbuffers::NativeTable {", "+struct TensorT : public ::flatbuffers::NativeTable {", "   typedef Tensor TableType;", "   std::vector<int32_t> shape{};", "   tflite::TensorType type = tflite::TensorType_FLOAT32;", "@@ -4854,7 +4861,7 @@ struct TensorT : public flatbuffers::NativeTable {", "   TensorT &operator=(TensorT o) FLATBUFFERS_NOEXCEPT;", " };", " ", "-struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct Tensor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef TensorT NativeTableType;", "   typedef TensorBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -4869,8 +4876,8 @@ struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "     VT_HAS_RANK = 20,", "     VT_VARIANT_TENSORS = 22", "   };", "-  const flatbuffers::Vector<int32_t> *shape() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE);", "+  const ::flatbuffers::Vector<int32_t> *shape() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHAPE);", "   }", "   tflite::TensorType type() const {", "     return static_cast<tflite::TensorType>(GetField<int8_t>(VT_TYPE, 0));", "@@ -4878,8 +4885,8 @@ struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   uint32_t buffer() const {", "     return GetField<uint32_t>(VT_BUFFER, 0);", "   }", "-  const flatbuffers::String *name() const {", "-    return GetPointer<const flatbuffers::String *>(VT_NAME);", "+  const ::flatbuffers::String *name() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_NAME);", "   }", "   const tflite::QuantizationParameters *quantization() const {", "     return GetPointer<const tflite::QuantizationParameters *>(VT_QUANTIZATION);", "@@ -4890,16 +4897,16 @@ struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   const tflite::SparsityParameters *sparsity() const {", "     return GetPointer<const tflite::SparsityParameters *>(VT_SPARSITY);", "   }", "-  const flatbuffers::Vector<int32_t> *shape_signature() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE_SIGNATURE);", "+  const ::flatbuffers::Vector<int32_t> *shape_signature() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHAPE_SIGNATURE);", "   }", "   bool has_rank() const {", "     return GetField<uint8_t>(VT_HAS_RANK, 0) != 0;", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::VariantSubType>> *variant_tensors() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::VariantSubType>> *>(VT_VARIANT_TENSORS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::VariantSubType>> *variant_tensors() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::VariantSubType>> *>(VT_VARIANT_TENSORS);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_SHAPE) &&", "            verifier.VerifyVector(shape()) &&", "@@ -4920,16 +4927,16 @@ struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            verifier.VerifyVectorOfTables(variant_tensors()) &&", "            verifier.EndTable();", "   }", "-  TensorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(TensorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<Tensor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  TensorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(TensorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<Tensor> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TensorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct TensorBuilder {", "   typedef Tensor Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape) {", "     fbb_.AddOffset(Tensor::VT_SHAPE, shape);", "   }", "   void add_type(tflite::TensorType type) {", "@@ -4938,50 +4945,50 @@ struct TensorBuilder {", "   void add_buffer(uint32_t buffer) {", "     fbb_.AddElement<uint32_t>(Tensor::VT_BUFFER, buffer, 0);", "   }", "-  void add_name(flatbuffers::Offset<flatbuffers::String> name) {", "+  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {", "     fbb_.AddOffset(Tensor::VT_NAME, name);", "   }", "-  void add_quantization(flatbuffers::Offset<tflite::QuantizationParameters> quantization) {", "+  void add_quantization(::flatbuffers::Offset<tflite::QuantizationParameters> quantization) {", "     fbb_.AddOffset(Tensor::VT_QUANTIZATION, quantization);", "   }", "   void add_is_variable(bool is_variable) {", "     fbb_.AddElement<uint8_t>(Tensor::VT_IS_VARIABLE, static_cast<uint8_t>(is_variable), 0);", "   }", "-  void add_sparsity(flatbuffers::Offset<tflite::SparsityParameters> sparsity) {", "+  void add_sparsity(::flatbuffers::Offset<tflite::SparsityParameters> sparsity) {", "     fbb_.AddOffset(Tensor::VT_SPARSITY, sparsity);", "   }", "-  void add_shape_signature(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape_signature) {", "+  void add_shape_signature(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape_signature) {", "     fbb_.AddOffset(Tensor::VT_SHAPE_SIGNATURE, shape_signature);", "   }", "   void add_has_rank(bool has_rank) {", "     fbb_.AddElement<uint8_t>(Tensor::VT_HAS_RANK, static_cast<uint8_t>(has_rank), 0);", "   }", "-  void add_variant_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::VariantSubType>>> variant_tensors) {", "+  void add_variant_tensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::VariantSubType>>> variant_tensors) {", "     fbb_.AddOffset(Tensor::VT_VARIANT_TENSORS, variant_tensors);", "   }", "-  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit TensorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<Tensor> Finish() {", "+  ::flatbuffers::Offset<Tensor> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<Tensor>(end);", "+    auto o = ::flatbuffers::Offset<Tensor>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<Tensor> CreateTensor(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0,", "+inline ::flatbuffers::Offset<Tensor> CreateTensor(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape = 0,", "     tflite::TensorType type = tflite::TensorType_FLOAT32,", "     uint32_t buffer = 0,", "-    flatbuffers::Offset<flatbuffers::String> name = 0,", "-    flatbuffers::Offset<tflite::QuantizationParameters> quantization = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> name = 0,", "+    ::flatbuffers::Offset<tflite::QuantizationParameters> quantization = 0,", "     bool is_variable = false,", "-    flatbuffers::Offset<tflite::SparsityParameters> sparsity = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape_signature = 0,", "+    ::flatbuffers::Offset<tflite::SparsityParameters> sparsity = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape_signature = 0,", "     bool has_rank = false,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::VariantSubType>>> variant_tensors = 0) {", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::VariantSubType>>> variant_tensors = 0) {", "   TensorBuilder builder_(_fbb);", "   builder_.add_variant_tensors(variant_tensors);", "   builder_.add_shape_signature(shape_signature);", "@@ -4996,22 +5003,22 @@ inline flatbuffers::Offset<Tensor> CreateTensor(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<Tensor> CreateTensorDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<Tensor> CreateTensorDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const std::vector<int32_t> *shape = nullptr,", "     tflite::TensorType type = tflite::TensorType_FLOAT32,", "     uint32_t buffer = 0,", "     const char *name = nullptr,", "-    flatbuffers::Offset<tflite::QuantizationParameters> quantization = 0,", "+    ::flatbuffers::Offset<tflite::QuantizationParameters> quantization = 0,", "     bool is_variable = false,", "-    flatbuffers::Offset<tflite::SparsityParameters> sparsity = 0,", "+    ::flatbuffers::Offset<tflite::SparsityParameters> sparsity = 0,", "     const std::vector<int32_t> *shape_signature = nullptr,", "     bool has_rank = false,", "-    const std::vector<flatbuffers::Offset<tflite::VariantSubType>> *variant_tensors = nullptr) {", "+    const std::vector<::flatbuffers::Offset<tflite::VariantSubType>> *variant_tensors = nullptr) {", "   auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;", "   auto name__ = name ? _fbb.CreateString(name) : 0;", "   auto shape_signature__ = shape_signature ? _fbb.CreateVector<int32_t>(*shape_signature) : 0;", "-  auto variant_tensors__ = variant_tensors ? _fbb.CreateVector<flatbuffers::Offset<tflite::VariantSubType>>(*variant_tensors) : 0;", "+  auto variant_tensors__ = variant_tensors ? _fbb.CreateVector<::flatbuffers::Offset<tflite::VariantSubType>>(*variant_tensors) : 0;", "   return tflite::CreateTensor(", "       _fbb,", "       shape__,", "@@ -5026,9 +5033,9 @@ inline flatbuffers::Offset<Tensor> CreateTensorDirect(", "       variant_tensors__);", " }", " ", "-flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<Tensor> CreateTensor(::flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct Conv2DOptionsT : public flatbuffers::NativeTable {", "+struct Conv2DOptionsT : public ::flatbuffers::NativeTable {", "   typedef Conv2DOptions TableType;", "   tflite::Padding padding = tflite::Padding_SAME;", "   int32_t stride_w = 0;", "@@ -5038,7 +5045,7 @@ struct Conv2DOptionsT : public flatbuffers::NativeTable {", "   int32_t dilation_h_factor = 1;", " };", " ", "-struct Conv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct Conv2DOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef Conv2DOptionsT NativeTableType;", "   typedef Conv2DOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -5067,7 +5074,7 @@ struct Conv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t dilation_h_factor() const {", "     return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_PADDING, 1) &&", "            VerifyField<int32_t>(verifier, VT_STRIDE_W, 4) &&", "@@ -5077,15 +5084,15 @@ struct Conv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR, 4) &&", "            verifier.EndTable();", "   }", "-  Conv2DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(Conv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<Conv2DOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  Conv2DOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(Conv2DOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<Conv2DOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct Conv2DOptionsBuilder {", "   typedef Conv2DOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_padding(tflite::Padding padding) {", "     fbb_.AddElement<int8_t>(Conv2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);", "   }", "@@ -5104,19 +5111,19 @@ struct Conv2DOptionsBuilder {", "   void add_dilation_h_factor(int32_t dilation_h_factor) {", "     fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);", "   }", "-  explicit Conv2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit Conv2DOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<Conv2DOptions> Finish() {", "+  ::flatbuffers::Offset<Conv2DOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<Conv2DOptions>(end);", "+    auto o = ::flatbuffers::Offset<Conv2DOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::Padding padding = tflite::Padding_SAME,", "     int32_t stride_w = 0,", "     int32_t stride_h = 0,", "@@ -5133,9 +5140,9 @@ inline flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(::flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct Conv3DOptionsT : public flatbuffers::NativeTable {", "+struct Conv3DOptionsT : public ::flatbuffers::NativeTable {", "   typedef Conv3DOptions TableType;", "   tflite::Padding padding = tflite::Padding_SAME;", "   int32_t stride_d = 0;", "@@ -5147,7 +5154,7 @@ struct Conv3DOptionsT : public flatbuffers::NativeTable {", "   int32_t dilation_h_factor = 1;", " };", " ", "-struct Conv3DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct Conv3DOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef Conv3DOptionsT NativeTableType;", "   typedef Conv3DOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -5184,7 +5191,7 @@ struct Conv3DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t dilation_h_factor() const {", "     return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_PADDING, 1) &&", "            VerifyField<int32_t>(verifier, VT_STRIDE_D, 4) &&", "@@ -5196,15 +5203,15 @@ struct Conv3DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR, 4) &&", "            verifier.EndTable();", "   }", "-  Conv3DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(Conv3DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<Conv3DOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  Conv3DOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(Conv3DOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<Conv3DOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct Conv3DOptionsBuilder {", "   typedef Conv3DOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_padding(tflite::Padding padding) {", "     fbb_.AddElement<int8_t>(Conv3DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);", "   }", "@@ -5229,19 +5236,19 @@ struct Conv3DOptionsBuilder {", "   void add_dilation_h_factor(int32_t dilation_h_factor) {", "     fbb_.AddElement<int32_t>(Conv3DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);", "   }", "-  explicit Conv3DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit Conv3DOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<Conv3DOptions> Finish() {", "+  ::flatbuffers::Offset<Conv3DOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<Conv3DOptions>(end);", "+    auto o = ::flatbuffers::Offset<Conv3DOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::Padding padding = tflite::Padding_SAME,", "     int32_t stride_d = 0,", "     int32_t stride_w = 0,", "@@ -5262,9 +5269,9 @@ inline flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(::flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct Pool2DOptionsT : public flatbuffers::NativeTable {", "+struct Pool2DOptionsT : public ::flatbuffers::NativeTable {", "   typedef Pool2DOptions TableType;", "   tflite::Padding padding = tflite::Padding_SAME;", "   int32_t stride_w = 0;", "@@ -5274,7 +5281,7 @@ struct Pool2DOptionsT : public flatbuffers::NativeTable {", "   tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;", " };", " ", "-struct Pool2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct Pool2DOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef Pool2DOptionsT NativeTableType;", "   typedef Pool2DOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -5303,7 +5310,7 @@ struct Pool2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   tflite::ActivationFunctionType fused_activation_function() const {", "     return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_PADDING, 1) &&", "            VerifyField<int32_t>(verifier, VT_STRIDE_W, 4) &&", "@@ -5313,15 +5320,15 @@ struct Pool2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&", "            verifier.EndTable();", "   }", "-  Pool2DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(Pool2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<Pool2DOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  Pool2DOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(Pool2DOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<Pool2DOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct Pool2DOptionsBuilder {", "   typedef Pool2DOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_padding(tflite::Padding padding) {", "     fbb_.AddElement<int8_t>(Pool2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);", "   }", "@@ -5340,19 +5347,19 @@ struct Pool2DOptionsBuilder {", "   void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {", "     fbb_.AddElement<int8_t>(Pool2DOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);", "   }", "-  explicit Pool2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit Pool2DOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<Pool2DOptions> Finish() {", "+  ::flatbuffers::Offset<Pool2DOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<Pool2DOptions>(end);", "+    auto o = ::flatbuffers::Offset<Pool2DOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::Padding padding = tflite::Padding_SAME,", "     int32_t stride_w = 0,", "     int32_t stride_h = 0,", "@@ -5369,9 +5376,9 @@ inline flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(::flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct DepthwiseConv2DOptionsT : public flatbuffers::NativeTable {", "+struct DepthwiseConv2DOptionsT : public ::flatbuffers::NativeTable {", "   typedef DepthwiseConv2DOptions TableType;", "   tflite::Padding padding = tflite::Padding_SAME;", "   int32_t stride_w = 0;", "@@ -5382,7 +5389,7 @@ struct DepthwiseConv2DOptionsT : public flatbuffers::NativeTable {", "   int32_t dilation_h_factor = 1;", " };", " ", "-struct DepthwiseConv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct DepthwiseConv2DOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef DepthwiseConv2DOptionsT NativeTableType;", "   typedef DepthwiseConv2DOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -5415,7 +5422,7 @@ struct DepthwiseConv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tab", "   int32_t dilation_h_factor() const {", "     return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_PADDING, 1) &&", "            VerifyField<int32_t>(verifier, VT_STRIDE_W, 4) &&", "@@ -5426,15 +5433,15 @@ struct DepthwiseConv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tab", "            VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR, 4) &&", "            verifier.EndTable();", "   }", "-  DepthwiseConv2DOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(DepthwiseConv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<DepthwiseConv2DOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  DepthwiseConv2DOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(DepthwiseConv2DOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<DepthwiseConv2DOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct DepthwiseConv2DOptionsBuilder {", "   typedef DepthwiseConv2DOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_padding(tflite::Padding padding) {", "     fbb_.AddElement<int8_t>(DepthwiseConv2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);", "   }", "@@ -5456,19 +5463,19 @@ struct DepthwiseConv2DOptionsBuilder {", "   void add_dilation_h_factor(int32_t dilation_h_factor) {", "     fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);", "   }", "-  explicit DepthwiseConv2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit DepthwiseConv2DOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<DepthwiseConv2DOptions> Finish() {", "+  ::flatbuffers::Offset<DepthwiseConv2DOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<DepthwiseConv2DOptions>(end);", "+    auto o = ::flatbuffers::Offset<DepthwiseConv2DOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::Padding padding = tflite::Padding_SAME,", "     int32_t stride_w = 0,", "     int32_t stride_h = 0,", "@@ -5487,16 +5494,16 @@ inline flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ConcatEmbeddingsOptionsT : public flatbuffers::NativeTable {", "+struct ConcatEmbeddingsOptionsT : public ::flatbuffers::NativeTable {", "   typedef ConcatEmbeddingsOptions TableType;", "   int32_t num_channels = 0;", "   std::vector<int32_t> num_columns_per_channel{};", "   std::vector<int32_t> embedding_dim_per_channel{};", " };", " ", "-struct ConcatEmbeddingsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ConcatEmbeddingsOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ConcatEmbeddingsOptionsT NativeTableType;", "   typedef ConcatEmbeddingsOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -5507,13 +5514,13 @@ struct ConcatEmbeddingsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Ta", "   int32_t num_channels() const {", "     return GetField<int32_t>(VT_NUM_CHANNELS, 0);", "   }", "-  const flatbuffers::Vector<int32_t> *num_columns_per_channel() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NUM_COLUMNS_PER_CHANNEL);", "+  const ::flatbuffers::Vector<int32_t> *num_columns_per_channel() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_NUM_COLUMNS_PER_CHANNEL);", "   }", "-  const flatbuffers::Vector<int32_t> *embedding_dim_per_channel() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_EMBEDDING_DIM_PER_CHANNEL);", "+  const ::flatbuffers::Vector<int32_t> *embedding_dim_per_channel() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_EMBEDDING_DIM_PER_CHANNEL);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_NUM_CHANNELS, 4) &&", "            VerifyOffset(verifier, VT_NUM_COLUMNS_PER_CHANNEL) &&", "@@ -5522,40 +5529,40 @@ struct ConcatEmbeddingsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Ta", "            verifier.VerifyVector(embedding_dim_per_channel()) &&", "            verifier.EndTable();", "   }", "-  ConcatEmbeddingsOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ConcatEmbeddingsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ConcatEmbeddingsOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ConcatEmbeddingsOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ConcatEmbeddingsOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ConcatEmbeddingsOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ConcatEmbeddingsOptionsBuilder {", "   typedef ConcatEmbeddingsOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_num_channels(int32_t num_channels) {", "     fbb_.AddElement<int32_t>(ConcatEmbeddingsOptions::VT_NUM_CHANNELS, num_channels, 0);", "   }", "-  void add_num_columns_per_channel(flatbuffers::Offset<flatbuffers::Vector<int32_t>> num_columns_per_channel) {", "+  void add_num_columns_per_channel(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> num_columns_per_channel) {", "     fbb_.AddOffset(ConcatEmbeddingsOptions::VT_NUM_COLUMNS_PER_CHANNEL, num_columns_per_channel);", "   }", "-  void add_embedding_dim_per_channel(flatbuffers::Offset<flatbuffers::Vector<int32_t>> embedding_dim_per_channel) {", "+  void add_embedding_dim_per_channel(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> embedding_dim_per_channel) {", "     fbb_.AddOffset(ConcatEmbeddingsOptions::VT_EMBEDDING_DIM_PER_CHANNEL, embedding_dim_per_channel);", "   }", "-  explicit ConcatEmbeddingsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit ConcatEmbeddingsOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ConcatEmbeddingsOptions> Finish() {", "+  ::flatbuffers::Offset<ConcatEmbeddingsOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ConcatEmbeddingsOptions>(end);", "+    auto o = ::flatbuffers::Offset<ConcatEmbeddingsOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t num_channels = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> num_columns_per_channel = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> embedding_dim_per_channel = 0) {", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> num_columns_per_channel = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> embedding_dim_per_channel = 0) {", "   ConcatEmbeddingsOptionsBuilder builder_(_fbb);", "   builder_.add_embedding_dim_per_channel(embedding_dim_per_channel);", "   builder_.add_num_columns_per_channel(num_columns_per_channel);", "@@ -5563,8 +5570,8 @@ inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOption", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptionsDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptionsDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t num_channels = 0,", "     const std::vector<int32_t> *num_columns_per_channel = nullptr,", "     const std::vector<int32_t> *embedding_dim_per_channel = nullptr) {", "@@ -5577,14 +5584,14 @@ inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOption", "       embedding_dim_per_channel__);", " }", " ", "-flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct LSHProjectionOptionsT : public flatbuffers::NativeTable {", "+struct LSHProjectionOptionsT : public ::flatbuffers::NativeTable {", "   typedef LSHProjectionOptions TableType;", "   tflite::LSHProjectionType type = tflite::LSHProjectionType_UNKNOWN;", " };", " ", "-struct LSHProjectionOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct LSHProjectionOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef LSHProjectionOptionsT NativeTableType;", "   typedef LSHProjectionOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -5593,52 +5600,52 @@ struct LSHProjectionOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table", "   tflite::LSHProjectionType type() const {", "     return static_cast<tflite::LSHProjectionType>(GetField<int8_t>(VT_TYPE, 0));", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_TYPE, 1) &&", "            verifier.EndTable();", "   }", "-  LSHProjectionOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(LSHProjectionOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<LSHProjectionOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  LSHProjectionOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(LSHProjectionOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<LSHProjectionOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct LSHProjectionOptionsBuilder {", "   typedef LSHProjectionOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_type(tflite::LSHProjectionType type) {", "     fbb_.AddElement<int8_t>(LSHProjectionOptions::VT_TYPE, static_cast<int8_t>(type), 0);", "   }", "-  explicit LSHProjectionOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit LSHProjectionOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<LSHProjectionOptions> Finish() {", "+  ::flatbuffers::Offset<LSHProjectionOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<LSHProjectionOptions>(end);", "+    auto o = ::flatbuffers::Offset<LSHProjectionOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::LSHProjectionType type = tflite::LSHProjectionType_UNKNOWN) {", "   LSHProjectionOptionsBuilder builder_(_fbb);", "   builder_.add_type(type);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SVDFOptionsT : public flatbuffers::NativeTable {", "+struct SVDFOptionsT : public ::flatbuffers::NativeTable {", "   typedef SVDFOptions TableType;", "   int32_t rank = 0;", "   tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;", "   bool asymmetric_quantize_inputs = false;", " };", " ", "-struct SVDFOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SVDFOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SVDFOptionsT NativeTableType;", "   typedef SVDFOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -5655,22 +5662,22 @@ struct SVDFOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool asymmetric_quantize_inputs() const {", "     return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_RANK, 4) &&", "            VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&", "            VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) &&", "            verifier.EndTable();", "   }", "-  SVDFOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SVDFOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SVDFOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SVDFOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SVDFOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SVDFOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SVDFOptionsBuilder {", "   typedef SVDFOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_rank(int32_t rank) {", "     fbb_.AddElement<int32_t>(SVDFOptions::VT_RANK, rank, 0);", "   }", "@@ -5680,19 +5687,19 @@ struct SVDFOptionsBuilder {", "   void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {", "     fbb_.AddElement<uint8_t>(SVDFOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);", "   }", "-  explicit SVDFOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit SVDFOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SVDFOptions> Finish() {", "+  ::flatbuffers::Offset<SVDFOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SVDFOptions>(end);", "+    auto o = ::flatbuffers::Offset<SVDFOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t rank = 0,", "     tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,", "     bool asymmetric_quantize_inputs = false) {", "@@ -5703,15 +5710,15 @@ inline flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct RNNOptionsT : public flatbuffers::NativeTable {", "+struct RNNOptionsT : public ::flatbuffers::NativeTable {", "   typedef RNNOptions TableType;", "   tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;", "   bool asymmetric_quantize_inputs = false;", " };", " ", "-struct RNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct RNNOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef RNNOptionsT NativeTableType;", "   typedef RNNOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -5724,40 +5731,40 @@ struct RNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool asymmetric_quantize_inputs() const {", "     return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&", "            VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) &&", "            verifier.EndTable();", "   }", "-  RNNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(RNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<RNNOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  RNNOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(RNNOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<RNNOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct RNNOptionsBuilder {", "   typedef RNNOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {", "     fbb_.AddElement<int8_t>(RNNOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);", "   }", "   void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {", "     fbb_.AddElement<uint8_t>(RNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);", "   }", "-  explicit RNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit RNNOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<RNNOptions> Finish() {", "+  ::flatbuffers::Offset<RNNOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<RNNOptions>(end);", "+    auto o = ::flatbuffers::Offset<RNNOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<RNNOptions> CreateRNNOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<RNNOptions> CreateRNNOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,", "     bool asymmetric_quantize_inputs = false) {", "   RNNOptionsBuilder builder_(_fbb);", "@@ -5766,16 +5773,16 @@ inline flatbuffers::Offset<RNNOptions> CreateRNNOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<RNNOptions> CreateRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<RNNOptions> CreateRNNOptions(::flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SequenceRNNOptionsT : public flatbuffers::NativeTable {", "+struct SequenceRNNOptionsT : public ::flatbuffers::NativeTable {", "   typedef SequenceRNNOptions TableType;", "   bool time_major = false;", "   tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;", "   bool asymmetric_quantize_inputs = false;", " };", " ", "-struct SequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SequenceRNNOptionsT NativeTableType;", "   typedef SequenceRNNOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -5792,22 +5799,22 @@ struct SequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool asymmetric_quantize_inputs() const {", "     return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<uint8_t>(verifier, VT_TIME_MAJOR, 1) &&", "            VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&", "            VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) &&", "            verifier.EndTable();", "   }", "-  SequenceRNNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SequenceRNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SequenceRNNOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SequenceRNNOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SequenceRNNOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SequenceRNNOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SequenceRNNOptionsBuilder {", "   typedef SequenceRNNOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_time_major(bool time_major) {", "     fbb_.AddElement<uint8_t>(SequenceRNNOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);", "   }", "@@ -5817,19 +5824,19 @@ struct SequenceRNNOptionsBuilder {", "   void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {", "     fbb_.AddElement<uint8_t>(SequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);", "   }", "-  explicit SequenceRNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit SequenceRNNOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SequenceRNNOptions> Finish() {", "+  ::flatbuffers::Offset<SequenceRNNOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SequenceRNNOptions>(end);", "+    auto o = ::flatbuffers::Offset<SequenceRNNOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     bool time_major = false,", "     tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,", "     bool asymmetric_quantize_inputs = false) {", "@@ -5840,9 +5847,9 @@ inline flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct BidirectionalSequenceRNNOptionsT : public flatbuffers::NativeTable {", "+struct BidirectionalSequenceRNNOptionsT : public ::flatbuffers::NativeTable {", "   typedef BidirectionalSequenceRNNOptions TableType;", "   bool time_major = false;", "   tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;", "@@ -5850,7 +5857,7 @@ struct BidirectionalSequenceRNNOptionsT : public flatbuffers::NativeTable {", "   bool asymmetric_quantize_inputs = false;", " };", " ", "-struct BidirectionalSequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct BidirectionalSequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef BidirectionalSequenceRNNOptionsT NativeTableType;", "   typedef BidirectionalSequenceRNNOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -5871,7 +5878,7 @@ struct BidirectionalSequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuf", "   bool asymmetric_quantize_inputs() const {", "     return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<uint8_t>(verifier, VT_TIME_MAJOR, 1) &&", "            VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&", "@@ -5879,15 +5886,15 @@ struct BidirectionalSequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuf", "            VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) &&", "            verifier.EndTable();", "   }", "-  BidirectionalSequenceRNNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(BidirectionalSequenceRNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<BidirectionalSequenceRNNOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  BidirectionalSequenceRNNOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(BidirectionalSequenceRNNOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<BidirectionalSequenceRNNOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct BidirectionalSequenceRNNOptionsBuilder {", "   typedef BidirectionalSequenceRNNOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_time_major(bool time_major) {", "     fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);", "   }", "@@ -5900,19 +5907,19 @@ struct BidirectionalSequenceRNNOptionsBuilder {", "   void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {", "     fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);", "   }", "-  explicit BidirectionalSequenceRNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit BidirectionalSequenceRNNOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<BidirectionalSequenceRNNOptions> Finish() {", "+  ::flatbuffers::Offset<BidirectionalSequenceRNNOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<BidirectionalSequenceRNNOptions>(end);", "+    auto o = ::flatbuffers::Offset<BidirectionalSequenceRNNOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     bool time_major = false,", "     tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,", "     bool merge_outputs = false,", "@@ -5925,9 +5932,9 @@ inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalS", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct FullyConnectedOptionsT : public flatbuffers::NativeTable {", "+struct FullyConnectedOptionsT : public ::flatbuffers::NativeTable {", "   typedef FullyConnectedOptions TableType;", "   tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;", "   tflite::FullyConnectedOptionsWeightsFormat weights_format = tflite::FullyConnectedOptionsWeightsFormat_DEFAULT;", "@@ -5935,7 +5942,7 @@ struct FullyConnectedOptionsT : public flatbuffers::NativeTable {", "   bool asymmetric_quantize_inputs = false;", " };", " ", "-struct FullyConnectedOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct FullyConnectedOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef FullyConnectedOptionsT NativeTableType;", "   typedef FullyConnectedOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -5956,7 +5963,7 @@ struct FullyConnectedOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tabl", "   bool asymmetric_quantize_inputs() const {", "     return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&", "            VerifyField<int8_t>(verifier, VT_WEIGHTS_FORMAT, 1) &&", "@@ -5964,15 +5971,15 @@ struct FullyConnectedOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tabl", "            VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) &&", "            verifier.EndTable();", "   }", "-  FullyConnectedOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(FullyConnectedOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<FullyConnectedOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  FullyConnectedOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(FullyConnectedOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<FullyConnectedOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct FullyConnectedOptionsBuilder {", "   typedef FullyConnectedOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {", "     fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);", "   }", "@@ -5985,19 +5992,19 @@ struct FullyConnectedOptionsBuilder {", "   void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {", "     fbb_.AddElement<uint8_t>(FullyConnectedOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);", "   }", "-  explicit FullyConnectedOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit FullyConnectedOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<FullyConnectedOptions> Finish() {", "+  ::flatbuffers::Offset<FullyConnectedOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<FullyConnectedOptions>(end);", "+    auto o = ::flatbuffers::Offset<FullyConnectedOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,", "     tflite::FullyConnectedOptionsWeightsFormat weights_format = tflite::FullyConnectedOptionsWeightsFormat_DEFAULT,", "     bool keep_num_dims = false,", "@@ -6010,14 +6017,14 @@ inline flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(::flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SoftmaxOptionsT : public flatbuffers::NativeTable {", "+struct SoftmaxOptionsT : public ::flatbuffers::NativeTable {", "   typedef SoftmaxOptions TableType;", "   float beta = 0.0f;", " };", " ", "-struct SoftmaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SoftmaxOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SoftmaxOptionsT NativeTableType;", "   typedef SoftmaxOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -6026,51 +6033,51 @@ struct SoftmaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   float beta() const {", "     return GetField<float>(VT_BETA, 0.0f);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<float>(verifier, VT_BETA, 4) &&", "            verifier.EndTable();", "   }", "-  SoftmaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SoftmaxOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SoftmaxOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SoftmaxOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SoftmaxOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SoftmaxOptionsBuilder {", "   typedef SoftmaxOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_beta(float beta) {", "     fbb_.AddElement<float>(SoftmaxOptions::VT_BETA, beta, 0.0f);", "   }", "-  explicit SoftmaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit SoftmaxOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SoftmaxOptions> Finish() {", "+  ::flatbuffers::Offset<SoftmaxOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SoftmaxOptions>(end);", "+    auto o = ::flatbuffers::Offset<SoftmaxOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     float beta = 0.0f) {", "   SoftmaxOptionsBuilder builder_(_fbb);", "   builder_.add_beta(beta);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ConcatenationOptionsT : public flatbuffers::NativeTable {", "+struct ConcatenationOptionsT : public ::flatbuffers::NativeTable {", "   typedef ConcatenationOptions TableType;", "   int32_t axis = 0;", "   tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;", " };", " ", "-struct ConcatenationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ConcatenationOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ConcatenationOptionsT NativeTableType;", "   typedef ConcatenationOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -6083,40 +6090,40 @@ struct ConcatenationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table", "   tflite::ActivationFunctionType fused_activation_function() const {", "     return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_AXIS, 4) &&", "            VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&", "            verifier.EndTable();", "   }", "-  ConcatenationOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ConcatenationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ConcatenationOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ConcatenationOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ConcatenationOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ConcatenationOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ConcatenationOptionsBuilder {", "   typedef ConcatenationOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_axis(int32_t axis) {", "     fbb_.AddElement<int32_t>(ConcatenationOptions::VT_AXIS, axis, 0);", "   }", "   void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {", "     fbb_.AddElement<int8_t>(ConcatenationOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);", "   }", "-  explicit ConcatenationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit ConcatenationOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ConcatenationOptions> Finish() {", "+  ::flatbuffers::Offset<ConcatenationOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ConcatenationOptions>(end);", "+    auto o = ::flatbuffers::Offset<ConcatenationOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t axis = 0,", "     tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {", "   ConcatenationOptionsBuilder builder_(_fbb);", "@@ -6125,15 +6132,15 @@ inline flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct AddOptionsT : public flatbuffers::NativeTable {", "+struct AddOptionsT : public ::flatbuffers::NativeTable {", "   typedef AddOptions TableType;", "   tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;", "   bool pot_scale_int16 = true;", " };", " ", "-struct AddOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct AddOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef AddOptionsT NativeTableType;", "   typedef AddOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -6146,40 +6153,40 @@ struct AddOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool pot_scale_int16() const {", "     return GetField<uint8_t>(VT_POT_SCALE_INT16, 1) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&", "            VerifyField<uint8_t>(verifier, VT_POT_SCALE_INT16, 1) &&", "            verifier.EndTable();", "   }", "-  AddOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(AddOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<AddOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  AddOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(AddOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<AddOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct AddOptionsBuilder {", "   typedef AddOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {", "     fbb_.AddElement<int8_t>(AddOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);", "   }", "   void add_pot_scale_int16(bool pot_scale_int16) {", "     fbb_.AddElement<uint8_t>(AddOptions::VT_POT_SCALE_INT16, static_cast<uint8_t>(pot_scale_int16), 1);", "   }", "-  explicit AddOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit AddOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<AddOptions> Finish() {", "+  ::flatbuffers::Offset<AddOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<AddOptions>(end);", "+    auto o = ::flatbuffers::Offset<AddOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<AddOptions> CreateAddOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<AddOptions> CreateAddOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,", "     bool pot_scale_int16 = true) {", "   AddOptionsBuilder builder_(_fbb);", "@@ -6188,14 +6195,14 @@ inline flatbuffers::Offset<AddOptions> CreateAddOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<AddOptions> CreateAddOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<AddOptions> CreateAddOptions(::flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct MulOptionsT : public flatbuffers::NativeTable {", "+struct MulOptionsT : public ::flatbuffers::NativeTable {", "   typedef MulOptions TableType;", "   tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;", " };", " ", "-struct MulOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct MulOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef MulOptionsT NativeTableType;", "   typedef MulOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -6204,50 +6211,50 @@ struct MulOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   tflite::ActivationFunctionType fused_activation_function() const {", "     return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&", "            verifier.EndTable();", "   }", "-  MulOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(MulOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<MulOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  MulOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(MulOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<MulOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct MulOptionsBuilder {", "   typedef MulOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {", "     fbb_.AddElement<int8_t>(MulOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);", "   }", "-  explicit MulOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit MulOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<MulOptions> Finish() {", "+  ::flatbuffers::Offset<MulOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<MulOptions>(end);", "+    auto o = ::flatbuffers::Offset<MulOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<MulOptions> CreateMulOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<MulOptions> CreateMulOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {", "   MulOptionsBuilder builder_(_fbb);", "   builder_.add_fused_activation_function(fused_activation_function);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<MulOptions> CreateMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<MulOptions> CreateMulOptions(::flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct L2NormOptionsT : public flatbuffers::NativeTable {", "+struct L2NormOptionsT : public ::flatbuffers::NativeTable {", "   typedef L2NormOptions TableType;", "   tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;", " };", " ", "-struct L2NormOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct L2NormOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef L2NormOptionsT NativeTableType;", "   typedef L2NormOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -6256,45 +6263,45 @@ struct L2NormOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   tflite::ActivationFunctionType fused_activation_function() const {", "     return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&", "            verifier.EndTable();", "   }", "-  L2NormOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(L2NormOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<L2NormOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  L2NormOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(L2NormOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<L2NormOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct L2NormOptionsBuilder {", "   typedef L2NormOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {", "     fbb_.AddElement<int8_t>(L2NormOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);", "   }", "-  explicit L2NormOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit L2NormOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<L2NormOptions> Finish() {", "+  ::flatbuffers::Offset<L2NormOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<L2NormOptions>(end);", "+    auto o = ::flatbuffers::Offset<L2NormOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {", "   L2NormOptionsBuilder builder_(_fbb);", "   builder_.add_fused_activation_function(fused_activation_function);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(::flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct LocalResponseNormalizationOptionsT : public flatbuffers::NativeTable {", "+struct LocalResponseNormalizationOptionsT : public ::flatbuffers::NativeTable {", "   typedef LocalResponseNormalizationOptions TableType;", "   int32_t radius = 0;", "   float bias = 0.0f;", "@@ -6302,7 +6309,7 @@ struct LocalResponseNormalizationOptionsT : public flatbuffers::NativeTable {", "   float beta = 0.0f;", " };", " ", "-struct LocalResponseNormalizationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct LocalResponseNormalizationOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef LocalResponseNormalizationOptionsT NativeTableType;", "   typedef LocalResponseNormalizationOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -6323,7 +6330,7 @@ struct LocalResponseNormalizationOptions FLATBUFFERS_FINAL_CLASS : private flatb", "   float beta() const {", "     return GetField<float>(VT_BETA, 0.0f);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_RADIUS, 4) &&", "            VerifyField<float>(verifier, VT_BIAS, 4) &&", "@@ -6331,15 +6338,15 @@ struct LocalResponseNormalizationOptions FLATBUFFERS_FINAL_CLASS : private flatb", "            VerifyField<float>(verifier, VT_BETA, 4) &&", "            verifier.EndTable();", "   }", "-  LocalResponseNormalizationOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(LocalResponseNormalizationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<LocalResponseNormalizationOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  LocalResponseNormalizationOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(LocalResponseNormalizationOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<LocalResponseNormalizationOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct LocalResponseNormalizationOptionsBuilder {", "   typedef LocalResponseNormalizationOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_radius(int32_t radius) {", "     fbb_.AddElement<int32_t>(LocalResponseNormalizationOptions::VT_RADIUS, radius, 0);", "   }", "@@ -6352,19 +6359,19 @@ struct LocalResponseNormalizationOptionsBuilder {", "   void add_beta(float beta) {", "     fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BETA, beta, 0.0f);", "   }", "-  explicit LocalResponseNormalizationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit LocalResponseNormalizationOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<LocalResponseNormalizationOptions> Finish() {", "+  ::flatbuffers::Offset<LocalResponseNormalizationOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<LocalResponseNormalizationOptions>(end);", "+    auto o = ::flatbuffers::Offset<LocalResponseNormalizationOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t radius = 0,", "     float bias = 0.0f,", "     float alpha = 0.0f,", "@@ -6377,9 +6384,9 @@ inline flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalRespons", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct LSTMOptionsT : public flatbuffers::NativeTable {", "+struct LSTMOptionsT : public ::flatbuffers::NativeTable {", "   typedef LSTMOptions TableType;", "   tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;", "   float cell_clip = 0.0f;", "@@ -6388,7 +6395,7 @@ struct LSTMOptionsT : public flatbuffers::NativeTable {", "   bool asymmetric_quantize_inputs = false;", " };", " ", "-struct LSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct LSTMOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef LSTMOptionsT NativeTableType;", "   typedef LSTMOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -6413,7 +6420,7 @@ struct LSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool asymmetric_quantize_inputs() const {", "     return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&", "            VerifyField<float>(verifier, VT_CELL_CLIP, 4) &&", "@@ -6422,15 +6429,15 @@ struct LSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) &&", "            verifier.EndTable();", "   }", "-  LSTMOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(LSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<LSTMOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  LSTMOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(LSTMOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<LSTMOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct LSTMOptionsBuilder {", "   typedef LSTMOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {", "     fbb_.AddElement<int8_t>(LSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);", "   }", "@@ -6446,19 +6453,19 @@ struct LSTMOptionsBuilder {", "   void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {", "     fbb_.AddElement<uint8_t>(LSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);", "   }", "-  explicit LSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit LSTMOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<LSTMOptions> Finish() {", "+  ::flatbuffers::Offset<LSTMOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<LSTMOptions>(end);", "+    auto o = ::flatbuffers::Offset<LSTMOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,", "     float cell_clip = 0.0f,", "     float proj_clip = 0.0f,", "@@ -6473,9 +6480,9 @@ inline flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct UnidirectionalSequenceLSTMOptionsT : public flatbuffers::NativeTable {", "+struct UnidirectionalSequenceLSTMOptionsT : public ::flatbuffers::NativeTable {", "   typedef UnidirectionalSequenceLSTMOptions TableType;", "   tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;", "   float cell_clip = 0.0f;", "@@ -6485,7 +6492,7 @@ struct UnidirectionalSequenceLSTMOptionsT : public flatbuffers::NativeTable {", "   bool diagonal_recurrent_tensors = false;", " };", " ", "-struct UnidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct UnidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef UnidirectionalSequenceLSTMOptionsT NativeTableType;", "   typedef UnidirectionalSequenceLSTMOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -6514,7 +6521,7 @@ struct UnidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private flatb", "   bool diagonal_recurrent_tensors() const {", "     return GetField<uint8_t>(VT_DIAGONAL_RECURRENT_TENSORS, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&", "            VerifyField<float>(verifier, VT_CELL_CLIP, 4) &&", "@@ -6524,15 +6531,15 @@ struct UnidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private flatb", "            VerifyField<uint8_t>(verifier, VT_DIAGONAL_RECURRENT_TENSORS, 1) &&", "            verifier.EndTable();", "   }", "-  UnidirectionalSequenceLSTMOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(UnidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  UnidirectionalSequenceLSTMOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(UnidirectionalSequenceLSTMOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct UnidirectionalSequenceLSTMOptionsBuilder {", "   typedef UnidirectionalSequenceLSTMOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {", "     fbb_.AddElement<int8_t>(UnidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);", "   }", "@@ -6551,19 +6558,19 @@ struct UnidirectionalSequenceLSTMOptionsBuilder {", "   void add_diagonal_recurrent_tensors(bool diagonal_recurrent_tensors) {", "     fbb_.AddElement<uint8_t>(UnidirectionalSequenceLSTMOptions::VT_DIAGONAL_RECURRENT_TENSORS, static_cast<uint8_t>(diagonal_recurrent_tensors), 0);", "   }", "-  explicit UnidirectionalSequenceLSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit UnidirectionalSequenceLSTMOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> Finish() {", "+  ::flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<UnidirectionalSequenceLSTMOptions>(end);", "+    auto o = ::flatbuffers::Offset<UnidirectionalSequenceLSTMOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,", "     float cell_clip = 0.0f,", "     float proj_clip = 0.0f,", "@@ -6580,9 +6587,9 @@ inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirection", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct BidirectionalSequenceLSTMOptionsT : public flatbuffers::NativeTable {", "+struct BidirectionalSequenceLSTMOptionsT : public ::flatbuffers::NativeTable {", "   typedef BidirectionalSequenceLSTMOptions TableType;", "   tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;", "   float cell_clip = 0.0f;", "@@ -6592,7 +6599,7 @@ struct BidirectionalSequenceLSTMOptionsT : public flatbuffers::NativeTable {", "   bool asymmetric_quantize_inputs = false;", " };", " ", "-struct BidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct BidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef BidirectionalSequenceLSTMOptionsT NativeTableType;", "   typedef BidirectionalSequenceLSTMOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -6621,7 +6628,7 @@ struct BidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbu", "   bool asymmetric_quantize_inputs() const {", "     return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&", "            VerifyField<float>(verifier, VT_CELL_CLIP, 4) &&", "@@ -6631,15 +6638,15 @@ struct BidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbu", "            VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) &&", "            verifier.EndTable();", "   }", "-  BidirectionalSequenceLSTMOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(BidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<BidirectionalSequenceLSTMOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  BidirectionalSequenceLSTMOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(BidirectionalSequenceLSTMOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<BidirectionalSequenceLSTMOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct BidirectionalSequenceLSTMOptionsBuilder {", "   typedef BidirectionalSequenceLSTMOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {", "     fbb_.AddElement<int8_t>(BidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);", "   }", "@@ -6658,19 +6665,19 @@ struct BidirectionalSequenceLSTMOptionsBuilder {", "   void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {", "     fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);", "   }", "-  explicit BidirectionalSequenceLSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit BidirectionalSequenceLSTMOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<BidirectionalSequenceLSTMOptions> Finish() {", "+  ::flatbuffers::Offset<BidirectionalSequenceLSTMOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<BidirectionalSequenceLSTMOptions>(end);", "+    auto o = ::flatbuffers::Offset<BidirectionalSequenceLSTMOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,", "     float cell_clip = 0.0f,", "     float proj_clip = 0.0f,", "@@ -6687,15 +6694,15 @@ inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectional", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ResizeBilinearOptionsT : public flatbuffers::NativeTable {", "+struct ResizeBilinearOptionsT : public ::flatbuffers::NativeTable {", "   typedef ResizeBilinearOptions TableType;", "   bool align_corners = false;", "   bool half_pixel_centers = false;", " };", " ", "-struct ResizeBilinearOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ResizeBilinearOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ResizeBilinearOptionsT NativeTableType;", "   typedef ResizeBilinearOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -6708,40 +6715,40 @@ struct ResizeBilinearOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tabl", "   bool half_pixel_centers() const {", "     return GetField<uint8_t>(VT_HALF_PIXEL_CENTERS, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS, 1) &&", "            VerifyField<uint8_t>(verifier, VT_HALF_PIXEL_CENTERS, 1) &&", "            verifier.EndTable();", "   }", "-  ResizeBilinearOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ResizeBilinearOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ResizeBilinearOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ResizeBilinearOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ResizeBilinearOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ResizeBilinearOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ResizeBilinearOptionsBuilder {", "   typedef ResizeBilinearOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_align_corners(bool align_corners) {", "     fbb_.AddElement<uint8_t>(ResizeBilinearOptions::VT_ALIGN_CORNERS, static_cast<uint8_t>(align_corners), 0);", "   }", "   void add_half_pixel_centers(bool half_pixel_centers) {", "     fbb_.AddElement<uint8_t>(ResizeBilinearOptions::VT_HALF_PIXEL_CENTERS, static_cast<uint8_t>(half_pixel_centers), 0);", "   }", "-  explicit ResizeBilinearOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit ResizeBilinearOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ResizeBilinearOptions> Finish() {", "+  ::flatbuffers::Offset<ResizeBilinearOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ResizeBilinearOptions>(end);", "+    auto o = ::flatbuffers::Offset<ResizeBilinearOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     bool align_corners = false,", "     bool half_pixel_centers = false) {", "   ResizeBilinearOptionsBuilder builder_(_fbb);", "@@ -6750,15 +6757,15 @@ inline flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ResizeNearestNeighborOptionsT : public flatbuffers::NativeTable {", "+struct ResizeNearestNeighborOptionsT : public ::flatbuffers::NativeTable {", "   typedef ResizeNearestNeighborOptions TableType;", "   bool align_corners = false;", "   bool half_pixel_centers = false;", " };", " ", "-struct ResizeNearestNeighborOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ResizeNearestNeighborOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ResizeNearestNeighborOptionsT NativeTableType;", "   typedef ResizeNearestNeighborOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -6771,40 +6778,40 @@ struct ResizeNearestNeighborOptions FLATBUFFERS_FINAL_CLASS : private flatbuffer", "   bool half_pixel_centers() const {", "     return GetField<uint8_t>(VT_HALF_PIXEL_CENTERS, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS, 1) &&", "            VerifyField<uint8_t>(verifier, VT_HALF_PIXEL_CENTERS, 1) &&", "            verifier.EndTable();", "   }", "-  ResizeNearestNeighborOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ResizeNearestNeighborOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ResizeNearestNeighborOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ResizeNearestNeighborOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ResizeNearestNeighborOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ResizeNearestNeighborOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ResizeNearestNeighborOptionsBuilder {", "   typedef ResizeNearestNeighborOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_align_corners(bool align_corners) {", "     fbb_.AddElement<uint8_t>(ResizeNearestNeighborOptions::VT_ALIGN_CORNERS, static_cast<uint8_t>(align_corners), 0);", "   }", "   void add_half_pixel_centers(bool half_pixel_centers) {", "     fbb_.AddElement<uint8_t>(ResizeNearestNeighborOptions::VT_HALF_PIXEL_CENTERS, static_cast<uint8_t>(half_pixel_centers), 0);", "   }", "-  explicit ResizeNearestNeighborOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit ResizeNearestNeighborOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ResizeNearestNeighborOptions> Finish() {", "+  ::flatbuffers::Offset<ResizeNearestNeighborOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ResizeNearestNeighborOptions>(end);", "+    auto o = ::flatbuffers::Offset<ResizeNearestNeighborOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     bool align_corners = false,", "     bool half_pixel_centers = false) {", "   ResizeNearestNeighborOptionsBuilder builder_(_fbb);", "@@ -6813,14 +6820,14 @@ inline flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeig", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct CallOptionsT : public flatbuffers::NativeTable {", "+struct CallOptionsT : public ::flatbuffers::NativeTable {", "   typedef CallOptions TableType;", "   uint32_t subgraph = 0;", " };", " ", "-struct CallOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct CallOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef CallOptionsT NativeTableType;", "   typedef CallOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -6829,175 +6836,175 @@ struct CallOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   uint32_t subgraph() const {", "     return GetField<uint32_t>(VT_SUBGRAPH, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<uint32_t>(verifier, VT_SUBGRAPH, 4) &&", "            verifier.EndTable();", "   }", "-  CallOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(CallOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<CallOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  CallOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(CallOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<CallOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct CallOptionsBuilder {", "   typedef CallOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_subgraph(uint32_t subgraph) {", "     fbb_.AddElement<uint32_t>(CallOptions::VT_SUBGRAPH, subgraph, 0);", "   }", "-  explicit CallOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit CallOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<CallOptions> Finish() {", "+  ::flatbuffers::Offset<CallOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<CallOptions>(end);", "+    auto o = ::flatbuffers::Offset<CallOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<CallOptions> CreateCallOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<CallOptions> CreateCallOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     uint32_t subgraph = 0) {", "   CallOptionsBuilder builder_(_fbb);", "   builder_.add_subgraph(subgraph);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<CallOptions> CreateCallOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<CallOptions> CreateCallOptions(::flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct PadOptionsT : public flatbuffers::NativeTable {", "+struct PadOptionsT : public ::flatbuffers::NativeTable {", "   typedef PadOptions TableType;", " };", " ", "-struct PadOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct PadOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef PadOptionsT NativeTableType;", "   typedef PadOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  PadOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(PadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<PadOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  PadOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(PadOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<PadOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct PadOptionsBuilder {", "   typedef PadOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit PadOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit PadOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<PadOptions> Finish() {", "+  ::flatbuffers::Offset<PadOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<PadOptions>(end);", "+    auto o = ::flatbuffers::Offset<PadOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<PadOptions> CreatePadOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<PadOptions> CreatePadOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   PadOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<PadOptions> CreatePadOptions(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<PadOptions> CreatePadOptions(::flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct PadV2OptionsT : public flatbuffers::NativeTable {", "+struct PadV2OptionsT : public ::flatbuffers::NativeTable {", "   typedef PadV2Options TableType;", " };", " ", "-struct PadV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct PadV2Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef PadV2OptionsT NativeTableType;", "   typedef PadV2OptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  PadV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(PadV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<PadV2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  PadV2OptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(PadV2OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<PadV2Options> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct PadV2OptionsBuilder {", "   typedef PadV2Options Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit PadV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit PadV2OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<PadV2Options> Finish() {", "+  ::flatbuffers::Offset<PadV2Options> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<PadV2Options>(end);", "+    auto o = ::flatbuffers::Offset<PadV2Options>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<PadV2Options> CreatePadV2Options(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<PadV2Options> CreatePadV2Options(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   PadV2OptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<PadV2Options> CreatePadV2Options(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<PadV2Options> CreatePadV2Options(::flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ReshapeOptionsT : public flatbuffers::NativeTable {", "+struct ReshapeOptionsT : public ::flatbuffers::NativeTable {", "   typedef ReshapeOptions TableType;", "   std::vector<int32_t> new_shape{};", " };", " ", "-struct ReshapeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ReshapeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ReshapeOptionsT NativeTableType;", "   typedef ReshapeOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_NEW_SHAPE = 4", "   };", "-  const flatbuffers::Vector<int32_t> *new_shape() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NEW_SHAPE);", "+  const ::flatbuffers::Vector<int32_t> *new_shape() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_NEW_SHAPE);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_NEW_SHAPE) &&", "            verifier.VerifyVector(new_shape()) &&", "            verifier.EndTable();", "   }", "-  ReshapeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ReshapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ReshapeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ReshapeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ReshapeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ReshapeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ReshapeOptionsBuilder {", "   typedef ReshapeOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_new_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> new_shape) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_new_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> new_shape) {", "     fbb_.AddOffset(ReshapeOptions::VT_NEW_SHAPE, new_shape);", "   }", "-  explicit ReshapeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit ReshapeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ReshapeOptions> Finish() {", "+  ::flatbuffers::Offset<ReshapeOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ReshapeOptions>(end);", "+    auto o = ::flatbuffers::Offset<ReshapeOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> new_shape = 0) {", "+inline ::flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> new_shape = 0) {", "   ReshapeOptionsBuilder builder_(_fbb);", "   builder_.add_new_shape(new_shape);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptionsDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<ReshapeOptions> CreateReshapeOptionsDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const std::vector<int32_t> *new_shape = nullptr) {", "   auto new_shape__ = new_shape ? _fbb.CreateVector<int32_t>(*new_shape) : 0;", "   return tflite::CreateReshapeOptions(", "@@ -7005,94 +7012,94 @@ inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptionsDirect(", "       new_shape__);", " }", " ", "-flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SpaceToBatchNDOptionsT : public flatbuffers::NativeTable {", "+struct SpaceToBatchNDOptionsT : public ::flatbuffers::NativeTable {", "   typedef SpaceToBatchNDOptions TableType;", " };", " ", "-struct SpaceToBatchNDOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SpaceToBatchNDOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SpaceToBatchNDOptionsT NativeTableType;", "   typedef SpaceToBatchNDOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  SpaceToBatchNDOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SpaceToBatchNDOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SpaceToBatchNDOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SpaceToBatchNDOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SpaceToBatchNDOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SpaceToBatchNDOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SpaceToBatchNDOptionsBuilder {", "   typedef SpaceToBatchNDOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit SpaceToBatchNDOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit SpaceToBatchNDOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SpaceToBatchNDOptions> Finish() {", "+  ::flatbuffers::Offset<SpaceToBatchNDOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SpaceToBatchNDOptions>(end);", "+    auto o = ::flatbuffers::Offset<SpaceToBatchNDOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   SpaceToBatchNDOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct BatchToSpaceNDOptionsT : public flatbuffers::NativeTable {", "+struct BatchToSpaceNDOptionsT : public ::flatbuffers::NativeTable {", "   typedef BatchToSpaceNDOptions TableType;", " };", " ", "-struct BatchToSpaceNDOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct BatchToSpaceNDOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef BatchToSpaceNDOptionsT NativeTableType;", "   typedef BatchToSpaceNDOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  BatchToSpaceNDOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(BatchToSpaceNDOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<BatchToSpaceNDOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  BatchToSpaceNDOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(BatchToSpaceNDOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<BatchToSpaceNDOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct BatchToSpaceNDOptionsBuilder {", "   typedef BatchToSpaceNDOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit BatchToSpaceNDOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit BatchToSpaceNDOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<BatchToSpaceNDOptions> Finish() {", "+  ::flatbuffers::Offset<BatchToSpaceNDOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<BatchToSpaceNDOptions>(end);", "+    auto o = ::flatbuffers::Offset<BatchToSpaceNDOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   BatchToSpaceNDOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SkipGramOptionsT : public flatbuffers::NativeTable {", "+struct SkipGramOptionsT : public ::flatbuffers::NativeTable {", "   typedef SkipGramOptions TableType;", "   int32_t ngram_size = 0;", "   int32_t max_skip_size = 0;", "   bool include_all_ngrams = false;", " };", " ", "-struct SkipGramOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SkipGramOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SkipGramOptionsT NativeTableType;", "   typedef SkipGramOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -7109,22 +7116,22 @@ struct SkipGramOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool include_all_ngrams() const {", "     return GetField<uint8_t>(VT_INCLUDE_ALL_NGRAMS, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_NGRAM_SIZE, 4) &&", "            VerifyField<int32_t>(verifier, VT_MAX_SKIP_SIZE, 4) &&", "            VerifyField<uint8_t>(verifier, VT_INCLUDE_ALL_NGRAMS, 1) &&", "            verifier.EndTable();", "   }", "-  SkipGramOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SkipGramOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SkipGramOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SkipGramOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SkipGramOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SkipGramOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SkipGramOptionsBuilder {", "   typedef SkipGramOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_ngram_size(int32_t ngram_size) {", "     fbb_.AddElement<int32_t>(SkipGramOptions::VT_NGRAM_SIZE, ngram_size, 0);", "   }", "@@ -7134,19 +7141,19 @@ struct SkipGramOptionsBuilder {", "   void add_include_all_ngrams(bool include_all_ngrams) {", "     fbb_.AddElement<uint8_t>(SkipGramOptions::VT_INCLUDE_ALL_NGRAMS, static_cast<uint8_t>(include_all_ngrams), 0);", "   }", "-  explicit SkipGramOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit SkipGramOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SkipGramOptions> Finish() {", "+  ::flatbuffers::Offset<SkipGramOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SkipGramOptions>(end);", "+    auto o = ::flatbuffers::Offset<SkipGramOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t ngram_size = 0,", "     int32_t max_skip_size = 0,", "     bool include_all_ngrams = false) {", "@@ -7157,14 +7164,14 @@ inline flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SpaceToDepthOptionsT : public flatbuffers::NativeTable {", "+struct SpaceToDepthOptionsT : public ::flatbuffers::NativeTable {", "   typedef SpaceToDepthOptions TableType;", "   int32_t block_size = 0;", " };", " ", "-struct SpaceToDepthOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SpaceToDepthOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SpaceToDepthOptionsT NativeTableType;", "   typedef SpaceToDepthOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -7173,50 +7180,50 @@ struct SpaceToDepthOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table", "   int32_t block_size() const {", "     return GetField<int32_t>(VT_BLOCK_SIZE, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_BLOCK_SIZE, 4) &&", "            verifier.EndTable();", "   }", "-  SpaceToDepthOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SpaceToDepthOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SpaceToDepthOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SpaceToDepthOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SpaceToDepthOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SpaceToDepthOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SpaceToDepthOptionsBuilder {", "   typedef SpaceToDepthOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_block_size(int32_t block_size) {", "     fbb_.AddElement<int32_t>(SpaceToDepthOptions::VT_BLOCK_SIZE, block_size, 0);", "   }", "-  explicit SpaceToDepthOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit SpaceToDepthOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SpaceToDepthOptions> Finish() {", "+  ::flatbuffers::Offset<SpaceToDepthOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SpaceToDepthOptions>(end);", "+    auto o = ::flatbuffers::Offset<SpaceToDepthOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t block_size = 0) {", "   SpaceToDepthOptionsBuilder builder_(_fbb);", "   builder_.add_block_size(block_size);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct DepthToSpaceOptionsT : public flatbuffers::NativeTable {", "+struct DepthToSpaceOptionsT : public ::flatbuffers::NativeTable {", "   typedef DepthToSpaceOptions TableType;", "   int32_t block_size = 0;", " };", " ", "-struct DepthToSpaceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct DepthToSpaceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef DepthToSpaceOptionsT NativeTableType;", "   typedef DepthToSpaceOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -7225,51 +7232,51 @@ struct DepthToSpaceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table", "   int32_t block_size() const {", "     return GetField<int32_t>(VT_BLOCK_SIZE, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_BLOCK_SIZE, 4) &&", "            verifier.EndTable();", "   }", "-  DepthToSpaceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(DepthToSpaceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<DepthToSpaceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  DepthToSpaceOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(DepthToSpaceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<DepthToSpaceOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct DepthToSpaceOptionsBuilder {", "   typedef DepthToSpaceOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_block_size(int32_t block_size) {", "     fbb_.AddElement<int32_t>(DepthToSpaceOptions::VT_BLOCK_SIZE, block_size, 0);", "   }", "-  explicit DepthToSpaceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit DepthToSpaceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<DepthToSpaceOptions> Finish() {", "+  ::flatbuffers::Offset<DepthToSpaceOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<DepthToSpaceOptions>(end);", "+    auto o = ::flatbuffers::Offset<DepthToSpaceOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<DepthToSpaceOptions> CreateDepthToSpaceOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<DepthToSpaceOptions> CreateDepthToSpaceOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t block_size = 0) {", "   DepthToSpaceOptionsBuilder builder_(_fbb);", "   builder_.add_block_size(block_size);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<DepthToSpaceOptions> CreateDepthToSpaceOptions(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<DepthToSpaceOptions> CreateDepthToSpaceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SubOptionsT : public flatbuffers::NativeTable {", "+struct SubOptionsT : public ::flatbuffers::NativeTable {", "   typedef SubOptions TableType;", "   tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;", "   bool pot_scale_int16 = true;", " };", " ", "-struct SubOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SubOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SubOptionsT NativeTableType;", "   typedef SubOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -7282,40 +7289,40 @@ struct SubOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool pot_scale_int16() const {", "     return GetField<uint8_t>(VT_POT_SCALE_INT16, 1) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&", "            VerifyField<uint8_t>(verifier, VT_POT_SCALE_INT16, 1) &&", "            verifier.EndTable();", "   }", "-  SubOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SubOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SubOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SubOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SubOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SubOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SubOptionsBuilder {", "   typedef SubOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {", "     fbb_.AddElement<int8_t>(SubOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);", "   }", "   void add_pot_scale_int16(bool pot_scale_int16) {", "     fbb_.AddElement<uint8_t>(SubOptions::VT_POT_SCALE_INT16, static_cast<uint8_t>(pot_scale_int16), 1);", "   }", "-  explicit SubOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit SubOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SubOptions> Finish() {", "+  ::flatbuffers::Offset<SubOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SubOptions>(end);", "+    auto o = ::flatbuffers::Offset<SubOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SubOptions> CreateSubOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<SubOptions> CreateSubOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE,", "     bool pot_scale_int16 = true) {", "   SubOptionsBuilder builder_(_fbb);", "@@ -7324,14 +7331,14 @@ inline flatbuffers::Offset<SubOptions> CreateSubOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<SubOptions> CreateSubOptions(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SubOptions> CreateSubOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct DivOptionsT : public flatbuffers::NativeTable {", "+struct DivOptionsT : public ::flatbuffers::NativeTable {", "   typedef DivOptions TableType;", "   tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;", " };", " ", "-struct DivOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct DivOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef DivOptionsT NativeTableType;", "   typedef DivOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -7340,89 +7347,89 @@ struct DivOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   tflite::ActivationFunctionType fused_activation_function() const {", "     return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&", "            verifier.EndTable();", "   }", "-  DivOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(DivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<DivOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  DivOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(DivOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<DivOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct DivOptionsBuilder {", "   typedef DivOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {", "     fbb_.AddElement<int8_t>(DivOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);", "   }", "-  explicit DivOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit DivOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<DivOptions> Finish() {", "+  ::flatbuffers::Offset<DivOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<DivOptions>(end);", "+    auto o = ::flatbuffers::Offset<DivOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<DivOptions> CreateDivOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<DivOptions> CreateDivOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE) {", "   DivOptionsBuilder builder_(_fbb);", "   builder_.add_fused_activation_function(fused_activation_function);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<DivOptions> CreateDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<DivOptions> CreateDivOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct TopKV2OptionsT : public flatbuffers::NativeTable {", "+struct TopKV2OptionsT : public ::flatbuffers::NativeTable {", "   typedef TopKV2Options TableType;", " };", " ", "-struct TopKV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct TopKV2Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef TopKV2OptionsT NativeTableType;", "   typedef TopKV2OptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  TopKV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(TopKV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<TopKV2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  TopKV2OptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(TopKV2OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<TopKV2Options> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct TopKV2OptionsBuilder {", "   typedef TopKV2Options Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit TopKV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit TopKV2OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<TopKV2Options> Finish() {", "+  ::flatbuffers::Offset<TopKV2Options> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<TopKV2Options>(end);", "+    auto o = ::flatbuffers::Offset<TopKV2Options>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   TopKV2OptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(::flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct EmbeddingLookupSparseOptionsT : public flatbuffers::NativeTable {", "+struct EmbeddingLookupSparseOptionsT : public ::flatbuffers::NativeTable {", "   typedef EmbeddingLookupSparseOptions TableType;", "   tflite::CombinerType combiner = tflite::CombinerType_SUM;", " };", " ", "-struct EmbeddingLookupSparseOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct EmbeddingLookupSparseOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef EmbeddingLookupSparseOptionsT NativeTableType;", "   typedef EmbeddingLookupSparseOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -7431,51 +7438,51 @@ struct EmbeddingLookupSparseOptions FLATBUFFERS_FINAL_CLASS : private flatbuffer", "   tflite::CombinerType combiner() const {", "     return static_cast<tflite::CombinerType>(GetField<int8_t>(VT_COMBINER, 0));", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_COMBINER, 1) &&", "            verifier.EndTable();", "   }", "-  EmbeddingLookupSparseOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(EmbeddingLookupSparseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<EmbeddingLookupSparseOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  EmbeddingLookupSparseOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(EmbeddingLookupSparseOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<EmbeddingLookupSparseOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct EmbeddingLookupSparseOptionsBuilder {", "   typedef EmbeddingLookupSparseOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_combiner(tflite::CombinerType combiner) {", "     fbb_.AddElement<int8_t>(EmbeddingLookupSparseOptions::VT_COMBINER, static_cast<int8_t>(combiner), 0);", "   }", "-  explicit EmbeddingLookupSparseOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit EmbeddingLookupSparseOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<EmbeddingLookupSparseOptions> Finish() {", "+  ::flatbuffers::Offset<EmbeddingLookupSparseOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<EmbeddingLookupSparseOptions>(end);", "+    auto o = ::flatbuffers::Offset<EmbeddingLookupSparseOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::CombinerType combiner = tflite::CombinerType_SUM) {", "   EmbeddingLookupSparseOptionsBuilder builder_(_fbb);", "   builder_.add_combiner(combiner);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(::flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct GatherOptionsT : public flatbuffers::NativeTable {", "+struct GatherOptionsT : public ::flatbuffers::NativeTable {", "   typedef GatherOptions TableType;", "   int32_t axis = 0;", "   int32_t batch_dims = 0;", " };", " ", "-struct GatherOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct GatherOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef GatherOptionsT NativeTableType;", "   typedef GatherOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -7488,40 +7495,40 @@ struct GatherOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t batch_dims() const {", "     return GetField<int32_t>(VT_BATCH_DIMS, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_AXIS, 4) &&", "            VerifyField<int32_t>(verifier, VT_BATCH_DIMS, 4) &&", "            verifier.EndTable();", "   }", "-  GatherOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(GatherOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<GatherOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  GatherOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(GatherOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<GatherOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct GatherOptionsBuilder {", "   typedef GatherOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_axis(int32_t axis) {", "     fbb_.AddElement<int32_t>(GatherOptions::VT_AXIS, axis, 0);", "   }", "   void add_batch_dims(int32_t batch_dims) {", "     fbb_.AddElement<int32_t>(GatherOptions::VT_BATCH_DIMS, batch_dims, 0);", "   }", "-  explicit GatherOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit GatherOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<GatherOptions> Finish() {", "+  ::flatbuffers::Offset<GatherOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<GatherOptions>(end);", "+    auto o = ::flatbuffers::Offset<GatherOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<GatherOptions> CreateGatherOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<GatherOptions> CreateGatherOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t axis = 0,", "     int32_t batch_dims = 0) {", "   GatherOptionsBuilder builder_(_fbb);", "@@ -7530,131 +7537,131 @@ inline flatbuffers::Offset<GatherOptions> CreateGatherOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<GatherOptions> CreateGatherOptions(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<GatherOptions> CreateGatherOptions(::flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct TransposeOptionsT : public flatbuffers::NativeTable {", "+struct TransposeOptionsT : public ::flatbuffers::NativeTable {", "   typedef TransposeOptions TableType;", " };", " ", "-struct TransposeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct TransposeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef TransposeOptionsT NativeTableType;", "   typedef TransposeOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  TransposeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(TransposeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<TransposeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  TransposeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(TransposeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<TransposeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct TransposeOptionsBuilder {", "   typedef TransposeOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit TransposeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit TransposeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<TransposeOptions> Finish() {", "+  ::flatbuffers::Offset<TransposeOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<TransposeOptions>(end);", "+    auto o = ::flatbuffers::Offset<TransposeOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   TransposeOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ExpOptionsT : public flatbuffers::NativeTable {", "+struct ExpOptionsT : public ::flatbuffers::NativeTable {", "   typedef ExpOptions TableType;", " };", " ", "-struct ExpOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ExpOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ExpOptionsT NativeTableType;", "   typedef ExpOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  ExpOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ExpOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ExpOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ExpOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ExpOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ExpOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ExpOptionsBuilder {", "   typedef ExpOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit ExpOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit ExpOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ExpOptions> Finish() {", "+  ::flatbuffers::Offset<ExpOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ExpOptions>(end);", "+    auto o = ::flatbuffers::Offset<ExpOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ExpOptions> CreateExpOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<ExpOptions> CreateExpOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   ExpOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<ExpOptions> CreateExpOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ExpOptions> CreateExpOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct CosOptionsT : public flatbuffers::NativeTable {", "+struct CosOptionsT : public ::flatbuffers::NativeTable {", "   typedef CosOptions TableType;", " };", " ", "-struct CosOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct CosOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef CosOptionsT NativeTableType;", "   typedef CosOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  CosOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(CosOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<CosOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  CosOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(CosOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<CosOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct CosOptionsBuilder {", "   typedef CosOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit CosOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit CosOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<CosOptions> Finish() {", "+  ::flatbuffers::Offset<CosOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<CosOptions>(end);", "+    auto o = ::flatbuffers::Offset<CosOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<CosOptions> CreateCosOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<CosOptions> CreateCosOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   CosOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<CosOptions> CreateCosOptions(flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<CosOptions> CreateCosOptions(::flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ReducerOptionsT : public flatbuffers::NativeTable {", "+struct ReducerOptionsT : public ::flatbuffers::NativeTable {", "   typedef ReducerOptions TableType;", "   bool keep_dims = false;", " };", " ", "-struct ReducerOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ReducerOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ReducerOptionsT NativeTableType;", "   typedef ReducerOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -7663,97 +7670,97 @@ struct ReducerOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool keep_dims() const {", "     return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<uint8_t>(verifier, VT_KEEP_DIMS, 1) &&", "            verifier.EndTable();", "   }", "-  ReducerOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ReducerOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ReducerOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ReducerOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ReducerOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ReducerOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ReducerOptionsBuilder {", "   typedef ReducerOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_keep_dims(bool keep_dims) {", "     fbb_.AddElement<uint8_t>(ReducerOptions::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);", "   }", "-  explicit ReducerOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit ReducerOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ReducerOptions> Finish() {", "+  ::flatbuffers::Offset<ReducerOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ReducerOptions>(end);", "+    auto o = ::flatbuffers::Offset<ReducerOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ReducerOptions> CreateReducerOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<ReducerOptions> CreateReducerOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     bool keep_dims = false) {", "   ReducerOptionsBuilder builder_(_fbb);", "   builder_.add_keep_dims(keep_dims);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<ReducerOptions> CreateReducerOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ReducerOptions> CreateReducerOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SqueezeOptionsT : public flatbuffers::NativeTable {", "+struct SqueezeOptionsT : public ::flatbuffers::NativeTable {", "   typedef SqueezeOptions TableType;", "   std::vector<int32_t> squeeze_dims{};", " };", " ", "-struct SqueezeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SqueezeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SqueezeOptionsT NativeTableType;", "   typedef SqueezeOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_SQUEEZE_DIMS = 4", "   };", "-  const flatbuffers::Vector<int32_t> *squeeze_dims() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SQUEEZE_DIMS);", "+  const ::flatbuffers::Vector<int32_t> *squeeze_dims() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SQUEEZE_DIMS);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_SQUEEZE_DIMS) &&", "            verifier.VerifyVector(squeeze_dims()) &&", "            verifier.EndTable();", "   }", "-  SqueezeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SqueezeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SqueezeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SqueezeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SqueezeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SqueezeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SqueezeOptionsBuilder {", "   typedef SqueezeOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_squeeze_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeeze_dims) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_squeeze_dims(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> squeeze_dims) {", "     fbb_.AddOffset(SqueezeOptions::VT_SQUEEZE_DIMS, squeeze_dims);", "   }", "-  explicit SqueezeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit SqueezeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SqueezeOptions> Finish() {", "+  ::flatbuffers::Offset<SqueezeOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SqueezeOptions>(end);", "+    auto o = ::flatbuffers::Offset<SqueezeOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeeze_dims = 0) {", "+inline ::flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> squeeze_dims = 0) {", "   SqueezeOptionsBuilder builder_(_fbb);", "   builder_.add_squeeze_dims(squeeze_dims);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptionsDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptionsDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const std::vector<int32_t> *squeeze_dims = nullptr) {", "   auto squeeze_dims__ = squeeze_dims ? _fbb.CreateVector<int32_t>(*squeeze_dims) : 0;", "   return tflite::CreateSqueezeOptions(", "@@ -7761,14 +7768,14 @@ inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptionsDirect(", "       squeeze_dims__);", " }", " ", "-flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SplitOptionsT : public flatbuffers::NativeTable {", "+struct SplitOptionsT : public ::flatbuffers::NativeTable {", "   typedef SplitOptions TableType;", "   int32_t num_splits = 0;", " };", " ", "-struct SplitOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SplitOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SplitOptionsT NativeTableType;", "   typedef SplitOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -7777,50 +7784,50 @@ struct SplitOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t num_splits() const {", "     return GetField<int32_t>(VT_NUM_SPLITS, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_NUM_SPLITS, 4) &&", "            verifier.EndTable();", "   }", "-  SplitOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SplitOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SplitOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SplitOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SplitOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SplitOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SplitOptionsBuilder {", "   typedef SplitOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_num_splits(int32_t num_splits) {", "     fbb_.AddElement<int32_t>(SplitOptions::VT_NUM_SPLITS, num_splits, 0);", "   }", "-  explicit SplitOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit SplitOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SplitOptions> Finish() {", "+  ::flatbuffers::Offset<SplitOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SplitOptions>(end);", "+    auto o = ::flatbuffers::Offset<SplitOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SplitOptions> CreateSplitOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<SplitOptions> CreateSplitOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t num_splits = 0) {", "   SplitOptionsBuilder builder_(_fbb);", "   builder_.add_num_splits(num_splits);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<SplitOptions> CreateSplitOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SplitOptions> CreateSplitOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SplitVOptionsT : public flatbuffers::NativeTable {", "+struct SplitVOptionsT : public ::flatbuffers::NativeTable {", "   typedef SplitVOptions TableType;", "   int32_t num_splits = 0;", " };", " ", "-struct SplitVOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SplitVOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SplitVOptionsT NativeTableType;", "   typedef SplitVOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -7829,45 +7836,45 @@ struct SplitVOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t num_splits() const {", "     return GetField<int32_t>(VT_NUM_SPLITS, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_NUM_SPLITS, 4) &&", "            verifier.EndTable();", "   }", "-  SplitVOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SplitVOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SplitVOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SplitVOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SplitVOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SplitVOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SplitVOptionsBuilder {", "   typedef SplitVOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_num_splits(int32_t num_splits) {", "     fbb_.AddElement<int32_t>(SplitVOptions::VT_NUM_SPLITS, num_splits, 0);", "   }", "-  explicit SplitVOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit SplitVOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SplitVOptions> Finish() {", "+  ::flatbuffers::Offset<SplitVOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SplitVOptions>(end);", "+    auto o = ::flatbuffers::Offset<SplitVOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t num_splits = 0) {", "   SplitVOptionsBuilder builder_(_fbb);", "   builder_.add_num_splits(num_splits);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct StridedSliceOptionsT : public flatbuffers::NativeTable {", "+struct StridedSliceOptionsT : public ::flatbuffers::NativeTable {", "   typedef StridedSliceOptions TableType;", "   int32_t begin_mask = 0;", "   int32_t end_mask = 0;", "@@ -7876,7 +7883,7 @@ struct StridedSliceOptionsT : public flatbuffers::NativeTable {", "   int32_t shrink_axis_mask = 0;", " };", " ", "-struct StridedSliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct StridedSliceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef StridedSliceOptionsT NativeTableType;", "   typedef StridedSliceOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -7901,7 +7908,7 @@ struct StridedSliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table", "   int32_t shrink_axis_mask() const {", "     return GetField<int32_t>(VT_SHRINK_AXIS_MASK, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_BEGIN_MASK, 4) &&", "            VerifyField<int32_t>(verifier, VT_END_MASK, 4) &&", "@@ -7910,15 +7917,15 @@ struct StridedSliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table", "            VerifyField<int32_t>(verifier, VT_SHRINK_AXIS_MASK, 4) &&", "            verifier.EndTable();", "   }", "-  StridedSliceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(StridedSliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<StridedSliceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  StridedSliceOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(StridedSliceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<StridedSliceOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct StridedSliceOptionsBuilder {", "   typedef StridedSliceOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_begin_mask(int32_t begin_mask) {", "     fbb_.AddElement<int32_t>(StridedSliceOptions::VT_BEGIN_MASK, begin_mask, 0);", "   }", "@@ -7934,19 +7941,19 @@ struct StridedSliceOptionsBuilder {", "   void add_shrink_axis_mask(int32_t shrink_axis_mask) {", "     fbb_.AddElement<int32_t>(StridedSliceOptions::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);", "   }", "-  explicit StridedSliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit StridedSliceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<StridedSliceOptions> Finish() {", "+  ::flatbuffers::Offset<StridedSliceOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<StridedSliceOptions>(end);", "+    auto o = ::flatbuffers::Offset<StridedSliceOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t begin_mask = 0,", "     int32_t end_mask = 0,", "     int32_t ellipsis_mask = 0,", "@@ -7961,54 +7968,54 @@ inline flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct LogSoftmaxOptionsT : public flatbuffers::NativeTable {", "+struct LogSoftmaxOptionsT : public ::flatbuffers::NativeTable {", "   typedef LogSoftmaxOptions TableType;", " };", " ", "-struct LogSoftmaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct LogSoftmaxOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef LogSoftmaxOptionsT NativeTableType;", "   typedef LogSoftmaxOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  LogSoftmaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(LogSoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<LogSoftmaxOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  LogSoftmaxOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(LogSoftmaxOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<LogSoftmaxOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct LogSoftmaxOptionsBuilder {", "   typedef LogSoftmaxOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit LogSoftmaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit LogSoftmaxOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<LogSoftmaxOptions> Finish() {", "+  ::flatbuffers::Offset<LogSoftmaxOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<LogSoftmaxOptions>(end);", "+    auto o = ::flatbuffers::Offset<LogSoftmaxOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   LogSoftmaxOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct CastOptionsT : public flatbuffers::NativeTable {", "+struct CastOptionsT : public ::flatbuffers::NativeTable {", "   typedef CastOptions TableType;", "   tflite::TensorType in_data_type = tflite::TensorType_FLOAT32;", "   tflite::TensorType out_data_type = tflite::TensorType_FLOAT32;", " };", " ", "-struct CastOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct CastOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef CastOptionsT NativeTableType;", "   typedef CastOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -8021,40 +8028,40 @@ struct CastOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   tflite::TensorType out_data_type() const {", "     return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUT_DATA_TYPE, 0));", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_IN_DATA_TYPE, 1) &&", "            VerifyField<int8_t>(verifier, VT_OUT_DATA_TYPE, 1) &&", "            verifier.EndTable();", "   }", "-  CastOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(CastOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<CastOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  CastOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(CastOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<CastOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct CastOptionsBuilder {", "   typedef CastOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_in_data_type(tflite::TensorType in_data_type) {", "     fbb_.AddElement<int8_t>(CastOptions::VT_IN_DATA_TYPE, static_cast<int8_t>(in_data_type), 0);", "   }", "   void add_out_data_type(tflite::TensorType out_data_type) {", "     fbb_.AddElement<int8_t>(CastOptions::VT_OUT_DATA_TYPE, static_cast<int8_t>(out_data_type), 0);", "   }", "-  explicit CastOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit CastOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<CastOptions> Finish() {", "+  ::flatbuffers::Offset<CastOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<CastOptions>(end);", "+    auto o = ::flatbuffers::Offset<CastOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<CastOptions> CreateCastOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<CastOptions> CreateCastOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::TensorType in_data_type = tflite::TensorType_FLOAT32,", "     tflite::TensorType out_data_type = tflite::TensorType_FLOAT32) {", "   CastOptionsBuilder builder_(_fbb);", "@@ -8063,131 +8070,131 @@ inline flatbuffers::Offset<CastOptions> CreateCastOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<CastOptions> CreateCastOptions(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<CastOptions> CreateCastOptions(::flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct DequantizeOptionsT : public flatbuffers::NativeTable {", "+struct DequantizeOptionsT : public ::flatbuffers::NativeTable {", "   typedef DequantizeOptions TableType;", " };", " ", "-struct DequantizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct DequantizeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef DequantizeOptionsT NativeTableType;", "   typedef DequantizeOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  DequantizeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(DequantizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<DequantizeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  DequantizeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(DequantizeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<DequantizeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct DequantizeOptionsBuilder {", "   typedef DequantizeOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit DequantizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit DequantizeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<DequantizeOptions> Finish() {", "+  ::flatbuffers::Offset<DequantizeOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<DequantizeOptions>(end);", "+    auto o = ::flatbuffers::Offset<DequantizeOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   DequantizeOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct MaximumMinimumOptionsT : public flatbuffers::NativeTable {", "+struct MaximumMinimumOptionsT : public ::flatbuffers::NativeTable {", "   typedef MaximumMinimumOptions TableType;", " };", " ", "-struct MaximumMinimumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct MaximumMinimumOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef MaximumMinimumOptionsT NativeTableType;", "   typedef MaximumMinimumOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  MaximumMinimumOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(MaximumMinimumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<MaximumMinimumOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  MaximumMinimumOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(MaximumMinimumOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<MaximumMinimumOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct MaximumMinimumOptionsBuilder {", "   typedef MaximumMinimumOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit MaximumMinimumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit MaximumMinimumOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<MaximumMinimumOptions> Finish() {", "+  ::flatbuffers::Offset<MaximumMinimumOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<MaximumMinimumOptions>(end);", "+    auto o = ::flatbuffers::Offset<MaximumMinimumOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   MaximumMinimumOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(::flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct TileOptionsT : public flatbuffers::NativeTable {", "+struct TileOptionsT : public ::flatbuffers::NativeTable {", "   typedef TileOptions TableType;", " };", " ", "-struct TileOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct TileOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef TileOptionsT NativeTableType;", "   typedef TileOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  TileOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(TileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<TileOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  TileOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(TileOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<TileOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct TileOptionsBuilder {", "   typedef TileOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit TileOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit TileOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<TileOptions> Finish() {", "+  ::flatbuffers::Offset<TileOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<TileOptions>(end);", "+    auto o = ::flatbuffers::Offset<TileOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<TileOptions> CreateTileOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<TileOptions> CreateTileOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   TileOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<TileOptions> CreateTileOptions(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<TileOptions> CreateTileOptions(::flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ArgMaxOptionsT : public flatbuffers::NativeTable {", "+struct ArgMaxOptionsT : public ::flatbuffers::NativeTable {", "   typedef ArgMaxOptions TableType;", "   tflite::TensorType output_type = tflite::TensorType_FLOAT32;", " };", " ", "-struct ArgMaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ArgMaxOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ArgMaxOptionsT NativeTableType;", "   typedef ArgMaxOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -8196,50 +8203,50 @@ struct ArgMaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   tflite::TensorType output_type() const {", "     return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE, 1) &&", "            verifier.EndTable();", "   }", "-  ArgMaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ArgMaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ArgMaxOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ArgMaxOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ArgMaxOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ArgMaxOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ArgMaxOptionsBuilder {", "   typedef ArgMaxOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_output_type(tflite::TensorType output_type) {", "     fbb_.AddElement<int8_t>(ArgMaxOptions::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);", "   }", "-  explicit ArgMaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit ArgMaxOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ArgMaxOptions> Finish() {", "+  ::flatbuffers::Offset<ArgMaxOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ArgMaxOptions>(end);", "+    auto o = ::flatbuffers::Offset<ArgMaxOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::TensorType output_type = tflite::TensorType_FLOAT32) {", "   ArgMaxOptionsBuilder builder_(_fbb);", "   builder_.add_output_type(output_type);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ArgMinOptionsT : public flatbuffers::NativeTable {", "+struct ArgMinOptionsT : public ::flatbuffers::NativeTable {", "   typedef ArgMinOptions TableType;", "   tflite::TensorType output_type = tflite::TensorType_FLOAT32;", " };", " ", "-struct ArgMinOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ArgMinOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ArgMinOptionsT NativeTableType;", "   typedef ArgMinOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -8248,318 +8255,318 @@ struct ArgMinOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   tflite::TensorType output_type() const {", "     return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE, 1) &&", "            verifier.EndTable();", "   }", "-  ArgMinOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ArgMinOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ArgMinOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ArgMinOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ArgMinOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ArgMinOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ArgMinOptionsBuilder {", "   typedef ArgMinOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_output_type(tflite::TensorType output_type) {", "     fbb_.AddElement<int8_t>(ArgMinOptions::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);", "   }", "-  explicit ArgMinOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit ArgMinOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ArgMinOptions> Finish() {", "+  ::flatbuffers::Offset<ArgMinOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ArgMinOptions>(end);", "+    auto o = ::flatbuffers::Offset<ArgMinOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::TensorType output_type = tflite::TensorType_FLOAT32) {", "   ArgMinOptionsBuilder builder_(_fbb);", "   builder_.add_output_type(output_type);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct GreaterOptionsT : public flatbuffers::NativeTable {", "+struct GreaterOptionsT : public ::flatbuffers::NativeTable {", "   typedef GreaterOptions TableType;", " };", " ", "-struct GreaterOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct GreaterOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef GreaterOptionsT NativeTableType;", "   typedef GreaterOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  GreaterOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(GreaterOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<GreaterOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  GreaterOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(GreaterOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<GreaterOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct GreaterOptionsBuilder {", "   typedef GreaterOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit GreaterOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit GreaterOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<GreaterOptions> Finish() {", "+  ::flatbuffers::Offset<GreaterOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<GreaterOptions>(end);", "+    auto o = ::flatbuffers::Offset<GreaterOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   GreaterOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(::flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct GreaterEqualOptionsT : public flatbuffers::NativeTable {", "+struct GreaterEqualOptionsT : public ::flatbuffers::NativeTable {", "   typedef GreaterEqualOptions TableType;", " };", " ", "-struct GreaterEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct GreaterEqualOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef GreaterEqualOptionsT NativeTableType;", "   typedef GreaterEqualOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  GreaterEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(GreaterEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<GreaterEqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  GreaterEqualOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(GreaterEqualOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<GreaterEqualOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct GreaterEqualOptionsBuilder {", "   typedef GreaterEqualOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit GreaterEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit GreaterEqualOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<GreaterEqualOptions> Finish() {", "+  ::flatbuffers::Offset<GreaterEqualOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<GreaterEqualOptions>(end);", "+    auto o = ::flatbuffers::Offset<GreaterEqualOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   GreaterEqualOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(::flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct LessOptionsT : public flatbuffers::NativeTable {", "+struct LessOptionsT : public ::flatbuffers::NativeTable {", "   typedef LessOptions TableType;", " };", " ", "-struct LessOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct LessOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef LessOptionsT NativeTableType;", "   typedef LessOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  LessOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(LessOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<LessOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  LessOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(LessOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<LessOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct LessOptionsBuilder {", "   typedef LessOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit LessOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit LessOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<LessOptions> Finish() {", "+  ::flatbuffers::Offset<LessOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<LessOptions>(end);", "+    auto o = ::flatbuffers::Offset<LessOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<LessOptions> CreateLessOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<LessOptions> CreateLessOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   LessOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<LessOptions> CreateLessOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<LessOptions> CreateLessOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct LessEqualOptionsT : public flatbuffers::NativeTable {", "+struct LessEqualOptionsT : public ::flatbuffers::NativeTable {", "   typedef LessEqualOptions TableType;", " };", " ", "-struct LessEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct LessEqualOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef LessEqualOptionsT NativeTableType;", "   typedef LessEqualOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  LessEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(LessEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<LessEqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  LessEqualOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(LessEqualOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<LessEqualOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct LessEqualOptionsBuilder {", "   typedef LessEqualOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit LessEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit LessEqualOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<LessEqualOptions> Finish() {", "+  ::flatbuffers::Offset<LessEqualOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<LessEqualOptions>(end);", "+    auto o = ::flatbuffers::Offset<LessEqualOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   LessEqualOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct NegOptionsT : public flatbuffers::NativeTable {", "+struct NegOptionsT : public ::flatbuffers::NativeTable {", "   typedef NegOptions TableType;", " };", " ", "-struct NegOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct NegOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef NegOptionsT NativeTableType;", "   typedef NegOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  NegOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(NegOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<NegOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  NegOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(NegOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<NegOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct NegOptionsBuilder {", "   typedef NegOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit NegOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit NegOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<NegOptions> Finish() {", "+  ::flatbuffers::Offset<NegOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<NegOptions>(end);", "+    auto o = ::flatbuffers::Offset<NegOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<NegOptions> CreateNegOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<NegOptions> CreateNegOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   NegOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<NegOptions> CreateNegOptions(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<NegOptions> CreateNegOptions(::flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SelectOptionsT : public flatbuffers::NativeTable {", "+struct SelectOptionsT : public ::flatbuffers::NativeTable {", "   typedef SelectOptions TableType;", " };", " ", "-struct SelectOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SelectOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SelectOptionsT NativeTableType;", "   typedef SelectOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  SelectOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SelectOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SelectOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SelectOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SelectOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SelectOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SelectOptionsBuilder {", "   typedef SelectOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit SelectOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit SelectOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SelectOptions> Finish() {", "+  ::flatbuffers::Offset<SelectOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SelectOptions>(end);", "+    auto o = ::flatbuffers::Offset<SelectOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SelectOptions> CreateSelectOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<SelectOptions> CreateSelectOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   SelectOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<SelectOptions> CreateSelectOptions(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SelectOptions> CreateSelectOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SliceOptionsT : public flatbuffers::NativeTable {", "+struct SliceOptionsT : public ::flatbuffers::NativeTable {", "   typedef SliceOptions TableType;", " };", " ", "-struct SliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SliceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SliceOptionsT NativeTableType;", "   typedef SliceOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  SliceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SliceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SliceOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SliceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SliceOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SliceOptionsBuilder {", "   typedef SliceOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit SliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit SliceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SliceOptions> Finish() {", "+  ::flatbuffers::Offset<SliceOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SliceOptions>(end);", "+    auto o = ::flatbuffers::Offset<SliceOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SliceOptions> CreateSliceOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<SliceOptions> CreateSliceOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   SliceOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<SliceOptions> CreateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SliceOptions> CreateSliceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct TransposeConvOptionsT : public flatbuffers::NativeTable {", "+struct TransposeConvOptionsT : public ::flatbuffers::NativeTable {", "   typedef TransposeConvOptions TableType;", "   tflite::Padding padding = tflite::Padding_SAME;", "   int32_t stride_w = 0;", "@@ -8567,7 +8574,7 @@ struct TransposeConvOptionsT : public flatbuffers::NativeTable {", "   tflite::ActivationFunctionType fused_activation_function = tflite::ActivationFunctionType_NONE;", " };", " ", "-struct TransposeConvOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct TransposeConvOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef TransposeConvOptionsT NativeTableType;", "   typedef TransposeConvOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -8588,7 +8595,7 @@ struct TransposeConvOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table", "   tflite::ActivationFunctionType fused_activation_function() const {", "     return static_cast<tflite::ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_PADDING, 1) &&", "            VerifyField<int32_t>(verifier, VT_STRIDE_W, 4) &&", "@@ -8596,15 +8603,15 @@ struct TransposeConvOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table", "            VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION, 1) &&", "            verifier.EndTable();", "   }", "-  TransposeConvOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(TransposeConvOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<TransposeConvOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  TransposeConvOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(TransposeConvOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<TransposeConvOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct TransposeConvOptionsBuilder {", "   typedef TransposeConvOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_padding(tflite::Padding padding) {", "     fbb_.AddElement<int8_t>(TransposeConvOptions::VT_PADDING, static_cast<int8_t>(padding), 0);", "   }", "@@ -8617,19 +8624,19 @@ struct TransposeConvOptionsBuilder {", "   void add_fused_activation_function(tflite::ActivationFunctionType fused_activation_function) {", "     fbb_.AddElement<int8_t>(TransposeConvOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);", "   }", "-  explicit TransposeConvOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit TransposeConvOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<TransposeConvOptions> Finish() {", "+  ::flatbuffers::Offset<TransposeConvOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<TransposeConvOptions>(end);", "+    auto o = ::flatbuffers::Offset<TransposeConvOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::Padding padding = tflite::Padding_SAME,", "     int32_t stride_w = 0,", "     int32_t stride_h = 0,", "@@ -8642,53 +8649,53 @@ inline flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(::flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ExpandDimsOptionsT : public flatbuffers::NativeTable {", "+struct ExpandDimsOptionsT : public ::flatbuffers::NativeTable {", "   typedef ExpandDimsOptions TableType;", " };", " ", "-struct ExpandDimsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ExpandDimsOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ExpandDimsOptionsT NativeTableType;", "   typedef ExpandDimsOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  ExpandDimsOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ExpandDimsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ExpandDimsOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ExpandDimsOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ExpandDimsOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ExpandDimsOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ExpandDimsOptionsBuilder {", "   typedef ExpandDimsOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit ExpandDimsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit ExpandDimsOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ExpandDimsOptions> Finish() {", "+  ::flatbuffers::Offset<ExpandDimsOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ExpandDimsOptions>(end);", "+    auto o = ::flatbuffers::Offset<ExpandDimsOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   ExpandDimsOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SparseToDenseOptionsT : public flatbuffers::NativeTable {", "+struct SparseToDenseOptionsT : public ::flatbuffers::NativeTable {", "   typedef SparseToDenseOptions TableType;", "   bool validate_indices = false;", " };", " ", "-struct SparseToDenseOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SparseToDenseOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SparseToDenseOptionsT NativeTableType;", "   typedef SparseToDenseOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -8697,128 +8704,128 @@ struct SparseToDenseOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table", "   bool validate_indices() const {", "     return GetField<uint8_t>(VT_VALIDATE_INDICES, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<uint8_t>(verifier, VT_VALIDATE_INDICES, 1) &&", "            verifier.EndTable();", "   }", "-  SparseToDenseOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SparseToDenseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SparseToDenseOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SparseToDenseOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SparseToDenseOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SparseToDenseOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SparseToDenseOptionsBuilder {", "   typedef SparseToDenseOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_validate_indices(bool validate_indices) {", "     fbb_.AddElement<uint8_t>(SparseToDenseOptions::VT_VALIDATE_INDICES, static_cast<uint8_t>(validate_indices), 0);", "   }", "-  explicit SparseToDenseOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit SparseToDenseOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SparseToDenseOptions> Finish() {", "+  ::flatbuffers::Offset<SparseToDenseOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SparseToDenseOptions>(end);", "+    auto o = ::flatbuffers::Offset<SparseToDenseOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     bool validate_indices = false) {", "   SparseToDenseOptionsBuilder builder_(_fbb);", "   builder_.add_validate_indices(validate_indices);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct EqualOptionsT : public flatbuffers::NativeTable {", "+struct EqualOptionsT : public ::flatbuffers::NativeTable {", "   typedef EqualOptions TableType;", " };", " ", "-struct EqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct EqualOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef EqualOptionsT NativeTableType;", "   typedef EqualOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  EqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(EqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<EqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  EqualOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(EqualOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<EqualOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct EqualOptionsBuilder {", "   typedef EqualOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit EqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit EqualOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<EqualOptions> Finish() {", "+  ::flatbuffers::Offset<EqualOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<EqualOptions>(end);", "+    auto o = ::flatbuffers::Offset<EqualOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<EqualOptions> CreateEqualOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<EqualOptions> CreateEqualOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   EqualOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<EqualOptions> CreateEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<EqualOptions> CreateEqualOptions(::flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct NotEqualOptionsT : public flatbuffers::NativeTable {", "+struct NotEqualOptionsT : public ::flatbuffers::NativeTable {", "   typedef NotEqualOptions TableType;", " };", " ", "-struct NotEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct NotEqualOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef NotEqualOptionsT NativeTableType;", "   typedef NotEqualOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  NotEqualOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(NotEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<NotEqualOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  NotEqualOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(NotEqualOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<NotEqualOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct NotEqualOptionsBuilder {", "   typedef NotEqualOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit NotEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit NotEqualOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<NotEqualOptions> Finish() {", "+  ::flatbuffers::Offset<NotEqualOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<NotEqualOptions>(end);", "+    auto o = ::flatbuffers::Offset<NotEqualOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   NotEqualOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(::flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ShapeOptionsT : public flatbuffers::NativeTable {", "+struct ShapeOptionsT : public ::flatbuffers::NativeTable {", "   typedef ShapeOptions TableType;", "   tflite::TensorType out_type = tflite::TensorType_FLOAT32;", " };", " ", "-struct ShapeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ShapeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ShapeOptionsT NativeTableType;", "   typedef ShapeOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -8827,123 +8834,123 @@ struct ShapeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   tflite::TensorType out_type() const {", "     return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUT_TYPE, 0));", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_OUT_TYPE, 1) &&", "            verifier.EndTable();", "   }", "-  ShapeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ShapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ShapeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ShapeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ShapeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ShapeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ShapeOptionsBuilder {", "   typedef ShapeOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_out_type(tflite::TensorType out_type) {", "     fbb_.AddElement<int8_t>(ShapeOptions::VT_OUT_TYPE, static_cast<int8_t>(out_type), 0);", "   }", "-  explicit ShapeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit ShapeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ShapeOptions> Finish() {", "+  ::flatbuffers::Offset<ShapeOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ShapeOptions>(end);", "+    auto o = ::flatbuffers::Offset<ShapeOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ShapeOptions> CreateShapeOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<ShapeOptions> CreateShapeOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::TensorType out_type = tflite::TensorType_FLOAT32) {", "   ShapeOptionsBuilder builder_(_fbb);", "   builder_.add_out_type(out_type);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<ShapeOptions> CreateShapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ShapeOptions> CreateShapeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct RankOptionsT : public flatbuffers::NativeTable {", "+struct RankOptionsT : public ::flatbuffers::NativeTable {", "   typedef RankOptions TableType;", " };", " ", "-struct RankOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct RankOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef RankOptionsT NativeTableType;", "   typedef RankOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  RankOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(RankOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<RankOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  RankOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(RankOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<RankOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct RankOptionsBuilder {", "   typedef RankOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit RankOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit RankOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<RankOptions> Finish() {", "+  ::flatbuffers::Offset<RankOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<RankOptions>(end);", "+    auto o = ::flatbuffers::Offset<RankOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<RankOptions> CreateRankOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<RankOptions> CreateRankOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   RankOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<RankOptions> CreateRankOptions(flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<RankOptions> CreateRankOptions(::flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct PowOptionsT : public flatbuffers::NativeTable {", "+struct PowOptionsT : public ::flatbuffers::NativeTable {", "   typedef PowOptions TableType;", " };", " ", "-struct PowOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct PowOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef PowOptionsT NativeTableType;", "   typedef PowOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  PowOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(PowOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<PowOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  PowOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(PowOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<PowOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct PowOptionsBuilder {", "   typedef PowOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit PowOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit PowOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<PowOptions> Finish() {", "+  ::flatbuffers::Offset<PowOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<PowOptions>(end);", "+    auto o = ::flatbuffers::Offset<PowOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<PowOptions> CreatePowOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<PowOptions> CreatePowOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   PowOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<PowOptions> CreatePowOptions(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<PowOptions> CreatePowOptions(::flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct FakeQuantOptionsT : public flatbuffers::NativeTable {", "+struct FakeQuantOptionsT : public ::flatbuffers::NativeTable {", "   typedef FakeQuantOptions TableType;", "   float min = 0.0f;", "   float max = 0.0f;", "@@ -8951,7 +8958,7 @@ struct FakeQuantOptionsT : public flatbuffers::NativeTable {", "   bool narrow_range = false;", " };", " ", "-struct FakeQuantOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct FakeQuantOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef FakeQuantOptionsT NativeTableType;", "   typedef FakeQuantOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -8972,7 +8979,7 @@ struct FakeQuantOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool narrow_range() const {", "     return GetField<uint8_t>(VT_NARROW_RANGE, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<float>(verifier, VT_MIN, 4) &&", "            VerifyField<float>(verifier, VT_MAX, 4) &&", "@@ -8980,15 +8987,15 @@ struct FakeQuantOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            VerifyField<uint8_t>(verifier, VT_NARROW_RANGE, 1) &&", "            verifier.EndTable();", "   }", "-  FakeQuantOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(FakeQuantOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<FakeQuantOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  FakeQuantOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(FakeQuantOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<FakeQuantOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct FakeQuantOptionsBuilder {", "   typedef FakeQuantOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_min(float min) {", "     fbb_.AddElement<float>(FakeQuantOptions::VT_MIN, min, 0.0f);", "   }", "@@ -9001,19 +9008,19 @@ struct FakeQuantOptionsBuilder {", "   void add_narrow_range(bool narrow_range) {", "     fbb_.AddElement<uint8_t>(FakeQuantOptions::VT_NARROW_RANGE, static_cast<uint8_t>(narrow_range), 0);", "   }", "-  explicit FakeQuantOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit FakeQuantOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<FakeQuantOptions> Finish() {", "+  ::flatbuffers::Offset<FakeQuantOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<FakeQuantOptions>(end);", "+    auto o = ::flatbuffers::Offset<FakeQuantOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     float min = 0.0f,", "     float max = 0.0f,", "     int32_t num_bits = 0,", "@@ -9026,15 +9033,15 @@ inline flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(::flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct PackOptionsT : public flatbuffers::NativeTable {", "+struct PackOptionsT : public ::flatbuffers::NativeTable {", "   typedef PackOptions TableType;", "   int32_t values_count = 0;", "   int32_t axis = 0;", " };", " ", "-struct PackOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct PackOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef PackOptionsT NativeTableType;", "   typedef PackOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -9047,40 +9054,40 @@ struct PackOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t axis() const {", "     return GetField<int32_t>(VT_AXIS, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_VALUES_COUNT, 4) &&", "            VerifyField<int32_t>(verifier, VT_AXIS, 4) &&", "            verifier.EndTable();", "   }", "-  PackOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(PackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<PackOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  PackOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(PackOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<PackOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct PackOptionsBuilder {", "   typedef PackOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_values_count(int32_t values_count) {", "     fbb_.AddElement<int32_t>(PackOptions::VT_VALUES_COUNT, values_count, 0);", "   }", "   void add_axis(int32_t axis) {", "     fbb_.AddElement<int32_t>(PackOptions::VT_AXIS, axis, 0);", "   }", "-  explicit PackOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit PackOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<PackOptions> Finish() {", "+  ::flatbuffers::Offset<PackOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<PackOptions>(end);", "+    auto o = ::flatbuffers::Offset<PackOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<PackOptions> CreatePackOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<PackOptions> CreatePackOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t values_count = 0,", "     int32_t axis = 0) {", "   PackOptionsBuilder builder_(_fbb);", "@@ -9089,53 +9096,53 @@ inline flatbuffers::Offset<PackOptions> CreatePackOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<PackOptions> CreatePackOptions(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<PackOptions> CreatePackOptions(::flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct LogicalOrOptionsT : public flatbuffers::NativeTable {", "+struct LogicalOrOptionsT : public ::flatbuffers::NativeTable {", "   typedef LogicalOrOptions TableType;", " };", " ", "-struct LogicalOrOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct LogicalOrOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef LogicalOrOptionsT NativeTableType;", "   typedef LogicalOrOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  LogicalOrOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(LogicalOrOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<LogicalOrOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  LogicalOrOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(LogicalOrOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<LogicalOrOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct LogicalOrOptionsBuilder {", "   typedef LogicalOrOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit LogicalOrOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit LogicalOrOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<LogicalOrOptions> Finish() {", "+  ::flatbuffers::Offset<LogicalOrOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<LogicalOrOptions>(end);", "+    auto o = ::flatbuffers::Offset<LogicalOrOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   LogicalOrOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct OneHotOptionsT : public flatbuffers::NativeTable {", "+struct OneHotOptionsT : public ::flatbuffers::NativeTable {", "   typedef OneHotOptions TableType;", "   int32_t axis = 0;", " };", " ", "-struct OneHotOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct OneHotOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef OneHotOptionsT NativeTableType;", "   typedef OneHotOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -9144,207 +9151,207 @@ struct OneHotOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t axis() const {", "     return GetField<int32_t>(VT_AXIS, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_AXIS, 4) &&", "            verifier.EndTable();", "   }", "-  OneHotOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(OneHotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<OneHotOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  OneHotOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(OneHotOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<OneHotOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct OneHotOptionsBuilder {", "   typedef OneHotOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_axis(int32_t axis) {", "     fbb_.AddElement<int32_t>(OneHotOptions::VT_AXIS, axis, 0);", "   }", "-  explicit OneHotOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit OneHotOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<OneHotOptions> Finish() {", "+  ::flatbuffers::Offset<OneHotOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<OneHotOptions>(end);", "+    auto o = ::flatbuffers::Offset<OneHotOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t axis = 0) {", "   OneHotOptionsBuilder builder_(_fbb);", "   builder_.add_axis(axis);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(::flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct AbsOptionsT : public flatbuffers::NativeTable {", "+struct AbsOptionsT : public ::flatbuffers::NativeTable {", "   typedef AbsOptions TableType;", " };", " ", "-struct AbsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct AbsOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef AbsOptionsT NativeTableType;", "   typedef AbsOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  AbsOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(AbsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<AbsOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  AbsOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(AbsOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<AbsOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct AbsOptionsBuilder {", "   typedef AbsOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit AbsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit AbsOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<AbsOptions> Finish() {", "+  ::flatbuffers::Offset<AbsOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<AbsOptions>(end);", "+    auto o = ::flatbuffers::Offset<AbsOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<AbsOptions> CreateAbsOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<AbsOptions> CreateAbsOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   AbsOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<AbsOptions> CreateAbsOptions(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<AbsOptions> CreateAbsOptions(::flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct HardSwishOptionsT : public flatbuffers::NativeTable {", "+struct HardSwishOptionsT : public ::flatbuffers::NativeTable {", "   typedef HardSwishOptions TableType;", " };", " ", "-struct HardSwishOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct HardSwishOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef HardSwishOptionsT NativeTableType;", "   typedef HardSwishOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  HardSwishOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(HardSwishOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<HardSwishOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  HardSwishOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(HardSwishOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<HardSwishOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct HardSwishOptionsBuilder {", "   typedef HardSwishOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit HardSwishOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit HardSwishOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<HardSwishOptions> Finish() {", "+  ::flatbuffers::Offset<HardSwishOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<HardSwishOptions>(end);", "+    auto o = ::flatbuffers::Offset<HardSwishOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<HardSwishOptions> CreateHardSwishOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<HardSwishOptions> CreateHardSwishOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   HardSwishOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<HardSwishOptions> CreateHardSwishOptions(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<HardSwishOptions> CreateHardSwishOptions(::flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct LogicalAndOptionsT : public flatbuffers::NativeTable {", "+struct LogicalAndOptionsT : public ::flatbuffers::NativeTable {", "   typedef LogicalAndOptions TableType;", " };", " ", "-struct LogicalAndOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct LogicalAndOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef LogicalAndOptionsT NativeTableType;", "   typedef LogicalAndOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  LogicalAndOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(LogicalAndOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<LogicalAndOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  LogicalAndOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(LogicalAndOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<LogicalAndOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct LogicalAndOptionsBuilder {", "   typedef LogicalAndOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit LogicalAndOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit LogicalAndOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<LogicalAndOptions> Finish() {", "+  ::flatbuffers::Offset<LogicalAndOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<LogicalAndOptions>(end);", "+    auto o = ::flatbuffers::Offset<LogicalAndOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   LogicalAndOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct LogicalNotOptionsT : public flatbuffers::NativeTable {", "+struct LogicalNotOptionsT : public ::flatbuffers::NativeTable {", "   typedef LogicalNotOptions TableType;", " };", " ", "-struct LogicalNotOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct LogicalNotOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef LogicalNotOptionsT NativeTableType;", "   typedef LogicalNotOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  LogicalNotOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(LogicalNotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<LogicalNotOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  LogicalNotOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(LogicalNotOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<LogicalNotOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct LogicalNotOptionsBuilder {", "   typedef LogicalNotOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit LogicalNotOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit LogicalNotOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<LogicalNotOptions> Finish() {", "+  ::flatbuffers::Offset<LogicalNotOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<LogicalNotOptions>(end);", "+    auto o = ::flatbuffers::Offset<LogicalNotOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   LogicalNotOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct UnpackOptionsT : public flatbuffers::NativeTable {", "+struct UnpackOptionsT : public ::flatbuffers::NativeTable {", "   typedef UnpackOptions TableType;", "   int32_t num = 0;", "   int32_t axis = 0;", " };", " ", "-struct UnpackOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct UnpackOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef UnpackOptionsT NativeTableType;", "   typedef UnpackOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -9357,40 +9364,40 @@ struct UnpackOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t axis() const {", "     return GetField<int32_t>(VT_AXIS, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_NUM, 4) &&", "            VerifyField<int32_t>(verifier, VT_AXIS, 4) &&", "            verifier.EndTable();", "   }", "-  UnpackOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(UnpackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<UnpackOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  UnpackOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(UnpackOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<UnpackOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct UnpackOptionsBuilder {", "   typedef UnpackOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_num(int32_t num) {", "     fbb_.AddElement<int32_t>(UnpackOptions::VT_NUM, num, 0);", "   }", "   void add_axis(int32_t axis) {", "     fbb_.AddElement<int32_t>(UnpackOptions::VT_AXIS, axis, 0);", "   }", "-  explicit UnpackOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit UnpackOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<UnpackOptions> Finish() {", "+  ::flatbuffers::Offset<UnpackOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<UnpackOptions>(end);", "+    auto o = ::flatbuffers::Offset<UnpackOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t num = 0,", "     int32_t axis = 0) {", "   UnpackOptionsBuilder builder_(_fbb);", "@@ -9399,248 +9406,248 @@ inline flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct FloorDivOptionsT : public flatbuffers::NativeTable {", "+struct FloorDivOptionsT : public ::flatbuffers::NativeTable {", "   typedef FloorDivOptions TableType;", " };", " ", "-struct FloorDivOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct FloorDivOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef FloorDivOptionsT NativeTableType;", "   typedef FloorDivOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  FloorDivOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(FloorDivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<FloorDivOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  FloorDivOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(FloorDivOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<FloorDivOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct FloorDivOptionsBuilder {", "   typedef FloorDivOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit FloorDivOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit FloorDivOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<FloorDivOptions> Finish() {", "+  ::flatbuffers::Offset<FloorDivOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<FloorDivOptions>(end);", "+    auto o = ::flatbuffers::Offset<FloorDivOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   FloorDivOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(::flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SquareOptionsT : public flatbuffers::NativeTable {", "+struct SquareOptionsT : public ::flatbuffers::NativeTable {", "   typedef SquareOptions TableType;", " };", " ", "-struct SquareOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SquareOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SquareOptionsT NativeTableType;", "   typedef SquareOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  SquareOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SquareOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SquareOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SquareOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SquareOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SquareOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SquareOptionsBuilder {", "   typedef SquareOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit SquareOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit SquareOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SquareOptions> Finish() {", "+  ::flatbuffers::Offset<SquareOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SquareOptions>(end);", "+    auto o = ::flatbuffers::Offset<SquareOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SquareOptions> CreateSquareOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<SquareOptions> CreateSquareOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   SquareOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<SquareOptions> CreateSquareOptions(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SquareOptions> CreateSquareOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ZerosLikeOptionsT : public flatbuffers::NativeTable {", "+struct ZerosLikeOptionsT : public ::flatbuffers::NativeTable {", "   typedef ZerosLikeOptions TableType;", " };", " ", "-struct ZerosLikeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ZerosLikeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ZerosLikeOptionsT NativeTableType;", "   typedef ZerosLikeOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  ZerosLikeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ZerosLikeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ZerosLikeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ZerosLikeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ZerosLikeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ZerosLikeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ZerosLikeOptionsBuilder {", "   typedef ZerosLikeOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit ZerosLikeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit ZerosLikeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ZerosLikeOptions> Finish() {", "+  ::flatbuffers::Offset<ZerosLikeOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ZerosLikeOptions>(end);", "+    auto o = ::flatbuffers::Offset<ZerosLikeOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   ZerosLikeOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct FillOptionsT : public flatbuffers::NativeTable {", "+struct FillOptionsT : public ::flatbuffers::NativeTable {", "   typedef FillOptions TableType;", " };", " ", "-struct FillOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct FillOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef FillOptionsT NativeTableType;", "   typedef FillOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  FillOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(FillOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<FillOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  FillOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(FillOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<FillOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct FillOptionsBuilder {", "   typedef FillOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit FillOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit FillOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<FillOptions> Finish() {", "+  ::flatbuffers::Offset<FillOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<FillOptions>(end);", "+    auto o = ::flatbuffers::Offset<FillOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<FillOptions> CreateFillOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<FillOptions> CreateFillOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   FillOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<FillOptions> CreateFillOptions(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<FillOptions> CreateFillOptions(::flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct FloorModOptionsT : public flatbuffers::NativeTable {", "+struct FloorModOptionsT : public ::flatbuffers::NativeTable {", "   typedef FloorModOptions TableType;", " };", " ", "-struct FloorModOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct FloorModOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef FloorModOptionsT NativeTableType;", "   typedef FloorModOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  FloorModOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(FloorModOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<FloorModOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  FloorModOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(FloorModOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<FloorModOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct FloorModOptionsBuilder {", "   typedef FloorModOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit FloorModOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit FloorModOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<FloorModOptions> Finish() {", "+  ::flatbuffers::Offset<FloorModOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<FloorModOptions>(end);", "+    auto o = ::flatbuffers::Offset<FloorModOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   FloorModOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(::flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct RangeOptionsT : public flatbuffers::NativeTable {", "+struct RangeOptionsT : public ::flatbuffers::NativeTable {", "   typedef RangeOptions TableType;", " };", " ", "-struct RangeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct RangeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef RangeOptionsT NativeTableType;", "   typedef RangeOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  RangeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(RangeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<RangeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  RangeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(RangeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<RangeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct RangeOptionsBuilder {", "   typedef RangeOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit RangeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit RangeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<RangeOptions> Finish() {", "+  ::flatbuffers::Offset<RangeOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<RangeOptions>(end);", "+    auto o = ::flatbuffers::Offset<RangeOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<RangeOptions> CreateRangeOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<RangeOptions> CreateRangeOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   RangeOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<RangeOptions> CreateRangeOptions(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<RangeOptions> CreateRangeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct LeakyReluOptionsT : public flatbuffers::NativeTable {", "+struct LeakyReluOptionsT : public ::flatbuffers::NativeTable {", "   typedef LeakyReluOptions TableType;", "   float alpha = 0.0f;", " };", " ", "-struct LeakyReluOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct LeakyReluOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef LeakyReluOptionsT NativeTableType;", "   typedef LeakyReluOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -9649,89 +9656,89 @@ struct LeakyReluOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   float alpha() const {", "     return GetField<float>(VT_ALPHA, 0.0f);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<float>(verifier, VT_ALPHA, 4) &&", "            verifier.EndTable();", "   }", "-  LeakyReluOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(LeakyReluOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<LeakyReluOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  LeakyReluOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(LeakyReluOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<LeakyReluOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct LeakyReluOptionsBuilder {", "   typedef LeakyReluOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_alpha(float alpha) {", "     fbb_.AddElement<float>(LeakyReluOptions::VT_ALPHA, alpha, 0.0f);", "   }", "-  explicit LeakyReluOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit LeakyReluOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<LeakyReluOptions> Finish() {", "+  ::flatbuffers::Offset<LeakyReluOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<LeakyReluOptions>(end);", "+    auto o = ::flatbuffers::Offset<LeakyReluOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     float alpha = 0.0f) {", "   LeakyReluOptionsBuilder builder_(_fbb);", "   builder_.add_alpha(alpha);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SquaredDifferenceOptionsT : public flatbuffers::NativeTable {", "+struct SquaredDifferenceOptionsT : public ::flatbuffers::NativeTable {", "   typedef SquaredDifferenceOptions TableType;", " };", " ", "-struct SquaredDifferenceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SquaredDifferenceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SquaredDifferenceOptionsT NativeTableType;", "   typedef SquaredDifferenceOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  SquaredDifferenceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SquaredDifferenceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SquaredDifferenceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SquaredDifferenceOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SquaredDifferenceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SquaredDifferenceOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SquaredDifferenceOptionsBuilder {", "   typedef SquaredDifferenceOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit SquaredDifferenceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit SquaredDifferenceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SquaredDifferenceOptions> Finish() {", "+  ::flatbuffers::Offset<SquaredDifferenceOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SquaredDifferenceOptions>(end);", "+    auto o = ::flatbuffers::Offset<SquaredDifferenceOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   SquaredDifferenceOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct MirrorPadOptionsT : public flatbuffers::NativeTable {", "+struct MirrorPadOptionsT : public ::flatbuffers::NativeTable {", "   typedef MirrorPadOptions TableType;", "   tflite::MirrorPadMode mode = tflite::MirrorPadMode_REFLECT;", " };", " ", "-struct MirrorPadOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct MirrorPadOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef MirrorPadOptionsT NativeTableType;", "   typedef MirrorPadOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -9740,50 +9747,50 @@ struct MirrorPadOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   tflite::MirrorPadMode mode() const {", "     return static_cast<tflite::MirrorPadMode>(GetField<int8_t>(VT_MODE, 0));", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_MODE, 1) &&", "            verifier.EndTable();", "   }", "-  MirrorPadOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(MirrorPadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<MirrorPadOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  MirrorPadOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(MirrorPadOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<MirrorPadOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct MirrorPadOptionsBuilder {", "   typedef MirrorPadOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_mode(tflite::MirrorPadMode mode) {", "     fbb_.AddElement<int8_t>(MirrorPadOptions::VT_MODE, static_cast<int8_t>(mode), 0);", "   }", "-  explicit MirrorPadOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit MirrorPadOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<MirrorPadOptions> Finish() {", "+  ::flatbuffers::Offset<MirrorPadOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<MirrorPadOptions>(end);", "+    auto o = ::flatbuffers::Offset<MirrorPadOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::MirrorPadMode mode = tflite::MirrorPadMode_REFLECT) {", "   MirrorPadOptionsBuilder builder_(_fbb);", "   builder_.add_mode(mode);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(::flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct UniqueOptionsT : public flatbuffers::NativeTable {", "+struct UniqueOptionsT : public ::flatbuffers::NativeTable {", "   typedef UniqueOptions TableType;", "   tflite::TensorType idx_out_type = tflite::TensorType_INT32;", " };", " ", "-struct UniqueOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct UniqueOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef UniqueOptionsT NativeTableType;", "   typedef UniqueOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -9792,207 +9799,207 @@ struct UniqueOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   tflite::TensorType idx_out_type() const {", "     return static_cast<tflite::TensorType>(GetField<int8_t>(VT_IDX_OUT_TYPE, 2));", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_IDX_OUT_TYPE, 1) &&", "            verifier.EndTable();", "   }", "-  UniqueOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(UniqueOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<UniqueOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  UniqueOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(UniqueOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<UniqueOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct UniqueOptionsBuilder {", "   typedef UniqueOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_idx_out_type(tflite::TensorType idx_out_type) {", "     fbb_.AddElement<int8_t>(UniqueOptions::VT_IDX_OUT_TYPE, static_cast<int8_t>(idx_out_type), 2);", "   }", "-  explicit UniqueOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit UniqueOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<UniqueOptions> Finish() {", "+  ::flatbuffers::Offset<UniqueOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<UniqueOptions>(end);", "+    auto o = ::flatbuffers::Offset<UniqueOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     tflite::TensorType idx_out_type = tflite::TensorType_INT32) {", "   UniqueOptionsBuilder builder_(_fbb);", "   builder_.add_idx_out_type(idx_out_type);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ReverseV2OptionsT : public flatbuffers::NativeTable {", "+struct ReverseV2OptionsT : public ::flatbuffers::NativeTable {", "   typedef ReverseV2Options TableType;", " };", " ", "-struct ReverseV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ReverseV2Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ReverseV2OptionsT NativeTableType;", "   typedef ReverseV2OptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  ReverseV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ReverseV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ReverseV2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ReverseV2OptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ReverseV2OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ReverseV2Options> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ReverseV2OptionsBuilder {", "   typedef ReverseV2Options Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit ReverseV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit ReverseV2OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ReverseV2Options> Finish() {", "+  ::flatbuffers::Offset<ReverseV2Options> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ReverseV2Options>(end);", "+    auto o = ::flatbuffers::Offset<ReverseV2Options>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   ReverseV2OptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(::flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct AddNOptionsT : public flatbuffers::NativeTable {", "+struct AddNOptionsT : public ::flatbuffers::NativeTable {", "   typedef AddNOptions TableType;", " };", " ", "-struct AddNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct AddNOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef AddNOptionsT NativeTableType;", "   typedef AddNOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  AddNOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(AddNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<AddNOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  AddNOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(AddNOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<AddNOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct AddNOptionsBuilder {", "   typedef AddNOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit AddNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit AddNOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<AddNOptions> Finish() {", "+  ::flatbuffers::Offset<AddNOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<AddNOptions>(end);", "+    auto o = ::flatbuffers::Offset<AddNOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<AddNOptions> CreateAddNOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<AddNOptions> CreateAddNOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   AddNOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<AddNOptions> CreateAddNOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<AddNOptions> CreateAddNOptions(::flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct GatherNdOptionsT : public flatbuffers::NativeTable {", "+struct GatherNdOptionsT : public ::flatbuffers::NativeTable {", "   typedef GatherNdOptions TableType;", " };", " ", "-struct GatherNdOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct GatherNdOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef GatherNdOptionsT NativeTableType;", "   typedef GatherNdOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  GatherNdOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(GatherNdOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<GatherNdOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  GatherNdOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(GatherNdOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<GatherNdOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct GatherNdOptionsBuilder {", "   typedef GatherNdOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit GatherNdOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit GatherNdOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<GatherNdOptions> Finish() {", "+  ::flatbuffers::Offset<GatherNdOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<GatherNdOptions>(end);", "+    auto o = ::flatbuffers::Offset<GatherNdOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   GatherNdOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(::flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct WhereOptionsT : public flatbuffers::NativeTable {", "+struct WhereOptionsT : public ::flatbuffers::NativeTable {", "   typedef WhereOptions TableType;", " };", " ", "-struct WhereOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct WhereOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef WhereOptionsT NativeTableType;", "   typedef WhereOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  WhereOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(WhereOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<WhereOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  WhereOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(WhereOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<WhereOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct WhereOptionsBuilder {", "   typedef WhereOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit WhereOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit WhereOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<WhereOptions> Finish() {", "+  ::flatbuffers::Offset<WhereOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<WhereOptions>(end);", "+    auto o = ::flatbuffers::Offset<WhereOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<WhereOptions> CreateWhereOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<WhereOptions> CreateWhereOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   WhereOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<WhereOptions> CreateWhereOptions(flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<WhereOptions> CreateWhereOptions(::flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ReverseSequenceOptionsT : public flatbuffers::NativeTable {", "+struct ReverseSequenceOptionsT : public ::flatbuffers::NativeTable {", "   typedef ReverseSequenceOptions TableType;", "   int32_t seq_dim = 0;", "   int32_t batch_dim = 0;", " };", " ", "-struct ReverseSequenceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ReverseSequenceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ReverseSequenceOptionsT NativeTableType;", "   typedef ReverseSequenceOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -10005,40 +10012,40 @@ struct ReverseSequenceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tab", "   int32_t batch_dim() const {", "     return GetField<int32_t>(VT_BATCH_DIM, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_SEQ_DIM, 4) &&", "            VerifyField<int32_t>(verifier, VT_BATCH_DIM, 4) &&", "            verifier.EndTable();", "   }", "-  ReverseSequenceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ReverseSequenceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ReverseSequenceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ReverseSequenceOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ReverseSequenceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ReverseSequenceOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ReverseSequenceOptionsBuilder {", "   typedef ReverseSequenceOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_seq_dim(int32_t seq_dim) {", "     fbb_.AddElement<int32_t>(ReverseSequenceOptions::VT_SEQ_DIM, seq_dim, 0);", "   }", "   void add_batch_dim(int32_t batch_dim) {", "     fbb_.AddElement<int32_t>(ReverseSequenceOptions::VT_BATCH_DIM, batch_dim, 0);", "   }", "-  explicit ReverseSequenceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit ReverseSequenceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ReverseSequenceOptions> Finish() {", "+  ::flatbuffers::Offset<ReverseSequenceOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ReverseSequenceOptions>(end);", "+    auto o = ::flatbuffers::Offset<ReverseSequenceOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t seq_dim = 0,", "     int32_t batch_dim = 0) {", "   ReverseSequenceOptionsBuilder builder_(_fbb);", "@@ -10047,132 +10054,132 @@ inline flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct MatrixDiagOptionsT : public flatbuffers::NativeTable {", "+struct MatrixDiagOptionsT : public ::flatbuffers::NativeTable {", "   typedef MatrixDiagOptions TableType;", " };", " ", "-struct MatrixDiagOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct MatrixDiagOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef MatrixDiagOptionsT NativeTableType;", "   typedef MatrixDiagOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  MatrixDiagOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(MatrixDiagOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<MatrixDiagOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  MatrixDiagOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(MatrixDiagOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<MatrixDiagOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct MatrixDiagOptionsBuilder {", "   typedef MatrixDiagOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit MatrixDiagOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit MatrixDiagOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<MatrixDiagOptions> Finish() {", "+  ::flatbuffers::Offset<MatrixDiagOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<MatrixDiagOptions>(end);", "+    auto o = ::flatbuffers::Offset<MatrixDiagOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<MatrixDiagOptions> CreateMatrixDiagOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<MatrixDiagOptions> CreateMatrixDiagOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   MatrixDiagOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<MatrixDiagOptions> CreateMatrixDiagOptions(flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<MatrixDiagOptions> CreateMatrixDiagOptions(::flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct QuantizeOptionsT : public flatbuffers::NativeTable {", "+struct QuantizeOptionsT : public ::flatbuffers::NativeTable {", "   typedef QuantizeOptions TableType;", " };", " ", "-struct QuantizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct QuantizeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef QuantizeOptionsT NativeTableType;", "   typedef QuantizeOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  QuantizeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(QuantizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<QuantizeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  QuantizeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(QuantizeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<QuantizeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct QuantizeOptionsBuilder {", "   typedef QuantizeOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit QuantizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit QuantizeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<QuantizeOptions> Finish() {", "+  ::flatbuffers::Offset<QuantizeOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<QuantizeOptions>(end);", "+    auto o = ::flatbuffers::Offset<QuantizeOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   QuantizeOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct MatrixSetDiagOptionsT : public flatbuffers::NativeTable {", "+struct MatrixSetDiagOptionsT : public ::flatbuffers::NativeTable {", "   typedef MatrixSetDiagOptions TableType;", " };", " ", "-struct MatrixSetDiagOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct MatrixSetDiagOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef MatrixSetDiagOptionsT NativeTableType;", "   typedef MatrixSetDiagOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  MatrixSetDiagOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(MatrixSetDiagOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<MatrixSetDiagOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  MatrixSetDiagOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(MatrixSetDiagOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<MatrixSetDiagOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct MatrixSetDiagOptionsBuilder {", "   typedef MatrixSetDiagOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit MatrixSetDiagOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit MatrixSetDiagOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<MatrixSetDiagOptions> Finish() {", "+  ::flatbuffers::Offset<MatrixSetDiagOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<MatrixSetDiagOptions>(end);", "+    auto o = ::flatbuffers::Offset<MatrixSetDiagOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<MatrixSetDiagOptions> CreateMatrixSetDiagOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<MatrixSetDiagOptions> CreateMatrixSetDiagOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   MatrixSetDiagOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<MatrixSetDiagOptions> CreateMatrixSetDiagOptions(flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<MatrixSetDiagOptions> CreateMatrixSetDiagOptions(::flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct IfOptionsT : public flatbuffers::NativeTable {", "+struct IfOptionsT : public ::flatbuffers::NativeTable {", "   typedef IfOptions TableType;", "   int32_t then_subgraph_index = 0;", "   int32_t else_subgraph_index = 0;", " };", " ", "-struct IfOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct IfOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef IfOptionsT NativeTableType;", "   typedef IfOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -10185,40 +10192,40 @@ struct IfOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t else_subgraph_index() const {", "     return GetField<int32_t>(VT_ELSE_SUBGRAPH_INDEX, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_THEN_SUBGRAPH_INDEX, 4) &&", "            VerifyField<int32_t>(verifier, VT_ELSE_SUBGRAPH_INDEX, 4) &&", "            verifier.EndTable();", "   }", "-  IfOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(IfOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<IfOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  IfOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(IfOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<IfOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct IfOptionsBuilder {", "   typedef IfOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_then_subgraph_index(int32_t then_subgraph_index) {", "     fbb_.AddElement<int32_t>(IfOptions::VT_THEN_SUBGRAPH_INDEX, then_subgraph_index, 0);", "   }", "   void add_else_subgraph_index(int32_t else_subgraph_index) {", "     fbb_.AddElement<int32_t>(IfOptions::VT_ELSE_SUBGRAPH_INDEX, else_subgraph_index, 0);", "   }", "-  explicit IfOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit IfOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<IfOptions> Finish() {", "+  ::flatbuffers::Offset<IfOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<IfOptions>(end);", "+    auto o = ::flatbuffers::Offset<IfOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<IfOptions> CreateIfOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<IfOptions> CreateIfOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t then_subgraph_index = 0,", "     int32_t else_subgraph_index = 0) {", "   IfOptionsBuilder builder_(_fbb);", "@@ -10227,14 +10234,14 @@ inline flatbuffers::Offset<IfOptions> CreateIfOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<IfOptions> CreateIfOptions(flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<IfOptions> CreateIfOptions(::flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct CallOnceOptionsT : public flatbuffers::NativeTable {", "+struct CallOnceOptionsT : public ::flatbuffers::NativeTable {", "   typedef CallOnceOptions TableType;", "   int32_t init_subgraph_index = 0;", " };", " ", "-struct CallOnceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct CallOnceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef CallOnceOptionsT NativeTableType;", "   typedef CallOnceOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -10243,51 +10250,51 @@ struct CallOnceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t init_subgraph_index() const {", "     return GetField<int32_t>(VT_INIT_SUBGRAPH_INDEX, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_INIT_SUBGRAPH_INDEX, 4) &&", "            verifier.EndTable();", "   }", "-  CallOnceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(CallOnceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<CallOnceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  CallOnceOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(CallOnceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<CallOnceOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct CallOnceOptionsBuilder {", "   typedef CallOnceOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_init_subgraph_index(int32_t init_subgraph_index) {", "     fbb_.AddElement<int32_t>(CallOnceOptions::VT_INIT_SUBGRAPH_INDEX, init_subgraph_index, 0);", "   }", "-  explicit CallOnceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit CallOnceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<CallOnceOptions> Finish() {", "+  ::flatbuffers::Offset<CallOnceOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<CallOnceOptions>(end);", "+    auto o = ::flatbuffers::Offset<CallOnceOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<CallOnceOptions> CreateCallOnceOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<CallOnceOptions> CreateCallOnceOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t init_subgraph_index = 0) {", "   CallOnceOptionsBuilder builder_(_fbb);", "   builder_.add_init_subgraph_index(init_subgraph_index);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<CallOnceOptions> CreateCallOnceOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<CallOnceOptions> CreateCallOnceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct WhileOptionsT : public flatbuffers::NativeTable {", "+struct WhileOptionsT : public ::flatbuffers::NativeTable {", "   typedef WhileOptions TableType;", "   int32_t cond_subgraph_index = 0;", "   int32_t body_subgraph_index = 0;", " };", " ", "-struct WhileOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct WhileOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef WhileOptionsT NativeTableType;", "   typedef WhileOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -10300,40 +10307,40 @@ struct WhileOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int32_t body_subgraph_index() const {", "     return GetField<int32_t>(VT_BODY_SUBGRAPH_INDEX, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_COND_SUBGRAPH_INDEX, 4) &&", "            VerifyField<int32_t>(verifier, VT_BODY_SUBGRAPH_INDEX, 4) &&", "            verifier.EndTable();", "   }", "-  WhileOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(WhileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<WhileOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  WhileOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(WhileOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<WhileOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct WhileOptionsBuilder {", "   typedef WhileOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_cond_subgraph_index(int32_t cond_subgraph_index) {", "     fbb_.AddElement<int32_t>(WhileOptions::VT_COND_SUBGRAPH_INDEX, cond_subgraph_index, 0);", "   }", "   void add_body_subgraph_index(int32_t body_subgraph_index) {", "     fbb_.AddElement<int32_t>(WhileOptions::VT_BODY_SUBGRAPH_INDEX, body_subgraph_index, 0);", "   }", "-  explicit WhileOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit WhileOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<WhileOptions> Finish() {", "+  ::flatbuffers::Offset<WhileOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<WhileOptions>(end);", "+    auto o = ::flatbuffers::Offset<WhileOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<WhileOptions> CreateWhileOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<WhileOptions> CreateWhileOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t cond_subgraph_index = 0,", "     int32_t body_subgraph_index = 0) {", "   WhileOptionsBuilder builder_(_fbb);", "@@ -10342,250 +10349,250 @@ inline flatbuffers::Offset<WhileOptions> CreateWhileOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<WhileOptions> CreateWhileOptions(flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<WhileOptions> CreateWhileOptions(::flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct NonMaxSuppressionV4OptionsT : public flatbuffers::NativeTable {", "+struct NonMaxSuppressionV4OptionsT : public ::flatbuffers::NativeTable {", "   typedef NonMaxSuppressionV4Options TableType;", " };", " ", "-struct NonMaxSuppressionV4Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct NonMaxSuppressionV4Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef NonMaxSuppressionV4OptionsT NativeTableType;", "   typedef NonMaxSuppressionV4OptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  NonMaxSuppressionV4OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(NonMaxSuppressionV4OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<NonMaxSuppressionV4Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  NonMaxSuppressionV4OptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(NonMaxSuppressionV4OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<NonMaxSuppressionV4Options> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct NonMaxSuppressionV4OptionsBuilder {", "   typedef NonMaxSuppressionV4Options Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit NonMaxSuppressionV4OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit NonMaxSuppressionV4OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<NonMaxSuppressionV4Options> Finish() {", "+  ::flatbuffers::Offset<NonMaxSuppressionV4Options> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<NonMaxSuppressionV4Options>(end);", "+    auto o = ::flatbuffers::Offset<NonMaxSuppressionV4Options>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<NonMaxSuppressionV4Options> CreateNonMaxSuppressionV4Options(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<NonMaxSuppressionV4Options> CreateNonMaxSuppressionV4Options(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   NonMaxSuppressionV4OptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<NonMaxSuppressionV4Options> CreateNonMaxSuppressionV4Options(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<NonMaxSuppressionV4Options> CreateNonMaxSuppressionV4Options(::flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct NonMaxSuppressionV5OptionsT : public flatbuffers::NativeTable {", "+struct NonMaxSuppressionV5OptionsT : public ::flatbuffers::NativeTable {", "   typedef NonMaxSuppressionV5Options TableType;", " };", " ", "-struct NonMaxSuppressionV5Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct NonMaxSuppressionV5Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef NonMaxSuppressionV5OptionsT NativeTableType;", "   typedef NonMaxSuppressionV5OptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  NonMaxSuppressionV5OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(NonMaxSuppressionV5OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<NonMaxSuppressionV5Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  NonMaxSuppressionV5OptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(NonMaxSuppressionV5OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<NonMaxSuppressionV5Options> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct NonMaxSuppressionV5OptionsBuilder {", "   typedef NonMaxSuppressionV5Options Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit NonMaxSuppressionV5OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit NonMaxSuppressionV5OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<NonMaxSuppressionV5Options> Finish() {", "+  ::flatbuffers::Offset<NonMaxSuppressionV5Options> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<NonMaxSuppressionV5Options>(end);", "+    auto o = ::flatbuffers::Offset<NonMaxSuppressionV5Options>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<NonMaxSuppressionV5Options> CreateNonMaxSuppressionV5Options(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<NonMaxSuppressionV5Options> CreateNonMaxSuppressionV5Options(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   NonMaxSuppressionV5OptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<NonMaxSuppressionV5Options> CreateNonMaxSuppressionV5Options(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<NonMaxSuppressionV5Options> CreateNonMaxSuppressionV5Options(::flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ScatterNdOptionsT : public flatbuffers::NativeTable {", "+struct ScatterNdOptionsT : public ::flatbuffers::NativeTable {", "   typedef ScatterNdOptions TableType;", " };", " ", "-struct ScatterNdOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ScatterNdOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ScatterNdOptionsT NativeTableType;", "   typedef ScatterNdOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  ScatterNdOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ScatterNdOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ScatterNdOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ScatterNdOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ScatterNdOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ScatterNdOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ScatterNdOptionsBuilder {", "   typedef ScatterNdOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit ScatterNdOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit ScatterNdOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ScatterNdOptions> Finish() {", "+  ::flatbuffers::Offset<ScatterNdOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ScatterNdOptions>(end);", "+    auto o = ::flatbuffers::Offset<ScatterNdOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ScatterNdOptions> CreateScatterNdOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<ScatterNdOptions> CreateScatterNdOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   ScatterNdOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<ScatterNdOptions> CreateScatterNdOptions(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ScatterNdOptions> CreateScatterNdOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SelectV2OptionsT : public flatbuffers::NativeTable {", "+struct SelectV2OptionsT : public ::flatbuffers::NativeTable {", "   typedef SelectV2Options TableType;", " };", " ", "-struct SelectV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SelectV2Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SelectV2OptionsT NativeTableType;", "   typedef SelectV2OptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  SelectV2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SelectV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SelectV2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SelectV2OptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SelectV2OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SelectV2Options> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SelectV2OptionsBuilder {", "   typedef SelectV2Options Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit SelectV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit SelectV2OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SelectV2Options> Finish() {", "+  ::flatbuffers::Offset<SelectV2Options> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SelectV2Options>(end);", "+    auto o = ::flatbuffers::Offset<SelectV2Options>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SelectV2Options> CreateSelectV2Options(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<SelectV2Options> CreateSelectV2Options(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   SelectV2OptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<SelectV2Options> CreateSelectV2Options(flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SelectV2Options> CreateSelectV2Options(::flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct DensifyOptionsT : public flatbuffers::NativeTable {", "+struct DensifyOptionsT : public ::flatbuffers::NativeTable {", "   typedef DensifyOptions TableType;", " };", " ", "-struct DensifyOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct DensifyOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef DensifyOptionsT NativeTableType;", "   typedef DensifyOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  DensifyOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(DensifyOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<DensifyOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  DensifyOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(DensifyOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<DensifyOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct DensifyOptionsBuilder {", "   typedef DensifyOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit DensifyOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit DensifyOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<DensifyOptions> Finish() {", "+  ::flatbuffers::Offset<DensifyOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<DensifyOptions>(end);", "+    auto o = ::flatbuffers::Offset<DensifyOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<DensifyOptions> CreateDensifyOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<DensifyOptions> CreateDensifyOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   DensifyOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<DensifyOptions> CreateDensifyOptions(flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<DensifyOptions> CreateDensifyOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SegmentSumOptionsT : public flatbuffers::NativeTable {", "+struct SegmentSumOptionsT : public ::flatbuffers::NativeTable {", "   typedef SegmentSumOptions TableType;", " };", " ", "-struct SegmentSumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SegmentSumOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SegmentSumOptionsT NativeTableType;", "   typedef SegmentSumOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  SegmentSumOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SegmentSumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SegmentSumOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SegmentSumOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SegmentSumOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SegmentSumOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SegmentSumOptionsBuilder {", "   typedef SegmentSumOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit SegmentSumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit SegmentSumOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SegmentSumOptions> Finish() {", "+  ::flatbuffers::Offset<SegmentSumOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SegmentSumOptions>(end);", "+    auto o = ::flatbuffers::Offset<SegmentSumOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SegmentSumOptions> CreateSegmentSumOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<SegmentSumOptions> CreateSegmentSumOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   SegmentSumOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<SegmentSumOptions> CreateSegmentSumOptions(flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SegmentSumOptions> CreateSegmentSumOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct BatchMatMulOptionsT : public flatbuffers::NativeTable {", "+struct BatchMatMulOptionsT : public ::flatbuffers::NativeTable {", "   typedef BatchMatMulOptions TableType;", "   bool adj_x = false;", "   bool adj_y = false;", "   bool asymmetric_quantize_inputs = false;", " };", " ", "-struct BatchMatMulOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct BatchMatMulOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef BatchMatMulOptionsT NativeTableType;", "   typedef BatchMatMulOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -10602,22 +10609,22 @@ struct BatchMatMulOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool asymmetric_quantize_inputs() const {", "     return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<uint8_t>(verifier, VT_ADJ_X, 1) &&", "            VerifyField<uint8_t>(verifier, VT_ADJ_Y, 1) &&", "            VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS, 1) &&", "            verifier.EndTable();", "   }", "-  BatchMatMulOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(BatchMatMulOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<BatchMatMulOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  BatchMatMulOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(BatchMatMulOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<BatchMatMulOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct BatchMatMulOptionsBuilder {", "   typedef BatchMatMulOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_adj_x(bool adj_x) {", "     fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ADJ_X, static_cast<uint8_t>(adj_x), 0);", "   }", "@@ -10627,19 +10634,19 @@ struct BatchMatMulOptionsBuilder {", "   void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {", "     fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);", "   }", "-  explicit BatchMatMulOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit BatchMatMulOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<BatchMatMulOptions> Finish() {", "+  ::flatbuffers::Offset<BatchMatMulOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<BatchMatMulOptions>(end);", "+    auto o = ::flatbuffers::Offset<BatchMatMulOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     bool adj_x = false,", "     bool adj_y = false,", "     bool asymmetric_quantize_inputs = false) {", "@@ -10650,15 +10657,15 @@ inline flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct CumsumOptionsT : public flatbuffers::NativeTable {", "+struct CumsumOptionsT : public ::flatbuffers::NativeTable {", "   typedef CumsumOptions TableType;", "   bool exclusive = false;", "   bool reverse = false;", " };", " ", "-struct CumsumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct CumsumOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef CumsumOptionsT NativeTableType;", "   typedef CumsumOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -10671,40 +10678,40 @@ struct CumsumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool reverse() const {", "     return GetField<uint8_t>(VT_REVERSE, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<uint8_t>(verifier, VT_EXCLUSIVE, 1) &&", "            VerifyField<uint8_t>(verifier, VT_REVERSE, 1) &&", "            verifier.EndTable();", "   }", "-  CumsumOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(CumsumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<CumsumOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  CumsumOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(CumsumOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<CumsumOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct CumsumOptionsBuilder {", "   typedef CumsumOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_exclusive(bool exclusive) {", "     fbb_.AddElement<uint8_t>(CumsumOptions::VT_EXCLUSIVE, static_cast<uint8_t>(exclusive), 0);", "   }", "   void add_reverse(bool reverse) {", "     fbb_.AddElement<uint8_t>(CumsumOptions::VT_REVERSE, static_cast<uint8_t>(reverse), 0);", "   }", "-  explicit CumsumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit CumsumOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<CumsumOptions> Finish() {", "+  ::flatbuffers::Offset<CumsumOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<CumsumOptions>(end);", "+    auto o = ::flatbuffers::Offset<CumsumOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<CumsumOptions> CreateCumsumOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<CumsumOptions> CreateCumsumOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     bool exclusive = false,", "     bool reverse = false) {", "   CumsumOptionsBuilder builder_(_fbb);", "@@ -10713,94 +10720,94 @@ inline flatbuffers::Offset<CumsumOptions> CreateCumsumOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<CumsumOptions> CreateCumsumOptions(flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<CumsumOptions> CreateCumsumOptions(::flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct BroadcastToOptionsT : public flatbuffers::NativeTable {", "+struct BroadcastToOptionsT : public ::flatbuffers::NativeTable {", "   typedef BroadcastToOptions TableType;", " };", " ", "-struct BroadcastToOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct BroadcastToOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef BroadcastToOptionsT NativeTableType;", "   typedef BroadcastToOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  BroadcastToOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(BroadcastToOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<BroadcastToOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  BroadcastToOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(BroadcastToOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<BroadcastToOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct BroadcastToOptionsBuilder {", "   typedef BroadcastToOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit BroadcastToOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit BroadcastToOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<BroadcastToOptions> Finish() {", "+  ::flatbuffers::Offset<BroadcastToOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<BroadcastToOptions>(end);", "+    auto o = ::flatbuffers::Offset<BroadcastToOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<BroadcastToOptions> CreateBroadcastToOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<BroadcastToOptions> CreateBroadcastToOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   BroadcastToOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<BroadcastToOptions> CreateBroadcastToOptions(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<BroadcastToOptions> CreateBroadcastToOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct Rfft2dOptionsT : public flatbuffers::NativeTable {", "+struct Rfft2dOptionsT : public ::flatbuffers::NativeTable {", "   typedef Rfft2dOptions TableType;", " };", " ", "-struct Rfft2dOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct Rfft2dOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef Rfft2dOptionsT NativeTableType;", "   typedef Rfft2dOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  Rfft2dOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(Rfft2dOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<Rfft2dOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  Rfft2dOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(Rfft2dOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<Rfft2dOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct Rfft2dOptionsBuilder {", "   typedef Rfft2dOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit Rfft2dOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit Rfft2dOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<Rfft2dOptions> Finish() {", "+  ::flatbuffers::Offset<Rfft2dOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<Rfft2dOptions>(end);", "+    auto o = ::flatbuffers::Offset<Rfft2dOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<Rfft2dOptions> CreateRfft2dOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<Rfft2dOptions> CreateRfft2dOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   Rfft2dOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<Rfft2dOptions> CreateRfft2dOptions(flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<Rfft2dOptions> CreateRfft2dOptions(::flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct HashtableOptionsT : public flatbuffers::NativeTable {", "+struct HashtableOptionsT : public ::flatbuffers::NativeTable {", "   typedef HashtableOptions TableType;", "   int32_t table_id = 0;", "   tflite::TensorType key_dtype = tflite::TensorType_FLOAT32;", "   tflite::TensorType value_dtype = tflite::TensorType_FLOAT32;", " };", " ", "-struct HashtableOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct HashtableOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef HashtableOptionsT NativeTableType;", "   typedef HashtableOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -10817,22 +10824,22 @@ struct HashtableOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   tflite::TensorType value_dtype() const {", "     return static_cast<tflite::TensorType>(GetField<int8_t>(VT_VALUE_DTYPE, 0));", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int32_t>(verifier, VT_TABLE_ID, 4) &&", "            VerifyField<int8_t>(verifier, VT_KEY_DTYPE, 1) &&", "            VerifyField<int8_t>(verifier, VT_VALUE_DTYPE, 1) &&", "            verifier.EndTable();", "   }", "-  HashtableOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(HashtableOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<HashtableOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  HashtableOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(HashtableOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<HashtableOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct HashtableOptionsBuilder {", "   typedef HashtableOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_table_id(int32_t table_id) {", "     fbb_.AddElement<int32_t>(HashtableOptions::VT_TABLE_ID, table_id, 0);", "   }", "@@ -10842,19 +10849,19 @@ struct HashtableOptionsBuilder {", "   void add_value_dtype(tflite::TensorType value_dtype) {", "     fbb_.AddElement<int8_t>(HashtableOptions::VT_VALUE_DTYPE, static_cast<int8_t>(value_dtype), 0);", "   }", "-  explicit HashtableOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit HashtableOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<HashtableOptions> Finish() {", "+  ::flatbuffers::Offset<HashtableOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<HashtableOptions>(end);", "+    auto o = ::flatbuffers::Offset<HashtableOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<HashtableOptions> CreateHashtableOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<HashtableOptions> CreateHashtableOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int32_t table_id = 0,", "     tflite::TensorType key_dtype = tflite::TensorType_FLOAT32,", "     tflite::TensorType value_dtype = tflite::TensorType_FLOAT32) {", "@@ -10865,145 +10872,145 @@ inline flatbuffers::Offset<HashtableOptions> CreateHashtableOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<HashtableOptions> CreateHashtableOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<HashtableOptions> CreateHashtableOptions(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct HashtableFindOptionsT : public flatbuffers::NativeTable {", "+struct HashtableFindOptionsT : public ::flatbuffers::NativeTable {", "   typedef HashtableFindOptions TableType;", " };", " ", "-struct HashtableFindOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct HashtableFindOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef HashtableFindOptionsT NativeTableType;", "   typedef HashtableFindOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  HashtableFindOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(HashtableFindOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<HashtableFindOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  HashtableFindOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(HashtableFindOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<HashtableFindOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct HashtableFindOptionsBuilder {", "   typedef HashtableFindOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit HashtableFindOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit HashtableFindOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<HashtableFindOptions> Finish() {", "+  ::flatbuffers::Offset<HashtableFindOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<HashtableFindOptions>(end);", "+    auto o = ::flatbuffers::Offset<HashtableFindOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<HashtableFindOptions> CreateHashtableFindOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<HashtableFindOptions> CreateHashtableFindOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   HashtableFindOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<HashtableFindOptions> CreateHashtableFindOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<HashtableFindOptions> CreateHashtableFindOptions(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct HashtableImportOptionsT : public flatbuffers::NativeTable {", "+struct HashtableImportOptionsT : public ::flatbuffers::NativeTable {", "   typedef HashtableImportOptions TableType;", " };", " ", "-struct HashtableImportOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct HashtableImportOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef HashtableImportOptionsT NativeTableType;", "   typedef HashtableImportOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  HashtableImportOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(HashtableImportOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<HashtableImportOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  HashtableImportOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(HashtableImportOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<HashtableImportOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct HashtableImportOptionsBuilder {", "   typedef HashtableImportOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit HashtableImportOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit HashtableImportOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<HashtableImportOptions> Finish() {", "+  ::flatbuffers::Offset<HashtableImportOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<HashtableImportOptions>(end);", "+    auto o = ::flatbuffers::Offset<HashtableImportOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<HashtableImportOptions> CreateHashtableImportOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<HashtableImportOptions> CreateHashtableImportOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   HashtableImportOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<HashtableImportOptions> CreateHashtableImportOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<HashtableImportOptions> CreateHashtableImportOptions(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct HashtableSizeOptionsT : public flatbuffers::NativeTable {", "+struct HashtableSizeOptionsT : public ::flatbuffers::NativeTable {", "   typedef HashtableSizeOptions TableType;", " };", " ", "-struct HashtableSizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct HashtableSizeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef HashtableSizeOptionsT NativeTableType;", "   typedef HashtableSizeOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  HashtableSizeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(HashtableSizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<HashtableSizeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  HashtableSizeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(HashtableSizeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<HashtableSizeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct HashtableSizeOptionsBuilder {", "   typedef HashtableSizeOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit HashtableSizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit HashtableSizeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<HashtableSizeOptions> Finish() {", "+  ::flatbuffers::Offset<HashtableSizeOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<HashtableSizeOptions>(end);", "+    auto o = ::flatbuffers::Offset<HashtableSizeOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<HashtableSizeOptions> CreateHashtableSizeOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<HashtableSizeOptions> CreateHashtableSizeOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   HashtableSizeOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<HashtableSizeOptions> CreateHashtableSizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<HashtableSizeOptions> CreateHashtableSizeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct VarHandleOptionsT : public flatbuffers::NativeTable {", "+struct VarHandleOptionsT : public ::flatbuffers::NativeTable {", "   typedef VarHandleOptions TableType;", "   std::string container{};", "   std::string shared_name{};", " };", " ", "-struct VarHandleOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct VarHandleOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef VarHandleOptionsT NativeTableType;", "   typedef VarHandleOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_CONTAINER = 4,", "     VT_SHARED_NAME = 6", "   };", "-  const flatbuffers::String *container() const {", "-    return GetPointer<const flatbuffers::String *>(VT_CONTAINER);", "+  const ::flatbuffers::String *container() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_CONTAINER);", "   }", "-  const flatbuffers::String *shared_name() const {", "-    return GetPointer<const flatbuffers::String *>(VT_SHARED_NAME);", "+  const ::flatbuffers::String *shared_name() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_SHARED_NAME);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_CONTAINER) &&", "            verifier.VerifyString(container()) &&", "@@ -11011,44 +11018,44 @@ struct VarHandleOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            verifier.VerifyString(shared_name()) &&", "            verifier.EndTable();", "   }", "-  VarHandleOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(VarHandleOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<VarHandleOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  VarHandleOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(VarHandleOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<VarHandleOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct VarHandleOptionsBuilder {", "   typedef VarHandleOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_container(flatbuffers::Offset<flatbuffers::String> container) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_container(::flatbuffers::Offset<::flatbuffers::String> container) {", "     fbb_.AddOffset(VarHandleOptions::VT_CONTAINER, container);", "   }", "-  void add_shared_name(flatbuffers::Offset<flatbuffers::String> shared_name) {", "+  void add_shared_name(::flatbuffers::Offset<::flatbuffers::String> shared_name) {", "     fbb_.AddOffset(VarHandleOptions::VT_SHARED_NAME, shared_name);", "   }", "-  explicit VarHandleOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit VarHandleOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<VarHandleOptions> Finish() {", "+  ::flatbuffers::Offset<VarHandleOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<VarHandleOptions>(end);", "+    auto o = ::flatbuffers::Offset<VarHandleOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::String> container = 0,", "-    flatbuffers::Offset<flatbuffers::String> shared_name = 0) {", "+inline ::flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::String> container = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> shared_name = 0) {", "   VarHandleOptionsBuilder builder_(_fbb);", "   builder_.add_shared_name(shared_name);", "   builder_.add_container(container);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptionsDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptionsDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const char *container = nullptr,", "     const char *shared_name = nullptr) {", "   auto container__ = container ? _fbb.CreateString(container) : 0;", "@@ -11059,93 +11066,93 @@ inline flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptionsDirect(", "       shared_name__);", " }", " ", "-flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptions(flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptions(::flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ReadVariableOptionsT : public flatbuffers::NativeTable {", "+struct ReadVariableOptionsT : public ::flatbuffers::NativeTable {", "   typedef ReadVariableOptions TableType;", " };", " ", "-struct ReadVariableOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ReadVariableOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ReadVariableOptionsT NativeTableType;", "   typedef ReadVariableOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  ReadVariableOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ReadVariableOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ReadVariableOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ReadVariableOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ReadVariableOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ReadVariableOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ReadVariableOptionsBuilder {", "   typedef ReadVariableOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit ReadVariableOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit ReadVariableOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ReadVariableOptions> Finish() {", "+  ::flatbuffers::Offset<ReadVariableOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ReadVariableOptions>(end);", "+    auto o = ::flatbuffers::Offset<ReadVariableOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ReadVariableOptions> CreateReadVariableOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<ReadVariableOptions> CreateReadVariableOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   ReadVariableOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<ReadVariableOptions> CreateReadVariableOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ReadVariableOptions> CreateReadVariableOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct AssignVariableOptionsT : public flatbuffers::NativeTable {", "+struct AssignVariableOptionsT : public ::flatbuffers::NativeTable {", "   typedef AssignVariableOptions TableType;", " };", " ", "-struct AssignVariableOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct AssignVariableOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef AssignVariableOptionsT NativeTableType;", "   typedef AssignVariableOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  AssignVariableOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(AssignVariableOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<AssignVariableOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  AssignVariableOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(AssignVariableOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<AssignVariableOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct AssignVariableOptionsBuilder {", "   typedef AssignVariableOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit AssignVariableOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit AssignVariableOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<AssignVariableOptions> Finish() {", "+  ::flatbuffers::Offset<AssignVariableOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<AssignVariableOptions>(end);", "+    auto o = ::flatbuffers::Offset<AssignVariableOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<AssignVariableOptions> CreateAssignVariableOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<AssignVariableOptions> CreateAssignVariableOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   AssignVariableOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<AssignVariableOptions> CreateAssignVariableOptions(flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<AssignVariableOptions> CreateAssignVariableOptions(::flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct RandomOptionsT : public flatbuffers::NativeTable {", "+struct RandomOptionsT : public ::flatbuffers::NativeTable {", "   typedef RandomOptions TableType;", "   int64_t seed = 0;", "   int64_t seed2 = 0;", " };", " ", "-struct RandomOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct RandomOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef RandomOptionsT NativeTableType;", "   typedef RandomOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -11158,40 +11165,40 @@ struct RandomOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int64_t seed2() const {", "     return GetField<int64_t>(VT_SEED2, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int64_t>(verifier, VT_SEED, 8) &&", "            VerifyField<int64_t>(verifier, VT_SEED2, 8) &&", "            verifier.EndTable();", "   }", "-  RandomOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(RandomOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<RandomOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  RandomOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(RandomOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<RandomOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct RandomOptionsBuilder {", "   typedef RandomOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_seed(int64_t seed) {", "     fbb_.AddElement<int64_t>(RandomOptions::VT_SEED, seed, 0);", "   }", "   void add_seed2(int64_t seed2) {", "     fbb_.AddElement<int64_t>(RandomOptions::VT_SEED2, seed2, 0);", "   }", "-  explicit RandomOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit RandomOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<RandomOptions> Finish() {", "+  ::flatbuffers::Offset<RandomOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<RandomOptions>(end);", "+    auto o = ::flatbuffers::Offset<RandomOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<RandomOptions> CreateRandomOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<RandomOptions> CreateRandomOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int64_t seed = 0,", "     int64_t seed2 = 0) {", "   RandomOptionsBuilder builder_(_fbb);", "@@ -11200,61 +11207,61 @@ inline flatbuffers::Offset<RandomOptions> CreateRandomOptions(", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<RandomOptions> CreateRandomOptions(flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<RandomOptions> CreateRandomOptions(::flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct BucketizeOptionsT : public flatbuffers::NativeTable {", "+struct BucketizeOptionsT : public ::flatbuffers::NativeTable {", "   typedef BucketizeOptions TableType;", "   std::vector<float> boundaries{};", " };", " ", "-struct BucketizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct BucketizeOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef BucketizeOptionsT NativeTableType;", "   typedef BucketizeOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_BOUNDARIES = 4", "   };", "-  const flatbuffers::Vector<float> *boundaries() const {", "-    return GetPointer<const flatbuffers::Vector<float> *>(VT_BOUNDARIES);", "+  const ::flatbuffers::Vector<float> *boundaries() const {", "+    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_BOUNDARIES);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_BOUNDARIES) &&", "            verifier.VerifyVector(boundaries()) &&", "            verifier.EndTable();", "   }", "-  BucketizeOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(BucketizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<BucketizeOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BucketizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  BucketizeOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(BucketizeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<BucketizeOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BucketizeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct BucketizeOptionsBuilder {", "   typedef BucketizeOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_boundaries(flatbuffers::Offset<flatbuffers::Vector<float>> boundaries) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_boundaries(::flatbuffers::Offset<::flatbuffers::Vector<float>> boundaries) {", "     fbb_.AddOffset(BucketizeOptions::VT_BOUNDARIES, boundaries);", "   }", "-  explicit BucketizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit BucketizeOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<BucketizeOptions> Finish() {", "+  ::flatbuffers::Offset<BucketizeOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<BucketizeOptions>(end);", "+    auto o = ::flatbuffers::Offset<BucketizeOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<float>> boundaries = 0) {", "+inline ::flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<float>> boundaries = 0) {", "   BucketizeOptionsBuilder builder_(_fbb);", "   builder_.add_boundaries(boundaries);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptionsDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptionsDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const std::vector<float> *boundaries = nullptr) {", "   auto boundaries__ = boundaries ? _fbb.CreateVector<float>(*boundaries) : 0;", "   return tflite::CreateBucketizeOptions(", "@@ -11262,14 +11269,14 @@ inline flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptionsDirect(", "       boundaries__);", " }", " ", "-flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const BucketizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BucketizeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct GeluOptionsT : public flatbuffers::NativeTable {", "+struct GeluOptionsT : public ::flatbuffers::NativeTable {", "   typedef GeluOptions TableType;", "   bool approximate = false;", " };", " ", "-struct GeluOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct GeluOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef GeluOptionsT NativeTableType;", "   typedef GeluOptionsBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -11278,357 +11285,357 @@ struct GeluOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   bool approximate() const {", "     return GetField<uint8_t>(VT_APPROXIMATE, 0) != 0;", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<uint8_t>(verifier, VT_APPROXIMATE, 1) &&", "            verifier.EndTable();", "   }", "-  GeluOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(GeluOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<GeluOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeluOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  GeluOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(GeluOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<GeluOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeluOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct GeluOptionsBuilder {", "   typedef GeluOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_approximate(bool approximate) {", "     fbb_.AddElement<uint8_t>(GeluOptions::VT_APPROXIMATE, static_cast<uint8_t>(approximate), 0);", "   }", "-  explicit GeluOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit GeluOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<GeluOptions> Finish() {", "+  ::flatbuffers::Offset<GeluOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<GeluOptions>(end);", "+    auto o = ::flatbuffers::Offset<GeluOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<GeluOptions> CreateGeluOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<GeluOptions> CreateGeluOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     bool approximate = false) {", "   GeluOptionsBuilder builder_(_fbb);", "   builder_.add_approximate(approximate);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<GeluOptions> CreateGeluOptions(flatbuffers::FlatBufferBuilder &_fbb, const GeluOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<GeluOptions> CreateGeluOptions(::flatbuffers::FlatBufferBuilder &_fbb, const GeluOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct DynamicUpdateSliceOptionsT : public flatbuffers::NativeTable {", "+struct DynamicUpdateSliceOptionsT : public ::flatbuffers::NativeTable {", "   typedef DynamicUpdateSliceOptions TableType;", " };", " ", "-struct DynamicUpdateSliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct DynamicUpdateSliceOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef DynamicUpdateSliceOptionsT NativeTableType;", "   typedef DynamicUpdateSliceOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  DynamicUpdateSliceOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(DynamicUpdateSliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<DynamicUpdateSliceOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DynamicUpdateSliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  DynamicUpdateSliceOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(DynamicUpdateSliceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<DynamicUpdateSliceOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DynamicUpdateSliceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct DynamicUpdateSliceOptionsBuilder {", "   typedef DynamicUpdateSliceOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit DynamicUpdateSliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit DynamicUpdateSliceOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<DynamicUpdateSliceOptions> Finish() {", "+  ::flatbuffers::Offset<DynamicUpdateSliceOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<DynamicUpdateSliceOptions>(end);", "+    auto o = ::flatbuffers::Offset<DynamicUpdateSliceOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<DynamicUpdateSliceOptions> CreateDynamicUpdateSliceOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<DynamicUpdateSliceOptions> CreateDynamicUpdateSliceOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   DynamicUpdateSliceOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<DynamicUpdateSliceOptions> CreateDynamicUpdateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const DynamicUpdateSliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<DynamicUpdateSliceOptions> CreateDynamicUpdateSliceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DynamicUpdateSliceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct UnsortedSegmentProdOptionsT : public flatbuffers::NativeTable {", "+struct UnsortedSegmentProdOptionsT : public ::flatbuffers::NativeTable {", "   typedef UnsortedSegmentProdOptions TableType;", " };", " ", "-struct UnsortedSegmentProdOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct UnsortedSegmentProdOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef UnsortedSegmentProdOptionsT NativeTableType;", "   typedef UnsortedSegmentProdOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  UnsortedSegmentProdOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(UnsortedSegmentProdOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<UnsortedSegmentProdOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentProdOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  UnsortedSegmentProdOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(UnsortedSegmentProdOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<UnsortedSegmentProdOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentProdOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct UnsortedSegmentProdOptionsBuilder {", "   typedef UnsortedSegmentProdOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit UnsortedSegmentProdOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit UnsortedSegmentProdOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<UnsortedSegmentProdOptions> Finish() {", "+  ::flatbuffers::Offset<UnsortedSegmentProdOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<UnsortedSegmentProdOptions>(end);", "+    auto o = ::flatbuffers::Offset<UnsortedSegmentProdOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<UnsortedSegmentProdOptions> CreateUnsortedSegmentProdOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<UnsortedSegmentProdOptions> CreateUnsortedSegmentProdOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   UnsortedSegmentProdOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<UnsortedSegmentProdOptions> CreateUnsortedSegmentProdOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentProdOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<UnsortedSegmentProdOptions> CreateUnsortedSegmentProdOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentProdOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct UnsortedSegmentMaxOptionsT : public flatbuffers::NativeTable {", "+struct UnsortedSegmentMaxOptionsT : public ::flatbuffers::NativeTable {", "   typedef UnsortedSegmentMaxOptions TableType;", " };", " ", "-struct UnsortedSegmentMaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct UnsortedSegmentMaxOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef UnsortedSegmentMaxOptionsT NativeTableType;", "   typedef UnsortedSegmentMaxOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  UnsortedSegmentMaxOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(UnsortedSegmentMaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<UnsortedSegmentMaxOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  UnsortedSegmentMaxOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(UnsortedSegmentMaxOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<UnsortedSegmentMaxOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMaxOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct UnsortedSegmentMaxOptionsBuilder {", "   typedef UnsortedSegmentMaxOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit UnsortedSegmentMaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit UnsortedSegmentMaxOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<UnsortedSegmentMaxOptions> Finish() {", "+  ::flatbuffers::Offset<UnsortedSegmentMaxOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<UnsortedSegmentMaxOptions>(end);", "+    auto o = ::flatbuffers::Offset<UnsortedSegmentMaxOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<UnsortedSegmentMaxOptions> CreateUnsortedSegmentMaxOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<UnsortedSegmentMaxOptions> CreateUnsortedSegmentMaxOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   UnsortedSegmentMaxOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<UnsortedSegmentMaxOptions> CreateUnsortedSegmentMaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<UnsortedSegmentMaxOptions> CreateUnsortedSegmentMaxOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMaxOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct UnsortedSegmentSumOptionsT : public flatbuffers::NativeTable {", "+struct UnsortedSegmentSumOptionsT : public ::flatbuffers::NativeTable {", "   typedef UnsortedSegmentSumOptions TableType;", " };", " ", "-struct UnsortedSegmentSumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct UnsortedSegmentSumOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef UnsortedSegmentSumOptionsT NativeTableType;", "   typedef UnsortedSegmentSumOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  UnsortedSegmentSumOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(UnsortedSegmentSumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<UnsortedSegmentSumOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  UnsortedSegmentSumOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(UnsortedSegmentSumOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<UnsortedSegmentSumOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct UnsortedSegmentSumOptionsBuilder {", "   typedef UnsortedSegmentSumOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit UnsortedSegmentSumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit UnsortedSegmentSumOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<UnsortedSegmentSumOptions> Finish() {", "+  ::flatbuffers::Offset<UnsortedSegmentSumOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<UnsortedSegmentSumOptions>(end);", "+    auto o = ::flatbuffers::Offset<UnsortedSegmentSumOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<UnsortedSegmentSumOptions> CreateUnsortedSegmentSumOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<UnsortedSegmentSumOptions> CreateUnsortedSegmentSumOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   UnsortedSegmentSumOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<UnsortedSegmentSumOptions> CreateUnsortedSegmentSumOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<UnsortedSegmentSumOptions> CreateUnsortedSegmentSumOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ATan2OptionsT : public flatbuffers::NativeTable {", "+struct ATan2OptionsT : public ::flatbuffers::NativeTable {", "   typedef ATan2Options TableType;", " };", " ", "-struct ATan2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct ATan2Options FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ATan2OptionsT NativeTableType;", "   typedef ATan2OptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  ATan2OptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ATan2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<ATan2Options> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ATan2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ATan2OptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ATan2OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<ATan2Options> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ATan2OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ATan2OptionsBuilder {", "   typedef ATan2Options Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit ATan2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit ATan2OptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<ATan2Options> Finish() {", "+  ::flatbuffers::Offset<ATan2Options> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<ATan2Options>(end);", "+    auto o = ::flatbuffers::Offset<ATan2Options>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<ATan2Options> CreateATan2Options(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<ATan2Options> CreateATan2Options(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   ATan2OptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<ATan2Options> CreateATan2Options(flatbuffers::FlatBufferBuilder &_fbb, const ATan2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<ATan2Options> CreateATan2Options(::flatbuffers::FlatBufferBuilder &_fbb, const ATan2OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct UnsortedSegmentMinOptionsT : public flatbuffers::NativeTable {", "+struct UnsortedSegmentMinOptionsT : public ::flatbuffers::NativeTable {", "   typedef UnsortedSegmentMinOptions TableType;", " };", " ", "-struct UnsortedSegmentMinOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct UnsortedSegmentMinOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef UnsortedSegmentMinOptionsT NativeTableType;", "   typedef UnsortedSegmentMinOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  UnsortedSegmentMinOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(UnsortedSegmentMinOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<UnsortedSegmentMinOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMinOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  UnsortedSegmentMinOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(UnsortedSegmentMinOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<UnsortedSegmentMinOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMinOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct UnsortedSegmentMinOptionsBuilder {", "   typedef UnsortedSegmentMinOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit UnsortedSegmentMinOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit UnsortedSegmentMinOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<UnsortedSegmentMinOptions> Finish() {", "+  ::flatbuffers::Offset<UnsortedSegmentMinOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<UnsortedSegmentMinOptions>(end);", "+    auto o = ::flatbuffers::Offset<UnsortedSegmentMinOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<UnsortedSegmentMinOptions> CreateUnsortedSegmentMinOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<UnsortedSegmentMinOptions> CreateUnsortedSegmentMinOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   UnsortedSegmentMinOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<UnsortedSegmentMinOptions> CreateUnsortedSegmentMinOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMinOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<UnsortedSegmentMinOptions> CreateUnsortedSegmentMinOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMinOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SignOptionsT : public flatbuffers::NativeTable {", "+struct SignOptionsT : public ::flatbuffers::NativeTable {", "   typedef SignOptions TableType;", " };", " ", "-struct SignOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SignOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SignOptionsT NativeTableType;", "   typedef SignOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  SignOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SignOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SignOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SignOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SignOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SignOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SignOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SignOptionsBuilder {", "   typedef SignOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit SignOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit SignOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SignOptions> Finish() {", "+  ::flatbuffers::Offset<SignOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SignOptions>(end);", "+    auto o = ::flatbuffers::Offset<SignOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SignOptions> CreateSignOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<SignOptions> CreateSignOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   SignOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<SignOptions> CreateSignOptions(flatbuffers::FlatBufferBuilder &_fbb, const SignOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SignOptions> CreateSignOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SignOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct BitcastOptionsT : public flatbuffers::NativeTable {", "+struct BitcastOptionsT : public ::flatbuffers::NativeTable {", "   typedef BitcastOptions TableType;", " };", " ", "-struct BitcastOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct BitcastOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef BitcastOptionsT NativeTableType;", "   typedef BitcastOptionsBuilder Builder;", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            verifier.EndTable();", "   }", "-  BitcastOptionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(BitcastOptionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<BitcastOptions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BitcastOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  BitcastOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(BitcastOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<BitcastOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BitcastOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct BitcastOptionsBuilder {", "   typedef BitcastOptions Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  explicit BitcastOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  explicit BitcastOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<BitcastOptions> Finish() {", "+  ::flatbuffers::Offset<BitcastOptions> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<BitcastOptions>(end);", "+    auto o = ::flatbuffers::Offset<BitcastOptions>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<BitcastOptions> CreateBitcastOptions(", "-    flatbuffers::FlatBufferBuilder &_fbb) {", "+inline ::flatbuffers::Offset<BitcastOptions> CreateBitcastOptions(", "+    ::flatbuffers::FlatBufferBuilder &_fbb) {", "   BitcastOptionsBuilder builder_(_fbb);", "   return builder_.Finish();", " }", " ", "-flatbuffers::Offset<BitcastOptions> CreateBitcastOptions(flatbuffers::FlatBufferBuilder &_fbb, const BitcastOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<BitcastOptions> CreateBitcastOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BitcastOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct OperatorCodeT : public flatbuffers::NativeTable {", "+struct OperatorCodeT : public ::flatbuffers::NativeTable {", "   typedef OperatorCode TableType;", "   int8_t deprecated_builtin_code = 0;", "   std::string custom_code{};", "@@ -11636,7 +11643,7 @@ struct OperatorCodeT : public flatbuffers::NativeTable {", "   tflite::BuiltinOperator builtin_code = tflite::BuiltinOperator_ADD;", " };", " ", "-struct OperatorCode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct OperatorCode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef OperatorCodeT NativeTableType;", "   typedef OperatorCodeBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -11648,8 +11655,8 @@ struct OperatorCode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   int8_t deprecated_builtin_code() const {", "     return GetField<int8_t>(VT_DEPRECATED_BUILTIN_CODE, 0);", "   }", "-  const flatbuffers::String *custom_code() const {", "-    return GetPointer<const flatbuffers::String *>(VT_CUSTOM_CODE);", "+  const ::flatbuffers::String *custom_code() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_CUSTOM_CODE);", "   }", "   int32_t version() const {", "     return GetField<int32_t>(VT_VERSION, 1);", "@@ -11657,7 +11664,7 @@ struct OperatorCode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   tflite::BuiltinOperator builtin_code() const {", "     return static_cast<tflite::BuiltinOperator>(GetField<int32_t>(VT_BUILTIN_CODE, 0));", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<int8_t>(verifier, VT_DEPRECATED_BUILTIN_CODE, 1) &&", "            VerifyOffset(verifier, VT_CUSTOM_CODE) &&", "@@ -11666,19 +11673,19 @@ struct OperatorCode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            VerifyField<int32_t>(verifier, VT_BUILTIN_CODE, 4) &&", "            verifier.EndTable();", "   }", "-  OperatorCodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(OperatorCodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<OperatorCode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  OperatorCodeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(OperatorCodeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<OperatorCode> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct OperatorCodeBuilder {", "   typedef OperatorCode Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_deprecated_builtin_code(int8_t deprecated_builtin_code) {", "     fbb_.AddElement<int8_t>(OperatorCode::VT_DEPRECATED_BUILTIN_CODE, deprecated_builtin_code, 0);", "   }", "-  void add_custom_code(flatbuffers::Offset<flatbuffers::String> custom_code) {", "+  void add_custom_code(::flatbuffers::Offset<::flatbuffers::String> custom_code) {", "     fbb_.AddOffset(OperatorCode::VT_CUSTOM_CODE, custom_code);", "   }", "   void add_version(int32_t version) {", "@@ -11687,21 +11694,21 @@ struct OperatorCodeBuilder {", "   void add_builtin_code(tflite::BuiltinOperator builtin_code) {", "     fbb_.AddElement<int32_t>(OperatorCode::VT_BUILTIN_CODE, static_cast<int32_t>(builtin_code), 0);", "   }", "-  explicit OperatorCodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit OperatorCodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<OperatorCode> Finish() {", "+  ::flatbuffers::Offset<OperatorCode> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<OperatorCode>(end);", "+    auto o = ::flatbuffers::Offset<OperatorCode>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<OperatorCode> CreateOperatorCode(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<OperatorCode> CreateOperatorCode(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int8_t deprecated_builtin_code = 0,", "-    flatbuffers::Offset<flatbuffers::String> custom_code = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> custom_code = 0,", "     int32_t version = 1,", "     tflite::BuiltinOperator builtin_code = tflite::BuiltinOperator_ADD) {", "   OperatorCodeBuilder builder_(_fbb);", "@@ -11712,8 +11719,8 @@ inline flatbuffers::Offset<OperatorCode> CreateOperatorCode(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<OperatorCode> CreateOperatorCodeDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<OperatorCode> CreateOperatorCodeDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     int8_t deprecated_builtin_code = 0,", "     const char *custom_code = nullptr,", "     int32_t version = 1,", "@@ -11727,9 +11734,9 @@ inline flatbuffers::Offset<OperatorCode> CreateOperatorCodeDirect(", "       builtin_code);", " }", " ", "-flatbuffers::Offset<OperatorCode> CreateOperatorCode(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<OperatorCode> CreateOperatorCode(::flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct OperatorT : public flatbuffers::NativeTable {", "+struct OperatorT : public ::flatbuffers::NativeTable {", "   typedef Operator TableType;", "   uint32_t opcode_index = 0;", "   std::vector<int32_t> inputs{};", "@@ -11741,7 +11748,7 @@ struct OperatorT : public flatbuffers::NativeTable {", "   std::vector<int32_t> intermediates{};", " };", " ", "-struct Operator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct Operator FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef OperatorT NativeTableType;", "   typedef OperatorBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -11758,11 +11765,11 @@ struct Operator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   uint32_t opcode_index() const {", "     return GetField<uint32_t>(VT_OPCODE_INDEX, 0);", "   }", "-  const flatbuffers::Vector<int32_t> *inputs() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTS);", "+  const ::flatbuffers::Vector<int32_t> *inputs() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INPUTS);", "   }", "-  const flatbuffers::Vector<int32_t> *outputs() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);", "+  const ::flatbuffers::Vector<int32_t> *outputs() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);", "   }", "   tflite::BuiltinOptions builtin_options_type() const {", "     return static_cast<tflite::BuiltinOptions>(GetField<uint8_t>(VT_BUILTIN_OPTIONS_TYPE, 0));", "@@ -12143,19 +12150,19 @@ struct Operator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   const tflite::BitcastOptions *builtin_options_as_BitcastOptions() const {", "     return builtin_options_type() == tflite::BuiltinOptions_BitcastOptions ? static_cast<const tflite::BitcastOptions *>(builtin_options()) : nullptr;", "   }", "-  const flatbuffers::Vector<uint8_t> *custom_options() const {", "-    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CUSTOM_OPTIONS);", "+  const ::flatbuffers::Vector<uint8_t> *custom_options() const {", "+    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CUSTOM_OPTIONS);", "   }", "   tflite::CustomOptionsFormat custom_options_format() const {", "     return static_cast<tflite::CustomOptionsFormat>(GetField<int8_t>(VT_CUSTOM_OPTIONS_FORMAT, 0));", "   }", "-  const flatbuffers::Vector<uint8_t> *mutating_variable_inputs() const {", "-    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MUTATING_VARIABLE_INPUTS);", "+  const ::flatbuffers::Vector<uint8_t> *mutating_variable_inputs() const {", "+    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_MUTATING_VARIABLE_INPUTS);", "   }", "-  const flatbuffers::Vector<int32_t> *intermediates() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INTERMEDIATES);", "+  const ::flatbuffers::Vector<int32_t> *intermediates() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INTERMEDIATES);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<uint32_t>(verifier, VT_OPCODE_INDEX, 4) &&", "            VerifyOffset(verifier, VT_INPUTS) &&", "@@ -12174,9 +12181,9 @@ struct Operator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            verifier.VerifyVector(intermediates()) &&", "            verifier.EndTable();", "   }", "-  OperatorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(OperatorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<Operator> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  OperatorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(OperatorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<Operator> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OperatorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " template<> inline const tflite::Conv2DOptions *Operator::builtin_options_as<tflite::Conv2DOptions>() const {", "@@ -12677,57 +12684,57 @@ template<> inline const tflite::BitcastOptions *Operator::builtin_options_as<tfl", " ", " struct OperatorBuilder {", "   typedef Operator Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_opcode_index(uint32_t opcode_index) {", "     fbb_.AddElement<uint32_t>(Operator::VT_OPCODE_INDEX, opcode_index, 0);", "   }", "-  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {", "+  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs) {", "     fbb_.AddOffset(Operator::VT_INPUTS, inputs);", "   }", "-  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {", "+  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs) {", "     fbb_.AddOffset(Operator::VT_OUTPUTS, outputs);", "   }", "   void add_builtin_options_type(tflite::BuiltinOptions builtin_options_type) {", "     fbb_.AddElement<uint8_t>(Operator::VT_BUILTIN_OPTIONS_TYPE, static_cast<uint8_t>(builtin_options_type), 0);", "   }", "-  void add_builtin_options(flatbuffers::Offset<void> builtin_options) {", "+  void add_builtin_options(::flatbuffers::Offset<void> builtin_options) {", "     fbb_.AddOffset(Operator::VT_BUILTIN_OPTIONS, builtin_options);", "   }", "-  void add_custom_options(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_options) {", "+  void add_custom_options(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> custom_options) {", "     fbb_.AddOffset(Operator::VT_CUSTOM_OPTIONS, custom_options);", "   }", "   void add_custom_options_format(tflite::CustomOptionsFormat custom_options_format) {", "     fbb_.AddElement<int8_t>(Operator::VT_CUSTOM_OPTIONS_FORMAT, static_cast<int8_t>(custom_options_format), 0);", "   }", "-  void add_mutating_variable_inputs(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mutating_variable_inputs) {", "+  void add_mutating_variable_inputs(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> mutating_variable_inputs) {", "     fbb_.AddOffset(Operator::VT_MUTATING_VARIABLE_INPUTS, mutating_variable_inputs);", "   }", "-  void add_intermediates(flatbuffers::Offset<flatbuffers::Vector<int32_t>> intermediates) {", "+  void add_intermediates(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> intermediates) {", "     fbb_.AddOffset(Operator::VT_INTERMEDIATES, intermediates);", "   }", "-  explicit OperatorBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit OperatorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<Operator> Finish() {", "+  ::flatbuffers::Offset<Operator> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<Operator>(end);", "+    auto o = ::flatbuffers::Offset<Operator>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<Operator> CreateOperator(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<Operator> CreateOperator(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     uint32_t opcode_index = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs = 0,", "     tflite::BuiltinOptions builtin_options_type = tflite::BuiltinOptions_NONE,", "-    flatbuffers::Offset<void> builtin_options = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_options = 0,", "+    ::flatbuffers::Offset<void> builtin_options = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> custom_options = 0,", "     tflite::CustomOptionsFormat custom_options_format = tflite::CustomOptionsFormat_FLEXBUFFERS,", "-    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mutating_variable_inputs = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> intermediates = 0) {", "+    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> mutating_variable_inputs = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> intermediates = 0) {", "   OperatorBuilder builder_(_fbb);", "   builder_.add_intermediates(intermediates);", "   builder_.add_mutating_variable_inputs(mutating_variable_inputs);", "@@ -12741,13 +12748,13 @@ inline flatbuffers::Offset<Operator> CreateOperator(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<Operator> CreateOperatorDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<Operator> CreateOperatorDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     uint32_t opcode_index = 0,", "     const std::vector<int32_t> *inputs = nullptr,", "     const std::vector<int32_t> *outputs = nullptr,", "     tflite::BuiltinOptions builtin_options_type = tflite::BuiltinOptions_NONE,", "-    flatbuffers::Offset<void> builtin_options = 0,", "+    ::flatbuffers::Offset<void> builtin_options = 0,", "     const std::vector<uint8_t> *custom_options = nullptr,", "     tflite::CustomOptionsFormat custom_options_format = tflite::CustomOptionsFormat_FLEXBUFFERS,", "     const std::vector<uint8_t> *mutating_variable_inputs = nullptr,", "@@ -12770,9 +12777,9 @@ inline flatbuffers::Offset<Operator> CreateOperatorDirect(", "       intermediates__);", " }", " ", "-flatbuffers::Offset<Operator> CreateOperator(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<Operator> CreateOperator(::flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SubGraphT : public flatbuffers::NativeTable {", "+struct SubGraphT : public ::flatbuffers::NativeTable {", "   typedef SubGraph TableType;", "   std::vector<std::unique_ptr<tflite::TensorT>> tensors{};", "   std::vector<int32_t> inputs{};", "@@ -12785,7 +12792,7 @@ struct SubGraphT : public flatbuffers::NativeTable {", "   SubGraphT &operator=(SubGraphT o) FLATBUFFERS_NOEXCEPT;", " };", " ", "-struct SubGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SubGraph FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SubGraphT NativeTableType;", "   typedef SubGraphBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -12795,22 +12802,22 @@ struct SubGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "     VT_OPERATORS = 10,", "     VT_NAME = 12", "   };", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>> *tensors() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>> *>(VT_TENSORS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::Tensor>> *tensors() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::Tensor>> *>(VT_TENSORS);", "   }", "-  const flatbuffers::Vector<int32_t> *inputs() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTS);", "+  const ::flatbuffers::Vector<int32_t> *inputs() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INPUTS);", "   }", "-  const flatbuffers::Vector<int32_t> *outputs() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);", "+  const ::flatbuffers::Vector<int32_t> *outputs() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>> *operators() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>> *>(VT_OPERATORS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::Operator>> *operators() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::Operator>> *>(VT_OPERATORS);", "   }", "-  const flatbuffers::String *name() const {", "-    return GetPointer<const flatbuffers::String *>(VT_NAME);", "+  const ::flatbuffers::String *name() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_NAME);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_TENSORS) &&", "            verifier.VerifyVector(tensors()) &&", "@@ -12826,48 +12833,48 @@ struct SubGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            verifier.VerifyString(name()) &&", "            verifier.EndTable();", "   }", "-  SubGraphT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SubGraphT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SubGraph> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SubGraphT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SubGraphT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SubGraph> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SubGraphBuilder {", "   typedef SubGraph Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>>> tensors) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_tensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::Tensor>>> tensors) {", "     fbb_.AddOffset(SubGraph::VT_TENSORS, tensors);", "   }", "-  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {", "+  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs) {", "     fbb_.AddOffset(SubGraph::VT_INPUTS, inputs);", "   }", "-  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {", "+  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs) {", "     fbb_.AddOffset(SubGraph::VT_OUTPUTS, outputs);", "   }", "-  void add_operators(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>>> operators) {", "+  void add_operators(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::Operator>>> operators) {", "     fbb_.AddOffset(SubGraph::VT_OPERATORS, operators);", "   }", "-  void add_name(flatbuffers::Offset<flatbuffers::String> name) {", "+  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {", "     fbb_.AddOffset(SubGraph::VT_NAME, name);", "   }", "-  explicit SubGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit SubGraphBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SubGraph> Finish() {", "+  ::flatbuffers::Offset<SubGraph> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SubGraph>(end);", "+    auto o = ::flatbuffers::Offset<SubGraph>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SubGraph> CreateSubGraph(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>>> tensors = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>>> operators = 0,", "-    flatbuffers::Offset<flatbuffers::String> name = 0) {", "+inline ::flatbuffers::Offset<SubGraph> CreateSubGraph(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::Tensor>>> tensors = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::Operator>>> operators = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {", "   SubGraphBuilder builder_(_fbb);", "   builder_.add_name(name);", "   builder_.add_operators(operators);", "@@ -12877,17 +12884,17 @@ inline flatbuffers::Offset<SubGraph> CreateSubGraph(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<SubGraph> CreateSubGraphDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    const std::vector<flatbuffers::Offset<tflite::Tensor>> *tensors = nullptr,", "+inline ::flatbuffers::Offset<SubGraph> CreateSubGraphDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    const std::vector<::flatbuffers::Offset<tflite::Tensor>> *tensors = nullptr,", "     const std::vector<int32_t> *inputs = nullptr,", "     const std::vector<int32_t> *outputs = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::Operator>> *operators = nullptr,", "+    const std::vector<::flatbuffers::Offset<tflite::Operator>> *operators = nullptr,", "     const char *name = nullptr) {", "-  auto tensors__ = tensors ? _fbb.CreateVector<flatbuffers::Offset<tflite::Tensor>>(*tensors) : 0;", "+  auto tensors__ = tensors ? _fbb.CreateVector<::flatbuffers::Offset<tflite::Tensor>>(*tensors) : 0;", "   auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;", "   auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;", "-  auto operators__ = operators ? _fbb.CreateVector<flatbuffers::Offset<tflite::Operator>>(*operators) : 0;", "+  auto operators__ = operators ? _fbb.CreateVector<::flatbuffers::Offset<tflite::Operator>>(*operators) : 0;", "   auto name__ = name ? _fbb.CreateString(name) : 0;", "   return tflite::CreateSubGraph(", "       _fbb,", "@@ -12898,61 +12905,61 @@ inline flatbuffers::Offset<SubGraph> CreateSubGraphDirect(", "       name__);", " }", " ", "-flatbuffers::Offset<SubGraph> CreateSubGraph(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SubGraph> CreateSubGraph(::flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct BufferT : public flatbuffers::NativeTable {", "+struct BufferT : public ::flatbuffers::NativeTable {", "   typedef Buffer TableType;", "   std::vector<uint8_t> data{};", " };", " ", "-struct Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct Buffer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef BufferT NativeTableType;", "   typedef BufferBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_DATA = 4", "   };", "-  const flatbuffers::Vector<uint8_t> *data() const {", "-    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);", "+  const ::flatbuffers::Vector<uint8_t> *data() const {", "+    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_DATA) &&", "            verifier.VerifyVector(data()) &&", "            verifier.EndTable();", "   }", "-  BufferT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(BufferT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<Buffer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BufferT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  BufferT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(BufferT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<Buffer> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BufferT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct BufferBuilder {", "   typedef Buffer Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {", "     fbb_.AddOffset(Buffer::VT_DATA, data);", "   }", "-  explicit BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit BufferBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<Buffer> Finish() {", "+  ::flatbuffers::Offset<Buffer> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<Buffer>(end);", "+    auto o = ::flatbuffers::Offset<Buffer>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<Buffer> CreateBuffer(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {", "+inline ::flatbuffers::Offset<Buffer> CreateBuffer(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {", "   BufferBuilder builder_(_fbb);", "   builder_.add_data(data);", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<Buffer> CreateBufferDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<Buffer> CreateBufferDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const std::vector<uint8_t> *data = nullptr) {", "   if (data) { _fbb.ForceVectorAlignment(data->size(), sizeof(uint8_t), 16); }", "   auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;", "@@ -12961,63 +12968,63 @@ inline flatbuffers::Offset<Buffer> CreateBufferDirect(", "       data__);", " }", " ", "-flatbuffers::Offset<Buffer> CreateBuffer(flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<Buffer> CreateBuffer(::flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct MetadataT : public flatbuffers::NativeTable {", "+struct MetadataT : public ::flatbuffers::NativeTable {", "   typedef Metadata TableType;", "   std::string name{};", "   uint32_t buffer = 0;", " };", " ", "-struct Metadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct Metadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef MetadataT NativeTableType;", "   typedef MetadataBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_NAME = 4,", "     VT_BUFFER = 6", "   };", "-  const flatbuffers::String *name() const {", "-    return GetPointer<const flatbuffers::String *>(VT_NAME);", "+  const ::flatbuffers::String *name() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_NAME);", "   }", "   uint32_t buffer() const {", "     return GetField<uint32_t>(VT_BUFFER, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_NAME) &&", "            verifier.VerifyString(name()) &&", "            VerifyField<uint32_t>(verifier, VT_BUFFER, 4) &&", "            verifier.EndTable();", "   }", "-  MetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(MetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<Metadata> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  MetadataT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(MetadataT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<Metadata> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MetadataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct MetadataBuilder {", "   typedef Metadata Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_name(flatbuffers::Offset<flatbuffers::String> name) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {", "     fbb_.AddOffset(Metadata::VT_NAME, name);", "   }", "   void add_buffer(uint32_t buffer) {", "     fbb_.AddElement<uint32_t>(Metadata::VT_BUFFER, buffer, 0);", "   }", "-  explicit MetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit MetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<Metadata> Finish() {", "+  ::flatbuffers::Offset<Metadata> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<Metadata>(end);", "+    auto o = ::flatbuffers::Offset<Metadata>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<Metadata> CreateMetadata(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::String> name = 0,", "+inline ::flatbuffers::Offset<Metadata> CreateMetadata(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::String> name = 0,", "     uint32_t buffer = 0) {", "   MetadataBuilder builder_(_fbb);", "   builder_.add_buffer(buffer);", "@@ -13025,8 +13032,8 @@ inline flatbuffers::Offset<Metadata> CreateMetadata(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<Metadata> CreateMetadataDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<Metadata> CreateMetadataDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const char *name = nullptr,", "     uint32_t buffer = 0) {", "   auto name__ = name ? _fbb.CreateString(name) : 0;", "@@ -13036,63 +13043,63 @@ inline flatbuffers::Offset<Metadata> CreateMetadataDirect(", "       buffer);", " }", " ", "-flatbuffers::Offset<Metadata> CreateMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<Metadata> CreateMetadata(::flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct TensorMapT : public flatbuffers::NativeTable {", "+struct TensorMapT : public ::flatbuffers::NativeTable {", "   typedef TensorMap TableType;", "   std::string name{};", "   uint32_t tensor_index = 0;", " };", " ", "-struct TensorMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct TensorMap FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef TensorMapT NativeTableType;", "   typedef TensorMapBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "     VT_NAME = 4,", "     VT_TENSOR_INDEX = 6", "   };", "-  const flatbuffers::String *name() const {", "-    return GetPointer<const flatbuffers::String *>(VT_NAME);", "+  const ::flatbuffers::String *name() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_NAME);", "   }", "   uint32_t tensor_index() const {", "     return GetField<uint32_t>(VT_TENSOR_INDEX, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_NAME) &&", "            verifier.VerifyString(name()) &&", "            VerifyField<uint32_t>(verifier, VT_TENSOR_INDEX, 4) &&", "            verifier.EndTable();", "   }", "-  TensorMapT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(TensorMapT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<TensorMap> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  TensorMapT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(TensorMapT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<TensorMap> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct TensorMapBuilder {", "   typedef TensorMap Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_name(flatbuffers::Offset<flatbuffers::String> name) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {", "     fbb_.AddOffset(TensorMap::VT_NAME, name);", "   }", "   void add_tensor_index(uint32_t tensor_index) {", "     fbb_.AddElement<uint32_t>(TensorMap::VT_TENSOR_INDEX, tensor_index, 0);", "   }", "-  explicit TensorMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit TensorMapBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<TensorMap> Finish() {", "+  ::flatbuffers::Offset<TensorMap> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<TensorMap>(end);", "+    auto o = ::flatbuffers::Offset<TensorMap>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<TensorMap> CreateTensorMap(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::String> name = 0,", "+inline ::flatbuffers::Offset<TensorMap> CreateTensorMap(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::String> name = 0,", "     uint32_t tensor_index = 0) {", "   TensorMapBuilder builder_(_fbb);", "   builder_.add_tensor_index(tensor_index);", "@@ -13100,8 +13107,8 @@ inline flatbuffers::Offset<TensorMap> CreateTensorMap(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<TensorMap> CreateTensorMapDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<TensorMap> CreateTensorMapDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     const char *name = nullptr,", "     uint32_t tensor_index = 0) {", "   auto name__ = name ? _fbb.CreateString(name) : 0;", "@@ -13111,9 +13118,9 @@ inline flatbuffers::Offset<TensorMap> CreateTensorMapDirect(", "       tensor_index);", " }", " ", "-flatbuffers::Offset<TensorMap> CreateTensorMap(flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<TensorMap> CreateTensorMap(::flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct SignatureDefT : public flatbuffers::NativeTable {", "+struct SignatureDefT : public ::flatbuffers::NativeTable {", "   typedef SignatureDef TableType;", "   std::vector<std::unique_ptr<tflite::TensorMapT>> inputs{};", "   std::vector<std::unique_ptr<tflite::TensorMapT>> outputs{};", "@@ -13125,7 +13132,7 @@ struct SignatureDefT : public flatbuffers::NativeTable {", "   SignatureDefT &operator=(SignatureDefT o) FLATBUFFERS_NOEXCEPT;", " };", " ", "-struct SignatureDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct SignatureDef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef SignatureDefT NativeTableType;", "   typedef SignatureDefBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -13134,19 +13141,19 @@ struct SignatureDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "     VT_SIGNATURE_KEY = 8,", "     VT_SUBGRAPH_INDEX = 12", "   };", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>> *inputs() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>> *>(VT_INPUTS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMap>> *inputs() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMap>> *>(VT_INPUTS);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>> *outputs() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>> *>(VT_OUTPUTS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMap>> *outputs() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMap>> *>(VT_OUTPUTS);", "   }", "-  const flatbuffers::String *signature_key() const {", "-    return GetPointer<const flatbuffers::String *>(VT_SIGNATURE_KEY);", "+  const ::flatbuffers::String *signature_key() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_SIGNATURE_KEY);", "   }", "   uint32_t subgraph_index() const {", "     return GetField<uint32_t>(VT_SUBGRAPH_INDEX, 0);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyOffset(verifier, VT_INPUTS) &&", "            verifier.VerifyVector(inputs()) &&", "@@ -13159,43 +13166,43 @@ struct SignatureDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            VerifyField<uint32_t>(verifier, VT_SUBGRAPH_INDEX, 4) &&", "            verifier.EndTable();", "   }", "-  SignatureDefT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(SignatureDefT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<SignatureDef> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  SignatureDefT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(SignatureDefT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<SignatureDef> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct SignatureDefBuilder {", "   typedef SignatureDef Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "-  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>>> inputs) {", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "+  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMap>>> inputs) {", "     fbb_.AddOffset(SignatureDef::VT_INPUTS, inputs);", "   }", "-  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>>> outputs) {", "+  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMap>>> outputs) {", "     fbb_.AddOffset(SignatureDef::VT_OUTPUTS, outputs);", "   }", "-  void add_signature_key(flatbuffers::Offset<flatbuffers::String> signature_key) {", "+  void add_signature_key(::flatbuffers::Offset<::flatbuffers::String> signature_key) {", "     fbb_.AddOffset(SignatureDef::VT_SIGNATURE_KEY, signature_key);", "   }", "   void add_subgraph_index(uint32_t subgraph_index) {", "     fbb_.AddElement<uint32_t>(SignatureDef::VT_SUBGRAPH_INDEX, subgraph_index, 0);", "   }", "-  explicit SignatureDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit SignatureDefBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<SignatureDef> Finish() {", "+  ::flatbuffers::Offset<SignatureDef> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<SignatureDef>(end);", "+    auto o = ::flatbuffers::Offset<SignatureDef>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<SignatureDef> CreateSignatureDef(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>>> inputs = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>>> outputs = 0,", "-    flatbuffers::Offset<flatbuffers::String> signature_key = 0,", "+inline ::flatbuffers::Offset<SignatureDef> CreateSignatureDef(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMap>>> inputs = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::TensorMap>>> outputs = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> signature_key = 0,", "     uint32_t subgraph_index = 0) {", "   SignatureDefBuilder builder_(_fbb);", "   builder_.add_subgraph_index(subgraph_index);", "@@ -13205,14 +13212,14 @@ inline flatbuffers::Offset<SignatureDef> CreateSignatureDef(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<SignatureDef> CreateSignatureDefDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "-    const std::vector<flatbuffers::Offset<tflite::TensorMap>> *inputs = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::TensorMap>> *outputs = nullptr,", "+inline ::flatbuffers::Offset<SignatureDef> CreateSignatureDefDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "+    const std::vector<::flatbuffers::Offset<tflite::TensorMap>> *inputs = nullptr,", "+    const std::vector<::flatbuffers::Offset<tflite::TensorMap>> *outputs = nullptr,", "     const char *signature_key = nullptr,", "     uint32_t subgraph_index = 0) {", "-  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<tflite::TensorMap>>(*inputs) : 0;", "-  auto outputs__ = outputs ? _fbb.CreateVector<flatbuffers::Offset<tflite::TensorMap>>(*outputs) : 0;", "+  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<tflite::TensorMap>>(*inputs) : 0;", "+  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<tflite::TensorMap>>(*outputs) : 0;", "   auto signature_key__ = signature_key ? _fbb.CreateString(signature_key) : 0;", "   return tflite::CreateSignatureDef(", "       _fbb,", "@@ -13222,9 +13229,9 @@ inline flatbuffers::Offset<SignatureDef> CreateSignatureDefDirect(", "       subgraph_index);", " }", " ", "-flatbuffers::Offset<SignatureDef> CreateSignatureDef(flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<SignatureDef> CreateSignatureDef(::flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-struct ModelT : public flatbuffers::NativeTable {", "+struct ModelT : public ::flatbuffers::NativeTable {", "   typedef Model TableType;", "   uint32_t version = 0;", "   std::vector<std::unique_ptr<tflite::OperatorCodeT>> operator_codes{};", "@@ -13240,7 +13247,7 @@ struct ModelT : public flatbuffers::NativeTable {", "   ModelT &operator=(ModelT o) FLATBUFFERS_NOEXCEPT;", " };", " ", "-struct Model FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "+struct Model FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {", "   typedef ModelT NativeTableType;", "   typedef ModelBuilder Builder;", "   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {", "@@ -13256,28 +13263,28 @@ struct Model FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "   uint32_t version() const {", "     return GetField<uint32_t>(VT_VERSION, 0);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>> *operator_codes() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>> *>(VT_OPERATOR_CODES);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::OperatorCode>> *operator_codes() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::OperatorCode>> *>(VT_OPERATOR_CODES);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>> *subgraphs() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>> *>(VT_SUBGRAPHS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::SubGraph>> *subgraphs() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::SubGraph>> *>(VT_SUBGRAPHS);", "   }", "-  const flatbuffers::String *description() const {", "-    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);", "+  const ::flatbuffers::String *description() const {", "+    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>> *buffers() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>> *>(VT_BUFFERS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::Buffer>> *buffers() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::Buffer>> *>(VT_BUFFERS);", "   }", "-  const flatbuffers::Vector<int32_t> *metadata_buffer() const {", "-    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_METADATA_BUFFER);", "+  const ::flatbuffers::Vector<int32_t> *metadata_buffer() const {", "+    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_METADATA_BUFFER);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::Metadata>> *metadata() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::Metadata>> *>(VT_METADATA);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::Metadata>> *metadata() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::Metadata>> *>(VT_METADATA);", "   }", "-  const flatbuffers::Vector<flatbuffers::Offset<tflite::SignatureDef>> *signature_defs() const {", "-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<tflite::SignatureDef>> *>(VT_SIGNATURE_DEFS);", "+  const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::SignatureDef>> *signature_defs() const {", "+    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tflite::SignatureDef>> *>(VT_SIGNATURE_DEFS);", "   }", "-  bool Verify(flatbuffers::Verifier &verifier) const {", "+  bool Verify(::flatbuffers::Verifier &verifier) const {", "     return VerifyTableStart(verifier) &&", "            VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&", "            VerifyOffset(verifier, VT_OPERATOR_CODES) &&", "@@ -13301,60 +13308,60 @@ struct Model FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {", "            verifier.VerifyVectorOfTables(signature_defs()) &&", "            verifier.EndTable();", "   }", "-  ModelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  void UnPackTo(ModelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;", "-  static flatbuffers::Offset<Model> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+  ModelT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  void UnPackTo(ModelT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;", "+  static ::flatbuffers::Offset<Model> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ModelT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " };", " ", " struct ModelBuilder {", "   typedef Model Table;", "-  flatbuffers::FlatBufferBuilder &fbb_;", "-  flatbuffers::uoffset_t start_;", "+  ::flatbuffers::FlatBufferBuilder &fbb_;", "+  ::flatbuffers::uoffset_t start_;", "   void add_version(uint32_t version) {", "     fbb_.AddElement<uint32_t>(Model::VT_VERSION, version, 0);", "   }", "-  void add_operator_codes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>>> operator_codes) {", "+  void add_operator_codes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::OperatorCode>>> operator_codes) {", "     fbb_.AddOffset(Model::VT_OPERATOR_CODES, operator_codes);", "   }", "-  void add_subgraphs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>>> subgraphs) {", "+  void add_subgraphs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::SubGraph>>> subgraphs) {", "     fbb_.AddOffset(Model::VT_SUBGRAPHS, subgraphs);", "   }", "-  void add_description(flatbuffers::Offset<flatbuffers::String> description) {", "+  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {", "     fbb_.AddOffset(Model::VT_DESCRIPTION, description);", "   }", "-  void add_buffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>>> buffers) {", "+  void add_buffers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::Buffer>>> buffers) {", "     fbb_.AddOffset(Model::VT_BUFFERS, buffers);", "   }", "-  void add_metadata_buffer(flatbuffers::Offset<flatbuffers::Vector<int32_t>> metadata_buffer) {", "+  void add_metadata_buffer(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> metadata_buffer) {", "     fbb_.AddOffset(Model::VT_METADATA_BUFFER, metadata_buffer);", "   }", "-  void add_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Metadata>>> metadata) {", "+  void add_metadata(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::Metadata>>> metadata) {", "     fbb_.AddOffset(Model::VT_METADATA, metadata);", "   }", "-  void add_signature_defs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::SignatureDef>>> signature_defs) {", "+  void add_signature_defs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::SignatureDef>>> signature_defs) {", "     fbb_.AddOffset(Model::VT_SIGNATURE_DEFS, signature_defs);", "   }", "-  explicit ModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)", "+  explicit ModelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)", "         : fbb_(_fbb) {", "     start_ = fbb_.StartTable();", "   }", "-  flatbuffers::Offset<Model> Finish() {", "+  ::flatbuffers::Offset<Model> Finish() {", "     const auto end = fbb_.EndTable(start_);", "-    auto o = flatbuffers::Offset<Model>(end);", "+    auto o = ::flatbuffers::Offset<Model>(end);", "     return o;", "   }", " };", " ", "-inline flatbuffers::Offset<Model> CreateModel(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<Model> CreateModel(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     uint32_t version = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>>> operator_codes = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>>> subgraphs = 0,", "-    flatbuffers::Offset<flatbuffers::String> description = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>>> buffers = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<int32_t>> metadata_buffer = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::Metadata>>> metadata = 0,", "-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<tflite::SignatureDef>>> signature_defs = 0) {", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::OperatorCode>>> operator_codes = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::SubGraph>>> subgraphs = 0,", "+    ::flatbuffers::Offset<::flatbuffers::String> description = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::Buffer>>> buffers = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> metadata_buffer = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::Metadata>>> metadata = 0,", "+    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tflite::SignatureDef>>> signature_defs = 0) {", "   ModelBuilder builder_(_fbb);", "   builder_.add_signature_defs(signature_defs);", "   builder_.add_metadata(metadata);", "@@ -13367,23 +13374,23 @@ inline flatbuffers::Offset<Model> CreateModel(", "   return builder_.Finish();", " }", " ", "-inline flatbuffers::Offset<Model> CreateModelDirect(", "-    flatbuffers::FlatBufferBuilder &_fbb,", "+inline ::flatbuffers::Offset<Model> CreateModelDirect(", "+    ::flatbuffers::FlatBufferBuilder &_fbb,", "     uint32_t version = 0,", "-    const std::vector<flatbuffers::Offset<tflite::OperatorCode>> *operator_codes = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::SubGraph>> *subgraphs = nullptr,", "+    const std::vector<::flatbuffers::Offset<tflite::OperatorCode>> *operator_codes = nullptr,", "+    const std::vector<::flatbuffers::Offset<tflite::SubGraph>> *subgraphs = nullptr,", "     const char *description = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::Buffer>> *buffers = nullptr,", "+    const std::vector<::flatbuffers::Offset<tflite::Buffer>> *buffers = nullptr,", "     const std::vector<int32_t> *metadata_buffer = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::Metadata>> *metadata = nullptr,", "-    const std::vector<flatbuffers::Offset<tflite::SignatureDef>> *signature_defs = nullptr) {", "-  auto operator_codes__ = operator_codes ? _fbb.CreateVector<flatbuffers::Offset<tflite::OperatorCode>>(*operator_codes) : 0;", "-  auto subgraphs__ = subgraphs ? _fbb.CreateVector<flatbuffers::Offset<tflite::SubGraph>>(*subgraphs) : 0;", "+    const std::vector<::flatbuffers::Offset<tflite::Metadata>> *metadata = nullptr,", "+    const std::vector<::flatbuffers::Offset<tflite::SignatureDef>> *signature_defs = nullptr) {", "+  auto operator_codes__ = operator_codes ? _fbb.CreateVector<::flatbuffers::Offset<tflite::OperatorCode>>(*operator_codes) : 0;", "+  auto subgraphs__ = subgraphs ? _fbb.CreateVector<::flatbuffers::Offset<tflite::SubGraph>>(*subgraphs) : 0;", "   auto description__ = description ? _fbb.CreateString(description) : 0;", "-  auto buffers__ = buffers ? _fbb.CreateVector<flatbuffers::Offset<tflite::Buffer>>(*buffers) : 0;", "+  auto buffers__ = buffers ? _fbb.CreateVector<::flatbuffers::Offset<tflite::Buffer>>(*buffers) : 0;", "   auto metadata_buffer__ = metadata_buffer ? _fbb.CreateVector<int32_t>(*metadata_buffer) : 0;", "-  auto metadata__ = metadata ? _fbb.CreateVector<flatbuffers::Offset<tflite::Metadata>>(*metadata) : 0;", "-  auto signature_defs__ = signature_defs ? _fbb.CreateVector<flatbuffers::Offset<tflite::SignatureDef>>(*signature_defs) : 0;", "+  auto metadata__ = metadata ? _fbb.CreateVector<::flatbuffers::Offset<tflite::Metadata>>(*metadata) : 0;", "+  auto signature_defs__ = signature_defs ? _fbb.CreateVector<::flatbuffers::Offset<tflite::SignatureDef>>(*signature_defs) : 0;", "   return tflite::CreateModel(", "       _fbb,", "       version,", "@@ -13396,28 +13403,28 @@ inline flatbuffers::Offset<Model> CreateModelDirect(", "       signature_defs__);", " }", " ", "-flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);", "+::flatbuffers::Offset<Model> CreateModel(::flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);", " ", "-inline CustomQuantizationT *CustomQuantization::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline CustomQuantizationT *CustomQuantization::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<CustomQuantizationT>(new CustomQuantizationT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void CustomQuantization::UnPackTo(CustomQuantizationT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void CustomQuantization::UnPackTo(CustomQuantizationT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = custom(); if (_e) { _o->custom.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->custom.begin()); } }", " }", " ", "-inline flatbuffers::Offset<CustomQuantization> CustomQuantization::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<CustomQuantization> CustomQuantization::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateCustomQuantization(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(::flatbuffers::FlatBufferBuilder &_fbb, const CustomQuantizationT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CustomQuantizationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CustomQuantizationT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   _fbb.ForceVectorAlignment(_o->custom.size(), sizeof(uint8_t), 16);", "   auto _custom = _o->custom.size() ? _fbb.CreateVector(_o->custom) : 0;", "   return tflite::CreateCustomQuantization(", "@@ -13425,32 +13432,32 @@ inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(flatbuff", "       _custom);", " }", " ", "-inline QuantizationParametersT *QuantizationParameters::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline QuantizationParametersT *QuantizationParameters::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<QuantizationParametersT>(new QuantizationParametersT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void QuantizationParameters::UnPackTo(QuantizationParametersT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void QuantizationParameters::UnPackTo(QuantizationParametersT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "-  { auto _e = min(); if (_e) { _o->min.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->min[_i] = _e->Get(_i); } } }", "-  { auto _e = max(); if (_e) { _o->max.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->max[_i] = _e->Get(_i); } } }", "-  { auto _e = scale(); if (_e) { _o->scale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scale[_i] = _e->Get(_i); } } }", "-  { auto _e = zero_point(); if (_e) { _o->zero_point.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->zero_point[_i] = _e->Get(_i); } } }", "+  { auto _e = min(); if (_e) { _o->min.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->min[_i] = _e->Get(_i); } } else { _o->min.resize(0); } }", "+  { auto _e = max(); if (_e) { _o->max.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->max[_i] = _e->Get(_i); } } else { _o->max.resize(0); } }", "+  { auto _e = scale(); if (_e) { _o->scale.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scale[_i] = _e->Get(_i); } } else { _o->scale.resize(0); } }", "+  { auto _e = zero_point(); if (_e) { _o->zero_point.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->zero_point[_i] = _e->Get(_i); } } else { _o->zero_point.resize(0); } }", "   { auto _e = details_type(); _o->details.type = _e; }", "   { auto _e = details(); if (_e) _o->details.value = tflite::QuantizationDetailsUnion::UnPack(_e, details_type(), _resolver); }", "   { auto _e = quantized_dimension(); _o->quantized_dimension = _e; }", " }", " ", "-inline flatbuffers::Offset<QuantizationParameters> QuantizationParameters::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<QuantizationParameters> QuantizationParameters::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateQuantizationParameters(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(::flatbuffers::FlatBufferBuilder &_fbb, const QuantizationParametersT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuantizationParametersT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const QuantizationParametersT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _min = _o->min.size() ? _fbb.CreateVector(_o->min) : 0;", "   auto _max = _o->max.size() ? _fbb.CreateVector(_o->max) : 0;", "   auto _scale = _o->scale.size() ? _fbb.CreateVector(_o->scale) : 0;", "@@ -13469,52 +13476,52 @@ inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(", "       _quantized_dimension);", " }", " ", "-inline Int32VectorT *Int32Vector::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline Int32VectorT *Int32Vector::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<Int32VectorT>(new Int32VectorT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void Int32Vector::UnPackTo(Int32VectorT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void Int32Vector::UnPackTo(Int32VectorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "-  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } }", "+  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } else { _o->values.resize(0); } }", " }", " ", "-inline flatbuffers::Offset<Int32Vector> Int32Vector::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Int32Vector> Int32Vector::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateInt32Vector(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<Int32Vector> CreateInt32Vector(flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Int32Vector> CreateInt32Vector(::flatbuffers::FlatBufferBuilder &_fbb, const Int32VectorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Int32VectorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Int32VectorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;", "   return tflite::CreateInt32Vector(", "       _fbb,", "       _values);", " }", " ", "-inline Uint16VectorT *Uint16Vector::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline Uint16VectorT *Uint16Vector::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<Uint16VectorT>(new Uint16VectorT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void Uint16Vector::UnPackTo(Uint16VectorT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void Uint16Vector::UnPackTo(Uint16VectorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "-  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } }", "+  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } else { _o->values.resize(0); } }", " }", " ", "-inline flatbuffers::Offset<Uint16Vector> Uint16Vector::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Uint16Vector> Uint16Vector::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateUint16Vector(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<Uint16Vector> CreateUint16Vector(flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Uint16Vector> CreateUint16Vector(::flatbuffers::FlatBufferBuilder &_fbb, const Uint16VectorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Uint16VectorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Uint16VectorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   _fbb.ForceVectorAlignment(_o->values.size(), sizeof(uint16_t), 4);", "   auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;", "   return tflite::CreateUint16Vector(", "@@ -13522,26 +13529,26 @@ inline flatbuffers::Offset<Uint16Vector> CreateUint16Vector(flatbuffers::FlatBuf", "       _values);", " }", " ", "-inline Uint8VectorT *Uint8Vector::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline Uint8VectorT *Uint8Vector::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<Uint8VectorT>(new Uint8VectorT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void Uint8Vector::UnPackTo(Uint8VectorT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void Uint8Vector::UnPackTo(Uint8VectorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = values(); if (_e) { _o->values.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->values.begin()); } }", " }", " ", "-inline flatbuffers::Offset<Uint8Vector> Uint8Vector::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Uint8Vector> Uint8Vector::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateUint8Vector(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<Uint8Vector> CreateUint8Vector(flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Uint8Vector> CreateUint8Vector(::flatbuffers::FlatBufferBuilder &_fbb, const Uint8VectorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Uint8VectorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Uint8VectorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   _fbb.ForceVectorAlignment(_o->values.size(), sizeof(uint8_t), 4);", "   auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;", "   return tflite::CreateUint8Vector(", "@@ -13549,13 +13556,13 @@ inline flatbuffers::Offset<Uint8Vector> CreateUint8Vector(flatbuffers::FlatBuffe", "       _values);", " }", " ", "-inline DimensionMetadataT *DimensionMetadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline DimensionMetadataT *DimensionMetadata::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<DimensionMetadataT>(new DimensionMetadataT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void DimensionMetadata::UnPackTo(DimensionMetadataT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void DimensionMetadata::UnPackTo(DimensionMetadataT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = format(); _o->format = _e; }", "@@ -13566,14 +13573,14 @@ inline void DimensionMetadata::UnPackTo(DimensionMetadataT *_o, const flatbuffer", "   { auto _e = array_indices(); if (_e) _o->array_indices.value = tflite::SparseIndexVectorUnion::UnPack(_e, array_indices_type(), _resolver); }", " }", " ", "-inline flatbuffers::Offset<DimensionMetadata> DimensionMetadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<DimensionMetadata> DimensionMetadata::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateDimensionMetadata(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(::flatbuffers::FlatBufferBuilder &_fbb, const DimensionMetadataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DimensionMetadataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DimensionMetadataT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _format = _o->format;", "   auto _dense_size = _o->dense_size;", "   auto _array_segments_type = _o->array_segments.type;", "@@ -13594,7 +13601,7 @@ inline SparsityParametersT::SparsityParametersT(const SparsityParametersT &o)", "       : traversal_order(o.traversal_order),", "         block_map(o.block_map) {", "   dim_metadata.reserve(o.dim_metadata.size());", "-  for (const auto &v : o.dim_metadata) { dim_metadata.emplace_back((v) ? new tflite::DimensionMetadataT(*v) : nullptr); }", "+  for (const auto &dim_metadata_ : o.dim_metadata) { dim_metadata.emplace_back((dim_metadata_) ? new tflite::DimensionMetadataT(*dim_metadata_) : nullptr); }", " }", " ", " inline SparsityParametersT &SparsityParametersT::operator=(SparsityParametersT o) FLATBUFFERS_NOEXCEPT {", "@@ -13604,31 +13611,31 @@ inline SparsityParametersT &SparsityParametersT::operator=(SparsityParametersT o", "   return *this;", " }", " ", "-inline SparsityParametersT *SparsityParameters::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SparsityParametersT *SparsityParameters::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SparsityParametersT>(new SparsityParametersT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SparsityParameters::UnPackTo(SparsityParametersT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SparsityParameters::UnPackTo(SparsityParametersT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "-  { auto _e = traversal_order(); if (_e) { _o->traversal_order.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->traversal_order[_i] = _e->Get(_i); } } }", "-  { auto _e = block_map(); if (_e) { _o->block_map.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->block_map[_i] = _e->Get(_i); } } }", "-  { auto _e = dim_metadata(); if (_e) { _o->dim_metadata.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->dim_metadata[_i]) { _e->Get(_i)->UnPackTo(_o->dim_metadata[_i].get(), _resolver); } else { _o->dim_metadata[_i] = std::unique_ptr<tflite::DimensionMetadataT>(_e->Get(_i)->UnPack(_resolver)); }; } } }", "+  { auto _e = traversal_order(); if (_e) { _o->traversal_order.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->traversal_order[_i] = _e->Get(_i); } } else { _o->traversal_order.resize(0); } }", "+  { auto _e = block_map(); if (_e) { _o->block_map.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->block_map[_i] = _e->Get(_i); } } else { _o->block_map.resize(0); } }", "+  { auto _e = dim_metadata(); if (_e) { _o->dim_metadata.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->dim_metadata[_i]) { _e->Get(_i)->UnPackTo(_o->dim_metadata[_i].get(), _resolver); } else { _o->dim_metadata[_i] = std::unique_ptr<tflite::DimensionMetadataT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->dim_metadata.resize(0); } }", " }", " ", "-inline flatbuffers::Offset<SparsityParameters> SparsityParameters::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SparsityParameters> SparsityParameters::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSparsityParameters(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(::flatbuffers::FlatBufferBuilder &_fbb, const SparsityParametersT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SparsityParametersT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SparsityParametersT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _traversal_order = _o->traversal_order.size() ? _fbb.CreateVector(_o->traversal_order) : 0;", "   auto _block_map = _o->block_map.size() ? _fbb.CreateVector(_o->block_map) : 0;", "-  auto _dim_metadata = _o->dim_metadata.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::DimensionMetadata>> (_o->dim_metadata.size(), [](size_t i, _VectorArgs *__va) { return CreateDimensionMetadata(*__va->__fbb, __va->__o->dim_metadata[i].get(), __va->__rehasher); }, &_va ) : 0;", "+  auto _dim_metadata = _o->dim_metadata.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::DimensionMetadata>> (_o->dim_metadata.size(), [](size_t i, _VectorArgs *__va) { return CreateDimensionMetadata(*__va->__fbb, __va->__o->dim_metadata[i].get(), __va->__rehasher); }, &_va ) : 0;", "   return tflite::CreateSparsityParameters(", "       _fbb,", "       _traversal_order,", "@@ -13636,28 +13643,28 @@ inline flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(flatbuff", "       _dim_metadata);", " }", " ", "-inline VariantSubTypeT *VariantSubType::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline VariantSubTypeT *VariantSubType::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<VariantSubTypeT>(new VariantSubTypeT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void VariantSubType::UnPackTo(VariantSubTypeT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void VariantSubType::UnPackTo(VariantSubTypeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "-  { auto _e = shape(); if (_e) { _o->shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape[_i] = _e->Get(_i); } } }", "+  { auto _e = shape(); if (_e) { _o->shape.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape[_i] = _e->Get(_i); } } else { _o->shape.resize(0); } }", "   { auto _e = type(); _o->type = _e; }", "   { auto _e = has_rank(); _o->has_rank = _e; }", " }", " ", "-inline flatbuffers::Offset<VariantSubType> VariantSubType::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VariantSubTypeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<VariantSubType> VariantSubType::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VariantSubTypeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateVariantSubType(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<VariantSubType> CreateVariantSubType(flatbuffers::FlatBufferBuilder &_fbb, const VariantSubTypeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<VariantSubType> CreateVariantSubType(::flatbuffers::FlatBufferBuilder &_fbb, const VariantSubTypeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VariantSubTypeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const VariantSubTypeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _shape = _o->shape.size() ? _fbb.CreateVector(_o->shape) : 0;", "   auto _type = _o->type;", "   auto _has_rank = _o->has_rank;", "@@ -13679,7 +13686,7 @@ inline TensorT::TensorT(const TensorT &o)", "         shape_signature(o.shape_signature),", "         has_rank(o.has_rank) {", "   variant_tensors.reserve(o.variant_tensors.size());", "-  for (const auto &v : o.variant_tensors) { variant_tensors.emplace_back((v) ? new tflite::VariantSubTypeT(*v) : nullptr); }", "+  for (const auto &variant_tensors_ : o.variant_tensors) { variant_tensors.emplace_back((variant_tensors_) ? new tflite::VariantSubTypeT(*variant_tensors_) : nullptr); }", " }", " ", " inline TensorT &TensorT::operator=(TensorT o) FLATBUFFERS_NOEXCEPT {", "@@ -13696,35 +13703,35 @@ inline TensorT &TensorT::operator=(TensorT o) FLATBUFFERS_NOEXCEPT {", "   return *this;", " }", " ", "-inline TensorT *Tensor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline TensorT *Tensor::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<TensorT>(new TensorT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void Tensor::UnPackTo(TensorT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void Tensor::UnPackTo(TensorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "-  { auto _e = shape(); if (_e) { _o->shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape[_i] = _e->Get(_i); } } }", "+  { auto _e = shape(); if (_e) { _o->shape.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape[_i] = _e->Get(_i); } } else { _o->shape.resize(0); } }", "   { auto _e = type(); _o->type = _e; }", "   { auto _e = buffer(); _o->buffer = _e; }", "   { auto _e = name(); if (_e) _o->name = _e->str(); }", "-  { auto _e = quantization(); if (_e) { if(_o->quantization) { _e->UnPackTo(_o->quantization.get(), _resolver); } else { _o->quantization = std::unique_ptr<tflite::QuantizationParametersT>(_e->UnPack(_resolver)); } } }", "+  { auto _e = quantization(); if (_e) { if(_o->quantization) { _e->UnPackTo(_o->quantization.get(), _resolver); } else { _o->quantization = std::unique_ptr<tflite::QuantizationParametersT>(_e->UnPack(_resolver)); } } else if (_o->quantization) { _o->quantization.reset(); } }", "   { auto _e = is_variable(); _o->is_variable = _e; }", "-  { auto _e = sparsity(); if (_e) { if(_o->sparsity) { _e->UnPackTo(_o->sparsity.get(), _resolver); } else { _o->sparsity = std::unique_ptr<tflite::SparsityParametersT>(_e->UnPack(_resolver)); } } }", "-  { auto _e = shape_signature(); if (_e) { _o->shape_signature.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape_signature[_i] = _e->Get(_i); } } }", "+  { auto _e = sparsity(); if (_e) { if(_o->sparsity) { _e->UnPackTo(_o->sparsity.get(), _resolver); } else { _o->sparsity = std::unique_ptr<tflite::SparsityParametersT>(_e->UnPack(_resolver)); } } else if (_o->sparsity) { _o->sparsity.reset(); } }", "+  { auto _e = shape_signature(); if (_e) { _o->shape_signature.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape_signature[_i] = _e->Get(_i); } } else { _o->shape_signature.resize(0); } }", "   { auto _e = has_rank(); _o->has_rank = _e; }", "-  { auto _e = variant_tensors(); if (_e) { _o->variant_tensors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->variant_tensors[_i]) { _e->Get(_i)->UnPackTo(_o->variant_tensors[_i].get(), _resolver); } else { _o->variant_tensors[_i] = std::unique_ptr<tflite::VariantSubTypeT>(_e->Get(_i)->UnPack(_resolver)); }; } } }", "+  { auto _e = variant_tensors(); if (_e) { _o->variant_tensors.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->variant_tensors[_i]) { _e->Get(_i)->UnPackTo(_o->variant_tensors[_i].get(), _resolver); } else { _o->variant_tensors[_i] = std::unique_ptr<tflite::VariantSubTypeT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->variant_tensors.resize(0); } }", " }", " ", "-inline flatbuffers::Offset<Tensor> Tensor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Tensor> Tensor::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TensorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateTensor(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Tensor> CreateTensor(::flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TensorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _shape = _o->shape.size() ? _fbb.CreateVector(_o->shape) : 0;", "   auto _type = _o->type;", "   auto _buffer = _o->buffer;", "@@ -13734,7 +13741,7 @@ inline flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &", "   auto _sparsity = _o->sparsity ? CreateSparsityParameters(_fbb, _o->sparsity.get(), _rehasher) : 0;", "   auto _shape_signature = _o->shape_signature.size() ? _fbb.CreateVector(_o->shape_signature) : 0;", "   auto _has_rank = _o->has_rank;", "-  auto _variant_tensors = _o->variant_tensors.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::VariantSubType>> (_o->variant_tensors.size(), [](size_t i, _VectorArgs *__va) { return CreateVariantSubType(*__va->__fbb, __va->__o->variant_tensors[i].get(), __va->__rehasher); }, &_va ) : 0;", "+  auto _variant_tensors = _o->variant_tensors.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::VariantSubType>> (_o->variant_tensors.size(), [](size_t i, _VectorArgs *__va) { return CreateVariantSubType(*__va->__fbb, __va->__o->variant_tensors[i].get(), __va->__rehasher); }, &_va ) : 0;", "   return tflite::CreateTensor(", "       _fbb,", "       _shape,", "@@ -13749,13 +13756,13 @@ inline flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &", "       _variant_tensors);", " }", " ", "-inline Conv2DOptionsT *Conv2DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline Conv2DOptionsT *Conv2DOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<Conv2DOptionsT>(new Conv2DOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void Conv2DOptions::UnPackTo(Conv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void Conv2DOptions::UnPackTo(Conv2DOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = padding(); _o->padding = _e; }", "@@ -13766,14 +13773,14 @@ inline void Conv2DOptions::UnPackTo(Conv2DOptionsT *_o, const flatbuffers::resol", "   { auto _e = dilation_h_factor(); _o->dilation_h_factor = _e; }", " }", " ", "-inline flatbuffers::Offset<Conv2DOptions> Conv2DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Conv2DOptions> Conv2DOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateConv2DOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(::flatbuffers::FlatBufferBuilder &_fbb, const Conv2DOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv2DOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Conv2DOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _padding = _o->padding;", "   auto _stride_w = _o->stride_w;", "   auto _stride_h = _o->stride_h;", "@@ -13790,13 +13797,13 @@ inline flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(flatbuffers::FlatB", "       _dilation_h_factor);", " }", " ", "-inline Conv3DOptionsT *Conv3DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline Conv3DOptionsT *Conv3DOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<Conv3DOptionsT>(new Conv3DOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void Conv3DOptions::UnPackTo(Conv3DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void Conv3DOptions::UnPackTo(Conv3DOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = padding(); _o->padding = _e; }", "@@ -13809,14 +13816,14 @@ inline void Conv3DOptions::UnPackTo(Conv3DOptionsT *_o, const flatbuffers::resol", "   { auto _e = dilation_h_factor(); _o->dilation_h_factor = _e; }", " }", " ", "-inline flatbuffers::Offset<Conv3DOptions> Conv3DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Conv3DOptions> Conv3DOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateConv3DOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(::flatbuffers::FlatBufferBuilder &_fbb, const Conv3DOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv3DOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Conv3DOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _padding = _o->padding;", "   auto _stride_d = _o->stride_d;", "   auto _stride_w = _o->stride_w;", "@@ -13837,13 +13844,13 @@ inline flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(flatbuffers::FlatB", "       _dilation_h_factor);", " }", " ", "-inline Pool2DOptionsT *Pool2DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline Pool2DOptionsT *Pool2DOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<Pool2DOptionsT>(new Pool2DOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void Pool2DOptions::UnPackTo(Pool2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void Pool2DOptions::UnPackTo(Pool2DOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = padding(); _o->padding = _e; }", "@@ -13854,14 +13861,14 @@ inline void Pool2DOptions::UnPackTo(Pool2DOptionsT *_o, const flatbuffers::resol", "   { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }", " }", " ", "-inline flatbuffers::Offset<Pool2DOptions> Pool2DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Pool2DOptions> Pool2DOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreatePool2DOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(::flatbuffers::FlatBufferBuilder &_fbb, const Pool2DOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Pool2DOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Pool2DOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _padding = _o->padding;", "   auto _stride_w = _o->stride_w;", "   auto _stride_h = _o->stride_h;", "@@ -13878,13 +13885,13 @@ inline flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(flatbuffers::FlatB", "       _fused_activation_function);", " }", " ", "-inline DepthwiseConv2DOptionsT *DepthwiseConv2DOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline DepthwiseConv2DOptionsT *DepthwiseConv2DOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<DepthwiseConv2DOptionsT>(new DepthwiseConv2DOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void DepthwiseConv2DOptions::UnPackTo(DepthwiseConv2DOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void DepthwiseConv2DOptions::UnPackTo(DepthwiseConv2DOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = padding(); _o->padding = _e; }", "@@ -13896,14 +13903,14 @@ inline void DepthwiseConv2DOptions::UnPackTo(DepthwiseConv2DOptionsT *_o, const", "   { auto _e = dilation_h_factor(); _o->dilation_h_factor = _e; }", " }", " ", "-inline flatbuffers::Offset<DepthwiseConv2DOptions> DepthwiseConv2DOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<DepthwiseConv2DOptions> DepthwiseConv2DOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateDepthwiseConv2DOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DepthwiseConv2DOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DepthwiseConv2DOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _padding = _o->padding;", "   auto _stride_w = _o->stride_w;", "   auto _stride_h = _o->stride_h;", "@@ -13922,28 +13929,28 @@ inline flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(", "       _dilation_h_factor);", " }", " ", "-inline ConcatEmbeddingsOptionsT *ConcatEmbeddingsOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ConcatEmbeddingsOptionsT *ConcatEmbeddingsOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ConcatEmbeddingsOptionsT>(new ConcatEmbeddingsOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ConcatEmbeddingsOptions::UnPackTo(ConcatEmbeddingsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ConcatEmbeddingsOptions::UnPackTo(ConcatEmbeddingsOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = num_channels(); _o->num_channels = _e; }", "-  { auto _e = num_columns_per_channel(); if (_e) { _o->num_columns_per_channel.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->num_columns_per_channel[_i] = _e->Get(_i); } } }", "-  { auto _e = embedding_dim_per_channel(); if (_e) { _o->embedding_dim_per_channel.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->embedding_dim_per_channel[_i] = _e->Get(_i); } } }", "+  { auto _e = num_columns_per_channel(); if (_e) { _o->num_columns_per_channel.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->num_columns_per_channel[_i] = _e->Get(_i); } } else { _o->num_columns_per_channel.resize(0); } }", "+  { auto _e = embedding_dim_per_channel(); if (_e) { _o->embedding_dim_per_channel.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->embedding_dim_per_channel[_i] = _e->Get(_i); } } else { _o->embedding_dim_per_channel.resize(0); } }", " }", " ", "-inline flatbuffers::Offset<ConcatEmbeddingsOptions> ConcatEmbeddingsOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ConcatEmbeddingsOptions> ConcatEmbeddingsOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateConcatEmbeddingsOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ConcatEmbeddingsOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConcatEmbeddingsOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ConcatEmbeddingsOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _num_channels = _o->num_channels;", "   auto _num_columns_per_channel = _o->num_columns_per_channel.size() ? _fbb.CreateVector(_o->num_columns_per_channel) : 0;", "   auto _embedding_dim_per_channel = _o->embedding_dim_per_channel.size() ? _fbb.CreateVector(_o->embedding_dim_per_channel) : 0;", "@@ -13954,39 +13961,39 @@ inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOption", "       _embedding_dim_per_channel);", " }", " ", "-inline LSHProjectionOptionsT *LSHProjectionOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline LSHProjectionOptionsT *LSHProjectionOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<LSHProjectionOptionsT>(new LSHProjectionOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void LSHProjectionOptions::UnPackTo(LSHProjectionOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void LSHProjectionOptions::UnPackTo(LSHProjectionOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = type(); _o->type = _e; }", " }", " ", "-inline flatbuffers::Offset<LSHProjectionOptions> LSHProjectionOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<LSHProjectionOptions> LSHProjectionOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateLSHProjectionOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LSHProjectionOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LSHProjectionOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LSHProjectionOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _type = _o->type;", "   return tflite::CreateLSHProjectionOptions(", "       _fbb,", "       _type);", " }", " ", "-inline SVDFOptionsT *SVDFOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SVDFOptionsT *SVDFOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SVDFOptionsT>(new SVDFOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SVDFOptions::UnPackTo(SVDFOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SVDFOptions::UnPackTo(SVDFOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = rank(); _o->rank = _e; }", "@@ -13994,14 +14001,14 @@ inline void SVDFOptions::UnPackTo(SVDFOptionsT *_o, const flatbuffers::resolver_", "   { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }", " }", " ", "-inline flatbuffers::Offset<SVDFOptions> SVDFOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SVDFOptions> SVDFOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSVDFOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SVDFOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SVDFOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SVDFOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _rank = _o->rank;", "   auto _fused_activation_function = _o->fused_activation_function;", "   auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;", "@@ -14012,27 +14019,27 @@ inline flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(flatbuffers::FlatBuffe", "       _asymmetric_quantize_inputs);", " }", " ", "-inline RNNOptionsT *RNNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline RNNOptionsT *RNNOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<RNNOptionsT>(new RNNOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void RNNOptions::UnPackTo(RNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void RNNOptions::UnPackTo(RNNOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }", "   { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }", " }", " ", "-inline flatbuffers::Offset<RNNOptions> RNNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<RNNOptions> RNNOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateRNNOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<RNNOptions> CreateRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<RNNOptions> CreateRNNOptions(::flatbuffers::FlatBufferBuilder &_fbb, const RNNOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RNNOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RNNOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _fused_activation_function = _o->fused_activation_function;", "   auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;", "   return tflite::CreateRNNOptions(", "@@ -14041,13 +14048,13 @@ inline flatbuffers::Offset<RNNOptions> CreateRNNOptions(flatbuffers::FlatBufferB", "       _asymmetric_quantize_inputs);", " }", " ", "-inline SequenceRNNOptionsT *SequenceRNNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SequenceRNNOptionsT *SequenceRNNOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SequenceRNNOptionsT>(new SequenceRNNOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SequenceRNNOptions::UnPackTo(SequenceRNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SequenceRNNOptions::UnPackTo(SequenceRNNOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = time_major(); _o->time_major = _e; }", "@@ -14055,14 +14062,14 @@ inline void SequenceRNNOptions::UnPackTo(SequenceRNNOptionsT *_o, const flatbuff", "   { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }", " }", " ", "-inline flatbuffers::Offset<SequenceRNNOptions> SequenceRNNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SequenceRNNOptions> SequenceRNNOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSequenceRNNOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SequenceRNNOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SequenceRNNOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SequenceRNNOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _time_major = _o->time_major;", "   auto _fused_activation_function = _o->fused_activation_function;", "   auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;", "@@ -14073,13 +14080,13 @@ inline flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(flatbuff", "       _asymmetric_quantize_inputs);", " }", " ", "-inline BidirectionalSequenceRNNOptionsT *BidirectionalSequenceRNNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline BidirectionalSequenceRNNOptionsT *BidirectionalSequenceRNNOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<BidirectionalSequenceRNNOptionsT>(new BidirectionalSequenceRNNOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void BidirectionalSequenceRNNOptions::UnPackTo(BidirectionalSequenceRNNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void BidirectionalSequenceRNNOptions::UnPackTo(BidirectionalSequenceRNNOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = time_major(); _o->time_major = _e; }", "@@ -14088,14 +14095,14 @@ inline void BidirectionalSequenceRNNOptions::UnPackTo(BidirectionalSequenceRNNOp", "   { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }", " }", " ", "-inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> BidirectionalSequenceRNNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BidirectionalSequenceRNNOptions> BidirectionalSequenceRNNOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateBidirectionalSequenceRNNOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceRNNOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BidirectionalSequenceRNNOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BidirectionalSequenceRNNOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _time_major = _o->time_major;", "   auto _fused_activation_function = _o->fused_activation_function;", "   auto _merge_outputs = _o->merge_outputs;", "@@ -14108,13 +14115,13 @@ inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalS", "       _asymmetric_quantize_inputs);", " }", " ", "-inline FullyConnectedOptionsT *FullyConnectedOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline FullyConnectedOptionsT *FullyConnectedOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<FullyConnectedOptionsT>(new FullyConnectedOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void FullyConnectedOptions::UnPackTo(FullyConnectedOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void FullyConnectedOptions::UnPackTo(FullyConnectedOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }", "@@ -14123,14 +14130,14 @@ inline void FullyConnectedOptions::UnPackTo(FullyConnectedOptionsT *_o, const fl", "   { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }", " }", " ", "-inline flatbuffers::Offset<FullyConnectedOptions> FullyConnectedOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<FullyConnectedOptions> FullyConnectedOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateFullyConnectedOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(::flatbuffers::FlatBufferBuilder &_fbb, const FullyConnectedOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FullyConnectedOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FullyConnectedOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _fused_activation_function = _o->fused_activation_function;", "   auto _weights_format = _o->weights_format;", "   auto _keep_num_dims = _o->keep_num_dims;", "@@ -14143,53 +14150,53 @@ inline flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(fl", "       _asymmetric_quantize_inputs);", " }", " ", "-inline SoftmaxOptionsT *SoftmaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SoftmaxOptionsT *SoftmaxOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SoftmaxOptionsT>(new SoftmaxOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SoftmaxOptions::UnPackTo(SoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SoftmaxOptions::UnPackTo(SoftmaxOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = beta(); _o->beta = _e; }", " }", " ", "-inline flatbuffers::Offset<SoftmaxOptions> SoftmaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SoftmaxOptions> SoftmaxOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSoftmaxOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoftmaxOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SoftmaxOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _beta = _o->beta;", "   return tflite::CreateSoftmaxOptions(", "       _fbb,", "       _beta);", " }", " ", "-inline ConcatenationOptionsT *ConcatenationOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ConcatenationOptionsT *ConcatenationOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ConcatenationOptionsT>(new ConcatenationOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ConcatenationOptions::UnPackTo(ConcatenationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ConcatenationOptions::UnPackTo(ConcatenationOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = axis(); _o->axis = _e; }", "   { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }", " }", " ", "-inline flatbuffers::Offset<ConcatenationOptions> ConcatenationOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ConcatenationOptions> ConcatenationOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateConcatenationOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ConcatenationOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConcatenationOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ConcatenationOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _axis = _o->axis;", "   auto _fused_activation_function = _o->fused_activation_function;", "   return tflite::CreateConcatenationOptions(", "@@ -14198,27 +14205,27 @@ inline flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(flat", "       _fused_activation_function);", " }", " ", "-inline AddOptionsT *AddOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline AddOptionsT *AddOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<AddOptionsT>(new AddOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void AddOptions::UnPackTo(AddOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void AddOptions::UnPackTo(AddOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }", "   { auto _e = pot_scale_int16(); _o->pot_scale_int16 = _e; }", " }", " ", "-inline flatbuffers::Offset<AddOptions> AddOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<AddOptions> AddOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateAddOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<AddOptions> CreateAddOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<AddOptions> CreateAddOptions(::flatbuffers::FlatBufferBuilder &_fbb, const AddOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AddOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _fused_activation_function = _o->fused_activation_function;", "   auto _pot_scale_int16 = _o->pot_scale_int16;", "   return tflite::CreateAddOptions(", "@@ -14227,65 +14234,65 @@ inline flatbuffers::Offset<AddOptions> CreateAddOptions(flatbuffers::FlatBufferB", "       _pot_scale_int16);", " }", " ", "-inline MulOptionsT *MulOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline MulOptionsT *MulOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<MulOptionsT>(new MulOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void MulOptions::UnPackTo(MulOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void MulOptions::UnPackTo(MulOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }", " }", " ", "-inline flatbuffers::Offset<MulOptions> MulOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<MulOptions> MulOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateMulOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<MulOptions> CreateMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<MulOptions> CreateMulOptions(::flatbuffers::FlatBufferBuilder &_fbb, const MulOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MulOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MulOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _fused_activation_function = _o->fused_activation_function;", "   return tflite::CreateMulOptions(", "       _fbb,", "       _fused_activation_function);", " }", " ", "-inline L2NormOptionsT *L2NormOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline L2NormOptionsT *L2NormOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<L2NormOptionsT>(new L2NormOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void L2NormOptions::UnPackTo(L2NormOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void L2NormOptions::UnPackTo(L2NormOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }", " }", " ", "-inline flatbuffers::Offset<L2NormOptions> L2NormOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<L2NormOptions> L2NormOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateL2NormOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(::flatbuffers::FlatBufferBuilder &_fbb, const L2NormOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const L2NormOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const L2NormOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _fused_activation_function = _o->fused_activation_function;", "   return tflite::CreateL2NormOptions(", "       _fbb,", "       _fused_activation_function);", " }", " ", "-inline LocalResponseNormalizationOptionsT *LocalResponseNormalizationOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline LocalResponseNormalizationOptionsT *LocalResponseNormalizationOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<LocalResponseNormalizationOptionsT>(new LocalResponseNormalizationOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void LocalResponseNormalizationOptions::UnPackTo(LocalResponseNormalizationOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void LocalResponseNormalizationOptions::UnPackTo(LocalResponseNormalizationOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = radius(); _o->radius = _e; }", "@@ -14294,14 +14301,14 @@ inline void LocalResponseNormalizationOptions::UnPackTo(LocalResponseNormalizati", "   { auto _e = beta(); _o->beta = _e; }", " }", " ", "-inline flatbuffers::Offset<LocalResponseNormalizationOptions> LocalResponseNormalizationOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<LocalResponseNormalizationOptions> LocalResponseNormalizationOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateLocalResponseNormalizationOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LocalResponseNormalizationOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LocalResponseNormalizationOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _radius = _o->radius;", "   auto _bias = _o->bias;", "   auto _alpha = _o->alpha;", "@@ -14314,13 +14321,13 @@ inline flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalRespons", "       _beta);", " }", " ", "-inline LSTMOptionsT *LSTMOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline LSTMOptionsT *LSTMOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<LSTMOptionsT>(new LSTMOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void LSTMOptions::UnPackTo(LSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void LSTMOptions::UnPackTo(LSTMOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }", "@@ -14330,14 +14337,14 @@ inline void LSTMOptions::UnPackTo(LSTMOptionsT *_o, const flatbuffers::resolver_", "   { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }", " }", " ", "-inline flatbuffers::Offset<LSTMOptions> LSTMOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<LSTMOptions> LSTMOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateLSTMOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LSTMOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LSTMOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LSTMOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _fused_activation_function = _o->fused_activation_function;", "   auto _cell_clip = _o->cell_clip;", "   auto _proj_clip = _o->proj_clip;", "@@ -14352,13 +14359,13 @@ inline flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(flatbuffers::FlatBuffe", "       _asymmetric_quantize_inputs);", " }", " ", "-inline UnidirectionalSequenceLSTMOptionsT *UnidirectionalSequenceLSTMOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline UnidirectionalSequenceLSTMOptionsT *UnidirectionalSequenceLSTMOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<UnidirectionalSequenceLSTMOptionsT>(new UnidirectionalSequenceLSTMOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void UnidirectionalSequenceLSTMOptions::UnPackTo(UnidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void UnidirectionalSequenceLSTMOptions::UnPackTo(UnidirectionalSequenceLSTMOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }", "@@ -14369,14 +14376,14 @@ inline void UnidirectionalSequenceLSTMOptions::UnPackTo(UnidirectionalSequenceLS", "   { auto _e = diagonal_recurrent_tensors(); _o->diagonal_recurrent_tensors = _e; }", " }", " ", "-inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> UnidirectionalSequenceLSTMOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> UnidirectionalSequenceLSTMOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateUnidirectionalSequenceLSTMOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnidirectionalSequenceLSTMOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnidirectionalSequenceLSTMOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UnidirectionalSequenceLSTMOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _fused_activation_function = _o->fused_activation_function;", "   auto _cell_clip = _o->cell_clip;", "   auto _proj_clip = _o->proj_clip;", "@@ -14393,13 +14400,13 @@ inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirection", "       _diagonal_recurrent_tensors);", " }", " ", "-inline BidirectionalSequenceLSTMOptionsT *BidirectionalSequenceLSTMOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline BidirectionalSequenceLSTMOptionsT *BidirectionalSequenceLSTMOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<BidirectionalSequenceLSTMOptionsT>(new BidirectionalSequenceLSTMOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void BidirectionalSequenceLSTMOptions::UnPackTo(BidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void BidirectionalSequenceLSTMOptions::UnPackTo(BidirectionalSequenceLSTMOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }", "@@ -14410,14 +14417,14 @@ inline void BidirectionalSequenceLSTMOptions::UnPackTo(BidirectionalSequenceLSTM", "   { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }", " }", " ", "-inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions> BidirectionalSequenceLSTMOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BidirectionalSequenceLSTMOptions> BidirectionalSequenceLSTMOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateBidirectionalSequenceLSTMOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BidirectionalSequenceLSTMOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BidirectionalSequenceLSTMOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BidirectionalSequenceLSTMOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _fused_activation_function = _o->fused_activation_function;", "   auto _cell_clip = _o->cell_clip;", "   auto _proj_clip = _o->proj_clip;", "@@ -14434,27 +14441,27 @@ inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectional", "       _asymmetric_quantize_inputs);", " }", " ", "-inline ResizeBilinearOptionsT *ResizeBilinearOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ResizeBilinearOptionsT *ResizeBilinearOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ResizeBilinearOptionsT>(new ResizeBilinearOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ResizeBilinearOptions::UnPackTo(ResizeBilinearOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ResizeBilinearOptions::UnPackTo(ResizeBilinearOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = align_corners(); _o->align_corners = _e; }", "   { auto _e = half_pixel_centers(); _o->half_pixel_centers = _e; }", " }", " ", "-inline flatbuffers::Offset<ResizeBilinearOptions> ResizeBilinearOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ResizeBilinearOptions> ResizeBilinearOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateResizeBilinearOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ResizeBilinearOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResizeBilinearOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ResizeBilinearOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _align_corners = _o->align_corners;", "   auto _half_pixel_centers = _o->half_pixel_centers;", "   return tflite::CreateResizeBilinearOptions(", "@@ -14463,27 +14470,27 @@ inline flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(fl", "       _half_pixel_centers);", " }", " ", "-inline ResizeNearestNeighborOptionsT *ResizeNearestNeighborOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ResizeNearestNeighborOptionsT *ResizeNearestNeighborOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ResizeNearestNeighborOptionsT>(new ResizeNearestNeighborOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ResizeNearestNeighborOptions::UnPackTo(ResizeNearestNeighborOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ResizeNearestNeighborOptions::UnPackTo(ResizeNearestNeighborOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = align_corners(); _o->align_corners = _e; }", "   { auto _e = half_pixel_centers(); _o->half_pixel_centers = _e; }", " }", " ", "-inline flatbuffers::Offset<ResizeNearestNeighborOptions> ResizeNearestNeighborOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ResizeNearestNeighborOptions> ResizeNearestNeighborOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateResizeNearestNeighborOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ResizeNearestNeighborOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResizeNearestNeighborOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ResizeNearestNeighborOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _align_corners = _o->align_corners;", "   auto _half_pixel_centers = _o->half_pixel_centers;", "   return tflite::CreateResizeNearestNeighborOptions(", "@@ -14492,157 +14499,157 @@ inline flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeig", "       _half_pixel_centers);", " }", " ", "-inline CallOptionsT *CallOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline CallOptionsT *CallOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<CallOptionsT>(new CallOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void CallOptions::UnPackTo(CallOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void CallOptions::UnPackTo(CallOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = subgraph(); _o->subgraph = _e; }", " }", " ", "-inline flatbuffers::Offset<CallOptions> CallOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<CallOptions> CallOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateCallOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<CallOptions> CreateCallOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<CallOptions> CreateCallOptions(::flatbuffers::FlatBufferBuilder &_fbb, const CallOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CallOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CallOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _subgraph = _o->subgraph;", "   return tflite::CreateCallOptions(", "       _fbb,", "       _subgraph);", " }", " ", "-inline PadOptionsT *PadOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline PadOptionsT *PadOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<PadOptionsT>(new PadOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void PadOptions::UnPackTo(PadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void PadOptions::UnPackTo(PadOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<PadOptions> PadOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<PadOptions> PadOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreatePadOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<PadOptions> CreatePadOptions(flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<PadOptions> CreatePadOptions(::flatbuffers::FlatBufferBuilder &_fbb, const PadOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PadOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PadOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreatePadOptions(", "       _fbb);", " }", " ", "-inline PadV2OptionsT *PadV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline PadV2OptionsT *PadV2Options::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<PadV2OptionsT>(new PadV2OptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void PadV2Options::UnPackTo(PadV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void PadV2Options::UnPackTo(PadV2OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<PadV2Options> PadV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<PadV2Options> PadV2Options::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreatePadV2Options(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<PadV2Options> CreatePadV2Options(flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<PadV2Options> CreatePadV2Options(::flatbuffers::FlatBufferBuilder &_fbb, const PadV2OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PadV2OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PadV2OptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreatePadV2Options(", "       _fbb);", " }", " ", "-inline ReshapeOptionsT *ReshapeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ReshapeOptionsT *ReshapeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ReshapeOptionsT>(new ReshapeOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ReshapeOptions::UnPackTo(ReshapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ReshapeOptions::UnPackTo(ReshapeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "-  { auto _e = new_shape(); if (_e) { _o->new_shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->new_shape[_i] = _e->Get(_i); } } }", "+  { auto _e = new_shape(); if (_e) { _o->new_shape.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->new_shape[_i] = _e->Get(_i); } } else { _o->new_shape.resize(0); } }", " }", " ", "-inline flatbuffers::Offset<ReshapeOptions> ReshapeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ReshapeOptions> ReshapeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateReshapeOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ReshapeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReshapeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReshapeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _new_shape = _o->new_shape.size() ? _fbb.CreateVector(_o->new_shape) : 0;", "   return tflite::CreateReshapeOptions(", "       _fbb,", "       _new_shape);", " }", " ", "-inline SpaceToBatchNDOptionsT *SpaceToBatchNDOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SpaceToBatchNDOptionsT *SpaceToBatchNDOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SpaceToBatchNDOptionsT>(new SpaceToBatchNDOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SpaceToBatchNDOptions::UnPackTo(SpaceToBatchNDOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SpaceToBatchNDOptions::UnPackTo(SpaceToBatchNDOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<SpaceToBatchNDOptions> SpaceToBatchNDOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SpaceToBatchNDOptions> SpaceToBatchNDOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSpaceToBatchNDOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpaceToBatchNDOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SpaceToBatchNDOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateSpaceToBatchNDOptions(", "       _fbb);", " }", " ", "-inline BatchToSpaceNDOptionsT *BatchToSpaceNDOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline BatchToSpaceNDOptionsT *BatchToSpaceNDOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<BatchToSpaceNDOptionsT>(new BatchToSpaceNDOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void BatchToSpaceNDOptions::UnPackTo(BatchToSpaceNDOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void BatchToSpaceNDOptions::UnPackTo(BatchToSpaceNDOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<BatchToSpaceNDOptions> BatchToSpaceNDOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BatchToSpaceNDOptions> BatchToSpaceNDOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateBatchToSpaceNDOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchToSpaceNDOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BatchToSpaceNDOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateBatchToSpaceNDOptions(", "       _fbb);", " }", " ", "-inline SkipGramOptionsT *SkipGramOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SkipGramOptionsT *SkipGramOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SkipGramOptionsT>(new SkipGramOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SkipGramOptions::UnPackTo(SkipGramOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SkipGramOptions::UnPackTo(SkipGramOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = ngram_size(); _o->ngram_size = _e; }", "@@ -14650,14 +14657,14 @@ inline void SkipGramOptions::UnPackTo(SkipGramOptionsT *_o, const flatbuffers::r", "   { auto _e = include_all_ngrams(); _o->include_all_ngrams = _e; }", " }", " ", "-inline flatbuffers::Offset<SkipGramOptions> SkipGramOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SkipGramOptions> SkipGramOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSkipGramOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SkipGramOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SkipGramOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SkipGramOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _ngram_size = _o->ngram_size;", "   auto _max_skip_size = _o->max_skip_size;", "   auto _include_all_ngrams = _o->include_all_ngrams;", "@@ -14668,79 +14675,79 @@ inline flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(flatbuffers::F", "       _include_all_ngrams);", " }", " ", "-inline SpaceToDepthOptionsT *SpaceToDepthOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SpaceToDepthOptionsT *SpaceToDepthOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SpaceToDepthOptionsT>(new SpaceToDepthOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SpaceToDepthOptions::UnPackTo(SpaceToDepthOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SpaceToDepthOptions::UnPackTo(SpaceToDepthOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = block_size(); _o->block_size = _e; }", " }", " ", "-inline flatbuffers::Offset<SpaceToDepthOptions> SpaceToDepthOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SpaceToDepthOptions> SpaceToDepthOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSpaceToDepthOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpaceToDepthOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SpaceToDepthOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _block_size = _o->block_size;", "   return tflite::CreateSpaceToDepthOptions(", "       _fbb,", "       _block_size);", " }", " ", "-inline DepthToSpaceOptionsT *DepthToSpaceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline DepthToSpaceOptionsT *DepthToSpaceOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<DepthToSpaceOptionsT>(new DepthToSpaceOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void DepthToSpaceOptions::UnPackTo(DepthToSpaceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void DepthToSpaceOptions::UnPackTo(DepthToSpaceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = block_size(); _o->block_size = _e; }", " }", " ", "-inline flatbuffers::Offset<DepthToSpaceOptions> DepthToSpaceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<DepthToSpaceOptions> DepthToSpaceOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateDepthToSpaceOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<DepthToSpaceOptions> CreateDepthToSpaceOptions(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<DepthToSpaceOptions> CreateDepthToSpaceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DepthToSpaceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DepthToSpaceOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _block_size = _o->block_size;", "   return tflite::CreateDepthToSpaceOptions(", "       _fbb,", "       _block_size);", " }", " ", "-inline SubOptionsT *SubOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SubOptionsT *SubOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SubOptionsT>(new SubOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SubOptions::UnPackTo(SubOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SubOptions::UnPackTo(SubOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }", "   { auto _e = pot_scale_int16(); _o->pot_scale_int16 = _e; }", " }", " ", "-inline flatbuffers::Offset<SubOptions> SubOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SubOptions> SubOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSubOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SubOptions> CreateSubOptions(flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SubOptions> CreateSubOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SubOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SubOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _fused_activation_function = _o->fused_activation_function;", "   auto _pot_scale_int16 = _o->pot_scale_int16;", "   return tflite::CreateSubOptions(", "@@ -14749,102 +14756,102 @@ inline flatbuffers::Offset<SubOptions> CreateSubOptions(flatbuffers::FlatBufferB", "       _pot_scale_int16);", " }", " ", "-inline DivOptionsT *DivOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline DivOptionsT *DivOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<DivOptionsT>(new DivOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void DivOptions::UnPackTo(DivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void DivOptions::UnPackTo(DivOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }", " }", " ", "-inline flatbuffers::Offset<DivOptions> DivOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<DivOptions> DivOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateDivOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<DivOptions> CreateDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<DivOptions> CreateDivOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DivOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DivOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DivOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _fused_activation_function = _o->fused_activation_function;", "   return tflite::CreateDivOptions(", "       _fbb,", "       _fused_activation_function);", " }", " ", "-inline TopKV2OptionsT *TopKV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline TopKV2OptionsT *TopKV2Options::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<TopKV2OptionsT>(new TopKV2OptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void TopKV2Options::UnPackTo(TopKV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void TopKV2Options::UnPackTo(TopKV2OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<TopKV2Options> TopKV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<TopKV2Options> TopKV2Options::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateTopKV2Options(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(::flatbuffers::FlatBufferBuilder &_fbb, const TopKV2OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TopKV2OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TopKV2OptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateTopKV2Options(", "       _fbb);", " }", " ", "-inline EmbeddingLookupSparseOptionsT *EmbeddingLookupSparseOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline EmbeddingLookupSparseOptionsT *EmbeddingLookupSparseOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<EmbeddingLookupSparseOptionsT>(new EmbeddingLookupSparseOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void EmbeddingLookupSparseOptions::UnPackTo(EmbeddingLookupSparseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void EmbeddingLookupSparseOptions::UnPackTo(EmbeddingLookupSparseOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = combiner(); _o->combiner = _e; }", " }", " ", "-inline flatbuffers::Offset<EmbeddingLookupSparseOptions> EmbeddingLookupSparseOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<EmbeddingLookupSparseOptions> EmbeddingLookupSparseOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateEmbeddingLookupSparseOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(::flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EmbeddingLookupSparseOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EmbeddingLookupSparseOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _combiner = _o->combiner;", "   return tflite::CreateEmbeddingLookupSparseOptions(", "       _fbb,", "       _combiner);", " }", " ", "-inline GatherOptionsT *GatherOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline GatherOptionsT *GatherOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<GatherOptionsT>(new GatherOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void GatherOptions::UnPackTo(GatherOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void GatherOptions::UnPackTo(GatherOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = axis(); _o->axis = _e; }", "   { auto _e = batch_dims(); _o->batch_dims = _e; }", " }", " ", "-inline flatbuffers::Offset<GatherOptions> GatherOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<GatherOptions> GatherOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateGatherOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<GatherOptions> CreateGatherOptions(flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<GatherOptions> CreateGatherOptions(::flatbuffers::FlatBufferBuilder &_fbb, const GatherOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GatherOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GatherOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _axis = _o->axis;", "   auto _batch_dims = _o->batch_dims;", "   return tflite::CreateGatherOptions(", "@@ -14853,186 +14860,186 @@ inline flatbuffers::Offset<GatherOptions> CreateGatherOptions(flatbuffers::FlatB", "       _batch_dims);", " }", " ", "-inline TransposeOptionsT *TransposeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline TransposeOptionsT *TransposeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<TransposeOptionsT>(new TransposeOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void TransposeOptions::UnPackTo(TransposeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void TransposeOptions::UnPackTo(TransposeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<TransposeOptions> TransposeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<TransposeOptions> TransposeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateTransposeOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const TransposeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransposeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TransposeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateTransposeOptions(", "       _fbb);", " }", " ", "-inline ExpOptionsT *ExpOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ExpOptionsT *ExpOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ExpOptionsT>(new ExpOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ExpOptions::UnPackTo(ExpOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ExpOptions::UnPackTo(ExpOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<ExpOptions> ExpOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ExpOptions> ExpOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateExpOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ExpOptions> CreateExpOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ExpOptions> CreateExpOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ExpOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExpOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ExpOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateExpOptions(", "       _fbb);", " }", " ", "-inline CosOptionsT *CosOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline CosOptionsT *CosOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<CosOptionsT>(new CosOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void CosOptions::UnPackTo(CosOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void CosOptions::UnPackTo(CosOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<CosOptions> CosOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<CosOptions> CosOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateCosOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<CosOptions> CreateCosOptions(flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<CosOptions> CreateCosOptions(::flatbuffers::FlatBufferBuilder &_fbb, const CosOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CosOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CosOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateCosOptions(", "       _fbb);", " }", " ", "-inline ReducerOptionsT *ReducerOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ReducerOptionsT *ReducerOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ReducerOptionsT>(new ReducerOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ReducerOptions::UnPackTo(ReducerOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ReducerOptions::UnPackTo(ReducerOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = keep_dims(); _o->keep_dims = _e; }", " }", " ", "-inline flatbuffers::Offset<ReducerOptions> ReducerOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ReducerOptions> ReducerOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateReducerOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ReducerOptions> CreateReducerOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ReducerOptions> CreateReducerOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ReducerOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReducerOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReducerOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _keep_dims = _o->keep_dims;", "   return tflite::CreateReducerOptions(", "       _fbb,", "       _keep_dims);", " }", " ", "-inline SqueezeOptionsT *SqueezeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SqueezeOptionsT *SqueezeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SqueezeOptionsT>(new SqueezeOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SqueezeOptions::UnPackTo(SqueezeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SqueezeOptions::UnPackTo(SqueezeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "-  { auto _e = squeeze_dims(); if (_e) { _o->squeeze_dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->squeeze_dims[_i] = _e->Get(_i); } } }", "+  { auto _e = squeeze_dims(); if (_e) { _o->squeeze_dims.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->squeeze_dims[_i] = _e->Get(_i); } } else { _o->squeeze_dims.resize(0); } }", " }", " ", "-inline flatbuffers::Offset<SqueezeOptions> SqueezeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SqueezeOptions> SqueezeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSqueezeOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SqueezeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SqueezeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SqueezeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _squeeze_dims = _o->squeeze_dims.size() ? _fbb.CreateVector(_o->squeeze_dims) : 0;", "   return tflite::CreateSqueezeOptions(", "       _fbb,", "       _squeeze_dims);", " }", " ", "-inline SplitOptionsT *SplitOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SplitOptionsT *SplitOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SplitOptionsT>(new SplitOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SplitOptions::UnPackTo(SplitOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SplitOptions::UnPackTo(SplitOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = num_splits(); _o->num_splits = _e; }", " }", " ", "-inline flatbuffers::Offset<SplitOptions> SplitOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SplitOptions> SplitOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSplitOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SplitOptions> CreateSplitOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SplitOptions> CreateSplitOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SplitOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SplitOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SplitOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _num_splits = _o->num_splits;", "   return tflite::CreateSplitOptions(", "       _fbb,", "       _num_splits);", " }", " ", "-inline SplitVOptionsT *SplitVOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SplitVOptionsT *SplitVOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SplitVOptionsT>(new SplitVOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SplitVOptions::UnPackTo(SplitVOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SplitVOptions::UnPackTo(SplitVOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = num_splits(); _o->num_splits = _e; }", " }", " ", "-inline flatbuffers::Offset<SplitVOptions> SplitVOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SplitVOptions> SplitVOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSplitVOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SplitVOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SplitVOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SplitVOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _num_splits = _o->num_splits;", "   return tflite::CreateSplitVOptions(", "       _fbb,", "       _num_splits);", " }", " ", "-inline StridedSliceOptionsT *StridedSliceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline StridedSliceOptionsT *StridedSliceOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<StridedSliceOptionsT>(new StridedSliceOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void StridedSliceOptions::UnPackTo(StridedSliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void StridedSliceOptions::UnPackTo(StridedSliceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = begin_mask(); _o->begin_mask = _e; }", "@@ -15042,14 +15049,14 @@ inline void StridedSliceOptions::UnPackTo(StridedSliceOptionsT *_o, const flatbu", "   { auto _e = shrink_axis_mask(); _o->shrink_axis_mask = _e; }", " }", " ", "-inline flatbuffers::Offset<StridedSliceOptions> StridedSliceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<StridedSliceOptions> StridedSliceOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateStridedSliceOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StridedSliceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StridedSliceOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _begin_mask = _o->begin_mask;", "   auto _end_mask = _o->end_mask;", "   auto _ellipsis_mask = _o->ellipsis_mask;", "@@ -15064,50 +15071,50 @@ inline flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(flatbu", "       _shrink_axis_mask);", " }", " ", "-inline LogSoftmaxOptionsT *LogSoftmaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline LogSoftmaxOptionsT *LogSoftmaxOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<LogSoftmaxOptionsT>(new LogSoftmaxOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void LogSoftmaxOptions::UnPackTo(LogSoftmaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void LogSoftmaxOptions::UnPackTo(LogSoftmaxOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<LogSoftmaxOptions> LogSoftmaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<LogSoftmaxOptions> LogSoftmaxOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateLogSoftmaxOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogSoftmaxOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LogSoftmaxOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateLogSoftmaxOptions(", "       _fbb);", " }", " ", "-inline CastOptionsT *CastOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline CastOptionsT *CastOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<CastOptionsT>(new CastOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void CastOptions::UnPackTo(CastOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void CastOptions::UnPackTo(CastOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = in_data_type(); _o->in_data_type = _e; }", "   { auto _e = out_data_type(); _o->out_data_type = _e; }", " }", " ", "-inline flatbuffers::Offset<CastOptions> CastOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<CastOptions> CastOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateCastOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<CastOptions> CreateCastOptions(flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<CastOptions> CreateCastOptions(::flatbuffers::FlatBufferBuilder &_fbb, const CastOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CastOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CastOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _in_data_type = _o->in_data_type;", "   auto _out_data_type = _o->out_data_type;", "   return tflite::CreateCastOptions(", "@@ -15116,295 +15123,295 @@ inline flatbuffers::Offset<CastOptions> CreateCastOptions(flatbuffers::FlatBuffe", "       _out_data_type);", " }", " ", "-inline DequantizeOptionsT *DequantizeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline DequantizeOptionsT *DequantizeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<DequantizeOptionsT>(new DequantizeOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void DequantizeOptions::UnPackTo(DequantizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void DequantizeOptions::UnPackTo(DequantizeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<DequantizeOptions> DequantizeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<DequantizeOptions> DequantizeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateDequantizeOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DequantizeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DequantizeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DequantizeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateDequantizeOptions(", "       _fbb);", " }", " ", "-inline MaximumMinimumOptionsT *MaximumMinimumOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline MaximumMinimumOptionsT *MaximumMinimumOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<MaximumMinimumOptionsT>(new MaximumMinimumOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void MaximumMinimumOptions::UnPackTo(MaximumMinimumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void MaximumMinimumOptions::UnPackTo(MaximumMinimumOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<MaximumMinimumOptions> MaximumMinimumOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<MaximumMinimumOptions> MaximumMinimumOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateMaximumMinimumOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(::flatbuffers::FlatBufferBuilder &_fbb, const MaximumMinimumOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MaximumMinimumOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MaximumMinimumOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateMaximumMinimumOptions(", "       _fbb);", " }", " ", "-inline TileOptionsT *TileOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline TileOptionsT *TileOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<TileOptionsT>(new TileOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void TileOptions::UnPackTo(TileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void TileOptions::UnPackTo(TileOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<TileOptions> TileOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<TileOptions> TileOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateTileOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<TileOptions> CreateTileOptions(flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<TileOptions> CreateTileOptions(::flatbuffers::FlatBufferBuilder &_fbb, const TileOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TileOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TileOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateTileOptions(", "       _fbb);", " }", " ", "-inline ArgMaxOptionsT *ArgMaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ArgMaxOptionsT *ArgMaxOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ArgMaxOptionsT>(new ArgMaxOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ArgMaxOptions::UnPackTo(ArgMaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ArgMaxOptions::UnPackTo(ArgMaxOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = output_type(); _o->output_type = _e; }", " }", " ", "-inline flatbuffers::Offset<ArgMaxOptions> ArgMaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ArgMaxOptions> ArgMaxOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateArgMaxOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMaxOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ArgMaxOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _output_type = _o->output_type;", "   return tflite::CreateArgMaxOptions(", "       _fbb,", "       _output_type);", " }", " ", "-inline ArgMinOptionsT *ArgMinOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ArgMinOptionsT *ArgMinOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ArgMinOptionsT>(new ArgMinOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ArgMinOptions::UnPackTo(ArgMinOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ArgMinOptions::UnPackTo(ArgMinOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = output_type(); _o->output_type = _e; }", " }", " ", "-inline flatbuffers::Offset<ArgMinOptions> ArgMinOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ArgMinOptions> ArgMinOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateArgMinOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ArgMinOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMinOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ArgMinOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _output_type = _o->output_type;", "   return tflite::CreateArgMinOptions(", "       _fbb,", "       _output_type);", " }", " ", "-inline GreaterOptionsT *GreaterOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline GreaterOptionsT *GreaterOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<GreaterOptionsT>(new GreaterOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void GreaterOptions::UnPackTo(GreaterOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void GreaterOptions::UnPackTo(GreaterOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<GreaterOptions> GreaterOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<GreaterOptions> GreaterOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateGreaterOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(::flatbuffers::FlatBufferBuilder &_fbb, const GreaterOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GreaterOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GreaterOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateGreaterOptions(", "       _fbb);", " }", " ", "-inline GreaterEqualOptionsT *GreaterEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline GreaterEqualOptionsT *GreaterEqualOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<GreaterEqualOptionsT>(new GreaterEqualOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void GreaterEqualOptions::UnPackTo(GreaterEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void GreaterEqualOptions::UnPackTo(GreaterEqualOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<GreaterEqualOptions> GreaterEqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<GreaterEqualOptions> GreaterEqualOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateGreaterEqualOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(::flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GreaterEqualOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GreaterEqualOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateGreaterEqualOptions(", "       _fbb);", " }", " ", "-inline LessOptionsT *LessOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline LessOptionsT *LessOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<LessOptionsT>(new LessOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void LessOptions::UnPackTo(LessOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void LessOptions::UnPackTo(LessOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<LessOptions> LessOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<LessOptions> LessOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateLessOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<LessOptions> CreateLessOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<LessOptions> CreateLessOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LessOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LessOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LessOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateLessOptions(", "       _fbb);", " }", " ", "-inline LessEqualOptionsT *LessEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline LessEqualOptionsT *LessEqualOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<LessEqualOptionsT>(new LessEqualOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void LessEqualOptions::UnPackTo(LessEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void LessEqualOptions::UnPackTo(LessEqualOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<LessEqualOptions> LessEqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<LessEqualOptions> LessEqualOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateLessEqualOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LessEqualOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LessEqualOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LessEqualOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateLessEqualOptions(", "       _fbb);", " }", " ", "-inline NegOptionsT *NegOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline NegOptionsT *NegOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<NegOptionsT>(new NegOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void NegOptions::UnPackTo(NegOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void NegOptions::UnPackTo(NegOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<NegOptions> NegOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<NegOptions> NegOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateNegOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<NegOptions> CreateNegOptions(flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<NegOptions> CreateNegOptions(::flatbuffers::FlatBufferBuilder &_fbb, const NegOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NegOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NegOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateNegOptions(", "       _fbb);", " }", " ", "-inline SelectOptionsT *SelectOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SelectOptionsT *SelectOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SelectOptionsT>(new SelectOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SelectOptions::UnPackTo(SelectOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SelectOptions::UnPackTo(SelectOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<SelectOptions> SelectOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SelectOptions> SelectOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSelectOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SelectOptions> CreateSelectOptions(flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SelectOptions> CreateSelectOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SelectOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SelectOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SelectOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateSelectOptions(", "       _fbb);", " }", " ", "-inline SliceOptionsT *SliceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SliceOptionsT *SliceOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SliceOptionsT>(new SliceOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SliceOptions::UnPackTo(SliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SliceOptions::UnPackTo(SliceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<SliceOptions> SliceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SliceOptions> SliceOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSliceOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SliceOptions> CreateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SliceOptions> CreateSliceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SliceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SliceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SliceOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateSliceOptions(", "       _fbb);", " }", " ", "-inline TransposeConvOptionsT *TransposeConvOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline TransposeConvOptionsT *TransposeConvOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<TransposeConvOptionsT>(new TransposeConvOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void TransposeConvOptions::UnPackTo(TransposeConvOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void TransposeConvOptions::UnPackTo(TransposeConvOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = padding(); _o->padding = _e; }", "@@ -15413,14 +15420,14 @@ inline void TransposeConvOptions::UnPackTo(TransposeConvOptionsT *_o, const flat", "   { auto _e = fused_activation_function(); _o->fused_activation_function = _e; }", " }", " ", "-inline flatbuffers::Offset<TransposeConvOptions> TransposeConvOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<TransposeConvOptions> TransposeConvOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateTransposeConvOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(::flatbuffers::FlatBufferBuilder &_fbb, const TransposeConvOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransposeConvOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TransposeConvOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _padding = _o->padding;", "   auto _stride_w = _o->stride_w;", "   auto _stride_h = _o->stride_h;", "@@ -15433,180 +15440,180 @@ inline flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(flat", "       _fused_activation_function);", " }", " ", "-inline ExpandDimsOptionsT *ExpandDimsOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ExpandDimsOptionsT *ExpandDimsOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ExpandDimsOptionsT>(new ExpandDimsOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ExpandDimsOptions::UnPackTo(ExpandDimsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ExpandDimsOptions::UnPackTo(ExpandDimsOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<ExpandDimsOptions> ExpandDimsOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ExpandDimsOptions> ExpandDimsOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateExpandDimsOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExpandDimsOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ExpandDimsOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateExpandDimsOptions(", "       _fbb);", " }", " ", "-inline SparseToDenseOptionsT *SparseToDenseOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SparseToDenseOptionsT *SparseToDenseOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SparseToDenseOptionsT>(new SparseToDenseOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SparseToDenseOptions::UnPackTo(SparseToDenseOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SparseToDenseOptions::UnPackTo(SparseToDenseOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = validate_indices(); _o->validate_indices = _e; }", " }", " ", "-inline flatbuffers::Offset<SparseToDenseOptions> SparseToDenseOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SparseToDenseOptions> SparseToDenseOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSparseToDenseOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SparseToDenseOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SparseToDenseOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _validate_indices = _o->validate_indices;", "   return tflite::CreateSparseToDenseOptions(", "       _fbb,", "       _validate_indices);", " }", " ", "-inline EqualOptionsT *EqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline EqualOptionsT *EqualOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<EqualOptionsT>(new EqualOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void EqualOptions::UnPackTo(EqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void EqualOptions::UnPackTo(EqualOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<EqualOptions> EqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<EqualOptions> EqualOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateEqualOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<EqualOptions> CreateEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<EqualOptions> CreateEqualOptions(::flatbuffers::FlatBufferBuilder &_fbb, const EqualOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EqualOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EqualOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateEqualOptions(", "       _fbb);", " }", " ", "-inline NotEqualOptionsT *NotEqualOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline NotEqualOptionsT *NotEqualOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<NotEqualOptionsT>(new NotEqualOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void NotEqualOptions::UnPackTo(NotEqualOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void NotEqualOptions::UnPackTo(NotEqualOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<NotEqualOptions> NotEqualOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<NotEqualOptions> NotEqualOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateNotEqualOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(::flatbuffers::FlatBufferBuilder &_fbb, const NotEqualOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NotEqualOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NotEqualOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateNotEqualOptions(", "       _fbb);", " }", " ", "-inline ShapeOptionsT *ShapeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ShapeOptionsT *ShapeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ShapeOptionsT>(new ShapeOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ShapeOptions::UnPackTo(ShapeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ShapeOptions::UnPackTo(ShapeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = out_type(); _o->out_type = _e; }", " }", " ", "-inline flatbuffers::Offset<ShapeOptions> ShapeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ShapeOptions> ShapeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateShapeOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ShapeOptions> CreateShapeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ShapeOptions> CreateShapeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ShapeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShapeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ShapeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _out_type = _o->out_type;", "   return tflite::CreateShapeOptions(", "       _fbb,", "       _out_type);", " }", " ", "-inline RankOptionsT *RankOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline RankOptionsT *RankOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<RankOptionsT>(new RankOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void RankOptions::UnPackTo(RankOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void RankOptions::UnPackTo(RankOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<RankOptions> RankOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<RankOptions> RankOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateRankOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<RankOptions> CreateRankOptions(flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<RankOptions> CreateRankOptions(::flatbuffers::FlatBufferBuilder &_fbb, const RankOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RankOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RankOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateRankOptions(", "       _fbb);", " }", " ", "-inline PowOptionsT *PowOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline PowOptionsT *PowOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<PowOptionsT>(new PowOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void PowOptions::UnPackTo(PowOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void PowOptions::UnPackTo(PowOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<PowOptions> PowOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<PowOptions> PowOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreatePowOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<PowOptions> CreatePowOptions(flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<PowOptions> CreatePowOptions(::flatbuffers::FlatBufferBuilder &_fbb, const PowOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PowOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PowOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreatePowOptions(", "       _fbb);", " }", " ", "-inline FakeQuantOptionsT *FakeQuantOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline FakeQuantOptionsT *FakeQuantOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<FakeQuantOptionsT>(new FakeQuantOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void FakeQuantOptions::UnPackTo(FakeQuantOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void FakeQuantOptions::UnPackTo(FakeQuantOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = min(); _o->min = _e; }", "@@ -15615,14 +15622,14 @@ inline void FakeQuantOptions::UnPackTo(FakeQuantOptionsT *_o, const flatbuffers:", "   { auto _e = narrow_range(); _o->narrow_range = _e; }", " }", " ", "-inline flatbuffers::Offset<FakeQuantOptions> FakeQuantOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<FakeQuantOptions> FakeQuantOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateFakeQuantOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(::flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FakeQuantOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FakeQuantOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _min = _o->min;", "   auto _max = _o->max;", "   auto _num_bits = _o->num_bits;", "@@ -15635,27 +15642,27 @@ inline flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(flatbuffers:", "       _narrow_range);", " }", " ", "-inline PackOptionsT *PackOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline PackOptionsT *PackOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<PackOptionsT>(new PackOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void PackOptions::UnPackTo(PackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void PackOptions::UnPackTo(PackOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = values_count(); _o->values_count = _e; }", "   { auto _e = axis(); _o->axis = _e; }", " }", " ", "-inline flatbuffers::Offset<PackOptions> PackOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<PackOptions> PackOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreatePackOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<PackOptions> CreatePackOptions(flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<PackOptions> CreatePackOptions(::flatbuffers::FlatBufferBuilder &_fbb, const PackOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PackOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PackOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _values_count = _o->values_count;", "   auto _axis = _o->axis;", "   return tflite::CreatePackOptions(", "@@ -15664,168 +15671,168 @@ inline flatbuffers::Offset<PackOptions> CreatePackOptions(flatbuffers::FlatBuffe", "       _axis);", " }", " ", "-inline LogicalOrOptionsT *LogicalOrOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline LogicalOrOptionsT *LogicalOrOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<LogicalOrOptionsT>(new LogicalOrOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void LogicalOrOptions::UnPackTo(LogicalOrOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void LogicalOrOptions::UnPackTo(LogicalOrOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<LogicalOrOptions> LogicalOrOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<LogicalOrOptions> LogicalOrOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateLogicalOrOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalOrOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LogicalOrOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateLogicalOrOptions(", "       _fbb);", " }", " ", "-inline OneHotOptionsT *OneHotOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline OneHotOptionsT *OneHotOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<OneHotOptionsT>(new OneHotOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void OneHotOptions::UnPackTo(OneHotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void OneHotOptions::UnPackTo(OneHotOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = axis(); _o->axis = _e; }", " }", " ", "-inline flatbuffers::Offset<OneHotOptions> OneHotOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<OneHotOptions> OneHotOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateOneHotOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(::flatbuffers::FlatBufferBuilder &_fbb, const OneHotOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OneHotOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OneHotOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _axis = _o->axis;", "   return tflite::CreateOneHotOptions(", "       _fbb,", "       _axis);", " }", " ", "-inline AbsOptionsT *AbsOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline AbsOptionsT *AbsOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<AbsOptionsT>(new AbsOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void AbsOptions::UnPackTo(AbsOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void AbsOptions::UnPackTo(AbsOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<AbsOptions> AbsOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<AbsOptions> AbsOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateAbsOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<AbsOptions> CreateAbsOptions(flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<AbsOptions> CreateAbsOptions(::flatbuffers::FlatBufferBuilder &_fbb, const AbsOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AbsOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AbsOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateAbsOptions(", "       _fbb);", " }", " ", "-inline HardSwishOptionsT *HardSwishOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline HardSwishOptionsT *HardSwishOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<HardSwishOptionsT>(new HardSwishOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void HardSwishOptions::UnPackTo(HardSwishOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void HardSwishOptions::UnPackTo(HardSwishOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<HardSwishOptions> HardSwishOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<HardSwishOptions> HardSwishOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateHardSwishOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<HardSwishOptions> CreateHardSwishOptions(flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<HardSwishOptions> CreateHardSwishOptions(::flatbuffers::FlatBufferBuilder &_fbb, const HardSwishOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HardSwishOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const HardSwishOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateHardSwishOptions(", "       _fbb);", " }", " ", "-inline LogicalAndOptionsT *LogicalAndOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline LogicalAndOptionsT *LogicalAndOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<LogicalAndOptionsT>(new LogicalAndOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void LogicalAndOptions::UnPackTo(LogicalAndOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void LogicalAndOptions::UnPackTo(LogicalAndOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<LogicalAndOptions> LogicalAndOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<LogicalAndOptions> LogicalAndOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateLogicalAndOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalAndOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LogicalAndOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateLogicalAndOptions(", "       _fbb);", " }", " ", "-inline LogicalNotOptionsT *LogicalNotOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline LogicalNotOptionsT *LogicalNotOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<LogicalNotOptionsT>(new LogicalNotOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void LogicalNotOptions::UnPackTo(LogicalNotOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void LogicalNotOptions::UnPackTo(LogicalNotOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<LogicalNotOptions> LogicalNotOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<LogicalNotOptions> LogicalNotOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateLogicalNotOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalNotOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LogicalNotOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateLogicalNotOptions(", "       _fbb);", " }", " ", "-inline UnpackOptionsT *UnpackOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline UnpackOptionsT *UnpackOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<UnpackOptionsT>(new UnpackOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void UnpackOptions::UnPackTo(UnpackOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void UnpackOptions::UnPackTo(UnpackOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = num(); _o->num = _e; }", "   { auto _e = axis(); _o->axis = _e; }", " }", " ", "-inline flatbuffers::Offset<UnpackOptions> UnpackOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<UnpackOptions> UnpackOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateUnpackOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnpackOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnpackOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UnpackOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _num = _o->num;", "   auto _axis = _o->axis;", "   return tflite::CreateUnpackOptions(", "@@ -15834,358 +15841,358 @@ inline flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(flatbuffers::FlatB", "       _axis);", " }", " ", "-inline FloorDivOptionsT *FloorDivOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline FloorDivOptionsT *FloorDivOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<FloorDivOptionsT>(new FloorDivOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void FloorDivOptions::UnPackTo(FloorDivOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void FloorDivOptions::UnPackTo(FloorDivOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<FloorDivOptions> FloorDivOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<FloorDivOptions> FloorDivOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateFloorDivOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(::flatbuffers::FlatBufferBuilder &_fbb, const FloorDivOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloorDivOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FloorDivOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateFloorDivOptions(", "       _fbb);", " }", " ", "-inline SquareOptionsT *SquareOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SquareOptionsT *SquareOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SquareOptionsT>(new SquareOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SquareOptions::UnPackTo(SquareOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SquareOptions::UnPackTo(SquareOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<SquareOptions> SquareOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SquareOptions> SquareOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSquareOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SquareOptions> CreateSquareOptions(flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SquareOptions> CreateSquareOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SquareOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SquareOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SquareOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateSquareOptions(", "       _fbb);", " }", " ", "-inline ZerosLikeOptionsT *ZerosLikeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ZerosLikeOptionsT *ZerosLikeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ZerosLikeOptionsT>(new ZerosLikeOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ZerosLikeOptions::UnPackTo(ZerosLikeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ZerosLikeOptions::UnPackTo(ZerosLikeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<ZerosLikeOptions> ZerosLikeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ZerosLikeOptions> ZerosLikeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateZerosLikeOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ZerosLikeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ZerosLikeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateZerosLikeOptions(", "       _fbb);", " }", " ", "-inline FillOptionsT *FillOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline FillOptionsT *FillOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<FillOptionsT>(new FillOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void FillOptions::UnPackTo(FillOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void FillOptions::UnPackTo(FillOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<FillOptions> FillOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<FillOptions> FillOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateFillOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<FillOptions> CreateFillOptions(flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<FillOptions> CreateFillOptions(::flatbuffers::FlatBufferBuilder &_fbb, const FillOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FillOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FillOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateFillOptions(", "       _fbb);", " }", " ", "-inline FloorModOptionsT *FloorModOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline FloorModOptionsT *FloorModOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<FloorModOptionsT>(new FloorModOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void FloorModOptions::UnPackTo(FloorModOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void FloorModOptions::UnPackTo(FloorModOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<FloorModOptions> FloorModOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<FloorModOptions> FloorModOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateFloorModOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(::flatbuffers::FlatBufferBuilder &_fbb, const FloorModOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloorModOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FloorModOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateFloorModOptions(", "       _fbb);", " }", " ", "-inline RangeOptionsT *RangeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline RangeOptionsT *RangeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<RangeOptionsT>(new RangeOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void RangeOptions::UnPackTo(RangeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void RangeOptions::UnPackTo(RangeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<RangeOptions> RangeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<RangeOptions> RangeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateRangeOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<RangeOptions> CreateRangeOptions(flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<RangeOptions> CreateRangeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const RangeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RangeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RangeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateRangeOptions(", "       _fbb);", " }", " ", "-inline LeakyReluOptionsT *LeakyReluOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline LeakyReluOptionsT *LeakyReluOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<LeakyReluOptionsT>(new LeakyReluOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void LeakyReluOptions::UnPackTo(LeakyReluOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void LeakyReluOptions::UnPackTo(LeakyReluOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = alpha(); _o->alpha = _e; }", " }", " ", "-inline flatbuffers::Offset<LeakyReluOptions> LeakyReluOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<LeakyReluOptions> LeakyReluOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateLeakyReluOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(::flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LeakyReluOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LeakyReluOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _alpha = _o->alpha;", "   return tflite::CreateLeakyReluOptions(", "       _fbb,", "       _alpha);", " }", " ", "-inline SquaredDifferenceOptionsT *SquaredDifferenceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SquaredDifferenceOptionsT *SquaredDifferenceOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SquaredDifferenceOptionsT>(new SquaredDifferenceOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SquaredDifferenceOptions::UnPackTo(SquaredDifferenceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SquaredDifferenceOptions::UnPackTo(SquaredDifferenceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<SquaredDifferenceOptions> SquaredDifferenceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SquaredDifferenceOptions> SquaredDifferenceOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSquaredDifferenceOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SquaredDifferenceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SquaredDifferenceOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateSquaredDifferenceOptions(", "       _fbb);", " }", " ", "-inline MirrorPadOptionsT *MirrorPadOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline MirrorPadOptionsT *MirrorPadOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<MirrorPadOptionsT>(new MirrorPadOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void MirrorPadOptions::UnPackTo(MirrorPadOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void MirrorPadOptions::UnPackTo(MirrorPadOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = mode(); _o->mode = _e; }", " }", " ", "-inline flatbuffers::Offset<MirrorPadOptions> MirrorPadOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<MirrorPadOptions> MirrorPadOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateMirrorPadOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(::flatbuffers::FlatBufferBuilder &_fbb, const MirrorPadOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MirrorPadOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MirrorPadOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _mode = _o->mode;", "   return tflite::CreateMirrorPadOptions(", "       _fbb,", "       _mode);", " }", " ", "-inline UniqueOptionsT *UniqueOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline UniqueOptionsT *UniqueOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<UniqueOptionsT>(new UniqueOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void UniqueOptions::UnPackTo(UniqueOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void UniqueOptions::UnPackTo(UniqueOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = idx_out_type(); _o->idx_out_type = _e; }", " }", " ", "-inline flatbuffers::Offset<UniqueOptions> UniqueOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<UniqueOptions> UniqueOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateUniqueOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UniqueOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UniqueOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _idx_out_type = _o->idx_out_type;", "   return tflite::CreateUniqueOptions(", "       _fbb,", "       _idx_out_type);", " }", " ", "-inline ReverseV2OptionsT *ReverseV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ReverseV2OptionsT *ReverseV2Options::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ReverseV2OptionsT>(new ReverseV2OptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ReverseV2Options::UnPackTo(ReverseV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ReverseV2Options::UnPackTo(ReverseV2OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<ReverseV2Options> ReverseV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ReverseV2Options> ReverseV2Options::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateReverseV2Options(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(::flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReverseV2OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReverseV2OptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateReverseV2Options(", "       _fbb);", " }", " ", "-inline AddNOptionsT *AddNOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline AddNOptionsT *AddNOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<AddNOptionsT>(new AddNOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void AddNOptions::UnPackTo(AddNOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void AddNOptions::UnPackTo(AddNOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<AddNOptions> AddNOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<AddNOptions> AddNOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateAddNOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<AddNOptions> CreateAddNOptions(flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<AddNOptions> CreateAddNOptions(::flatbuffers::FlatBufferBuilder &_fbb, const AddNOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddNOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AddNOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateAddNOptions(", "       _fbb);", " }", " ", "-inline GatherNdOptionsT *GatherNdOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline GatherNdOptionsT *GatherNdOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<GatherNdOptionsT>(new GatherNdOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void GatherNdOptions::UnPackTo(GatherNdOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void GatherNdOptions::UnPackTo(GatherNdOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<GatherNdOptions> GatherNdOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<GatherNdOptions> GatherNdOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateGatherNdOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(::flatbuffers::FlatBufferBuilder &_fbb, const GatherNdOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GatherNdOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GatherNdOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateGatherNdOptions(", "       _fbb);", " }", " ", "-inline WhereOptionsT *WhereOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline WhereOptionsT *WhereOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<WhereOptionsT>(new WhereOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void WhereOptions::UnPackTo(WhereOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void WhereOptions::UnPackTo(WhereOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<WhereOptions> WhereOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<WhereOptions> WhereOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateWhereOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<WhereOptions> CreateWhereOptions(flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<WhereOptions> CreateWhereOptions(::flatbuffers::FlatBufferBuilder &_fbb, const WhereOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WhereOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const WhereOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateWhereOptions(", "       _fbb);", " }", " ", "-inline ReverseSequenceOptionsT *ReverseSequenceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ReverseSequenceOptionsT *ReverseSequenceOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ReverseSequenceOptionsT>(new ReverseSequenceOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ReverseSequenceOptions::UnPackTo(ReverseSequenceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ReverseSequenceOptions::UnPackTo(ReverseSequenceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = seq_dim(); _o->seq_dim = _e; }", "   { auto _e = batch_dim(); _o->batch_dim = _e; }", " }", " ", "-inline flatbuffers::Offset<ReverseSequenceOptions> ReverseSequenceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ReverseSequenceOptions> ReverseSequenceOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateReverseSequenceOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReverseSequenceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReverseSequenceOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _seq_dim = _o->seq_dim;", "   auto _batch_dim = _o->batch_dim;", "   return tflite::CreateReverseSequenceOptions(", "@@ -16194,96 +16201,96 @@ inline flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(", "       _batch_dim);", " }", " ", "-inline MatrixDiagOptionsT *MatrixDiagOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline MatrixDiagOptionsT *MatrixDiagOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<MatrixDiagOptionsT>(new MatrixDiagOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void MatrixDiagOptions::UnPackTo(MatrixDiagOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void MatrixDiagOptions::UnPackTo(MatrixDiagOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<MatrixDiagOptions> MatrixDiagOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<MatrixDiagOptions> MatrixDiagOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateMatrixDiagOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<MatrixDiagOptions> CreateMatrixDiagOptions(flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<MatrixDiagOptions> CreateMatrixDiagOptions(::flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MatrixDiagOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MatrixDiagOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateMatrixDiagOptions(", "       _fbb);", " }", " ", "-inline QuantizeOptionsT *QuantizeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline QuantizeOptionsT *QuantizeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<QuantizeOptionsT>(new QuantizeOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void QuantizeOptions::UnPackTo(QuantizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void QuantizeOptions::UnPackTo(QuantizeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<QuantizeOptions> QuantizeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<QuantizeOptions> QuantizeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateQuantizeOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const QuantizeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuantizeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const QuantizeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateQuantizeOptions(", "       _fbb);", " }", " ", "-inline MatrixSetDiagOptionsT *MatrixSetDiagOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline MatrixSetDiagOptionsT *MatrixSetDiagOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<MatrixSetDiagOptionsT>(new MatrixSetDiagOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void MatrixSetDiagOptions::UnPackTo(MatrixSetDiagOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void MatrixSetDiagOptions::UnPackTo(MatrixSetDiagOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<MatrixSetDiagOptions> MatrixSetDiagOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<MatrixSetDiagOptions> MatrixSetDiagOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateMatrixSetDiagOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<MatrixSetDiagOptions> CreateMatrixSetDiagOptions(flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<MatrixSetDiagOptions> CreateMatrixSetDiagOptions(::flatbuffers::FlatBufferBuilder &_fbb, const MatrixSetDiagOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MatrixSetDiagOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MatrixSetDiagOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateMatrixSetDiagOptions(", "       _fbb);", " }", " ", "-inline IfOptionsT *IfOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline IfOptionsT *IfOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<IfOptionsT>(new IfOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void IfOptions::UnPackTo(IfOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void IfOptions::UnPackTo(IfOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = then_subgraph_index(); _o->then_subgraph_index = _e; }", "   { auto _e = else_subgraph_index(); _o->else_subgraph_index = _e; }", " }", " ", "-inline flatbuffers::Offset<IfOptions> IfOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<IfOptions> IfOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateIfOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<IfOptions> CreateIfOptions(flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<IfOptions> CreateIfOptions(::flatbuffers::FlatBufferBuilder &_fbb, const IfOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IfOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const IfOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _then_subgraph_index = _o->then_subgraph_index;", "   auto _else_subgraph_index = _o->else_subgraph_index;", "   return tflite::CreateIfOptions(", "@@ -16292,53 +16299,53 @@ inline flatbuffers::Offset<IfOptions> CreateIfOptions(flatbuffers::FlatBufferBui", "       _else_subgraph_index);", " }", " ", "-inline CallOnceOptionsT *CallOnceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline CallOnceOptionsT *CallOnceOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<CallOnceOptionsT>(new CallOnceOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void CallOnceOptions::UnPackTo(CallOnceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void CallOnceOptions::UnPackTo(CallOnceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = init_subgraph_index(); _o->init_subgraph_index = _e; }", " }", " ", "-inline flatbuffers::Offset<CallOnceOptions> CallOnceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<CallOnceOptions> CallOnceOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateCallOnceOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<CallOnceOptions> CreateCallOnceOptions(flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<CallOnceOptions> CreateCallOnceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const CallOnceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CallOnceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CallOnceOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _init_subgraph_index = _o->init_subgraph_index;", "   return tflite::CreateCallOnceOptions(", "       _fbb,", "       _init_subgraph_index);", " }", " ", "-inline WhileOptionsT *WhileOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline WhileOptionsT *WhileOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<WhileOptionsT>(new WhileOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void WhileOptions::UnPackTo(WhileOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void WhileOptions::UnPackTo(WhileOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = cond_subgraph_index(); _o->cond_subgraph_index = _e; }", "   { auto _e = body_subgraph_index(); _o->body_subgraph_index = _e; }", " }", " ", "-inline flatbuffers::Offset<WhileOptions> WhileOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<WhileOptions> WhileOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateWhileOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<WhileOptions> CreateWhileOptions(flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<WhileOptions> CreateWhileOptions(::flatbuffers::FlatBufferBuilder &_fbb, const WhileOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WhileOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const WhileOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _cond_subgraph_index = _o->cond_subgraph_index;", "   auto _body_subgraph_index = _o->body_subgraph_index;", "   return tflite::CreateWhileOptions(", "@@ -16347,151 +16354,151 @@ inline flatbuffers::Offset<WhileOptions> CreateWhileOptions(flatbuffers::FlatBuf", "       _body_subgraph_index);", " }", " ", "-inline NonMaxSuppressionV4OptionsT *NonMaxSuppressionV4Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline NonMaxSuppressionV4OptionsT *NonMaxSuppressionV4Options::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<NonMaxSuppressionV4OptionsT>(new NonMaxSuppressionV4OptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void NonMaxSuppressionV4Options::UnPackTo(NonMaxSuppressionV4OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void NonMaxSuppressionV4Options::UnPackTo(NonMaxSuppressionV4OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<NonMaxSuppressionV4Options> NonMaxSuppressionV4Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<NonMaxSuppressionV4Options> NonMaxSuppressionV4Options::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateNonMaxSuppressionV4Options(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<NonMaxSuppressionV4Options> CreateNonMaxSuppressionV4Options(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<NonMaxSuppressionV4Options> CreateNonMaxSuppressionV4Options(::flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV4OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NonMaxSuppressionV4OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NonMaxSuppressionV4OptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateNonMaxSuppressionV4Options(", "       _fbb);", " }", " ", "-inline NonMaxSuppressionV5OptionsT *NonMaxSuppressionV5Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline NonMaxSuppressionV5OptionsT *NonMaxSuppressionV5Options::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<NonMaxSuppressionV5OptionsT>(new NonMaxSuppressionV5OptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void NonMaxSuppressionV5Options::UnPackTo(NonMaxSuppressionV5OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void NonMaxSuppressionV5Options::UnPackTo(NonMaxSuppressionV5OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<NonMaxSuppressionV5Options> NonMaxSuppressionV5Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<NonMaxSuppressionV5Options> NonMaxSuppressionV5Options::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateNonMaxSuppressionV5Options(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<NonMaxSuppressionV5Options> CreateNonMaxSuppressionV5Options(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<NonMaxSuppressionV5Options> CreateNonMaxSuppressionV5Options(::flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionV5OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NonMaxSuppressionV5OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NonMaxSuppressionV5OptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateNonMaxSuppressionV5Options(", "       _fbb);", " }", " ", "-inline ScatterNdOptionsT *ScatterNdOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ScatterNdOptionsT *ScatterNdOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ScatterNdOptionsT>(new ScatterNdOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ScatterNdOptions::UnPackTo(ScatterNdOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ScatterNdOptions::UnPackTo(ScatterNdOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<ScatterNdOptions> ScatterNdOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ScatterNdOptions> ScatterNdOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateScatterNdOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ScatterNdOptions> CreateScatterNdOptions(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ScatterNdOptions> CreateScatterNdOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScatterNdOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ScatterNdOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateScatterNdOptions(", "       _fbb);", " }", " ", "-inline SelectV2OptionsT *SelectV2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SelectV2OptionsT *SelectV2Options::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SelectV2OptionsT>(new SelectV2OptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SelectV2Options::UnPackTo(SelectV2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SelectV2Options::UnPackTo(SelectV2OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<SelectV2Options> SelectV2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SelectV2Options> SelectV2Options::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSelectV2Options(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SelectV2Options> CreateSelectV2Options(flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SelectV2Options> CreateSelectV2Options(::flatbuffers::FlatBufferBuilder &_fbb, const SelectV2OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SelectV2OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SelectV2OptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateSelectV2Options(", "       _fbb);", " }", " ", "-inline DensifyOptionsT *DensifyOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline DensifyOptionsT *DensifyOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<DensifyOptionsT>(new DensifyOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void DensifyOptions::UnPackTo(DensifyOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void DensifyOptions::UnPackTo(DensifyOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<DensifyOptions> DensifyOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<DensifyOptions> DensifyOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateDensifyOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<DensifyOptions> CreateDensifyOptions(flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<DensifyOptions> CreateDensifyOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DensifyOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DensifyOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DensifyOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateDensifyOptions(", "       _fbb);", " }", " ", "-inline SegmentSumOptionsT *SegmentSumOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SegmentSumOptionsT *SegmentSumOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SegmentSumOptionsT>(new SegmentSumOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SegmentSumOptions::UnPackTo(SegmentSumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SegmentSumOptions::UnPackTo(SegmentSumOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<SegmentSumOptions> SegmentSumOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SegmentSumOptions> SegmentSumOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSegmentSumOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SegmentSumOptions> CreateSegmentSumOptions(flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SegmentSumOptions> CreateSegmentSumOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SegmentSumOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SegmentSumOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SegmentSumOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateSegmentSumOptions(", "       _fbb);", " }", " ", "-inline BatchMatMulOptionsT *BatchMatMulOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline BatchMatMulOptionsT *BatchMatMulOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<BatchMatMulOptionsT>(new BatchMatMulOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void BatchMatMulOptions::UnPackTo(BatchMatMulOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void BatchMatMulOptions::UnPackTo(BatchMatMulOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = adj_x(); _o->adj_x = _e; }", "@@ -16499,14 +16506,14 @@ inline void BatchMatMulOptions::UnPackTo(BatchMatMulOptionsT *_o, const flatbuff", "   { auto _e = asymmetric_quantize_inputs(); _o->asymmetric_quantize_inputs = _e; }", " }", " ", "-inline flatbuffers::Offset<BatchMatMulOptions> BatchMatMulOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BatchMatMulOptions> BatchMatMulOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateBatchMatMulOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BatchMatMulOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchMatMulOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BatchMatMulOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _adj_x = _o->adj_x;", "   auto _adj_y = _o->adj_y;", "   auto _asymmetric_quantize_inputs = _o->asymmetric_quantize_inputs;", "@@ -16517,27 +16524,27 @@ inline flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(flatbuff", "       _asymmetric_quantize_inputs);", " }", " ", "-inline CumsumOptionsT *CumsumOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline CumsumOptionsT *CumsumOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<CumsumOptionsT>(new CumsumOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void CumsumOptions::UnPackTo(CumsumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void CumsumOptions::UnPackTo(CumsumOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = exclusive(); _o->exclusive = _e; }", "   { auto _e = reverse(); _o->reverse = _e; }", " }", " ", "-inline flatbuffers::Offset<CumsumOptions> CumsumOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<CumsumOptions> CumsumOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateCumsumOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<CumsumOptions> CreateCumsumOptions(flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<CumsumOptions> CreateCumsumOptions(::flatbuffers::FlatBufferBuilder &_fbb, const CumsumOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CumsumOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CumsumOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _exclusive = _o->exclusive;", "   auto _reverse = _o->reverse;", "   return tflite::CreateCumsumOptions(", "@@ -16546,59 +16553,59 @@ inline flatbuffers::Offset<CumsumOptions> CreateCumsumOptions(flatbuffers::FlatB", "       _reverse);", " }", " ", "-inline BroadcastToOptionsT *BroadcastToOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline BroadcastToOptionsT *BroadcastToOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<BroadcastToOptionsT>(new BroadcastToOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void BroadcastToOptions::UnPackTo(BroadcastToOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void BroadcastToOptions::UnPackTo(BroadcastToOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<BroadcastToOptions> BroadcastToOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BroadcastToOptions> BroadcastToOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateBroadcastToOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<BroadcastToOptions> CreateBroadcastToOptions(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BroadcastToOptions> CreateBroadcastToOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BroadcastToOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BroadcastToOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateBroadcastToOptions(", "       _fbb);", " }", " ", "-inline Rfft2dOptionsT *Rfft2dOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline Rfft2dOptionsT *Rfft2dOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<Rfft2dOptionsT>(new Rfft2dOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void Rfft2dOptions::UnPackTo(Rfft2dOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void Rfft2dOptions::UnPackTo(Rfft2dOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<Rfft2dOptions> Rfft2dOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Rfft2dOptions> Rfft2dOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateRfft2dOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<Rfft2dOptions> CreateRfft2dOptions(flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Rfft2dOptions> CreateRfft2dOptions(::flatbuffers::FlatBufferBuilder &_fbb, const Rfft2dOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Rfft2dOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Rfft2dOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateRfft2dOptions(", "       _fbb);", " }", " ", "-inline HashtableOptionsT *HashtableOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline HashtableOptionsT *HashtableOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<HashtableOptionsT>(new HashtableOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void HashtableOptions::UnPackTo(HashtableOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void HashtableOptions::UnPackTo(HashtableOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = table_id(); _o->table_id = _e; }", "@@ -16606,14 +16613,14 @@ inline void HashtableOptions::UnPackTo(HashtableOptionsT *_o, const flatbuffers:", "   { auto _e = value_dtype(); _o->value_dtype = _e; }", " }", " ", "-inline flatbuffers::Offset<HashtableOptions> HashtableOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<HashtableOptions> HashtableOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateHashtableOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<HashtableOptions> CreateHashtableOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<HashtableOptions> CreateHashtableOptions(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HashtableOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const HashtableOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _table_id = _o->table_id;", "   auto _key_dtype = _o->key_dtype;", "   auto _value_dtype = _o->value_dtype;", "@@ -16624,96 +16631,96 @@ inline flatbuffers::Offset<HashtableOptions> CreateHashtableOptions(flatbuffers:", "       _value_dtype);", " }", " ", "-inline HashtableFindOptionsT *HashtableFindOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline HashtableFindOptionsT *HashtableFindOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<HashtableFindOptionsT>(new HashtableFindOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void HashtableFindOptions::UnPackTo(HashtableFindOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void HashtableFindOptions::UnPackTo(HashtableFindOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<HashtableFindOptions> HashtableFindOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<HashtableFindOptions> HashtableFindOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateHashtableFindOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<HashtableFindOptions> CreateHashtableFindOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<HashtableFindOptions> CreateHashtableFindOptions(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableFindOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HashtableFindOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const HashtableFindOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateHashtableFindOptions(", "       _fbb);", " }", " ", "-inline HashtableImportOptionsT *HashtableImportOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline HashtableImportOptionsT *HashtableImportOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<HashtableImportOptionsT>(new HashtableImportOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void HashtableImportOptions::UnPackTo(HashtableImportOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void HashtableImportOptions::UnPackTo(HashtableImportOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<HashtableImportOptions> HashtableImportOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<HashtableImportOptions> HashtableImportOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateHashtableImportOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<HashtableImportOptions> CreateHashtableImportOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<HashtableImportOptions> CreateHashtableImportOptions(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableImportOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HashtableImportOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const HashtableImportOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateHashtableImportOptions(", "       _fbb);", " }", " ", "-inline HashtableSizeOptionsT *HashtableSizeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline HashtableSizeOptionsT *HashtableSizeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<HashtableSizeOptionsT>(new HashtableSizeOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void HashtableSizeOptions::UnPackTo(HashtableSizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void HashtableSizeOptions::UnPackTo(HashtableSizeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<HashtableSizeOptions> HashtableSizeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<HashtableSizeOptions> HashtableSizeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateHashtableSizeOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<HashtableSizeOptions> CreateHashtableSizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<HashtableSizeOptions> CreateHashtableSizeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const HashtableSizeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HashtableSizeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const HashtableSizeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateHashtableSizeOptions(", "       _fbb);", " }", " ", "-inline VarHandleOptionsT *VarHandleOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline VarHandleOptionsT *VarHandleOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<VarHandleOptionsT>(new VarHandleOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void VarHandleOptions::UnPackTo(VarHandleOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void VarHandleOptions::UnPackTo(VarHandleOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = container(); if (_e) _o->container = _e->str(); }", "   { auto _e = shared_name(); if (_e) _o->shared_name = _e->str(); }", " }", " ", "-inline flatbuffers::Offset<VarHandleOptions> VarHandleOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<VarHandleOptions> VarHandleOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateVarHandleOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptions(flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptions(::flatbuffers::FlatBufferBuilder &_fbb, const VarHandleOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VarHandleOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const VarHandleOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _container = _o->container.empty() ? 0 : _fbb.CreateString(_o->container);", "   auto _shared_name = _o->shared_name.empty() ? 0 : _fbb.CreateString(_o->shared_name);", "   return tflite::CreateVarHandleOptions(", "@@ -16722,73 +16729,73 @@ inline flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptions(flatbuffers:", "       _shared_name);", " }", " ", "-inline ReadVariableOptionsT *ReadVariableOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ReadVariableOptionsT *ReadVariableOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ReadVariableOptionsT>(new ReadVariableOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ReadVariableOptions::UnPackTo(ReadVariableOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ReadVariableOptions::UnPackTo(ReadVariableOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<ReadVariableOptions> ReadVariableOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ReadVariableOptions> ReadVariableOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateReadVariableOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ReadVariableOptions> CreateReadVariableOptions(flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ReadVariableOptions> CreateReadVariableOptions(::flatbuffers::FlatBufferBuilder &_fbb, const ReadVariableOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReadVariableOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReadVariableOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateReadVariableOptions(", "       _fbb);", " }", " ", "-inline AssignVariableOptionsT *AssignVariableOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline AssignVariableOptionsT *AssignVariableOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<AssignVariableOptionsT>(new AssignVariableOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void AssignVariableOptions::UnPackTo(AssignVariableOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void AssignVariableOptions::UnPackTo(AssignVariableOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<AssignVariableOptions> AssignVariableOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<AssignVariableOptions> AssignVariableOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateAssignVariableOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<AssignVariableOptions> CreateAssignVariableOptions(flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<AssignVariableOptions> CreateAssignVariableOptions(::flatbuffers::FlatBufferBuilder &_fbb, const AssignVariableOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AssignVariableOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AssignVariableOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateAssignVariableOptions(", "       _fbb);", " }", " ", "-inline RandomOptionsT *RandomOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline RandomOptionsT *RandomOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<RandomOptionsT>(new RandomOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void RandomOptions::UnPackTo(RandomOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void RandomOptions::UnPackTo(RandomOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = seed(); _o->seed = _e; }", "   { auto _e = seed2(); _o->seed2 = _e; }", " }", " ", "-inline flatbuffers::Offset<RandomOptions> RandomOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<RandomOptions> RandomOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateRandomOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<RandomOptions> CreateRandomOptions(flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<RandomOptions> CreateRandomOptions(::flatbuffers::FlatBufferBuilder &_fbb, const RandomOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RandomOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RandomOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _seed = _o->seed;", "   auto _seed2 = _o->seed2;", "   return tflite::CreateRandomOptions(", "@@ -16797,249 +16804,249 @@ inline flatbuffers::Offset<RandomOptions> CreateRandomOptions(flatbuffers::FlatB", "       _seed2);", " }", " ", "-inline BucketizeOptionsT *BucketizeOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline BucketizeOptionsT *BucketizeOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<BucketizeOptionsT>(new BucketizeOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void BucketizeOptions::UnPackTo(BucketizeOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void BucketizeOptions::UnPackTo(BucketizeOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "-  { auto _e = boundaries(); if (_e) { _o->boundaries.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->boundaries[_i] = _e->Get(_i); } } }", "+  { auto _e = boundaries(); if (_e) { _o->boundaries.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->boundaries[_i] = _e->Get(_i); } } else { _o->boundaries.resize(0); } }", " }", " ", "-inline flatbuffers::Offset<BucketizeOptions> BucketizeOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BucketizeOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BucketizeOptions> BucketizeOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BucketizeOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateBucketizeOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptions(flatbuffers::FlatBufferBuilder &_fbb, const BucketizeOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BucketizeOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BucketizeOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BucketizeOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _boundaries = _o->boundaries.size() ? _fbb.CreateVector(_o->boundaries) : 0;", "   return tflite::CreateBucketizeOptions(", "       _fbb,", "       _boundaries);", " }", " ", "-inline GeluOptionsT *GeluOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline GeluOptionsT *GeluOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<GeluOptionsT>(new GeluOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void GeluOptions::UnPackTo(GeluOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void GeluOptions::UnPackTo(GeluOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = approximate(); _o->approximate = _e; }", " }", " ", "-inline flatbuffers::Offset<GeluOptions> GeluOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeluOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<GeluOptions> GeluOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeluOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateGeluOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<GeluOptions> CreateGeluOptions(flatbuffers::FlatBufferBuilder &_fbb, const GeluOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<GeluOptions> CreateGeluOptions(::flatbuffers::FlatBufferBuilder &_fbb, const GeluOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GeluOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GeluOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _approximate = _o->approximate;", "   return tflite::CreateGeluOptions(", "       _fbb,", "       _approximate);", " }", " ", "-inline DynamicUpdateSliceOptionsT *DynamicUpdateSliceOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline DynamicUpdateSliceOptionsT *DynamicUpdateSliceOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<DynamicUpdateSliceOptionsT>(new DynamicUpdateSliceOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void DynamicUpdateSliceOptions::UnPackTo(DynamicUpdateSliceOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void DynamicUpdateSliceOptions::UnPackTo(DynamicUpdateSliceOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<DynamicUpdateSliceOptions> DynamicUpdateSliceOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DynamicUpdateSliceOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<DynamicUpdateSliceOptions> DynamicUpdateSliceOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DynamicUpdateSliceOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateDynamicUpdateSliceOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<DynamicUpdateSliceOptions> CreateDynamicUpdateSliceOptions(flatbuffers::FlatBufferBuilder &_fbb, const DynamicUpdateSliceOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<DynamicUpdateSliceOptions> CreateDynamicUpdateSliceOptions(::flatbuffers::FlatBufferBuilder &_fbb, const DynamicUpdateSliceOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DynamicUpdateSliceOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DynamicUpdateSliceOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateDynamicUpdateSliceOptions(", "       _fbb);", " }", " ", "-inline UnsortedSegmentProdOptionsT *UnsortedSegmentProdOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline UnsortedSegmentProdOptionsT *UnsortedSegmentProdOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<UnsortedSegmentProdOptionsT>(new UnsortedSegmentProdOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void UnsortedSegmentProdOptions::UnPackTo(UnsortedSegmentProdOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void UnsortedSegmentProdOptions::UnPackTo(UnsortedSegmentProdOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<UnsortedSegmentProdOptions> UnsortedSegmentProdOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentProdOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<UnsortedSegmentProdOptions> UnsortedSegmentProdOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentProdOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateUnsortedSegmentProdOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<UnsortedSegmentProdOptions> CreateUnsortedSegmentProdOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentProdOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<UnsortedSegmentProdOptions> CreateUnsortedSegmentProdOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentProdOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnsortedSegmentProdOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UnsortedSegmentProdOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateUnsortedSegmentProdOptions(", "       _fbb);", " }", " ", "-inline UnsortedSegmentMaxOptionsT *UnsortedSegmentMaxOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline UnsortedSegmentMaxOptionsT *UnsortedSegmentMaxOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<UnsortedSegmentMaxOptionsT>(new UnsortedSegmentMaxOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void UnsortedSegmentMaxOptions::UnPackTo(UnsortedSegmentMaxOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void UnsortedSegmentMaxOptions::UnPackTo(UnsortedSegmentMaxOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<UnsortedSegmentMaxOptions> UnsortedSegmentMaxOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMaxOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<UnsortedSegmentMaxOptions> UnsortedSegmentMaxOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMaxOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateUnsortedSegmentMaxOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<UnsortedSegmentMaxOptions> CreateUnsortedSegmentMaxOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMaxOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<UnsortedSegmentMaxOptions> CreateUnsortedSegmentMaxOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMaxOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnsortedSegmentMaxOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UnsortedSegmentMaxOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateUnsortedSegmentMaxOptions(", "       _fbb);", " }", " ", "-inline UnsortedSegmentSumOptionsT *UnsortedSegmentSumOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline UnsortedSegmentSumOptionsT *UnsortedSegmentSumOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<UnsortedSegmentSumOptionsT>(new UnsortedSegmentSumOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void UnsortedSegmentSumOptions::UnPackTo(UnsortedSegmentSumOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void UnsortedSegmentSumOptions::UnPackTo(UnsortedSegmentSumOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<UnsortedSegmentSumOptions> UnsortedSegmentSumOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<UnsortedSegmentSumOptions> UnsortedSegmentSumOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateUnsortedSegmentSumOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<UnsortedSegmentSumOptions> CreateUnsortedSegmentSumOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<UnsortedSegmentSumOptions> CreateUnsortedSegmentSumOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnsortedSegmentSumOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UnsortedSegmentSumOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateUnsortedSegmentSumOptions(", "       _fbb);", " }", " ", "-inline ATan2OptionsT *ATan2Options::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ATan2OptionsT *ATan2Options::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ATan2OptionsT>(new ATan2OptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void ATan2Options::UnPackTo(ATan2OptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void ATan2Options::UnPackTo(ATan2OptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<ATan2Options> ATan2Options::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ATan2OptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ATan2Options> ATan2Options::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ATan2OptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateATan2Options(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<ATan2Options> CreateATan2Options(flatbuffers::FlatBufferBuilder &_fbb, const ATan2OptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<ATan2Options> CreateATan2Options(::flatbuffers::FlatBufferBuilder &_fbb, const ATan2OptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ATan2OptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ATan2OptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateATan2Options(", "       _fbb);", " }", " ", "-inline UnsortedSegmentMinOptionsT *UnsortedSegmentMinOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline UnsortedSegmentMinOptionsT *UnsortedSegmentMinOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<UnsortedSegmentMinOptionsT>(new UnsortedSegmentMinOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void UnsortedSegmentMinOptions::UnPackTo(UnsortedSegmentMinOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void UnsortedSegmentMinOptions::UnPackTo(UnsortedSegmentMinOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<UnsortedSegmentMinOptions> UnsortedSegmentMinOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMinOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<UnsortedSegmentMinOptions> UnsortedSegmentMinOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMinOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateUnsortedSegmentMinOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<UnsortedSegmentMinOptions> CreateUnsortedSegmentMinOptions(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMinOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<UnsortedSegmentMinOptions> CreateUnsortedSegmentMinOptions(::flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentMinOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnsortedSegmentMinOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UnsortedSegmentMinOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateUnsortedSegmentMinOptions(", "       _fbb);", " }", " ", "-inline SignOptionsT *SignOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SignOptionsT *SignOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SignOptionsT>(new SignOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SignOptions::UnPackTo(SignOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SignOptions::UnPackTo(SignOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<SignOptions> SignOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SignOptions> SignOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SignOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSignOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SignOptions> CreateSignOptions(flatbuffers::FlatBufferBuilder &_fbb, const SignOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SignOptions> CreateSignOptions(::flatbuffers::FlatBufferBuilder &_fbb, const SignOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SignOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SignOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateSignOptions(", "       _fbb);", " }", " ", "-inline BitcastOptionsT *BitcastOptions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline BitcastOptionsT *BitcastOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<BitcastOptionsT>(new BitcastOptionsT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void BitcastOptions::UnPackTo(BitcastOptionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void BitcastOptions::UnPackTo(BitcastOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", " }", " ", "-inline flatbuffers::Offset<BitcastOptions> BitcastOptions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BitcastOptionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BitcastOptions> BitcastOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BitcastOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateBitcastOptions(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<BitcastOptions> CreateBitcastOptions(flatbuffers::FlatBufferBuilder &_fbb, const BitcastOptionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<BitcastOptions> CreateBitcastOptions(::flatbuffers::FlatBufferBuilder &_fbb, const BitcastOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BitcastOptionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BitcastOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   return tflite::CreateBitcastOptions(", "       _fbb);", " }", " ", "-inline OperatorCodeT *OperatorCode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline OperatorCodeT *OperatorCode::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<OperatorCodeT>(new OperatorCodeT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void OperatorCode::UnPackTo(OperatorCodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void OperatorCode::UnPackTo(OperatorCodeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = deprecated_builtin_code(); _o->deprecated_builtin_code = _e; }", "@@ -17048,14 +17055,14 @@ inline void OperatorCode::UnPackTo(OperatorCodeT *_o, const flatbuffers::resolve", "   { auto _e = builtin_code(); _o->builtin_code = _e; }", " }", " ", "-inline flatbuffers::Offset<OperatorCode> OperatorCode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<OperatorCode> OperatorCode::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateOperatorCode(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<OperatorCode> CreateOperatorCode(flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<OperatorCode> CreateOperatorCode(::flatbuffers::FlatBufferBuilder &_fbb, const OperatorCodeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OperatorCodeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OperatorCodeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _deprecated_builtin_code = _o->deprecated_builtin_code;", "   auto _custom_code = _o->custom_code.empty() ? 0 : _fbb.CreateString(_o->custom_code);", "   auto _version = _o->version;", "@@ -17068,34 +17075,34 @@ inline flatbuffers::Offset<OperatorCode> CreateOperatorCode(flatbuffers::FlatBuf", "       _builtin_code);", " }", " ", "-inline OperatorT *Operator::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline OperatorT *Operator::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<OperatorT>(new OperatorT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void Operator::UnPackTo(OperatorT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void Operator::UnPackTo(OperatorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = opcode_index(); _o->opcode_index = _e; }", "-  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = _e->Get(_i); } } }", "-  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = _e->Get(_i); } } }", "+  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = _e->Get(_i); } } else { _o->inputs.resize(0); } }", "+  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = _e->Get(_i); } } else { _o->outputs.resize(0); } }", "   { auto _e = builtin_options_type(); _o->builtin_options.type = _e; }", "   { auto _e = builtin_options(); if (_e) _o->builtin_options.value = tflite::BuiltinOptionsUnion::UnPack(_e, builtin_options_type(), _resolver); }", "   { auto _e = custom_options(); if (_e) { _o->custom_options.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->custom_options.begin()); } }", "   { auto _e = custom_options_format(); _o->custom_options_format = _e; }", "-  { auto _e = mutating_variable_inputs(); if (_e) { _o->mutating_variable_inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mutating_variable_inputs[_i] = _e->Get(_i) != 0; } } }", "-  { auto _e = intermediates(); if (_e) { _o->intermediates.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->intermediates[_i] = _e->Get(_i); } } }", "+  { auto _e = mutating_variable_inputs(); if (_e) { _o->mutating_variable_inputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mutating_variable_inputs[_i] = _e->Get(_i) != 0; } } else { _o->mutating_variable_inputs.resize(0); } }", "+  { auto _e = intermediates(); if (_e) { _o->intermediates.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->intermediates[_i] = _e->Get(_i); } } else { _o->intermediates.resize(0); } }", " }", " ", "-inline flatbuffers::Offset<Operator> Operator::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Operator> Operator::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OperatorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateOperator(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<Operator> CreateOperator(flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Operator> CreateOperator(::flatbuffers::FlatBufferBuilder &_fbb, const OperatorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OperatorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OperatorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _opcode_index = _o->opcode_index;", "   auto _inputs = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;", "   auto _outputs = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;", "@@ -17123,9 +17130,9 @@ inline SubGraphT::SubGraphT(const SubGraphT &o)", "         outputs(o.outputs),", "         name(o.name) {", "   tensors.reserve(o.tensors.size());", "-  for (const auto &v : o.tensors) { tensors.emplace_back((v) ? new tflite::TensorT(*v) : nullptr); }", "+  for (const auto &tensors_ : o.tensors) { tensors.emplace_back((tensors_) ? new tflite::TensorT(*tensors_) : nullptr); }", "   operators.reserve(o.operators.size());", "-  for (const auto &v : o.operators) { operators.emplace_back((v) ? new tflite::OperatorT(*v) : nullptr); }", "+  for (const auto &operators_ : o.operators) { operators.emplace_back((operators_) ? new tflite::OperatorT(*operators_) : nullptr); }", " }", " ", " inline SubGraphT &SubGraphT::operator=(SubGraphT o) FLATBUFFERS_NOEXCEPT {", "@@ -17137,34 +17144,34 @@ inline SubGraphT &SubGraphT::operator=(SubGraphT o) FLATBUFFERS_NOEXCEPT {", "   return *this;", " }", " ", "-inline SubGraphT *SubGraph::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SubGraphT *SubGraph::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SubGraphT>(new SubGraphT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SubGraph::UnPackTo(SubGraphT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SubGraph::UnPackTo(SubGraphT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "-  { auto _e = tensors(); if (_e) { _o->tensors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->tensors[_i]) { _e->Get(_i)->UnPackTo(_o->tensors[_i].get(), _resolver); } else { _o->tensors[_i] = std::unique_ptr<tflite::TensorT>(_e->Get(_i)->UnPack(_resolver)); }; } } }", "-  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = _e->Get(_i); } } }", "-  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = _e->Get(_i); } } }", "-  { auto _e = operators(); if (_e) { _o->operators.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->operators[_i]) { _e->Get(_i)->UnPackTo(_o->operators[_i].get(), _resolver); } else { _o->operators[_i] = std::unique_ptr<tflite::OperatorT>(_e->Get(_i)->UnPack(_resolver)); }; } } }", "+  { auto _e = tensors(); if (_e) { _o->tensors.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->tensors[_i]) { _e->Get(_i)->UnPackTo(_o->tensors[_i].get(), _resolver); } else { _o->tensors[_i] = std::unique_ptr<tflite::TensorT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->tensors.resize(0); } }", "+  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = _e->Get(_i); } } else { _o->inputs.resize(0); } }", "+  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = _e->Get(_i); } } else { _o->outputs.resize(0); } }", "+  { auto _e = operators(); if (_e) { _o->operators.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->operators[_i]) { _e->Get(_i)->UnPackTo(_o->operators[_i].get(), _resolver); } else { _o->operators[_i] = std::unique_ptr<tflite::OperatorT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->operators.resize(0); } }", "   { auto _e = name(); if (_e) _o->name = _e->str(); }", " }", " ", "-inline flatbuffers::Offset<SubGraph> SubGraph::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SubGraph> SubGraph::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSubGraph(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SubGraph> CreateSubGraph(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SubGraph> CreateSubGraph(::flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubGraphT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "-  auto _tensors = _o->tensors.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::Tensor>> (_o->tensors.size(), [](size_t i, _VectorArgs *__va) { return CreateTensor(*__va->__fbb, __va->__o->tensors[i].get(), __va->__rehasher); }, &_va ) : 0;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SubGraphT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  auto _tensors = _o->tensors.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::Tensor>> (_o->tensors.size(), [](size_t i, _VectorArgs *__va) { return CreateTensor(*__va->__fbb, __va->__o->tensors[i].get(), __va->__rehasher); }, &_va ) : 0;", "   auto _inputs = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;", "   auto _outputs = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;", "-  auto _operators = _o->operators.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::Operator>> (_o->operators.size(), [](size_t i, _VectorArgs *__va) { return CreateOperator(*__va->__fbb, __va->__o->operators[i].get(), __va->__rehasher); }, &_va ) : 0;", "+  auto _operators = _o->operators.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::Operator>> (_o->operators.size(), [](size_t i, _VectorArgs *__va) { return CreateOperator(*__va->__fbb, __va->__o->operators[i].get(), __va->__rehasher); }, &_va ) : 0;", "   auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);", "   return tflite::CreateSubGraph(", "       _fbb,", "@@ -17175,26 +17182,26 @@ inline flatbuffers::Offset<SubGraph> CreateSubGraph(flatbuffers::FlatBufferBuild", "       _name);", " }", " ", "-inline BufferT *Buffer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline BufferT *Buffer::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<BufferT>(new BufferT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void Buffer::UnPackTo(BufferT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void Buffer::UnPackTo(BufferT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }", " }", " ", "-inline flatbuffers::Offset<Buffer> Buffer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BufferT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Buffer> Buffer::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BufferT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateBuffer(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<Buffer> CreateBuffer(flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Buffer> CreateBuffer(::flatbuffers::FlatBufferBuilder &_fbb, const BufferT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BufferT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BufferT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   _fbb.ForceVectorAlignment(_o->data.size(), sizeof(uint8_t), 16);", "   auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;", "   return tflite::CreateBuffer(", "@@ -17202,27 +17209,27 @@ inline flatbuffers::Offset<Buffer> CreateBuffer(flatbuffers::FlatBufferBuilder &", "       _data);", " }", " ", "-inline MetadataT *Metadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline MetadataT *Metadata::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<MetadataT>(new MetadataT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void Metadata::UnPackTo(MetadataT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void Metadata::UnPackTo(MetadataT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = name(); if (_e) _o->name = _e->str(); }", "   { auto _e = buffer(); _o->buffer = _e; }", " }", " ", "-inline flatbuffers::Offset<Metadata> Metadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Metadata> Metadata::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MetadataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateMetadata(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<Metadata> CreateMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Metadata> CreateMetadata(::flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MetadataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MetadataT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);", "   auto _buffer = _o->buffer;", "   return tflite::CreateMetadata(", "@@ -17231,27 +17238,27 @@ inline flatbuffers::Offset<Metadata> CreateMetadata(flatbuffers::FlatBufferBuild", "       _buffer);", " }", " ", "-inline TensorMapT *TensorMap::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline TensorMapT *TensorMap::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<TensorMapT>(new TensorMapT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void TensorMap::UnPackTo(TensorMapT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void TensorMap::UnPackTo(TensorMapT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = name(); if (_e) _o->name = _e->str(); }", "   { auto _e = tensor_index(); _o->tensor_index = _e; }", " }", " ", "-inline flatbuffers::Offset<TensorMap> TensorMap::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<TensorMap> TensorMap::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateTensorMap(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<TensorMap> CreateTensorMap(flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<TensorMap> CreateTensorMap(::flatbuffers::FlatBufferBuilder &_fbb, const TensorMapT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorMapT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TensorMapT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);", "   auto _tensor_index = _o->tensor_index;", "   return tflite::CreateTensorMap(", "@@ -17264,9 +17271,9 @@ inline SignatureDefT::SignatureDefT(const SignatureDefT &o)", "       : signature_key(o.signature_key),", "         subgraph_index(o.subgraph_index) {", "   inputs.reserve(o.inputs.size());", "-  for (const auto &v : o.inputs) { inputs.emplace_back((v) ? new tflite::TensorMapT(*v) : nullptr); }", "+  for (const auto &inputs_ : o.inputs) { inputs.emplace_back((inputs_) ? new tflite::TensorMapT(*inputs_) : nullptr); }", "   outputs.reserve(o.outputs.size());", "-  for (const auto &v : o.outputs) { outputs.emplace_back((v) ? new tflite::TensorMapT(*v) : nullptr); }", "+  for (const auto &outputs_ : o.outputs) { outputs.emplace_back((outputs_) ? new tflite::TensorMapT(*outputs_) : nullptr); }", " }", " ", " inline SignatureDefT &SignatureDefT::operator=(SignatureDefT o) FLATBUFFERS_NOEXCEPT {", "@@ -17277,31 +17284,31 @@ inline SignatureDefT &SignatureDefT::operator=(SignatureDefT o) FLATBUFFERS_NOEX", "   return *this;", " }", " ", "-inline SignatureDefT *SignatureDef::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline SignatureDefT *SignatureDef::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<SignatureDefT>(new SignatureDefT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void SignatureDef::UnPackTo(SignatureDefT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void SignatureDef::UnPackTo(SignatureDefT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "-  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->inputs[_i]) { _e->Get(_i)->UnPackTo(_o->inputs[_i].get(), _resolver); } else { _o->inputs[_i] = std::unique_ptr<tflite::TensorMapT>(_e->Get(_i)->UnPack(_resolver)); }; } } }", "-  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->outputs[_i]) { _e->Get(_i)->UnPackTo(_o->outputs[_i].get(), _resolver); } else { _o->outputs[_i] = std::unique_ptr<tflite::TensorMapT>(_e->Get(_i)->UnPack(_resolver)); }; } } }", "+  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->inputs[_i]) { _e->Get(_i)->UnPackTo(_o->inputs[_i].get(), _resolver); } else { _o->inputs[_i] = std::unique_ptr<tflite::TensorMapT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->inputs.resize(0); } }", "+  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->outputs[_i]) { _e->Get(_i)->UnPackTo(_o->outputs[_i].get(), _resolver); } else { _o->outputs[_i] = std::unique_ptr<tflite::TensorMapT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->outputs.resize(0); } }", "   { auto _e = signature_key(); if (_e) _o->signature_key = _e->str(); }", "   { auto _e = subgraph_index(); _o->subgraph_index = _e; }", " }", " ", "-inline flatbuffers::Offset<SignatureDef> SignatureDef::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SignatureDef> SignatureDef::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateSignatureDef(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<SignatureDef> CreateSignatureDef(flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<SignatureDef> CreateSignatureDef(::flatbuffers::FlatBufferBuilder &_fbb, const SignatureDefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SignatureDefT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "-  auto _inputs = _o->inputs.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::TensorMap>> (_o->inputs.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorMap(*__va->__fbb, __va->__o->inputs[i].get(), __va->__rehasher); }, &_va ) : 0;", "-  auto _outputs = _o->outputs.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::TensorMap>> (_o->outputs.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorMap(*__va->__fbb, __va->__o->outputs[i].get(), __va->__rehasher); }, &_va ) : 0;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SignatureDefT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  auto _inputs = _o->inputs.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::TensorMap>> (_o->inputs.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorMap(*__va->__fbb, __va->__o->inputs[i].get(), __va->__rehasher); }, &_va ) : 0;", "+  auto _outputs = _o->outputs.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::TensorMap>> (_o->outputs.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorMap(*__va->__fbb, __va->__o->outputs[i].get(), __va->__rehasher); }, &_va ) : 0;", "   auto _signature_key = _o->signature_key.empty() ? 0 : _fbb.CreateString(_o->signature_key);", "   auto _subgraph_index = _o->subgraph_index;", "   return tflite::CreateSignatureDef(", "@@ -17317,15 +17324,15 @@ inline ModelT::ModelT(const ModelT &o)", "         description(o.description),", "         metadata_buffer(o.metadata_buffer) {", "   operator_codes.reserve(o.operator_codes.size());", "-  for (const auto &v : o.operator_codes) { operator_codes.emplace_back((v) ? new tflite::OperatorCodeT(*v) : nullptr); }", "+  for (const auto &operator_codes_ : o.operator_codes) { operator_codes.emplace_back((operator_codes_) ? new tflite::OperatorCodeT(*operator_codes_) : nullptr); }", "   subgraphs.reserve(o.subgraphs.size());", "-  for (const auto &v : o.subgraphs) { subgraphs.emplace_back((v) ? new tflite::SubGraphT(*v) : nullptr); }", "+  for (const auto &subgraphs_ : o.subgraphs) { subgraphs.emplace_back((subgraphs_) ? new tflite::SubGraphT(*subgraphs_) : nullptr); }", "   buffers.reserve(o.buffers.size());", "-  for (const auto &v : o.buffers) { buffers.emplace_back((v) ? new tflite::BufferT(*v) : nullptr); }", "+  for (const auto &buffers_ : o.buffers) { buffers.emplace_back((buffers_) ? new tflite::BufferT(*buffers_) : nullptr); }", "   metadata.reserve(o.metadata.size());", "-  for (const auto &v : o.metadata) { metadata.emplace_back((v) ? new tflite::MetadataT(*v) : nullptr); }", "+  for (const auto &metadata_ : o.metadata) { metadata.emplace_back((metadata_) ? new tflite::MetadataT(*metadata_) : nullptr); }", "   signature_defs.reserve(o.signature_defs.size());", "-  for (const auto &v : o.signature_defs) { signature_defs.emplace_back((v) ? new tflite::SignatureDefT(*v) : nullptr); }", "+  for (const auto &signature_defs_ : o.signature_defs) { signature_defs.emplace_back((signature_defs_) ? new tflite::SignatureDefT(*signature_defs_) : nullptr); }", " }", " ", " inline ModelT &ModelT::operator=(ModelT o) FLATBUFFERS_NOEXCEPT {", "@@ -17340,41 +17347,41 @@ inline ModelT &ModelT::operator=(ModelT o) FLATBUFFERS_NOEXCEPT {", "   return *this;", " }", " ", "-inline ModelT *Model::UnPack(const flatbuffers::resolver_function_t *_resolver) const {", "+inline ModelT *Model::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {", "   auto _o = std::unique_ptr<ModelT>(new ModelT());", "   UnPackTo(_o.get(), _resolver);", "   return _o.release();", " }", " ", "-inline void Model::UnPackTo(ModelT *_o, const flatbuffers::resolver_function_t *_resolver) const {", "+inline void Model::UnPackTo(ModelT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {", "   (void)_o;", "   (void)_resolver;", "   { auto _e = version(); _o->version = _e; }", "-  { auto _e = operator_codes(); if (_e) { _o->operator_codes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->operator_codes[_i]) { _e->Get(_i)->UnPackTo(_o->operator_codes[_i].get(), _resolver); } else { _o->operator_codes[_i] = std::unique_ptr<tflite::OperatorCodeT>(_e->Get(_i)->UnPack(_resolver)); }; } } }", "-  { auto _e = subgraphs(); if (_e) { _o->subgraphs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->subgraphs[_i]) { _e->Get(_i)->UnPackTo(_o->subgraphs[_i].get(), _resolver); } else { _o->subgraphs[_i] = std::unique_ptr<tflite::SubGraphT>(_e->Get(_i)->UnPack(_resolver)); }; } } }", "+  { auto _e = operator_codes(); if (_e) { _o->operator_codes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->operator_codes[_i]) { _e->Get(_i)->UnPackTo(_o->operator_codes[_i].get(), _resolver); } else { _o->operator_codes[_i] = std::unique_ptr<tflite::OperatorCodeT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->operator_codes.resize(0); } }", "+  { auto _e = subgraphs(); if (_e) { _o->subgraphs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->subgraphs[_i]) { _e->Get(_i)->UnPackTo(_o->subgraphs[_i].get(), _resolver); } else { _o->subgraphs[_i] = std::unique_ptr<tflite::SubGraphT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->subgraphs.resize(0); } }", "   { auto _e = description(); if (_e) _o->description = _e->str(); }", "-  { auto _e = buffers(); if (_e) { _o->buffers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->buffers[_i]) { _e->Get(_i)->UnPackTo(_o->buffers[_i].get(), _resolver); } else { _o->buffers[_i] = std::unique_ptr<tflite::BufferT>(_e->Get(_i)->UnPack(_resolver)); }; } } }", "-  { auto _e = metadata_buffer(); if (_e) { _o->metadata_buffer.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->metadata_buffer[_i] = _e->Get(_i); } } }", "-  { auto _e = metadata(); if (_e) { _o->metadata.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->metadata[_i]) { _e->Get(_i)->UnPackTo(_o->metadata[_i].get(), _resolver); } else { _o->metadata[_i] = std::unique_ptr<tflite::MetadataT>(_e->Get(_i)->UnPack(_resolver)); }; } } }", "-  { auto _e = signature_defs(); if (_e) { _o->signature_defs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->signature_defs[_i]) { _e->Get(_i)->UnPackTo(_o->signature_defs[_i].get(), _resolver); } else { _o->signature_defs[_i] = std::unique_ptr<tflite::SignatureDefT>(_e->Get(_i)->UnPack(_resolver)); }; } } }", "+  { auto _e = buffers(); if (_e) { _o->buffers.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->buffers[_i]) { _e->Get(_i)->UnPackTo(_o->buffers[_i].get(), _resolver); } else { _o->buffers[_i] = std::unique_ptr<tflite::BufferT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->buffers.resize(0); } }", "+  { auto _e = metadata_buffer(); if (_e) { _o->metadata_buffer.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->metadata_buffer[_i] = _e->Get(_i); } } else { _o->metadata_buffer.resize(0); } }", "+  { auto _e = metadata(); if (_e) { _o->metadata.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->metadata[_i]) { _e->Get(_i)->UnPackTo(_o->metadata[_i].get(), _resolver); } else { _o->metadata[_i] = std::unique_ptr<tflite::MetadataT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->metadata.resize(0); } }", "+  { auto _e = signature_defs(); if (_e) { _o->signature_defs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->signature_defs[_i]) { _e->Get(_i)->UnPackTo(_o->signature_defs[_i].get(), _resolver); } else { _o->signature_defs[_i] = std::unique_ptr<tflite::SignatureDefT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->signature_defs.resize(0); } }", " }", " ", "-inline flatbuffers::Offset<Model> Model::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Model> Model::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ModelT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   return CreateModel(_fbb, _o, _rehasher);", " }", " ", "-inline flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {", "+inline ::flatbuffers::Offset<Model> CreateModel(::flatbuffers::FlatBufferBuilder &_fbb, const ModelT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {", "   (void)_rehasher;", "   (void)_o;", "-  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ModelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "+  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ModelT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;", "   auto _version = _o->version;", "-  auto _operator_codes = _o->operator_codes.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::OperatorCode>> (_o->operator_codes.size(), [](size_t i, _VectorArgs *__va) { return CreateOperatorCode(*__va->__fbb, __va->__o->operator_codes[i].get(), __va->__rehasher); }, &_va ) : 0;", "-  auto _subgraphs = _o->subgraphs.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::SubGraph>> (_o->subgraphs.size(), [](size_t i, _VectorArgs *__va) { return CreateSubGraph(*__va->__fbb, __va->__o->subgraphs[i].get(), __va->__rehasher); }, &_va ) : 0;", "+  auto _operator_codes = _o->operator_codes.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::OperatorCode>> (_o->operator_codes.size(), [](size_t i, _VectorArgs *__va) { return CreateOperatorCode(*__va->__fbb, __va->__o->operator_codes[i].get(), __va->__rehasher); }, &_va ) : 0;", "+  auto _subgraphs = _o->subgraphs.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::SubGraph>> (_o->subgraphs.size(), [](size_t i, _VectorArgs *__va) { return CreateSubGraph(*__va->__fbb, __va->__o->subgraphs[i].get(), __va->__rehasher); }, &_va ) : 0;", "   auto _description = _o->description.empty() ? 0 : _fbb.CreateString(_o->description);", "-  auto _buffers = _o->buffers.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::Buffer>> (_o->buffers.size(), [](size_t i, _VectorArgs *__va) { return CreateBuffer(*__va->__fbb, __va->__o->buffers[i].get(), __va->__rehasher); }, &_va ) : 0;", "+  auto _buffers = _o->buffers.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::Buffer>> (_o->buffers.size(), [](size_t i, _VectorArgs *__va) { return CreateBuffer(*__va->__fbb, __va->__o->buffers[i].get(), __va->__rehasher); }, &_va ) : 0;", "   auto _metadata_buffer = _o->metadata_buffer.size() ? _fbb.CreateVector(_o->metadata_buffer) : 0;", "-  auto _metadata = _o->metadata.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::Metadata>> (_o->metadata.size(), [](size_t i, _VectorArgs *__va) { return CreateMetadata(*__va->__fbb, __va->__o->metadata[i].get(), __va->__rehasher); }, &_va ) : 0;", "-  auto _signature_defs = _o->signature_defs.size() ? _fbb.CreateVector<flatbuffers::Offset<tflite::SignatureDef>> (_o->signature_defs.size(), [](size_t i, _VectorArgs *__va) { return CreateSignatureDef(*__va->__fbb, __va->__o->signature_defs[i].get(), __va->__rehasher); }, &_va ) : 0;", "+  auto _metadata = _o->metadata.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::Metadata>> (_o->metadata.size(), [](size_t i, _VectorArgs *__va) { return CreateMetadata(*__va->__fbb, __va->__o->metadata[i].get(), __va->__rehasher); }, &_va ) : 0;", "+  auto _signature_defs = _o->signature_defs.size() ? _fbb.CreateVector<::flatbuffers::Offset<tflite::SignatureDef>> (_o->signature_defs.size(), [](size_t i, _VectorArgs *__va) { return CreateSignatureDef(*__va->__fbb, __va->__o->signature_defs[i].get(), __va->__rehasher); }, &_va ) : 0;", "   return tflite::CreateModel(", "       _fbb,", "       _version,", "@@ -17387,7 +17394,7 @@ inline flatbuffers::Offset<Model> CreateModel(flatbuffers::FlatBufferBuilder &_f", "       _signature_defs);", " }", " ", "-inline bool VerifyQuantizationDetails(flatbuffers::Verifier &verifier, const void *obj, QuantizationDetails type) {", "+inline bool VerifyQuantizationDetails(::flatbuffers::Verifier &verifier, const void *obj, QuantizationDetails type) {", "   switch (type) {", "     case QuantizationDetails_NONE: {", "       return true;", "@@ -17400,10 +17407,10 @@ inline bool VerifyQuantizationDetails(flatbuffers::Verifier &verifier, const voi", "   }", " }", " ", "-inline bool VerifyQuantizationDetailsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {", "+inline bool VerifyQuantizationDetailsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {", "   if (!values || !types) return !values && !types;", "   if (values->size() != types->size()) return false;", "-  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {", "+  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {", "     if (!VerifyQuantizationDetails(", "         verifier,  values->Get(i), types->GetEnum<QuantizationDetails>(i))) {", "       return false;", "@@ -17412,7 +17419,7 @@ inline bool VerifyQuantizationDetailsVector(flatbuffers::Verifier &verifier, con", "   return true;", " }", " ", "-inline void *QuantizationDetailsUnion::UnPack(const void *obj, QuantizationDetails type, const flatbuffers::resolver_function_t *resolver) {", "+inline void *QuantizationDetailsUnion::UnPack(const void *obj, QuantizationDetails type, const ::flatbuffers::resolver_function_t *resolver) {", "   (void)resolver;", "   switch (type) {", "     case QuantizationDetails_CustomQuantization: {", "@@ -17423,7 +17430,7 @@ inline void *QuantizationDetailsUnion::UnPack(const void *obj, QuantizationDetai", "   }", " }", " ", "-inline flatbuffers::Offset<void> QuantizationDetailsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {", "+inline ::flatbuffers::Offset<void> QuantizationDetailsUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {", "   (void)_rehasher;", "   switch (type) {", "     case QuantizationDetails_CustomQuantization: {", "@@ -17458,7 +17465,7 @@ inline void QuantizationDetailsUnion::Reset() {", "   type = QuantizationDetails_NONE;", " }", " ", "-inline bool VerifySparseIndexVector(flatbuffers::Verifier &verifier, const void *obj, SparseIndexVector type) {", "+inline bool VerifySparseIndexVector(::flatbuffers::Verifier &verifier, const void *obj, SparseIndexVector type) {", "   switch (type) {", "     case SparseIndexVector_NONE: {", "       return true;", "@@ -17479,10 +17486,10 @@ inline bool VerifySparseIndexVector(flatbuffers::Verifier &verifier, const void", "   }", " }", " ", "-inline bool VerifySparseIndexVectorVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {", "+inline bool VerifySparseIndexVectorVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {", "   if (!values || !types) return !values && !types;", "   if (values->size() != types->size()) return false;", "-  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {", "+  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {", "     if (!VerifySparseIndexVector(", "         verifier,  values->Get(i), types->GetEnum<SparseIndexVector>(i))) {", "       return false;", "@@ -17491,7 +17498,7 @@ inline bool VerifySparseIndexVectorVector(flatbuffers::Verifier &verifier, const", "   return true;", " }", " ", "-inline void *SparseIndexVectorUnion::UnPack(const void *obj, SparseIndexVector type, const flatbuffers::resolver_function_t *resolver) {", "+inline void *SparseIndexVectorUnion::UnPack(const void *obj, SparseIndexVector type, const ::flatbuffers::resolver_function_t *resolver) {", "   (void)resolver;", "   switch (type) {", "     case SparseIndexVector_Int32Vector: {", "@@ -17510,7 +17517,7 @@ inline void *SparseIndexVectorUnion::UnPack(const void *obj, SparseIndexVector t", "   }", " }", " ", "-inline flatbuffers::Offset<void> SparseIndexVectorUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {", "+inline ::flatbuffers::Offset<void> SparseIndexVectorUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {", "   (void)_rehasher;", "   switch (type) {", "     case SparseIndexVector_Int32Vector: {", "@@ -17571,7 +17578,7 @@ inline void SparseIndexVectorUnion::Reset() {", "   type = SparseIndexVector_NONE;", " }", " ", "-inline bool VerifyBuiltinOptions(flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type) {", "+inline bool VerifyBuiltinOptions(::flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type) {", "   switch (type) {", "     case BuiltinOptions_NONE: {", "       return true;", "@@ -18076,10 +18083,10 @@ inline bool VerifyBuiltinOptions(flatbuffers::Verifier &verifier, const void *ob", "   }", " }", " ", "-inline bool VerifyBuiltinOptionsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {", "+inline bool VerifyBuiltinOptionsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {", "   if (!values || !types) return !values && !types;", "   if (values->size() != types->size()) return false;", "-  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {", "+  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {", "     if (!VerifyBuiltinOptions(", "         verifier,  values->Get(i), types->GetEnum<BuiltinOptions>(i))) {", "       return false;", "@@ -18088,7 +18095,7 @@ inline bool VerifyBuiltinOptionsVector(flatbuffers::Verifier &verifier, const fl", "   return true;", " }", " ", "-inline void *BuiltinOptionsUnion::UnPack(const void *obj, BuiltinOptions type, const flatbuffers::resolver_function_t *resolver) {", "+inline void *BuiltinOptionsUnion::UnPack(const void *obj, BuiltinOptions type, const ::flatbuffers::resolver_function_t *resolver) {", "   (void)resolver;", "   switch (type) {", "     case BuiltinOptions_Conv2DOptions: {", "@@ -18591,7 +18598,7 @@ inline void *BuiltinOptionsUnion::UnPack(const void *obj, BuiltinOptions type, c", "   }", " }", " ", "-inline flatbuffers::Offset<void> BuiltinOptionsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {", "+inline ::flatbuffers::Offset<void> BuiltinOptionsUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {", "   (void)_rehasher;", "   switch (type) {", "     case BuiltinOptions_Conv2DOptions: {", "@@ -20226,11 +20233,11 @@ inline void BuiltinOptionsUnion::Reset() {", " }", " ", " inline const tflite::Model *GetModel(const void *buf) {", "-  return flatbuffers::GetRoot<tflite::Model>(buf);", "+  return ::flatbuffers::GetRoot<tflite::Model>(buf);", " }", " ", " inline const tflite::Model *GetSizePrefixedModel(const void *buf) {", "-  return flatbuffers::GetSizePrefixedRoot<tflite::Model>(buf);", "+  return ::flatbuffers::GetSizePrefixedRoot<tflite::Model>(buf);", " }", " ", " inline const char *ModelIdentifier() {", "@@ -20238,22 +20245,22 @@ inline const char *ModelIdentifier() {", " }", " ", " inline bool ModelBufferHasIdentifier(const void *buf) {", "-  return flatbuffers::BufferHasIdentifier(", "+  return ::flatbuffers::BufferHasIdentifier(", "       buf, ModelIdentifier());", " }", " ", " inline bool SizePrefixedModelBufferHasIdentifier(const void *buf) {", "-  return flatbuffers::BufferHasIdentifier(", "+  return ::flatbuffers::BufferHasIdentifier(", "       buf, ModelIdentifier(), true);", " }", " ", " inline bool VerifyModelBuffer(", "-    flatbuffers::Verifier &verifier) {", "+    ::flatbuffers::Verifier &verifier) {", "   return verifier.VerifyBuffer<tflite::Model>(ModelIdentifier());", " }", " ", " inline bool VerifySizePrefixedModelBuffer(", "-    flatbuffers::Verifier &verifier) {", "+    ::flatbuffers::Verifier &verifier) {", "   return verifier.VerifySizePrefixedBuffer<tflite::Model>(ModelIdentifier());", " }", " ", "@@ -20262,26 +20269,26 @@ inline const char *ModelExtension() {", " }", " ", " inline void FinishModelBuffer(", "-    flatbuffers::FlatBufferBuilder &fbb,", "-    flatbuffers::Offset<tflite::Model> root) {", "+    ::flatbuffers::FlatBufferBuilder &fbb,", "+    ::flatbuffers::Offset<tflite::Model> root) {", "   fbb.Finish(root, ModelIdentifier());", " }", " ", " inline void FinishSizePrefixedModelBuffer(", "-    flatbuffers::FlatBufferBuilder &fbb,", "-    flatbuffers::Offset<tflite::Model> root) {", "+    ::flatbuffers::FlatBufferBuilder &fbb,", "+    ::flatbuffers::Offset<tflite::Model> root) {", "   fbb.FinishSizePrefixed(root, ModelIdentifier());", " }", " ", " inline std::unique_ptr<tflite::ModelT> UnPackModel(", "     const void *buf,", "-    const flatbuffers::resolver_function_t *res = nullptr) {", "+    const ::flatbuffers::resolver_function_t *res = nullptr) {", "   return std::unique_ptr<tflite::ModelT>(GetModel(buf)->UnPack(res));", " }", " ", " inline std::unique_ptr<tflite::ModelT> UnPackSizePrefixedModel(", "     const void *buf,", "-    const flatbuffers::resolver_function_t *res = nullptr) {", "+    const ::flatbuffers::resolver_function_t *res = nullptr) {", "   return std::unique_ptr<tflite::ModelT>(GetSizePrefixedModel(buf)->UnPack(res));", " }", " ", "@@ -23,7 +23,7 @@ OverridableFetchContent_Declare(", "   flatbuffers", "   GIT_REPOSITORY https://github.com/google/flatbuffers", "   # Sync with tensorflow/third_party/flatbuffers/workspace.bzl", "-  GIT_TAG v2.0.6", "+  GIT_TAG v23.1.20", "   GIT_SHALLOW TRUE", "   GIT_PROGRESS TRUE", "   SOURCE_DIR \"${CMAKE_BINARY_DIR}/flatbuffers\"", "@@ -3,7 +3,7 @@", " # This will change in the future.", " absl-py ~= 1.0.0", " astunparse ~= 1.6.3", "-flatbuffers ~= 2.0", "+flatbuffers ~= 23.1.20", " google_pasta ~= 0.2", " h5py ~= 3.8.0  # Earliest version for Python 3.11", " # TODO(b/262592253): Support older versions of NumPy for Python 3.10 and lower", "@@ -84,7 +84,7 @@ def standard_or_nightly(standard, nightly):", " REQUIRED_PACKAGES = [", "     'absl-py >= 1.0.0',", "     'astunparse >= 1.6.0',", "-    'flatbuffers >= 2.0',", "+    'flatbuffers >= 23.1.20',", "     # TODO(b/213222745) gast versions above 0.4.0 break TF's tests", "     'gast >= 0.2.1, <= 0.4.0',", "     'google_pasta >= 0.1.1',", "@@ -7,8 +7,6 @@ licenses([\"notice\"])  # Apache 2.0", " ", " exports_files([\"LICENSE.txt\"])", " ", "-licenses([\"notice\"])", "-", " config_setting(", "     name = \"platform_freebsd\",", "     values = {\"cpu\": \"freebsd\"},", "@@ -46,12 +44,16 @@ filegroup(", "         \"include/flatbuffers/bfbs_generator.h\",", "         \"include/flatbuffers/buffer.h\",", "         \"include/flatbuffers/buffer_ref.h\",", "+        \"include/flatbuffers/code_generator.h\",", "         \"include/flatbuffers/code_generators.h\",", "         \"include/flatbuffers/default_allocator.h\",", "         \"include/flatbuffers/detached_buffer.h\",", "         \"include/flatbuffers/flatbuffer_builder.h\",", "         \"include/flatbuffers/flatbuffers.h\",", "+        \"include/flatbuffers/flatc.h\",", "+        \"include/flatbuffers/flex_flat_util.h\",", "         \"include/flatbuffers/flexbuffers.h\",", "+        \"include/flatbuffers/grpc.h\",", "         \"include/flatbuffers/hash.h\",", "         \"include/flatbuffers/idl.h\",", "         \"include/flatbuffers/minireflect.h\",", "@@ -176,7 +178,7 @@ py_library(", " ", " filegroup(", "     name = \"runtime_java_srcs\",", "-    srcs = glob([\"java/com/google/flatbuffers/**/*.java\"]),", "+    srcs = glob([\"java/src/main/java/com/google/flatbuffers/**/*.java\"]),", " )", " ", " java_library(", "@@ -5,9 +5,9 @@ load(\"//third_party:repo.bzl\", \"tf_http_archive\", \"tf_mirror_urls\")", " def repo():", "     tf_http_archive(", "         name = \"flatbuffers\",", "-        strip_prefix = \"flatbuffers-2.0.6\",", "-        sha256 = \"e2dc24985a85b278dd06313481a9ca051d048f9474e0f199e372fea3ea4248c9\",", "-        urls = tf_mirror_urls(\"https://github.com/google/flatbuffers/archive/v2.0.6.tar.gz\"),", "+        strip_prefix = \"flatbuffers-23.1.20\",", "+        sha256 = \"3f074b30a3ea5a1c0fb23c208d2ab8db1281bdc4a1707ef2c049a1cc9cc13136\",", "+        urls = tf_mirror_urls(\"https://github.com/google/flatbuffers/archive/v23.1.20.tar.gz\"),", "         build_file = \"//third_party/flatbuffers:flatbuffers.BUILD\",", "         system_build_file = \"//third_party/flatbuffers:BUILD.system\",", "         link_files = {", "@@ -1,4 +1,4 @@", "-## TFSA-2022-169: `CHECK` fail in `TensorListScatter` and `TensorListScatterV2` in eager mode", "+## TFSA-2022-170: `CHECK` fail in `TensorListScatter` and `TensorListScatterV2` in eager mode", " ", " ### CVE Number", " CVE-2022-35991", "@@ -0,0 +1,39 @@", "+## TFSA-2023-172: A heap out-of-buffer read vulnerability in the QuantizeAndDequantize operation", "+", "+### CVE Number", "+CVE-2023-25668", "+", "+### Impact", "+Attackers using Tensorflow can exploit the vulnerability. They can access heap memory which is not in the control of user, leading to a crash or RCE.", "+When axis is larger than the dim of input, c->Dim(input,axis) goes out of bound.", "+Same problem occurs in the QuantizeAndDequantizeV2/V3/V4/V4Grad operations too.", "+```python", "+import tensorflow as tf", "+@tf.function", "+def test():", "+    tf.raw_ops.QuantizeAndDequantizeV2(input=[2.5],", "+    \t\t\t\t\t\t\t\t   input_min=[1.0],", "+    \t\t\t\t\t\t\t\t   input_max=[10.0],", "+    \t\t\t\t\t\t\t\t   signed_input=True,", "+    \t\t\t\t\t\t\t\t   num_bits=1,", "+    \t\t\t\t\t\t\t\t   range_given=True,", "+    \t\t\t\t\t\t\t\t   round_mode='HALF_TO_EVEN',", "+    \t\t\t\t\t\t\t\t   narrow_range=True,", "+    \t\t\t\t\t\t\t\t   axis=0x7fffffff)", "+test()", "+```", "+", "+", "+", "+### Patches", "+We have patched the issue in GitHub commit [7b174a0f2e40ff3f3aa957aecddfd5aaae35eccb](https://github.com/tensorflow/tensorflow/commit/7b174a0f2e40ff3f3aa957aecddfd5aaae35eccb).", "+", "+The fix will be included in TensorFlow 2.12.0. We will also cherrypick this commit on TensorFlow 2.11.1", "+", "+", "+### For more information", "+Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.", "+", "+", "+", "+", "@@ -0,0 +1,31 @@", "+## TFSA-2023-174: Segfault when opening multiframe gif", "+", "+### CVE Number", "+CVE-2023-25667", "+", "+### Impact", "+Integer overflow occurs when 2^31 <= num_frames * height * width * channels < 2^32, for example Full HD screencast of at least 346 frames.", "+```python", "+import urllib.request", "+dat = urllib.request.urlopen('https://raw.githubusercontent.com/tensorflow/tensorflow/1c38ad9b78ffe06076745a1ee00cec42f39ff726/tensorflow/core/lib/gif/testdata/3g_multiframe.gif').read()", "+import tensorflow as tf", "+tf.io.decode_gif(dat)", "+```", "+", "+### Patches", "+We have patched the issue in GitHub commit [8dc723fcdd1a6127d6c970bd2ecb18b019a1a58d](https://github.com/tensorflow/tensorflow/commit/8dc723fcdd1a6127d6c970bd2ecb18b019a1a58d).", "+", "+The fix will be included in TensorFlow 2.12.0. We will also cherrypick this commit on TensorFlow 2.11.1", "+", "+", "+### For more information", "+Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.", "+", "+", "+### Attribution", "+This vulnerability has been reported by Andrei", "+", "+", "+", "+", "+", "@@ -0,0 +1,37 @@", "+## TFSA-2023-176: NPE in SparseSparseMaximum", "+", "+### CVE Number", "+CVE-2023-25665", "+", "+### Impact", "+When `SparseSparseMaximum` is given invalid sparse tensors as inputs, it can give an NPE. ", "+", "+```python", "+import tensorflow as tf", "+tf.raw_ops.SparseSparseMaximum(", "+ a_indices=[[1]],", "+ a_values =[ 0.1 ],", "+ a_shape = [2],", "+ b_indices=[[]],", "+ b_values =[2 ],", "+ b_shape = [2],", "+)", "+```", "+", "+### Patches", "+We have patched the issue in GitHub commit [5e0ecfb42f5f65629fd7a4edd6c4afe7ff0feb04](https://github.com/tensorflow/tensorflow/commit/5e0ecfb42f5f65629fd7a4edd6c4afe7ff0feb04).", "+", "+The fix will be included in TensorFlow 2.12. We will also cherrypick this commit on TensorFlow 2.11.1.", "+", "+", "+### For more information", "+Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.", "+", "+", "+### Attribution", "+This vulnerability has been reported by Yu Tian of Qihoo 360 AIVul Team", "+", "+", "+", "+", "+", "@@ -0,0 +1,47 @@", "+## TFSA-2023-178: FPE in AudioSpectrogram ", "+", "+### CVE Number", "+CVE-2023-25666", "+", "+### Impact", "+version:2.11.0 audio_ops.cc:70", "+", "+Status SpectrogramShapeFn(InferenceContext* c) { ShapeHandle input; TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &input)); int32_t window_size; TF_RETURN_IF_ERROR(c->GetAttr(\"window_size\", &window_size)); int32_t stride; TF_RETURN_IF_ERROR(c->GetAttr(\"stride\", &stride)); .....[1]", "+", "+DimensionHandle input_length = c->Dim(input, 0); DimensionHandle input_channels = c->Dim(input, 1);", "+", "+DimensionHandle output_length; if (!c->ValueKnown(input_length)) { output_length = c->UnknownDim(); } else { const int64_t input_length_value = c->Value(input_length); const int64_t length_minus_window = (input_length_value - window_size); int64_t output_length_value; if (length_minus_window < 0) { output_length_value = 0; } else { output_length_value = 1 + (length_minus_window / stride); .....[2] } output_length = c->MakeDim(output_length_value); }", "+", "+Get the value of stride at [1], and the used at [2]", "+```python", "+import tensorflow as tf", "+", "+para = {'input': tf.constant([[14.], [24.]], dtype=tf.float32), 'window_size': 1, 'stride': 0, 'magnitude_squared': False}", "+func = tf.raw_ops.AudioSpectrogram", "+", "+@tf.function(jit_compile=True)", "+def fuzz_jit():", "+   y = func(**para)", "+   return y", "+", "+fuzz_jit()", "+```", "+", "+### Patches", "+We have patched the issue in GitHub commit [d0d4e779da0d0f56499c6fa5ba09f0a576cc6b14](https://github.com/tensorflow/tensorflow/commit/d0d4e779da0d0f56499c6fa5ba09f0a576cc6b14).", "+", "+The fix will be included in TensorFlow 2.12.0. We will also cherrypick this commit on TensorFlow 2.11.1", "+", "+", "+### For more information", "+Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.", "+", "+", "+### Attribution", "+This vulnerability has been reported by r3pwnx", "+", "+", "+", "+", "+", "+", "@@ -0,0 +1,40 @@", "+## TFSA-2023-180: Heap-buffer-overflow in AvgPoolGrad  ", "+", "+### CVE Number", "+CVE-2023-25664", "+", "+### Impact", "+```python", "+import os", "+os.environ['TF_ENABLE_ONEDNN_OPTS'] = '0'", "+import tensorflow as tf", "+print(tf.__version__)", "+with tf.device(\"CPU\"):", "+    ksize = [1, 40, 128, 1]", "+    strides = [1, 128, 128, 30]", "+    padding = \"SAME\"", "+    data_format = \"NHWC\"", "+    orig_input_shape = [11, 9, 78, 9]", "+    grad = tf.saturate_cast(tf.random.uniform([16, 16, 16, 16], minval=-128, maxval=129, dtype=tf.int64), dtype=tf.float32)", "+    res = tf.raw_ops.AvgPoolGrad(", "+        ksize=ksize,", "+        strides=strides,", "+        padding=padding,", "+        data_format=data_format,", "+        orig_input_shape=orig_input_shape,", "+        grad=grad,", "+    )", "+```", "+", "+### Patches", "+We have patched the issue in GitHub commit [ddaac2bdd099bec5d7923dea45276a7558217e5b](https://github.com/tensorflow/tensorflow/commit/ddaac2bdd099bec5d7923dea45276a7558217e5b).", "+", "+The fix will be included in TensorFlow 2.12.0. We will also cherrypick this commit on TensorFlow 2.11.1", "+", "+", "+### For more information", "+Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.", "+", "+", "+### Attribution", "+This vulnerability has been reported by <evn@google.com>", "@@ -0,0 +1,24 @@", "+## TFSA-2023-182: NPE in TensorArrayConcatV2", "+", "+### CVE Number", "+CVE-2023-25663", "+", "+### Impact", "+When ctx->step_containter() is a null ptr, the Lookup function will be executed with a null pointer.", "+```python", "+import tensorflow as tf", "+tf.raw_ops.TensorArrayConcatV2(handle=['a', 'b'], flow_in = 0.1, dtype=tf.int32, element_shape_except0=1)", "+```", "+", "+### Patches", "+We have patched the issue in GitHub commit [239139d2ae6a81ae9ba499ad78b56d9b2931538a](https://github.com/tensorflow/tensorflow/commit/239139d2ae6a81ae9ba499ad78b56d9b2931538a).", "+", "+The fix will be included in TensorFlow 2.12.0. We will also cherrypick this commit on TensorFlow 2.11.1", "+", "+", "+### For more information", "+Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.", "+", "+", "+### Attribution", "+This vulnerability has been reported by Yu Tian", "\\ No newline at end of file", "@@ -0,0 +1,35 @@", "+## TFSA-2023-184: Integer overflow in EditDistance", "+", "+### CVE Number", "+CVE-2023-25662", "+", "+### Impact", "+TFversion 2.11.0 //tensorflow/core/ops/array_ops.cc:1067 const Tensor* hypothesis_shape_t = c->input_tensor(2); std::vector<DimensionHandle> dims(hypothesis_shape_t->NumElements() - 1); for (int i = 0; i < dims.size(); ++i) { dims[i] = c->MakeDim(std::max(h_values(i), t_values(i))); }", "+", "+if hypothesis_shape_t is empty, hypothesis_shape_t->NumElements() - 1 will be integer overflow, and the it will deadlock", "+```python", "+import tensorflow as tf", "+para={", "+    'hypothesis_indices': [[]],", "+    'hypothesis_values': ['tmp/'],", "+    'hypothesis_shape': [],", "+    'truth_indices': [[]],", "+    'truth_values': [''],", "+    'truth_shape': [],", "+    'normalize': False", "+    }", "+tf.raw_ops.EditDistance(**para)", "+```", "+", "+### Patches", "+We have patched the issue in GitHub commit [08b8e18643d6dcde00890733b270ff8d9960c56c](https://github.com/tensorflow/tensorflow/commit/08b8e18643d6dcde00890733b270ff8d9960c56c).", "+", "+The fix will be included in TensorFlow 2.12.0. We will also cherrypick this commit on TensorFlow 2.11.1", "+", "+", "+### For more information", "+Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.", "+", "+", "+### Attribution", "+This vulnerability has been reported by r3pwnx", "\\ No newline at end of file", "@@ -0,0 +1,30 @@", "+## TFSA-2023-186: Seg fault in `tf.raw_ops.Print`", "+", "+### CVE Number", "+CVE-2023-25660", "+", "+### Impact", "+When the parameter `summarize` of `tf.raw_ops.Print` is zero, the new method `SummarizeArray<bool>` will reference to a nullptr, leading to a seg fault.", "+", "+```python", "+import tensorflow as tf", "+", "+tf.raw_ops.Print(input =  tf.constant([1, 1, 1, 1],dtype=tf.int32),", "+                            data =  [[False, False, False, False], [False], [False, False, False]],", "+                            message =  'tmp/I',", "+                            first_n = 100,", "+                            summarize = 0)", "+```", "+", "+### Patches", "+We have patched the issue in GitHub commit [6d423b8bcc9aa9f5554dc988c1c16d038b508df1](https://github.com/tensorflow/tensorflow/commit/6d423b8bcc9aa9f5554dc988c1c16d038b508df1).", "+", "+The fix will be included in TensorFlow 2.12. We will also cherrypick this commit on TensorFlow 2.11.1.", "+", "+", "+### For more information", "+Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.", "+", "+", "+### Attribution", "+This vulnerability has been reported by Yu Tian of Qihoo 360 AIVul Team", "@@ -0,0 +1,27 @@", "+## TFSA-2023-188: OOB read in DynamicStitch", "+", "+### CVE Number", "+CVE-2023-25659", "+", "+### Impact", "+If the parameter `indices` for `DynamicStitch` does not match the shape of the parameter `data`, it can trigger an stack OOB read.", "+", "+```python", "+import tensorflow as tf", "+func = tf.raw_ops.DynamicStitch", "+para={'indices': [[0xdeadbeef], [405], [519], [758], [1015]], 'data': [[110.27793884277344], [120.29475402832031], [157.2418212890625], [157.2626953125], [188.45382690429688]]}", "+y = func(**para)", "+```", "+", "+### Patches", "+We have patched the issue in GitHub commit [ee004b18b976eeb5a758020af8880236cd707d05](https://github.com/tensorflow/tensorflow/commit/ee004b18b976eeb5a758020af8880236cd707d05).", "+", "+The fix will be included in TensorFlow 2.12. We will also cherrypick this commit on TensorFlow 2.11.1.", "+", "+", "+### For more information", "+Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.", "+", "+", "+### Attribution", "+This has been reported via Google OSS VRP.", "\\ No newline at end of file", "@@ -0,0 +1,34 @@", "+## TFSA-2023-190: OOB Read in GRUBlockCellGrad", "+", "+### CVE Number", "+CVE-2023-25658", "+", "+### Impact", "+Out of bounds read in GRUBlockCellGrad", "+```python", "+func = tf.raw_ops.GRUBlockCellGrad", "+", "+para = {'x': [[21.1, 156.2], [83.3, 115.4]], 'h_prev': array([[136.5],", "+      [136.6]]), 'w_ru': array([[26.7,  0.8],", "+      [47.9, 26.1],", "+      [26.2, 26.3]]), 'w_c': array([[ 0.4],", "+      [31.5],", "+      [ 0.6]]), 'b_ru': array([0.1, 0.2 ], dtype=float32), 'b_c': 0x41414141, 'r': array([[0.3],", "+      [0.4]], dtype=float32), 'u': array([[5.7],", "+      [5.8]]), 'c': array([[52.9],", "+      [53.1]]), 'd_h': array([[172.2],", "+      [188.3 ]])}", "+```", "+", "+### Patches", "+We have patched the issue in GitHub commit [ff459137c2716a2a60f7d441b855fcb466d778cb](https://github.com/tensorflow/tensorflow/commit/ff459137c2716a2a60f7d441b855fcb466d778cb).", "+", "+The fix will be included in TensorFlow 2.12.0. We will also cherrypick this commit on TensorFlow 2.11.1", "+", "+", "+### For more information", "+Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.", "+", "+", "+### Attribution", "+This vulnerability has been reported by r3pwnx.", "@@ -0,0 +1,20 @@", "+## TFSA-2023-171: FPE in TFLite in conv kernel", "+", "+### CVE Number", "+CVE-2023-27579 ", "+", "+### Impact", "+Constructing a tflite model with a paramater `filter_input_channel` of less than 1 gives a FPE.", "+", "+", "+### Patches", "+We have patched the issue in GitHub commit [34f8368c535253f5c9cb3a303297743b62442aaa](https://github.com/tensorflow/tensorflow/commit/34f8368c535253f5c9cb3a303297743b62442aaa).", "+", "+The fix will be included in TensorFlow 2.12. We will also cherrypick this commit on TensorFlow 2.11.1.", "+", "+", "+### For more information", "+Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.", "+", "+### Attribution", "+This vulnerability was reported by Wang Xuan of Qihoo 360 AIVul Team.", "@@ -0,0 +1,40 @@", "+## TFSA-2023-173: Double free in Fractional(Max/Avg)Pool", "+", "+### CVE Number", "+CVE-2023-25801", "+", "+### Impact", "+`nn_ops.fractional_avg_pool_v2` and `nn_ops.fractional_max_pool_v2` require the first and fourth elements of their parameter `pooling_ratio` to be equal to 1.0, as pooling on batch and channel dimensions is not supported.", "+", "+```python", "+import tensorflow as tf", "+import os", "+import numpy as np", "+from tensorflow.python.ops import nn_ops", "+try:", "+  arg_0_tensor = tf.random.uniform([3, 30, 50, 3], dtype=tf.float64)", "+  arg_0 = tf.identity(arg_0_tensor)", "+  arg_1_0 = 2", "+  arg_1_1 = 3", "+  arg_1_2 = 1", "+  arg_1_3 = 1", "+  arg_1 = [arg_1_0,arg_1_1,arg_1_2,arg_1_3,]", "+  arg_2 = True", "+  arg_3 = True", "+  seed = 341261001", "+  out = nn_ops.fractional_avg_pool_v2(arg_0,arg_1,arg_2,arg_3,seed=seed,)", "+except Exception as e:", "+  print(\"Error:\"+str(e))", "+```", "+", "+### Patches", "+We have patched the issue in GitHub commit [ee50d1e00f81f62a4517453f721c634bbb478307](https://github.com/tensorflow/tensorflow/commit/ee50d1e00f81f62a4517453f721c634bbb478307).", "+", "+The fix will be included in TensorFlow 2.12. We will also cherrypick this commit on TensorFlow 2.11.1.", "+", "+", "+### For more information", "+Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.", "+", "+### Attribution", "+This vulnerability was reported by [dmc1778](https://github.com/dmc1778), of [nimashiri2012@gmail.com](mailto:nimashiri2012@gmail.com).", "@@ -0,0 +1,34 @@", "+## TFSA-2023-175: Null dereference on ParallelConcat with XLA", "+", "+### CVE Number", "+CVE-2023-25676", "+", "+### Impact", "+When running with XLA, `tf.raw_ops.ParallelConcat` segfaults with a nullptr dereference when given a parameter `shape` with rank that is not greater than zero.", "+", "+```python", "+import tensorflow as tf", "+", "+func = tf.raw_ops.ParallelConcat", "+para = {'shape':  0, 'values': [1]}", "+", "+@tf.function(jit_compile=True)", "+def test():", "+   y = func(**para)", "+   return y", "+", "+test()", "+```", "+", "+### Patches", "+We have patched the issue in GitHub commit [da66bc6d5ff466aee084f9e7397980a24890cd15](https://github.com/tensorflow/tensorflow/commit/da66bc6d5ff466aee084f9e7397980a24890cd15).", "+", "+The fix will be included in TensorFlow 2.12. We will also cherrypick this commit on TensorFlow 2.11.1.", "+", "+", "+### For more information", "+Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.", "+", "+", "+### Attribution", "+This vulnerability has been reported by r3pwnx of 360 AIVul Team", "@@ -0,0 +1,34 @@", "+## TFSA-2023-177: Segfault in Bincount with XLA", "+", "+### CVE Number", "+CVE-2023-25675", "+", "+### Impact", "+When running with XLA, `tf.raw_ops.Bincount` segfaults when given a parameter `weights` that is neither the same shape as parameter `arr` nor a length-0 tensor.", "+", "+```python", "+import tensorflow as tf", "+", "+func = tf.raw_ops.Bincount", "+para={'arr': 6, 'size': 804, 'weights': [52, 351]}", "+", "+@tf.function(jit_compile=True)", "+def fuzz_jit():", "+ y = func(**para)", "+ return y", "+", "+print(fuzz_jit())", "+```", "+", "+### Patches", "+We have patched the issue in GitHub commit [8ae76cf085f4be26295d2ecf2081e759e04b8acf](https://github.com/tensorflow/tensorflow/commit/8ae76cf085f4be26295d2ecf2081e759e04b8acf).", "+", "+The fix will be included in TensorFlow 2.12. We will also cherrypick this commit on TensorFlow 2.11.1.", "+", "+", "+### For more information", "+Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.", "+", "+", "+### Attribution", "+This vulnerability has been reported by r3pwnx of 360 AIVul Team", "@@ -0,0 +1,33 @@", "+## TFSA-2023-179: NPE in RandomShuffle with XLA enable", "+", "+### CVE Number", "+CVE-2023-25674", "+", "+### Impact", "+NPE in RandomShuffle with XLA enable ", "+```python", "+import tensorflow as tf", "+", "+func = tf.raw_ops.RandomShuffle", "+para = {'value': 1e+20, 'seed': -4294967297, 'seed2': -2147483649}", "+", "+@tf.function(jit_compile=True)", "+def test():", "+   y = func(**para)", "+   return y", "+", "+test()", "+```", "+", "+### Patches", "+We have patched the issue in GitHub commit [728113a3be690facad6ce436660a0bc1858017fa](https://github.com/tensorflow/tensorflow/commit/728113a3be690facad6ce436660a0bc1858017fa).", "+", "+The fix will be included in TensorFlow 2.12.0. We will also cherrypick this commit on TensorFlow 2.11.1", "+", "+", "+### For more information", "+Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.", "+", "+", "+### Attribution", "+This vulnerability has been reported by r3pwnx", "@@ -0,0 +1,33 @@", "+## TFSA-2023-181: FPE in TensorListSplit with XLA ", "+", "+### CVE Number", "+CVE-2023-25673", "+", "+### Impact", "+FPE in TensorListSplit with XLA ", "+```python", "+import tensorflow as tf", "+", "+func = tf.raw_ops.TensorListSplit", "+para = {'tensor': [1], 'element_shape': -1, 'lengths': [0]}", "+", "+@tf.function(jit_compile=True)", "+def fuzz_jit():", "+ y = func(**para)", "+ return y", "+", "+print(fuzz_jit())", "+```", "+", "+### Patches", "+We have patched the issue in GitHub commit [728113a3be690facad6ce436660a0bc1858017fa](https://github.com/tensorflow/tensorflow/commit/728113a3be690facad6ce436660a0bc1858017fa).", "+", "+The fix will be included in TensorFlow 2.12.0. We will also cherrypick this commit on TensorFlow 2.11.1", "+", "+", "+### For more information", "+Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.", "+", "+", "+### Attribution", "+This vulnerability has been reported by r3pwnx", "\\ No newline at end of file", "@@ -0,0 +1,33 @@", "+## TFSA-2023-183: FPE in TensorListSplit with XLA ", "+", "+### CVE Number", "+CVE-2023-25673", "+", "+### Impact", "+FPE in TensorListSplit with XLA ", "+```python", "+import tensorflow as tf", "+", "+func = tf.raw_ops.TensorListSplit", "+para = {'tensor': [1], 'element_shape': -1, 'lengths': [0]}", "+", "+@tf.function(jit_compile=True)", "+def fuzz_jit():", "+ y = func(**para)", "+ return y", "+", "+print(fuzz_jit())", "+```", "+", "+### Patches", "+We have patched the issue in GitHub commit [728113a3be690facad6ce436660a0bc1858017fa](https://github.com/tensorflow/tensorflow/commit/728113a3be690facad6ce436660a0bc1858017fa).", "+", "+The fix will be included in TensorFlow 2.12.0. We will also cherrypick this commit on TensorFlow 2.11.1", "+", "+", "+### For more information", "+Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.", "+", "+", "+### Attribution", "+This vulnerability has been reported by r3pwnx", "\\ No newline at end of file", "@@ -0,0 +1,26 @@", "+## TFSA-2023-185: Segmentation fault in tfg-translate ", "+", "+### CVE Number", "+CVE-2023-25671", "+", "+### Impact", "+Out-of-bounds access due to mismatched integer type sizes in ValueMap::Manager::GetValueOrCreatePlaceholder. Bug with tfg-translate call to InitMlir. The problem happens with generic functions, as it is already handled for non-generic functions. This is because they, unlike non-generic functions, are using the \"old importer\". A better long-term solution may be to have the \"new importer\" handle generic functions.", "+", "+### Patches", "+We have patched the issue in GitHub", "+- commit [760322a71ac9033e122ef1f4b1c62813021e5938](https://github.com/tensorflow/tensorflow/commit/760322a71ac9033e122ef1f4b1c62813021e5938).", "+- commit [2eedc8f676d2c3b8be9492e547b2bc814c10b367](https://github.com/tensorflow/tensorflow/commit/2eedc8f676d2c3b8be9492e547b2bc814c10b367)", "+", "+The fix will be included in TensorFlow 2.12.0. We will also cherrypick this commit on TensorFlow 2.11.1", "+", "+", "+### For more information", "+Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.", "+", "+", "+### Attribution", "+This vulnerability has been reported by r3pwnx", "+", "+### Affiliation", "+360 AIVul", "+", "@@ -0,0 +1,28 @@", "+## TFSA-2023-187: NPE in QuantizedMatMulWithBiasAndDequantize", "+", "+### CVE Number", "+CVE-2023-25670", "+", "+### Impact", "+NPE in QuantizedMatMulWithBiasAndDequantize with MKL enable ", "+```python", "+import tensorflow as tf", "+", "+func = tf.raw_ops.QuantizedMatMulWithBiasAndDequantize", "+para={'a': tf.constant(138, dtype=tf.quint8), 'b': tf.constant(4, dtype=tf.qint8), 'bias': [[31.81644630432129, 47.21876525878906], [109.95201110839844, 152.07968139648438]], 'min_a': 141.5337138686371, 'max_a': [73.84139251708984, 173.15280151367188], 'min_b': [], 'max_b': [[16.128345489501953, 193.26820373535156]], 'min_freezed_output': [], 'max_freezed_output': [115.50032806396484, 156.974853515625], 'Toutput': 1.0, 'transpose_a': True, 'transpose_b': False, 'input_quant_mode': 'MIN_FIRST'}", "+", "+func(**para)", "+```", "+", "+### Patches", "+We have patched the issue in GitHub commit [8a47a39d9697969206d23a523c977238717e8727](https://github.com/tensorflow/tensorflow/commit/8a47a39d9697969206d23a523c977238717e8727).", "+", "+The fix will be included in TensorFlow 2.12.0. We will also cherrypick this commit on TensorFlow 2.11.1", "+", "+", "+### For more information", "+Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.", "+", "+", "+### Attribution", "+This vulnerability has been reported by r3pwnx", "@@ -0,0 +1,32 @@", "+## TFSA-2023-189: FPE in AvgPoolGrad with XLA", "+", "+### CVE Number", "+CVE-2023-25669", "+", "+### Impact", "+If the stride and window size are not positive for `tf.raw_ops.AvgPoolGrad`, it can give an FPE.", "+", "+```python", "+import tensorflow as tf", "+import numpy as np", "+", "+@tf.function(jit_compile=True)", "+def test():", "+   y = tf.raw_ops.AvgPoolGrad(orig_input_shape=[1,0,0,0], grad=[[[[0.39117979]]]], ksize=[1,0,0,0], strides=[1,0,0,0], padding=\"SAME\", data_format=\"NCHW\")", "+   return y", "+", "+print(test())", "+```", "+", "+### Patches", "+We have patched the issue in GitHub commit [1295ae4dbb52fe06b19733b0257e2340d7b63b8d](https://github.com/tensorflow/tensorflow/commit/1295ae4dbb52fe06b19733b0257e2340d7b63b8d).", "+", "+The fix will be included in TensorFlow 2.12. We will also cherrypick this commit on TensorFlow 2.11.1.", "+", "+", "+### For more information", "+Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.", "+", "+", "+### Attribution", "+This vulnerability has been reported by r3pwnx of 360 AIVul Team", "@@ -2692,4 +2692,41 @@ func.func private @_func(%arg0: tensor<?xi32, #mhlo.type_extensions<bounds = [51", "     %0 = \"tf.A\"(%arg0) {} : (tensor<?xi32, #mhlo.type_extensions<bounds = [512]>>) -> tensor<512xi32>", "     return %0 : tensor<512xi32>", "   }", "-}", "\\ No newline at end of file", "+}", "+", "+// -----", "+", "+// The following xla.OpSharding is used:", "+// Proto debug string:", "+//   type : OTHER", "+//   tile_assignment_dimensions: 1", "+//   tile_assignment_dimensions: 1", "+//   tile_assignment_dimensions: 4", "+//   tile_assignment_devices: 0", "+//   tile_assignment_devices: 1", "+//   tile_assignment_devices: 2", "+//   tile_assignment_devices: 3", "+//   last_tile_dims: REPLICATED", "+// Serialized string:", "+//   \"\\08\\03\\1A\\03\\01\\01\\04\\22\\04\\00\\01\\02\\03B\\01\\00\"", "+", "+// Test that SplitOp is not generated when an input sharding has ", "+// last_tile_dims REPLICATED and more tile_assignment_dimensions ", "+// than tensor dimenstions, even when the SPMD sharding is enabled and", "+// num_cores_per_replica is more than 1.", "+// Test that ConcatV2 Op is not generated when a output sharding has ", "+// last_tile_dims REPLICATED and more tile_assignment_dimensions ", "+// than tensor dimenstions, even when the SPMD sharding is enabled and", "+// num_cores_per_replica is more than 1.", "+//CHECK-NOT: tf.Split", "+// CHECK-NOT: tf.ConcatV2", "+module attributes {tf.versions = {producer = 888 : i32}, tf.devices = [\"/job:worker/replica:0/task:0/device:CPU:0\", \"/job:worker/replica:0/task:0/device:TPU_SYSTEM:0\", \"/job:worker/replica:0/task:0/device:TPU:0\", \"/job:worker/replica:0/task:0/device:TPU:1\", \"/job:worker/replica:0/task:0/device:TPU:2\", \"/job:worker/replica:0/task:0/device:TPU:3\"]} {", "+  func.func @cluster_to_single_core(%arg0: tensor<4x128xf32>) -> tensor<4x128xf32> {", "+    %0 = \"tf_device.cluster_func\"(%arg0) {_xla_compile_device_type = \"TPU\", _replication_info = \"cluster1\", func = @_func, num_replica = 1, num_cores_per_replica = 4, step_marker_location = \"STEP_MARK_AT_ENTRY\", topology = \"\\0A\\04\\02\\02\\01\\01\\10\\01\\18\\04\\22\\10\\00\\00\\00\\00\\01\\00\\00\\00\\00\\01\\00\\00\\01\\01\\00\\00\", device_assignment = [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0], input_sharding_configuration = [\"\\08\\03\\1A\\03\\01\\01\\04\\22\\04\\00\\01\\02\\03B\\01\\00\"], output_sharding_configuration = [\"\\08\\03\\1A\\03\\01\\01\\04\\22\\04\\00\\01\\02\\03B\\01\\00\"], use_spmd_for_xla_partitioning = true, use_tpu = true} : (tensor<4x128xf32>) -> tensor<4x128xf32>", "+    func.return %0 : tensor<4x128xf32>", "+  }", "+  func.func @_func(%arg0: tensor<4x128xf32>) -> tensor<4x128xf32> {", "+    func.return %arg0 : tensor<4x128xf32>", "+  }", "+}", "+", "@@ -564,14 +564,25 @@ func.func @func(%arg0: tensor<*xi32> {tf.aliasing_output = 1 : i64},", " ", " // -----", " ", "-// Partial tiled inputs using XlaSharding ops should fallback to MPMD mode.", "+// Partial tiled inputs using XlaSharding ops identified as REPLICATED should keep the sharding configuration.", "+// The following xla.OpSharding is used:", "+// Proto debug string:", "+//   type : OTHER", "+//   tile_assignment_dimensions: 1", "+//   tile_assignment_dimensions: 1", "+//   tile_assignment_dimensions: 2", "+//   tile_assignment_devices: 0", "+//   tile_assignment_devices: 1", "+//   last_tile_dims: REPLICATED", "+// Serialized string:", "+// \"\\08\\03\\1A\\03\\01\\01\\02\\22\\02\\00\\01B\\01\\00\"", " ", " // CHECK-LABEL: func @check_partial_tile_mpmd_fallback", " func.func @check_partial_tile_mpmd_fallback(%arg0: tensor<2x7xi64>) -> tensor<2x7xi32> {", "   // CHECK:      tf_device.cluster_func", "-  // CHECK-SAME: input_sharding_configuration = [\"\\08\\01\\1A\\01\\01\\22\\01\\00\"]", "-  // CHECK-SAME: output_sharding_configuration = [\"\\08\\01\\1A\\01\\01\\22\\01\\00\"]", "-  // CHECK-SAME: use_spmd_for_xla_partitioning = false", "+  // CHECK-SAME: input_sharding_configuration = [\"\\08\\03\\1A\\03\\01\\01\\02\\22\\02\\00\\01B\\01\\00\"]", "+  // CHECK-SAME: output_sharding_configuration = [\"\"]", "+  // CHECK-SAME: use_spmd_for_xla_partitioning = true", "   %0 = \"tf_device.cluster_func\"(%arg0) {", "       func = @func,", "       use_spmd_for_xla_partitioning = true, num_cores_per_replica = 2 : i64", "@@ -581,8 +592,7 @@ func.func @check_partial_tile_mpmd_fallback(%arg0: tensor<2x7xi64>) -> tensor<2x", " }", " ", " // CHECK-LABEL: func @func", "-// CHECK-SAME: %arg0: tensor<2x7xi64> {mhlo.sharding = \"\\08\\01\\1A\\01\\01\\22\\01\\00\"", "-// CHECK-SAME: ->{{.*}}mhlo.sharding = \"\\08\\01\\1A\\01\\01\\22\\01\\00\"", "+// CHECK-SAME: %arg0: tensor<2x7xi64> {mhlo.sharding = \"\\08\\03\\1A\\03\\01\\01\\02\\22\\02\\00\\01B\\01\\00\"", " func.func @func(%arg0: tensor<2x7xi64>) -> (tensor<2x7xi32>) {", "   %0 = \"tf.Cast\"(%arg0) {Truncate = false} : (tensor<2x7xi64>) -> tensor<2x7xi32>", "   %1 = \"tf.XlaSharding\"(%0) {_XlaSharding = \"\\08\\03\\1A\\03\\01\\01\\02\\22\\02\\00\\01B\\01\\00\", sharding = \"\\08\\03\\1A\\03\\01\\01\\02\\22\\02\\00\\01B\\01\\00\", unspecified_dims = []} : (tensor<2x7xi32>) -> tensor<2x7xi32>", "@@ -178,13 +178,11 @@ LogicalResult VerifySharding(mlir::Type type,", "     const int64_t tensor_rank = ranked_type.getRank();", "     int tile_assignment_rank = sharding->tile_assignment_dimensions_size();", " ", "-    if (partitioned_op) {", "-      // When a tensor is partial or subgroup tiled, its tile assignment will", "-      // have one or more dimension(s) than its rank; so, we subtract them to", "-      // determine which rank the sharding is compatible with.", "-      tile_assignment_rank -= (int)sharding->replicate_on_last_tile_dim();", "-      tile_assignment_rank -= sharding->last_tile_dims_size();", "-    }", "+    // When a tensor is partial or subgroup tiled, its tile assignment will", "+    // have one or more dimension(s) than its rank; so, we subtract them to", "+    // determine which rank the sharding is compatible with.", "+    tile_assignment_rank -= (int)sharding->replicate_on_last_tile_dim();", "+    tile_assignment_rank -= sharding->last_tile_dims_size();", " ", "     if (tensor_rank < tile_assignment_rank) {", "       if (partitioned_op) {", "@@ -41,6 +41,47 @@ namespace {", " ", " constexpr char kNumSplitAttr[] = \"num_split\";", " ", "+// Gets the proper tensor dimension from XLA OpSharding.", "+// \"replicate_on_last_tile_dim\" and \"last_tile_dims\" should be deducted from the", "+// real Tensor dimensions when tiled.", "+// For example:", "+// f32[8,512](sharding={devices=[1,1,2]0,1 last_tile_dims={REPLICATED})", "+// also means a replicated tensor over all devices.", "+//", "+// See xla_data.proto for detailed explanations on the fields.", "+int GetDimsFromXLAShardingTiled(const xla::OpSharding& xla_sharding) {", "+  return xla_sharding.tile_assignment_dimensions_size() -", "+         (xla_sharding.replicate_on_last_tile_dim() ? 1 : 0) -", "+         xla_sharding.last_tile_dims_size();", "+}", "+", "+// A sharding with OTHER type may be REPLICATED if:", "+// 'replicate_on_last_tile_dim' is true OR", "+// 'last_tile_dims' is not empty", "+// AND", "+// other than replicated last tile dims, all other dims are not sharded.", "+bool IsOtherReplicatedSharding(const xla::OpSharding& xla_sharding) {", "+  int max_dim = GetDimsFromXLAShardingTiled(xla_sharding);", "+  for (int i = 0; i < max_dim; ++i) {", "+    if (xla_sharding.tile_assignment_dimensions(i) != 1) {", "+      return false;", "+    }", "+  }", "+  return xla_sharding.type() == xla::OpSharding::OTHER &&", "+         (xla_sharding.replicate_on_last_tile_dim() ||", "+          !xla_sharding.last_tile_dims().empty());", "+}", "+", "+bool IsSplitSharding(const xla::OpSharding& sharding) {", "+  return sharding.type() == xla::OpSharding::OTHER &&", "+         !IsOtherReplicatedSharding(sharding);", "+}", "+", "+bool IsReplicatedSharding(const xla::OpSharding& sharding) {", "+  return sharding.type() == xla::OpSharding::REPLICATED ||", "+         IsOtherReplicatedSharding(sharding);", "+}", "+", " // Creates a tf::SplitOp that splits 'src_input' into 'num_splits' ways", " // in 'split_dimension' dimension and returns the split values.", " mlir::LogicalResult CreateSplitOp(const int num_split,", "@@ -186,14 +227,9 @@ mlir::LogicalResult HandleTileShardedInputs(", "   // from which sharded data will be fed into TPUExcute ops -- sorted by", "   // row major order.", "   tiled_inputs->reserve(input_sharding.tile_assignment_devices_size());", "-  // No split happens. Insert the original value.", "-  if (split_ops_for_tiled_input.empty()) {", "-    tiled_inputs->push_back(original_source);", "-  } else {", "-    for (auto split_op : split_ops_for_tiled_input)", "-      tiled_inputs->append(split_op.getResults().begin(),", "-                           split_op.getResults().end());", "-  }", "+  for (auto split_op : split_ops_for_tiled_input)", "+    tiled_inputs->append(split_op.getResults().begin(),", "+                         split_op.getResults().end());", " ", "   return mlir::success();", " }", "@@ -282,7 +318,7 @@ mlir::LogicalResult ExtractInputsForLogicalDevices(", "       continue;", "     }", " ", "-    if (input_sharding_type == xla::OpSharding::OTHER) {", "+    if (IsSplitSharding(sharding)) {", "       llvm::SmallVector<mlir::Value, 4> tiled_inputs;", "       auto result = HandleTileShardedInputs(", "           cluster_func.getLoc(), sharding, input_value, builder, &tiled_inputs);", "@@ -296,7 +332,7 @@ mlir::LogicalResult ExtractInputsForLogicalDevices(", "         const int assigned_logical_device = sharding.tile_assignment_devices(i);", "         (*input_list)[assigned_logical_device].emplace_back(tiled_inputs[i]);", "       }", "-    } else if (input_sharding_type == xla::OpSharding::REPLICATED) {", "+    } else if (IsReplicatedSharding(sharding)) {", "       for (auto& inputs : *input_list) inputs.emplace_back(input_value);", "     } else {", "       assert(input_sharding_type == xla::OpSharding::MAXIMAL);", "@@ -525,14 +561,13 @@ mlir::LogicalResult GetOutputTypesForLogicalDeviceComputation(", "        llvm::enumerate(cluster_func.getResults())) {", "     const auto output_index = result_and_index.index();", "     const auto& output_sharding = output_sharding_config[output_index];", "-    const auto output_sharding_type = output_sharding.type();", "     const auto cluster_func_output_type =", "         result_and_index.value().getType().cast<mlir::TensorType>();", " ", "     // If output shape of cluster func is statically known and output is tiled", "     // sharded, then the corresponding output shape of cluster func must be", "     // evenly divisible number of shardings.", "-    if (output_sharding_type == xla::OpSharding::OTHER) {", "+    if (IsSplitSharding(output_sharding)) {", "       mlir::Type tiled_logical_computation_type;", "       if (cluster_func_output_type.hasRank()) {", "         auto result = ValidateAndGetTiledExecuteOutputShape(", "@@ -544,7 +579,7 @@ mlir::LogicalResult GetOutputTypesForLogicalDeviceComputation(", "       }", "       cluster_to_core_index->emplace_back(core_index++);", "       output_types->emplace_back(tiled_logical_computation_type);", "-    } else if (output_sharding_type == xla::OpSharding::REPLICATED ||", "+    } else if (IsReplicatedSharding(output_sharding) ||", "                IsAssignedToLogicalDevice(core_id, output_sharding)) {", "       cluster_to_core_index->emplace_back(core_index++);", "       output_types->emplace_back(cluster_func_output_type);", "@@ -634,7 +669,7 @@ mlir::LogicalResult RemapOutputsFromLogicalDevices(", "       continue;", "     }", " ", "-    if (output_sharding_type == xla::OpSharding::OTHER) {", "+    if (IsSplitSharding(output_sharding)) {", "       if (failed(HandleTileShardedOutputs(", "               tpu_cluster_output_index, output_sharding_config,", "               cluster_to_core_index, location, old_parallel_execute_output,", "@@ -152,11 +152,13 @@ def canonicalize_signatures(signatures):", "     # Re-wrap the function so that it returns a dictionary of Tensors. This", "     # matches the format of 1.x-style signatures.", "     # pylint: disable=cell-var-from-loop", "-    @def_function.function", "     def signature_wrapper(**kwargs):", "       structured_outputs = signature_function(**kwargs)", "       return _normalize_outputs(", "           structured_outputs, signature_function.name, signature_key)", "+    if hasattr(function, \"__name__\"):", "+      signature_wrapper.__name__ = \"signature_wrapper_\" + function.__name__", "+    wrapped_function = def_function.function(signature_wrapper)", "     tensor_spec_signature = {}", "     if signature_function.structured_input_signature is not None:", "       # The structured input signature may contain other non-tensor arguments.", "@@ -177,7 +179,7 @@ def canonicalize_signatures(signatures):", "       else:", "         spec = tensor_spec.TensorSpec.from_tensor(inp, name=keyword)", "       tensor_spec_signature[keyword] = spec", "-    final_concrete = signature_wrapper._get_concrete_function_garbage_collected(  # pylint: disable=protected-access", "+    final_concrete = wrapped_function._get_concrete_function_garbage_collected(  # pylint: disable=protected-access", "         **tensor_spec_signature)", "     # pylint: disable=protected-access", "     if len(final_concrete._arg_keywords) == 1:", "@@ -218,7 +218,6 @@ from tensorflow.python.ops import array_ops", " from tensorflow.python.ops import control_flow_ops", " from tensorflow.python.ops import custom_gradient", " from tensorflow.python.ops import math_ops", "-from tensorflow.python.ops import resource_variable_ops", " from tensorflow.python.ops import summary_ops_v2", " from tensorflow.python.ops import variable_scope", " from tensorflow.python.platform import tf_logging", "@@ -3804,7 +3803,7 @@ def _from_proto_fn(v, import_scope=None):", "   else:", "     return _original_from_proto(v, import_scope=import_scope)", " ", "-resource_variable_ops._from_proto_fn = _from_proto_fn", "+variable_scope._from_proto_fn = _from_proto_fn", " # pylint: enable=protected-access", " ", " ", "@@ -2516,7 +2516,7 @@ class FunctionalInputLayerTest(test.TestCase):", "       self.assertEqual(0, len(cols_to_vars[dense_feature_bucketized]))", "       self.assertEqual(1, len(cols_to_vars[some_embedding_column]))", "       self.assertIsInstance(cols_to_vars[some_embedding_column][0],", "-                            variables_lib.VariableV1)", "+                            variables_lib.Variable)", "       self.assertAllEqual(cols_to_vars[some_embedding_column][0].shape, [5, 10])", " ", "   def test_fills_cols_to_vars_shared_embedding(self):", "@@ -45,6 +45,7 @@ tf_py_test(", "     deps = [", "         \"//tensorflow/python:array_ops\",", "         \"//tensorflow/python:client_testlib\",", "+        \"//tensorflow/python:control_flow_ops\",", "         \"//tensorflow/python:framework_for_generated_wrappers\",", "         \"//tensorflow/python:init_ops\",", "         \"//tensorflow/python:partitioned_variables\",", "@@ -23,6 +23,7 @@ from tensorflow.python.framework import dtypes", " from tensorflow.python.framework import ops", " from tensorflow.python.framework import test_util", " from tensorflow.python.ops import array_ops", "+from tensorflow.python.ops import control_flow_ops", " from tensorflow.python.ops import init_ops", " from tensorflow.python.ops import partitioned_variables", " from tensorflow.python.ops import random_ops", "@@ -32,6 +33,13 @@ from tensorflow.python.platform import test", " from tensorflow.python.training import saver as saver_lib", " ", " ", "+def initialized_value(var):", "+  return control_flow_ops.cond(", "+      variables.is_variable_initialized(var),", "+      var.read_value,", "+      lambda: var.initial_value)", "+", "+", " class PartitionerCreatorsTest(test.TestCase):", " ", "   def testFixedSizePartitioner(self):", "@@ -408,7 +416,7 @@ class PartitionedVariablesTestCase(test.TestCase):", "     with self.cached_session():", "       rnd = variables.Variable(random_ops.random_uniform([200, 40]))", "       vs = partitioned_variables.create_partitioned_variables(", "-          rnd.get_shape(), [1, 10], rnd.initialized_value())", "+          rnd.get_shape(), [1, 10], initialized_value(rnd))", "       self.evaluate(variables.global_variables_initializer())", "       val = array_ops.concat(vs, 1)", "       rnd = self.evaluate(rnd)", "@@ -427,7 +435,7 @@ class PartitionedVariablesTestCase(test.TestCase):", "           random_ops.random_uniform([20, 43], dtype=dtypes.float64))", "       var_lists = [", "           partitioned_variables.create_partitioned_variables(", "-              rnd.get_shape(), [1, i], rnd.initialized_value())", "+              rnd.get_shape(), [1, i], initialized_value(rnd))", "           for i in range(1, 10)", "       ]", "       self.evaluate(variables.global_variables_initializer())", "@@ -463,7 +471,7 @@ class PartitionedVariablesTestCase(test.TestCase):", "     with self.cached_session():", "       rnd = variables.Variable(random_ops.random_uniform([10, 43]))", "       vs = partitioned_variables.create_partitioned_variables(", "-          rnd.get_shape(), [1, 1], rnd.initialized_value())", "+          rnd.get_shape(), [1, 1], initialized_value(rnd))", "       self.evaluate(variables.global_variables_initializer())", "       val = array_ops.concat(vs, 0)", "       rnd = self.evaluate(rnd)", "@@ -474,7 +482,7 @@ class PartitionedVariablesTestCase(test.TestCase):", "     with self.cached_session():", "       rnd = variables.Variable(random_ops.random_uniform([10, 43]))", "       vs = partitioned_variables.create_partitioned_variables(", "-          rnd.get_shape(), [10, 1], rnd.initialized_value())", "+          rnd.get_shape(), [10, 1], initialized_value(rnd))", "       self.evaluate(variables.global_variables_initializer())", "       val = array_ops.concat(vs, 0)", "       rnd = self.evaluate(rnd)", "@@ -524,25 +532,25 @@ class PartitionedVariablesTestCase(test.TestCase):", "       rnd = variables.Variable(random_ops.random_uniform([10, 43]))", "       with self.assertRaises(ValueError):", "         partitioned_variables.create_partitioned_variables(", "-            [10], [1, 1], rnd.initialized_value())", "+            [10], [1, 1], initialized_value(rnd))", "       with self.assertRaises(ValueError):", "         partitioned_variables.create_partitioned_variables(", "-            [10, 20], [1], rnd.initialized_value())", "+            [10, 20], [1], initialized_value(rnd))", "       with self.assertRaises(ValueError):", "         partitioned_variables.create_partitioned_variables(", "-            [10, 43], [1], rnd.initialized_value())", "+            [10, 43], [1], initialized_value(rnd))", "       with self.assertRaises(ValueError):", "         partitioned_variables.create_partitioned_variables(", "-            [10, 43], [1, 2, 3], rnd.initialized_value())", "+            [10, 43], [1, 2, 3], initialized_value(rnd))", "       with self.assertRaises(ValueError):", "         partitioned_variables.create_partitioned_variables(", "-            [10, 43], [11, 1], rnd.initialized_value())", "+            [10, 43], [11, 1], initialized_value(rnd))", "       with self.assertRaises(ValueError):", "         partitioned_variables.create_partitioned_variables(", "-            [10, 43], [20, 1], rnd.initialized_value())", "+            [10, 43], [20, 1], initialized_value(rnd))", "       with self.assertRaises(ValueError):", "         partitioned_variables.create_partitioned_variables(", "-            [10, 43], [1, 50], rnd.initialized_value())", "+            [10, 43], [1, 50], initialized_value(rnd))", " ", "   @test_util.run_deprecated_v1", "   def testControlDepsNone(self):", "@@ -199,13 +199,22 @@ class ResourceVariableOpsTest(test_util.TensorFlowTestCase,", "     with context.eager_mode():", "       variable = resource_variable_ops.ResourceVariable(1.0, name=\"eager-init\")", "       self.assertAllEqual(variable.numpy(), 1.0)", "-      self.assertAllEqual(variable.initialized_value().numpy(), 1.0)", "+      self.assertAllEqual(variable.read_value().numpy(), 1.0)", " ", "   def testInitializeVariableUsingInitializedValue(self):", "     var1 = resource_variable_ops.ResourceVariable(1.0, name=\"var1\")", "-    var2 = resource_variable_ops.ResourceVariable(var1.initialized_value(),", "-                                                  name=\"var2\")", "-    self.assertAllEqual(var2.initialized_value(), 1.0)", "+    var2 = resource_variable_ops.ResourceVariable(", "+        control_flow_ops.cond(", "+            variables.is_variable_initialized(var1),", "+            var1.read_value,", "+            lambda: var1.initial_value),", "+        name=\"var2\")", "+    self.assertAllEqual(", "+        control_flow_ops.cond(", "+            variables.is_variable_initialized(var2),", "+            var2.read_value,", "+            lambda: var2.initial_value),", "+        1.0)", " ", "   def testEagerBool(self):", "     with context.eager_mode():", "@@ -977,12 +986,12 @@ class ResourceVariableOpsTest(test_util.TensorFlowTestCase,", "     with ops.Graph().as_default(), self.cached_session():", "       # v describes a VariableDef-based variable without an initial value.", "       v = resource_variable_ops.ResourceVariable(variable_def=v_def)", "-      self.assertEqual(3.0, self.evaluate(v.initialized_value()))", "+      self.assertEqual(3.0, self.evaluate(v.initial_value))", " ", "-      # initialized_value should not rerun the initializer_op if the variable", "+      # read_value should not rerun the initializer_op if the variable", "       # has already been initialized elsewhere.", "       self.evaluate(v.assign(1.0))", "-      self.assertEqual(1.0, v.initialized_value().eval())", "+      self.assertEqual(1.0, v.read_value().eval())", " ", "     v_def.ClearField(\"initial_value_name\")", "     with ops.Graph().as_default(), self.cached_session():", "@@ -991,9 +1000,12 @@ class ResourceVariableOpsTest(test_util.TensorFlowTestCase,", "       v = resource_variable_ops.ResourceVariable(variable_def=v_def)", "       # We should also be able to re-export the variable to a new meta graph.", "       self.assertProtoEquals(v_def, v.to_proto())", "-      # But attempts to use initialized_value will result in errors.", "+      # But attempts to use read_value will result in errors.", "       with self.assertRaises(ValueError):", "-        self.evaluate(v.initialized_value())", "+        self.evaluate(control_flow_ops.cond(", "+            variables.is_variable_initialized(v),", "+            v.read_value,", "+            lambda: v.initial_value))", " ", "   def testTrainableInProto(self):", "     with ops.Graph().as_default():", "@@ -30,6 +30,7 @@ from tensorflow.python.framework import tensor_shape", " from tensorflow.python.framework import test_util", " from tensorflow.python.ops import array_ops", " from tensorflow.python.ops import cond as tf_cond", "+from tensorflow.python.ops import control_flow_ops", " from tensorflow.python.ops import gen_state_ops", " from tensorflow.python.ops import math_ops", " from tensorflow.python.ops import random_ops", "@@ -41,6 +42,13 @@ from tensorflow.python.training import gradient_descent", " from tensorflow.python.util import compat", " ", " ", "+def initialized_value(var):", "+  return control_flow_ops.cond(", "+      variables.is_variable_initialized(var),", "+      var.read_value,", "+      lambda: var.initial_value)", "+", "+", " class VariablesTestCase(test.TestCase, parameterized.TestCase):", " ", "   @test_util.run_deprecated_v1", "@@ -85,14 +93,14 @@ class VariablesTestCase(test.TestCase, parameterized.TestCase):", "       self.assertEqual([3, 6], rnd.get_shape())", "       self.assertEqual([3, 6], rnd.shape)", " ", "-      dep = variables.Variable(rnd.initialized_value(), name=\"dep\")", "+      dep = variables.Variable(initialized_value(rnd), name=\"dep\")", "       self.assertEqual(\"dep:0\", dep.name)", "       self.assertEqual([3, 6], dep.get_shape())", "       self.assertEqual([3, 6], dep.get_shape())", "       self.assertEqual([3, 6], dep.shape)", " ", "       # Currently have to set the shape manually for Add.", "-      added_val = rnd.initialized_value() + dep.initialized_value() + 2.0", "+      added_val = initialized_value(rnd) + initialized_value(dep) + 2.0", "       added_val.set_shape(rnd.get_shape())", " ", "       depdep = variables.Variable(added_val, name=\"depdep\")", "@@ -328,7 +336,7 @@ class VariablesTestCase(test.TestCase, parameterized.TestCase):", "   def testCachingDevice(self):", "     with self.cached_session():", "       var = variables.Variable(2.0)", "-      self.assertEqual(var.device, var.initialized_value().device)", "+      self.assertEqual(var.device, initialized_value(var).device)", " ", "       var_cached = variables.Variable(2.0, caching_device=\"/job:foo\")", "       self.assertFalse(var_cached.device.startswith(\"/job:foo\"))", "@@ -477,7 +485,7 @@ class VariablesTestCase(test.TestCase, parameterized.TestCase):", "         self.evaluate(v1)", " ", "       v2 = variables.Variable(", "-          math_ops.negative(v1.initialized_value()), dtype=dtypes.float32)", "+          math_ops.negative(initialized_value(v1)), dtype=dtypes.float32)", "       self.assertEqual(v1.get_shape(), v2.get_shape())", "       self.assertEqual(v1.shape, v2.shape)", "       self.assertAllClose(np.negative(value), self.evaluate(v2.initial_value))", "@@ -504,8 +512,8 @@ class VariablesTestCase(test.TestCase, parameterized.TestCase):", "   def testNoRefDataRace(self):", "     with self.cached_session():", "       a = variables.Variable([1, 2, 3], dtype=dtypes.float32)", "-      b = variables.Variable(a.initialized_value() + 2)", "-      c = variables.Variable(b.initialized_value() + 2)", "+      b = variables.Variable(initialized_value(a) + 2)", "+      c = variables.Variable(initialized_value(b) + 2)", "       self.evaluate(variables.global_variables_initializer())", "       self.assertAllEqual(self.evaluate(a), [1, 2, 3])", "       self.assertAllEqual(self.evaluate(b), [3, 4, 5])", "@@ -539,12 +547,12 @@ class VariablesTestCase(test.TestCase, parameterized.TestCase):", "     with ops.Graph().as_default(), self.cached_session() as sess:", "       # v describes a VariableDef-based variable without an initial value.", "       v = variables.Variable(variable_def=v_def)", "-      self.assertEqual(3.0, self.evaluate(v.initialized_value()))", "+      self.assertEqual(3.0, self.evaluate(initialized_value(v)))", " ", "       # initialized_value should not rerun the initializer_op if the variable", "       # has already been initialized elsewhere.", "       self.evaluate(v.assign(1.0))", "-      self.assertEqual(1.0, self.evaluate(v.initialized_value()))", "+      self.assertEqual(1.0, self.evaluate(initialized_value(v)))", " ", "     v_def.ClearField(\"initial_value_name\")", "     with ops.Graph().as_default(), self.cached_session() as sess:", "@@ -555,7 +563,7 @@ class VariablesTestCase(test.TestCase, parameterized.TestCase):", "       self.assertProtoEquals(v_def, v.to_proto())", "       # But attempts to use initialized_value will result in errors.", "       with self.assertRaises(ValueError):", "-        self.evaluate(v.initialized_value())", "+        self.evaluate(initialized_value(v))", " ", "   def testTrainableInProto(self):", "     with ops.Graph().as_default():", "@@ -550,7 +550,10 @@ class ExponentialMovingAverage:", "         with ops.init_scope():", "           if isinstance(var, variables.Variable):", "             with ops.device(var.device):", "-              initialized_value = var.initialized_value()", "+              initialized_value = control_flow_ops.cond(", "+                  variables.is_variable_initialized(var),", "+                  var.read_value,", "+                  lambda: var.initial_value)  # pylint: disable=cell-var-from-loop", "             avg = slot_creator.create_slot(", "                 var,", "                 initialized_value,", "@@ -38,6 +38,7 @@ update_mavg = mavg.assign_sub((mavg - var) * (1 - decay))", " from tensorflow.python.compiler.xla.experimental import xla_sharding", " from tensorflow.python.distribute import distribution_strategy_context", " from tensorflow.python.ops import array_ops", "+from tensorflow.python.ops import control_flow_ops", " from tensorflow.python.ops import init_ops", " from tensorflow.python.ops import resource_variable_ops", " from tensorflow.python.ops import variable_scope", "@@ -263,7 +264,10 @@ def create_zeros_slot(primary,", "         copy_xla_sharding=copy_xla_sharding)", "   else:", "     if isinstance(primary, variables.Variable):", "-      slot_shape = array_ops.shape(primary.initialized_value())", "+      slot_shape = array_ops.shape(control_flow_ops.cond(", "+          variables.is_variable_initialized(primary),", "+          primary.read_value,", "+          lambda: primary.initial_value))", "     else:", "       slot_shape = array_ops.shape(primary)", "     val = array_ops.zeros(slot_shape, dtype=dtype)", "@@ -22,6 +22,7 @@ from tensorflow.python.framework import constant_op", " from tensorflow.python.framework import dtypes", " from tensorflow.python.framework import ops", " from tensorflow.python.ops import array_ops", "+from tensorflow.python.ops import control_flow_ops", " from tensorflow.python.ops import partitioned_variables", " from tensorflow.python.ops import random_ops", " from tensorflow.python.ops import variable_scope", "@@ -30,13 +31,20 @@ from tensorflow.python.platform import test", " from tensorflow.python.training import slot_creator", " ", " ", "+def initialized_value(var):", "+  return control_flow_ops.cond(", "+      variables.is_variable_initialized(var),", "+      var.read_value,", "+      lambda: var.initial_value)", "+", "+", " class SlotCreatorTest(test.TestCase):", " ", "   def testCreateSlotFromVariable(self):", "     # slot_creator is used only in optimizer V1.", "     with ops.Graph().as_default(), self.cached_session():", "       v = variables.Variable([1.0, 2.5], name=\"var\")", "-      slot = slot_creator.create_slot(v, v.initialized_value(), name=\"slot\")", "+      slot = slot_creator.create_slot(v, initialized_value(v), name=\"slot\")", " ", "       self.evaluate(variables.global_variables_initializer())", " ", "@@ -131,7 +139,7 @@ class SlotCreatorTest(test.TestCase):", "     with ops.Graph().as_default(), self.cached_session():", "       with variable_scope.variable_scope(\"scope\"):", "         v = variables.Variable([1.0, 2.5], name=\"var\")", "-        slot = slot_creator.create_slot(v, v.initialized_value(), name=\"slot\")", "+        slot = slot_creator.create_slot(v, initialized_value(v), name=\"slot\")", "         self.assertEqual(\"scope/scope/var/slot\", slot.op.name)", " ", "   def testCreateSlotFromFirstMDimensionVariable(self):", "@@ -143,7 +151,7 @@ class SlotCreatorTest(test.TestCase):", "           shape=[2, 2],", "           partitioner=partitioned_variables.fixed_size_partitioner(2))", "       for i, v in enumerate(p_v):", "-        slot = slot_creator.create_slot(v, s.initialized_value(), name=\"slot\")", "+        slot = slot_creator.create_slot(v, initialized_value(s), name=\"slot\")", "         si = slot._save_slice_info", " ", "         self.evaluate(variables.global_variables_initializer())", "@@ -165,7 +173,7 @@ class SlotCreatorTest(test.TestCase):", "           shape=[2, 2],", "           partitioner=partitioned_variables.fixed_size_partitioner(2))", "       for i, v in enumerate(p_v):", "-        slot = slot_creator.create_slot(v, s.initialized_value(), name=\"slot\")", "+        slot = slot_creator.create_slot(v, initialized_value(s), name=\"slot\")", " ", "         self.evaluate(variables.global_variables_initializer())", " ", "@@ -181,7 +189,7 @@ class SlotCreatorTest(test.TestCase):", "       v = xla_sharding.mesh_split(", "           v, np.array([0, 1]), [0], use_sharding_op=False)", "       slot = slot_creator.create_slot(", "-          v, v.initialized_value(), name=\"slot\", copy_xla_sharding=True)", "+          v, initialized_value(v), name=\"slot\", copy_xla_sharding=True)", "       self.assertEqual(", "           xla_sharding.get_tensor_sharding(v),", "           xla_sharding.get_tensor_sharding(slot))", "@@ -17,6 +17,7 @@ from tensorflow.python.eager import context", " from tensorflow.python.framework import dtypes", " from tensorflow.python.framework import graph_io", " from tensorflow.python.framework import ops", "+from tensorflow.python.ops import control_flow_ops", " from tensorflow.python.ops import init_ops", " from tensorflow.python.ops import resource_variable_ops", " from tensorflow.python.ops import state_ops", "@@ -390,11 +391,17 @@ def _get_or_create_global_step_read(graph=None):", "   # add 'zero' so that it will create a copy of variable as Tensor.", "   with graph.as_default() as g, g.name_scope(None):", "     with g.name_scope(global_step_tensor.op.name + '/'):", "-      # using initialized_value to ensure that global_step is initialized before", "+      # must ensure that global_step is initialized before", "       # this run. This is needed for example Estimator makes all model_fn build", "       # under global_step_read_tensor dependency.", "-      global_step_value = global_step_tensor.initialized_value() if isinstance(", "-          global_step_tensor, variables.Variable) else global_step_tensor", "+      if isinstance(global_step_tensor, variables.Variable):", "+        global_step_value = control_flow_ops.cond(", "+            variables.is_variable_initialized(global_step_tensor),", "+            global_step_tensor.read_value,", "+            lambda: global_step_tensor.initial_value)", "+      else:", "+        global_step_value = global_step_tensor", "+", "       global_step_read_tensor = global_step_value + 0", "       ops.add_to_collection(GLOBAL_STEP_READ_KEY, global_step_read_tensor)", "   return _get_global_step_read(graph)", "@@ -355,7 +355,11 @@ py_library(", "         \"//tensorflow/python/autograph/converters:control_flow\",", "         \"//tensorflow/python/autograph/converters:return_statements\",", "         \"//tensorflow/python/autograph/impl:api\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:cfg\",", "+        \"//tensorflow/python/autograph/pyct:qual_names\",", "+        \"//tensorflow/python/autograph/pyct:transformer\",", "+        \"//tensorflow/python/autograph/pyct:transpiler\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:activity\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:reaching_definitions\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:reaching_fndefs\",", "@@ -392,6 +396,8 @@ py_library(", "     srcs_version = \"PY3\",", "     deps = [", "         \"//tensorflow:tensorflow_py\",", "+        \"//tensorflow/python/autograph/pyct:transformer\",", "+        \"//tensorflow/python/autograph/pyct:transpiler\",", "     ],", " )", " ", "@@ -15,7 +15,12 @@ py_library(", "     srcs_version = \"PY3\",", "     deps = [", "         \"//tensorflow/python:util\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:inspect_utils\",", "+        \"//tensorflow/python/autograph/pyct:naming\",", "+        \"//tensorflow/python/autograph/pyct:parser\",", "+        \"//tensorflow/python/autograph/pyct:qual_names\",", "+        \"//tensorflow/python/autograph/pyct:transformer\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:activity\",", "     ],", " )", "@@ -32,6 +32,7 @@ py_strict_library(", "         \"//tensorflow/python/autograph/lang:directives\",", "         \"//tensorflow/python/autograph/lang:special_functions\",", "         \"//tensorflow/python/autograph/operators\",", "+        \"//tensorflow/python/autograph/pyct/common_transformers\",", "         \"//tensorflow/python/autograph/utils:__init__\",", "         \"//tensorflow/python/autograph/utils:ag_logging\",", "     ],", "@@ -21,7 +21,7 @@ py_strict_library(", "     deps = [", "         \"//tensorflow/python/autograph/core:converter\",", "         \"//tensorflow/python/autograph/lang:directives\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:templates\",", "         \"@gast_archive//:gast\",", "     ],", " )", "@@ -32,7 +32,9 @@ py_strict_library(", "     visibility = [\"//tensorflow:__subpackages__\"],", "     deps = [", "         \"//tensorflow/python/autograph/core:converter\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:qual_names\",", "+        \"//tensorflow/python/autograph/pyct:templates\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:activity\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:annos\",", "     ],", "@@ -44,7 +46,7 @@ py_strict_library(", "     visibility = [\"//tensorflow:__subpackages__\"],", "     deps = [", "         \"//tensorflow/python/autograph/core:converter\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:templates\",", "         \"@gast_archive//:gast\",", "     ],", " )", "@@ -55,7 +57,8 @@ py_strict_library(", "     visibility = [\"//tensorflow:__subpackages__\"],", "     deps = [", "         \"//tensorflow/python/autograph/core:converter\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:parser\",", "+        \"//tensorflow/python/autograph/pyct:templates\",", "         \"@gast_archive//:gast\",", "     ],", " )", "@@ -66,7 +69,9 @@ py_strict_library(", "     visibility = [\"//tensorflow:__subpackages__\"],", "     deps = [", "         \"//tensorflow/python/autograph/core:converter\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:qual_names\",", "+        \"//tensorflow/python/autograph/pyct:templates\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:activity\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:annos\",", "     ],", "@@ -78,7 +83,8 @@ py_strict_library(", "     visibility = [\"//tensorflow:__subpackages__\"],", "     deps = [", "         \"//tensorflow/python/autograph/core:converter\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:parser\",", "+        \"//tensorflow/python/autograph/pyct:templates\",", "         \"@gast_archive//:gast\",", "     ],", " )", "@@ -89,7 +95,10 @@ py_strict_library(", "     visibility = [\"//tensorflow:__subpackages__\"],", "     deps = [", "         \"//tensorflow/python/autograph/core:converter\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:parser\",", "+        \"//tensorflow/python/autograph/pyct:qual_names\",", "+        \"//tensorflow/python/autograph/pyct:templates\",", "         \"//tensorflow/python/autograph/utils:ag_logging\",", "         \"@gast_archive//:gast\",", "     ],", "@@ -102,7 +111,12 @@ py_strict_library(", "     deps = [", "         \"//tensorflow/python/autograph/core:converter\",", "         \"//tensorflow/python/autograph/lang:directives\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:ast_util\",", "+        \"//tensorflow/python/autograph/pyct:cfg\",", "+        \"//tensorflow/python/autograph/pyct:parser\",", "+        \"//tensorflow/python/autograph/pyct:qual_names\",", "+        \"//tensorflow/python/autograph/pyct:templates\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:activity\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:annos\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:liveness\",", "@@ -119,7 +133,7 @@ py_strict_library(", "     deps = [", "         \"//tensorflow/python/autograph/core:converter\",", "         \"//tensorflow/python/autograph/lang:directives\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "         \"//tensorflow/python/util:tf_inspect\",", "         \"@gast_archive//:gast\",", "     ],", "@@ -131,7 +145,8 @@ py_strict_library(", "     visibility = [\"//tensorflow:__subpackages__\"],", "     deps = [", "         \"//tensorflow/python/autograph/core:converter\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:templates\",", "         \"@gast_archive//:gast\",", "     ],", " )", "@@ -143,7 +158,12 @@ py_strict_library(", "     deps = [", "         \"//tensorflow/python/autograph/core:converter\",", "         \"//tensorflow/python/autograph/lang:directives\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:cfg\",", "+        \"//tensorflow/python/autograph/pyct:origin_info\",", "+        \"//tensorflow/python/autograph/pyct:parser\",", "+        \"//tensorflow/python/autograph/pyct:qual_names\",", "+        \"//tensorflow/python/autograph/pyct:templates\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:activity\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:annos\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:liveness\",", "@@ -159,7 +179,10 @@ py_strict_library(", "     visibility = [\"//tensorflow:__subpackages__\"],", "     deps = [", "         \"//tensorflow/python/autograph/core:converter\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:parser\",", "+        \"//tensorflow/python/autograph/pyct:qual_names\",", "+        \"//tensorflow/python/autograph/pyct:templates\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:activity\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:annos\",", "         \"@gast_archive//:gast\",", "@@ -173,7 +196,10 @@ py_strict_library(", "     deps = [", "         \"//tensorflow/python/autograph/core:converter\",", "         \"//tensorflow/python/autograph/lang:directives\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:parser\",", "+        \"//tensorflow/python/autograph/pyct:qual_names\",", "+        \"//tensorflow/python/autograph/pyct:templates\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:activity\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:annos\",", "         \"@gast_archive//:gast\",", "@@ -186,7 +212,10 @@ py_strict_library(", "     visibility = [\"//tensorflow:__subpackages__\"],", "     deps = [", "         \"//tensorflow/python/autograph/core:converter\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:parser\",", "+        \"//tensorflow/python/autograph/pyct:qual_names\",", "+        \"//tensorflow/python/autograph/pyct:templates\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:activity\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:annos\",", "         \"@gast_archive//:gast\",", "@@ -199,7 +228,7 @@ py_strict_library(", "     visibility = [\"//tensorflow:__subpackages__\"],", "     deps = [", "         \"//tensorflow/python/autograph/core:converter\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:templates\",", "         \"@gast_archive//:gast\",", "     ],", " )", "@@ -229,7 +258,7 @@ py_strict_test(", "         \":break_statements\",", "         \"//tensorflow/python:client_testlib\",", "         \"//tensorflow/python/autograph/core:test_lib\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "     ],", " )", " ", "@@ -303,7 +332,7 @@ py_strict_test(", "         \"//tensorflow/python:client_testlib\",", "         \"//tensorflow/python/autograph/core:test_lib\",", "         \"//tensorflow/python/autograph/lang:directives\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "     ],", " )", " ", "@@ -36,7 +36,7 @@ py_strict_library(", "     srcs = [\"unsupported_features_checker.py\"],", "     visibility = [\"//tensorflow:__subpackages__\"],", "     deps = [", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:errors\",", "         \"@gast_archive//:gast\",", "     ],", " )", "@@ -74,7 +74,11 @@ py_strict_library(", "     srcs = [\"converter.py\"],", "     visibility = [\"//tensorflow:__subpackages__\"],", "     deps = [", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:ast_util\",", "+        \"//tensorflow/python/autograph/pyct:parser\",", "+        \"//tensorflow/python/autograph/pyct:templates\",", "+        \"//tensorflow/python/autograph/pyct:transformer\",", "         \"//tensorflow/python/util:tf_export\",", "     ],", " )", "@@ -88,7 +92,10 @@ py_strict_test(", "         \":converter\",", "         \":test_lib\",", "         \"//tensorflow/python:client_testlib\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:loader\",", "+        \"//tensorflow/python/autograph/pyct:parser\",", "+        \"//tensorflow/python/autograph/pyct:templates\",", "     ],", " )", " ", "@@ -31,7 +31,15 @@ py_strict_library(", "         \"//tensorflow/python/autograph/core:unsupported_features_checker\",", "         \"//tensorflow/python/autograph/lang:special_functions\",", "         \"//tensorflow/python/autograph/operators\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:cache\",", "+        \"//tensorflow/python/autograph/pyct:cfg\",", "+        \"//tensorflow/python/autograph/pyct:error_utils\",", "+        \"//tensorflow/python/autograph/pyct:errors\",", "+        \"//tensorflow/python/autograph/pyct:inspect_utils\",", "+        \"//tensorflow/python/autograph/pyct:origin_info\",", "+        \"//tensorflow/python/autograph/pyct:qual_names\",", "+        \"//tensorflow/python/autograph/pyct:transpiler\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:activity\",", "         \"//tensorflow/python/autograph/pyct/static_analysis:reaching_definitions\",", "         \"//tensorflow/python/autograph/utils:__init__\",", "@@ -50,7 +58,8 @@ py_strict_library(", "     visibility = [\"//tensorflow:__subpackages__\"],", "     deps = [", "         \"//tensorflow/python/autograph/core:config\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:cache\",", "+        \"//tensorflow/python/autograph/pyct:inspect_utils\",", "         \"//tensorflow/python/autograph/utils:ag_logging\",", "         \"//tensorflow/python/eager/polymorphic_function:tf_method_target\",", "         \"//tensorflow/python/util:tf_inspect\",", "@@ -71,7 +80,9 @@ tf_py_test(", "         \"//tensorflow/python/autograph/core:ag_ctx\",", "         \"//tensorflow/python/autograph/core:converter\",", "         \"//tensorflow/python/autograph/core:test_lib\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:errors\",", "+        \"//tensorflow/python/autograph/pyct:inspect_utils\",", "+        \"//tensorflow/python/autograph/pyct:parser\",", "         \"//tensorflow/python/autograph/utils:ag_logging\",", "         \"//tensorflow/python/data/ops:dataset_ops\",", "         \"//tensorflow/python/eager:def_function\",", "@@ -1,136 +1,283 @@", "-load(\"//tensorflow:tensorflow.bzl\", \"py_test\")", "+load(\"//tensorflow:strict.default.bzl\", \"py_strict_library\", \"py_strict_test\")", " ", " package(", "     # copybara:uncomment default_applicable_licenses = [\"//tensorflow:license\"],", "     licenses = [\"notice\"],", " )", " ", "-filegroup(", "-    name = \"all_files\",", "-    srcs = glob(", "-        [\"**/*\"],", "-        exclude = [", "-            \"**/METADATA\",", "-            \"**/OWNERS\",", "-        ],", "-    ),", "-    visibility = [\"//visibility:private\"],", "-)", "-", "-py_library(", "-    name = \"pyct\",", "-    srcs = [", "-        \"__init__.py\",", "-        \"anno.py\",", "-        \"ast_util.py\",", "-        \"cache.py\",", "-        \"cfg.py\",", "-        \"error_utils.py\",", "-        \"errors.py\",", "-        \"gast_util.py\",", "-        \"inspect_utils.py\",", "-        \"loader.py\",", "-        \"naming.py\",", "-        \"origin_info.py\",", "-        \"parser.py\",", "-        \"pretty_printer.py\",", "-        \"qual_names.py\",", "-        \"templates.py\",", "-        \"transformer.py\",", "-        \"transpiler.py\",", "+py_strict_library(", "+    name = \"templates\",", "+    srcs = [\"templates.py\"],", "+    visibility = [\"//visibility:public\"],", "+    deps = [", "+        \":anno\",", "+        \":ast_util\",", "+        \":parser\",", "+        \":qual_names\",", "+        \"@gast_archive//:gast\",", "     ],", "-    srcs_version = \"PY3\",", "+)", "+", "+py_strict_library(", "+    name = \"transpiler\",", "+    srcs = [\"transpiler.py\"],", "+    visibility = [\"//visibility:public\"],", "+    deps = [", "+        \":cache\",", "+        \":inspect_utils\",", "+        \":loader\",", "+        \":naming\",", "+        \":origin_info\",", "+        \":parser\",", "+        \":templates\",", "+        \":transformer\",", "+        \"//tensorflow/python/autograph/utils:ag_logging\",", "+        \"@gast_archive//:gast\",", "+    ],", "+)", "+", "+py_strict_library(", "+    name = \"ast_util\",", "+    srcs = [\"ast_util.py\"],", "     visibility = [\"//visibility:public\"],", "     deps = [", "-        \"//tensorflow/python/autograph/pyct/common_transformers\",", "+        \":anno\",", "+        \":parser\",", "+        \":qual_names\",", "+        \"@gast_archive//:gast\",", "+    ],", "+)", "+", "+py_strict_library(", "+    name = \"loader\",", "+    srcs = [\"loader.py\"],", "+    visibility = [\"//visibility:public\"],", "+    deps = [", "+        \":origin_info\",", "+        \":parser\",", "+    ],", "+)", "+", "+py_strict_library(", "+    name = \"gast_util\",", "+    srcs = [\"gast_util.py\"],", "+    visibility = [\"//visibility:public\"],", "+    deps = [\"@gast_archive//:gast\"],", "+)", "+", "+py_strict_library(", "+    name = \"__init__\",", "+    srcs = [\"__init__.py\"],", "+    visibility = [\"//visibility:public\"],", "+)", "+", "+py_strict_library(", "+    name = \"parser\",", "+    srcs = [\"parser.py\"],", "+    visibility = [\"//visibility:public\"],", "+    deps = [", "+        \":errors\",", "+        \":inspect_utils\",", "+        \"//tensorflow/python/util:tf_inspect\",", "         \"@astunparse_archive//:astunparse\",", "         \"@gast_archive//:gast\",", "+    ],", "+)", "+", "+py_strict_library(", "+    name = \"naming\",", "+    srcs = [\"naming.py\"],", "+    visibility = [\"//visibility:public\"],", "+    deps = [\":qual_names\"],", "+)", "+", "+py_strict_library(", "+    name = \"inspect_utils\",", "+    srcs = [\"inspect_utils.py\"],", "+    visibility = [\"//visibility:public\"],", "+    deps = [\"//tensorflow/python/util:tf_inspect\"],", "+)", "+", "+py_strict_library(", "+    name = \"origin_info\",", "+    srcs = [\"origin_info.py\"],", "+    visibility = [\"//visibility:public\"],", "+    deps = [", "+        \":anno\",", "+        \":ast_util\",", "+        \":parser\",", "+        \":pretty_printer\",", "+        \"//tensorflow/python/util:tf_inspect\",", "+        \"@gast_archive//:gast\",", "+    ],", "+)", "+", "+py_strict_library(", "+    name = \"anno\",", "+    srcs = [\"anno.py\"],", "+    visibility = [\"//visibility:public\"],", "+    deps = [\"@gast_archive//:gast\"],", "+)", "+", "+py_strict_library(", "+    name = \"errors\",", "+    srcs = [\"errors.py\"],", "+    visibility = [\"//visibility:public\"],", "+)", "+", "+py_strict_library(", "+    name = \"transformer\",", "+    srcs = [\"transformer.py\"],", "+    visibility = [\"//visibility:public\"],", "+    deps = [", "+        \":anno\",", "+        \":parser\",", "+        \":pretty_printer\",", "+        \":templates\",", "+        \"@gast_archive//:gast\",", "+    ],", "+)", "+", "+py_strict_library(", "+    name = \"qual_names\",", "+    srcs = [\"qual_names.py\"],", "+    visibility = [\"//visibility:public\"],", "+    deps = [", "+        \":anno\",", "+        \":parser\",", "+        \"@gast_archive//:gast\",", "+    ],", "+)", "+", "+py_strict_library(", "+    name = \"cfg\",", "+    srcs = [\"cfg.py\"],", "+    visibility = [\"//visibility:public\"],", "+    deps = [", "+        \":anno\",", "+        \"@astunparse_archive//:astunparse\",", "+        \"@gast_archive//:gast\",", "+    ],", "+)", "+", "+py_strict_library(", "+    name = \"error_utils\",", "+    srcs = [\"error_utils.py\"],", "+    visibility = [\"//visibility:public\"],", "+    deps = [", "+        \":origin_info\",", "+        \"//tensorflow/python/util:traceback_utils\",", "+    ],", "+)", "+", "+py_strict_library(", "+    name = \"cache\",", "+    srcs = [\"cache.py\"],", "+    visibility = [\"//visibility:public\"],", "+)", "+", "+py_strict_library(", "+    name = \"pretty_printer\",", "+    srcs = [\"pretty_printer.py\"],", "+    visibility = [\"//visibility:public\"],", "+    deps = [", "+        \"@gast_archive//:gast\",", "         \"@termcolor_archive//:termcolor\",", "     ],", " )", " ", "-py_test(", "+py_strict_test(", "     name = \"anno_test\",", "     srcs = [\"anno_test.py\"],", "     python_version = \"PY3\",", "     srcs_version = \"PY3\",", "     deps = [", "-        \":pyct\",", "+        \":anno\",", "         \"//tensorflow/python:client_testlib\",", "     ],", " )", " ", "-py_test(", "+py_strict_test(", "     name = \"ast_util_test\",", "     srcs = [\"ast_util_test.py\"],", "     python_version = \"PY3\",", "     srcs_version = \"PY3\",", "     deps = [", "-        \":pyct\",", "+        \":anno\",", "+        \":ast_util\",", "+        \":loader\",", "+        \":parser\",", "+        \":pretty_printer\",", "+        \":qual_names\",", "         \"//tensorflow/python:client_testlib\",", "         \"@gast_archive//:gast\",", "     ],", " )", " ", "-py_test(", "+py_strict_test(", "     name = \"cache_test\",", "     srcs = [\"cache_test.py\"],", "     python_version = \"PY3\",", "     srcs_version = \"PY3\",", "     deps = [", "-        \":pyct\",", "+        \":cache\",", "         \"//tensorflow/python:client_testlib\",", "-        \"@gast_archive//:gast\",", "     ],", " )", " ", "-py_test(", "+py_strict_test(", "     name = \"cfg_test\",", "     srcs = [\"cfg_test.py\"],", "     python_version = \"PY3\",", "     srcs_version = \"PY3\",", "     deps = [", "-        \":pyct\",", "+        \":cfg\",", "+        \":parser\",", "         \"//tensorflow/python:client_testlib\",", "         \"@gast_archive//:gast\",", "     ],", " )", " ", "-py_test(", "+py_strict_test(", "     name = \"loader_test\",", "     srcs = [\"loader_test.py\"],", "     python_version = \"PY3\",", "     srcs_version = \"PY3\",", "     deps = [", "-        \":pyct\",", "+        \":ast_util\",", "+        \":loader\",", "+        \":parser\",", "+        \":pretty_printer\",", "         \"//tensorflow/python:client_testlib\",", "+        \"//tensorflow/python/util:tf_inspect\",", "         \"@gast_archive//:gast\",", "     ],", " )", " ", "-py_test(", "+py_strict_test(", "     name = \"error_utils_test\",", "     srcs = [\"error_utils_test.py\"],", "     python_version = \"PY3\",", "     srcs_version = \"PY3\",", "     deps = [", "-        \":pyct\",", "+        \":error_utils\",", "+        \":origin_info\",", "         \"//tensorflow/python:client_testlib\",", "-        \"@gast_archive//:gast\",", "     ],", " )", " ", "-py_test(", "+py_strict_test(", "     name = \"inspect_utils_test\",", "     srcs = [\"inspect_utils_test.py\"],", "     python_version = \"PY3\",", "     srcs_version = \"PY3\",", "     deps = [", "-        \":pyct\",", "+        \":inspect_utils\",", "         \"//tensorflow/python:client_testlib\",", "         \"//tensorflow/python/autograph/pyct/testing:basic_definitions\",", "         \"//tensorflow/python/autograph/pyct/testing:decorators\",", "-        \"@gast_archive//:gast\",", "+        \"//tensorflow/python/framework:constant_op\",", "+        \"//tensorflow/python/lib:__init__\",", "     ],", " )", " ", "@@ -140,94 +287,112 @@ sh_test(", "     tags = [\"no_oss\"],", " )", " ", "-py_test(", "+py_strict_test(", "     name = \"naming_test\",", "     srcs = [\"naming_test.py\"],", "     python_version = \"PY3\",", "     srcs_version = \"PY3\",", "     deps = [", "-        \":pyct\",", "+        \":naming\",", "         \"//tensorflow/python:client_testlib\",", "     ],", " )", " ", "-py_test(", "+py_strict_test(", "     name = \"origin_info_test\",", "     srcs = [\"origin_info_test.py\"],", "     python_version = \"PY3\",", "     srcs_version = \"PY3\",", "     deps = [", "-        \":pyct\",", "+        \":anno\",", "+        \":inspect_utils\",", "+        \":origin_info\",", "+        \":parser\",", "         \"//tensorflow/python:client_testlib\",", "         \"//tensorflow/python/autograph/pyct/testing:basic_definitions\",", "+        \"//tensorflow/python/util:tf_inspect\",", "     ],", " )", " ", "-py_test(", "+py_strict_test(", "     name = \"parser_test\",", "     srcs = [\"parser_test.py\"],", "     python_version = \"PY3\",", "     srcs_version = \"PY3\",", "     deps = [", "-        \":pyct\",", "+        \":ast_util\",", "+        \":errors\",", "+        \":parser\",", "+        \":pretty_printer\",", "         \"//tensorflow/python:client_testlib\",", "+        \"@gast_archive//:gast\",", "     ],", " )", " ", "-py_test(", "+py_strict_test(", "     name = \"pretty_printer_test\",", "     srcs = [\"pretty_printer_test.py\"],", "     python_version = \"PY3\",", "     srcs_version = \"PY3\",", "     deps = [", "-        \":pyct\",", "+        \":pretty_printer\",", "         \"//tensorflow/python:client_testlib\",", "     ],", " )", " ", "-py_test(", "+py_strict_test(", "     name = \"qual_names_test\",", "     srcs = [\"qual_names_test.py\"],", "     python_version = \"PY3\",", "     srcs_version = \"PY3\",", "     deps = [", "-        \":pyct\",", "+        \":anno\",", "+        \":parser\",", "+        \":qual_names\",", "         \"//tensorflow/python:client_testlib\",", "     ],", " )", " ", "-py_test(", "+py_strict_test(", "     name = \"templates_test\",", "     srcs = [\"templates_test.py\"],", "     python_version = \"PY3\",", "     srcs_version = \"PY3\",", "     deps = [", "-        \":pyct\",", "+        \":loader\",", "+        \":parser\",", "+        \":qual_names\",", "+        \":templates\",", "         \"//tensorflow/python:client_testlib\",", "         \"@absl_py//absl/testing:parameterized\",", "         \"@gast_archive//:gast\",", "     ],", " )", " ", "-py_test(", "+py_strict_test(", "     name = \"transformer_test\",", "     srcs = [\"transformer_test.py\"],", "     python_version = \"PY3\",", "     srcs_version = \"PY3\",", "     deps = [", "-        \":pyct\",", "+        \":anno\",", "+        \":origin_info\",", "+        \":parser\",", "+        \":transformer\",", "         \"//tensorflow/python:client_testlib\",", "         \"@gast_archive//:gast\",", "     ],", " )", " ", "-py_test(", "+py_strict_test(", "     name = \"transpiler_test\",", "     srcs = [\"transpiler_test.py\"],", "     python_version = \"PY3\",", "     srcs_version = \"PY3\",", "     deps = [", "-        \":pyct\",", "+        \":transformer\",", "+        \":transpiler\",", "         \"//tensorflow/python:client_testlib\",", "+        \"@gast_archive//:gast\",", "     ],", " )", "@@ -5,18 +5,6 @@ package(", "     licenses = [\"notice\"],", " )", " ", "-filegroup(", "-    name = \"all_files\",", "-    srcs = glob(", "-        [\"**/*\"],", "-        exclude = [", "-            \"**/METADATA\",", "-            \"**/OWNERS\",", "-        ],", "-    ),", "-    visibility = [\"//visibility:private\"],", "-)", "-", " py_library(", "     name = \"common_transformers\",", "     srcs = [", "@@ -24,7 +12,12 @@ py_library(", "     ],", "     srcs_version = \"PY3\",", "     visibility = [\"//visibility:public\"],", "-    deps = [\"@gast_archive//:gast\"],", "+    deps = [", "+        \"//tensorflow/python/autograph/pyct:gast_util\",", "+        \"//tensorflow/python/autograph/pyct:templates\",", "+        \"//tensorflow/python/autograph/pyct:transformer\",", "+        \"@gast_archive//:gast\",", "+    ],", " )", " ", " py_test(", "@@ -35,7 +28,9 @@ py_test(", "     tags = [\"no_oss\"],", "     deps = [", "         \"//tensorflow/python:client_testlib\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:loader\",", "+        \"//tensorflow/python/autograph/pyct:parser\",", "+        \"//tensorflow/python/autograph/pyct:transformer\",", "         \"@gast_archive//:gast\",", "     ],", " )", "@@ -11,7 +11,9 @@ py_strict_library(", "     visibility = [\"//visibility:public\"],", "     deps = [", "         \":annos\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:cfg\",", "+        \"//tensorflow/python/autograph/pyct:transformer\",", "         \"@gast_archive//:gast\",", "     ],", " )", "@@ -21,7 +23,9 @@ py_strict_library(", "     srcs = [\"reaching_fndefs.py\"],", "     visibility = [\"//visibility:public\"],", "     deps = [", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:cfg\",", "+        \"//tensorflow/python/autograph/pyct:transformer\",", "         \"@gast_archive//:gast\",", "     ],", " )", "@@ -33,7 +37,12 @@ py_strict_test(", "         \":activity\",", "         \":reaching_definitions\",", "         \":reaching_fndefs\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:cfg\",", "+        \"//tensorflow/python/autograph/pyct:naming\",", "+        \"//tensorflow/python/autograph/pyct:parser\",", "+        \"//tensorflow/python/autograph/pyct:qual_names\",", "+        \"//tensorflow/python/autograph/pyct:transformer\",", "         \"//tensorflow/python/platform:client_testlib\",", "     ],", " )", "@@ -44,7 +53,9 @@ py_strict_library(", "     visibility = [\"//visibility:public\"],", "     deps = [", "         \":annos\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:qual_names\",", "+        \"//tensorflow/python/autograph/pyct:transformer\",", "         \"@gast_archive//:gast\",", "     ],", " )", "@@ -56,7 +67,10 @@ py_strict_library(", "     deps = [", "         \":activity\",", "         \":annos\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:cfg\",", "+        \"//tensorflow/python/autograph/pyct:qual_names\",", "+        \"//tensorflow/python/autograph/pyct:transformer\",", "         \"@gast_archive//:gast\",", "     ],", " )", "@@ -66,7 +80,9 @@ py_strict_library(", "     srcs = [\"reaching_definitions.py\"],", "     visibility = [\"//visibility:public\"],", "     deps = [", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:cfg\",", "+        \"//tensorflow/python/autograph/pyct:transformer\",", "         \"@gast_archive//:gast\",", "     ],", " )", "@@ -86,7 +102,11 @@ py_strict_test(", "         \":activity\",", "         \":annos\",", "         \"//tensorflow/python:client_testlib\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:naming\",", "+        \"//tensorflow/python/autograph/pyct:parser\",", "+        \"//tensorflow/python/autograph/pyct:qual_names\",", "+        \"//tensorflow/python/autograph/pyct:transformer\",", "         \"@gast_archive//:gast\",", "     ],", " )", "@@ -102,7 +122,12 @@ py_strict_test(", "         \":liveness\",", "         \":reaching_fndefs\",", "         \"//tensorflow/python:client_testlib\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:cfg\",", "+        \"//tensorflow/python/autograph/pyct:naming\",", "+        \"//tensorflow/python/autograph/pyct:parser\",", "+        \"//tensorflow/python/autograph/pyct:qual_names\",", "+        \"//tensorflow/python/autograph/pyct:transformer\",", "     ],", " )", " ", "@@ -115,7 +140,12 @@ py_strict_test(", "         \":activity\",", "         \":reaching_definitions\",", "         \"//tensorflow/python:client_testlib\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:cfg\",", "+        \"//tensorflow/python/autograph/pyct:naming\",", "+        \"//tensorflow/python/autograph/pyct:parser\",", "+        \"//tensorflow/python/autograph/pyct:qual_names\",", "+        \"//tensorflow/python/autograph/pyct:transformer\",", "     ],", " )", " ", "@@ -130,6 +160,9 @@ py_strict_test(", "         \":reaching_fndefs\",", "         \":type_inference\",", "         \"//tensorflow/python:client_testlib\",", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:anno\",", "+        \"//tensorflow/python/autograph/pyct:cfg\",", "+        \"//tensorflow/python/autograph/pyct:qual_names\",", "+        \"//tensorflow/python/autograph/pyct:transpiler\",", "     ],", " )", "@@ -13,7 +13,7 @@ py_strict_library(", "     srcs_version = \"PY3\",", "     visibility = [\"//visibility:public\"],", "     deps = [", "-        \"//tensorflow/python/autograph/pyct\",", "+        \"//tensorflow/python/autograph/pyct:templates\",", "         \"//third_party/py/numpy\",", "         \"@gast_archive//:gast\",", "     ],", "@@ -46,7 +46,6 @@ py_strict_test(", "     deps = [", "         \":codegen\",", "         \"//tensorflow/python:client_testlib\",", "-        \"//tensorflow/python/autograph/pyct\",", "         \"//third_party/py/numpy\",", "     ],", " )", "@@ -1,4 +1,5 @@", " # python/lib package", "+load(\"//tensorflow:strict.default.bzl\", \"py_strict_library\")", " ", " visibility = [", "     \"//tensorflow:__subpackages__\",", "@@ -9,3 +10,10 @@ package(", "     default_visibility = visibility,", "     licenses = [\"notice\"],", " )", "+", "+py_strict_library(", "+    name = \"__init__\",", "+    srcs = [\"__init__.py\"],", "+    visibility = [\"//tensorflow:__subpackages__\"],", "+    deps = [],", "+)", "@@ -150,6 +150,7 @@ COMMON_PIP_DEPS = [", "     \"//tensorflow/python/kernel_tests/random:util\",", "     \"//tensorflow/python/kernel_tests/signal:test_util\",", "     \"//tensorflow/python/kernel_tests/sparse_ops:sparse_xent_op_test_base\",", "+    \"//tensorflow/python/lib:__init__\",", "     \"//tensorflow/python/ops/structured:structured_tensor_dynamic\",", "     \"//tensorflow/python/profiler:trace\",", "     \"//tensorflow/python/saved_model:saved_model\",", "@@ -91,7 +91,8 @@ TEST(CompileMlirUtil, HasLegalizationPass) {", "   llvm::StringRef device_type = \"XLA_CPU_JIT\";", "   absl::string_view kLegalizeTfPass =", "       \"xla-legalize-tf{allow-partial-conversion=false device-type=XLA_CPU_JIT \"", "-      \"legalize-chlo=true prefer-tf2xla=true use-tf2xla-fallback=true})\";", "+      \"legalize-chlo=true prefer-tf2xla=true use-tf2xla-fallback=true \"", "+      \"use-tf2xla-hlo-importer=false})\";", " ", "   CreateConvertMlirToXlaHloPipeline(pass_manager, device_type,", "                                     /*enable_op_fallback=*/true,", "@@ -0,0 +1,9 @@", "+// RUN: tf-opt \"-xla-legalize-tf=device-type=XLA_CPU_JIT allow-partial-conversion=true prefer-tf2xla=true use-tf2xla-fallback=true use-tf2xla-hlo-importer=true\" %s -verify-diagnostics | FileCheck %s", "+", "+module attributes {tf.versions = {bad_consumers = [], min_consumer = 0 : i32, producer = 268 : i32}} {", "+  // CHECK-LABEL: binary_op", "+  func.func @binary_op(%arg0: tensor<2xf32>, %arg1: tensor<2xf32>) -> tensor<2xf32> {", "+    %0 = \"tf.Atan2\"(%arg0, %arg1) : (tensor<2xf32>, tensor<2xf32>) -> tensor<2xf32>", "+    func.return %0 : tensor<2xf32>", "+  }", "+}", "@@ -1,4 +1,4 @@", "-// RUN: tf-opt \"-xla-legalize-tf=device-type=XLA_CPU_JIT allow-partial-conversion=true prefer-tf2xla=true use-tf2xla-fallback=true\" %s -verify-diagnostics | FileCheck %s", "+// RUN: tf-opt \"-xla-legalize-tf=device-type=XLA_CPU_JIT allow-partial-conversion=true prefer-tf2xla=true use-tf2xla-fallback=true use-tf2xla-hlo-importer=false\" %s -verify-diagnostics | FileCheck %s", " ", " module attributes {tf.versions = {bad_consumers = [], min_consumer = 0 : i32, producer = 268 : i32}} {", " ", "@@ -477,11 +477,13 @@ class Tf2XlaRewritePattern : public ConversionPattern {", "  public:", "   explicit Tf2XlaRewritePattern(MLIRContext* ctx, TypeConverter& converter,", "                                 const std::string& device_type,", "-                                bool prefer_tf2xla, bool is_module_pass)", "+                                bool prefer_tf2xla, bool is_module_pass,", "+                                bool use_tf2xla_hlo_importer)", "       : ConversionPattern(converter, MatchAnyOpTypeTag(), /*benefit=*/1, ctx),", "         device_type_(device_type),", "         prefer_tf2xla_(prefer_tf2xla),", "-        is_module_pass_(is_module_pass) {}", "+        is_module_pass_(is_module_pass),", "+        use_tf2xla_hlo_importer_(use_tf2xla_hlo_importer) {}", " ", "   LogicalResult matchAndRewrite(", "       Operation* op, ArrayRef<Value> operands,", "@@ -506,13 +508,14 @@ class Tf2XlaRewritePattern : public ConversionPattern {", "       return failure();", "     }", "     return Tf2XlaRewriter::RewriteOp(op, rewriter, device_type_,", "-                                     is_module_pass_);", "+                                     is_module_pass_, use_tf2xla_hlo_importer_);", "   }", " ", "  private:", "   std::string device_type_;", "   bool prefer_tf2xla_;", "   bool is_module_pass_;", "+  bool use_tf2xla_hlo_importer_;", " };", " ", " bool ShouldRefineTypeTo(Type original_ty, Type updated_ty) {", "@@ -603,10 +606,12 @@ Tf2XlaTypeConverter::Tf2XlaTypeConverter() {", " ", " void PopulateLegalizeTfWithTf2XlaPatterns(", "     llvm::StringRef device_type, RewritePatternSet& patterns, MLIRContext* ctx,", "-    Tf2XlaTypeConverter& converter, bool prefer_tf2xla, bool is_module_pass) {", "+    Tf2XlaTypeConverter& converter, bool prefer_tf2xla, bool is_module_pass,", "+    bool use_tf2xla_hlo_importer) {", "   patterns.add<TypePropagator>(ctx);", "   patterns.add<Tf2XlaRewritePattern>(ctx, converter, device_type.str(),", "-                                     prefer_tf2xla, is_module_pass);", "+                                     prefer_tf2xla, is_module_pass,", "+                                     use_tf2xla_hlo_importer);", " }", " ", " }  // end namespace mhlo", "@@ -79,12 +79,10 @@ class Tf2XlaTypeConverter : public TypeConverter {", " /// `prefer_tf2xla` means an op will be included iff it is not in", " /// `MlirLegalizedUnderPreferTf2XlaSet`. `!prefer_tf2xla` mean an op will be", " /// included if there is no native MLIR legalization for the op.", "-void PopulateLegalizeTfWithTf2XlaPatterns(llvm::StringRef device_type,", "-                                          RewritePatternSet& patterns,", "-                                          MLIRContext* ctx,", "-                                          Tf2XlaTypeConverter& converter,", "-                                          bool prefer_tf2xla = false,", "-                                          bool is_module_pass = false);", "+void PopulateLegalizeTfWithTf2XlaPatterns(", "+    llvm::StringRef device_type, RewritePatternSet& patterns, MLIRContext* ctx,", "+    Tf2XlaTypeConverter& converter, bool prefer_tf2xla = false,", "+    bool is_module_pass = false, bool use_tf2xla_hlo_importer = false);", " ", " /// Adds the TF to TF lowerings and TF to XLA rewrite patterns to the pattern", " /// list.", "@@ -95,20 +95,24 @@ static std::unique_ptr<tensorflow::StaticDeviceMgr> CreateDeviceMgr(", " LogicalResult Tf2XlaRewriter::RewriteOp(Operation* op,", "                                         PatternRewriter& rewriter,", "                                         const std::string& device_type,", "-                                        bool is_module_pass) {", "-  Tf2XlaRewriter tf2xla_rewriter(op, rewriter, device_type, is_module_pass);", "+                                        bool is_module_pass,", "+                                        bool use_tf2xla_hlo_importer) {", "+  Tf2XlaRewriter tf2xla_rewriter(op, rewriter, device_type, is_module_pass,", "+                                 use_tf2xla_hlo_importer);", "   return tf2xla_rewriter.LegalizeOp();", " }", " ", " Tf2XlaRewriter::Tf2XlaRewriter(Operation* op, PatternRewriter& rewriter,", "                                const std::string& device_type,", "-                               bool is_module_pass)", "+                               bool is_module_pass,", "+                               bool use_tf2xla_hlo_importer)", "     : op_(op),", "       device_type_(device_type),", "       rewriter_(rewriter),", "       hlo_builder_(op->getName().getStringRef().str(), rewriter_, op->getLoc(),", "                    /*build_functions=*/is_module_pass),", "-      context_(nullptr) {}", "+      context_(nullptr),", "+      use_tf2xla_hlo_importer_(use_tf2xla_hlo_importer) {}", " ", " Tf2XlaRewriter::~Tf2XlaRewriter() {", "   if (context_) context_->Unref();", "@@ -37,11 +37,13 @@ class Tf2XlaRewriter {", "   static mlir::LogicalResult RewriteOp(mlir::Operation* op,", "                                        mlir::PatternRewriter& rewriter,", "                                        const std::string& device_type,", "-                                       bool is_module_pass);", "+                                       bool is_module_pass,", "+                                       bool use_tf2xla_hlo_importer);", " ", "  private:", "   Tf2XlaRewriter(mlir::Operation* op, mlir::PatternRewriter& rewriter,", "-                 const std::string& device_type, bool is_module_pass);", "+                 const std::string& device_type, bool is_module_pass,", "+                 bool use_tf2xla_hlo_importer);", " ", "   ~Tf2XlaRewriter();", " ", "@@ -76,6 +78,8 @@ class Tf2XlaRewriter {", "   std::unique_ptr<tensorflow::FunctionLibraryDefinition> flib_def_;", "   std::unique_ptr<tensorflow::ProcessFunctionLibraryRuntime> pflr_;", "   tensorflow::OpKernelContext::Params params_;", "+", "+  bool use_tf2xla_hlo_importer_;", " };", " ", " }  // namespace mhlo", "@@ -750,7 +750,7 @@ mlir::LogicalResult ApplyPatterns(Operation *op, RewritePatternSet &patterns,", " /// used.", " LogicalResult legalizeTF(Operation *op, bool legalize_chlo,", "                          std::optional<StringRef> tf2xla_fallback_device_type,", "-                         bool prefer_tf2xla) {", "+                         bool prefer_tf2xla, bool use_tf2xla_hlo_importer) {", "   MLIRContext *context = op->getContext();", "   RewritePatternSet legalize_lower_patterns(context);", "   // Note that the `OperationConverter` orders patterns lexicographically by:", "@@ -791,9 +791,9 @@ LogicalResult legalizeTF(Operation *op, bool legalize_chlo,", "   Tf2XlaTypeConverter converter;", "   if (tf2xla_fallback_device_type) {", "     // Add TF->HLO legalization patterns via TF2XLA fallback.", "-    PopulateLegalizeTfWithTf2XlaPatterns(tf2xla_fallback_device_type.value(),", "-                                         patterns, context, converter,", "-                                         prefer_tf2xla);", "+    PopulateLegalizeTfWithTf2XlaPatterns(", "+        tf2xla_fallback_device_type.value(), patterns, context, converter,", "+        prefer_tf2xla, use_tf2xla_hlo_importer);", "   }", " ", "   // Populate with CHLO->HLO lowerings to account for TF ops legalized to", "@@ -817,7 +817,8 @@ void LegalizeTF::runOnOperation() {", "     tf2xla_fallback_device_type = device_type_;", "   }", "   if (failed(legalizeTF(getOperation(), legalize_chlo_,", "-                        tf2xla_fallback_device_type, prefer_tf2xla_))) {", "+                        tf2xla_fallback_device_type, prefer_tf2xla_,", "+                        use_tf2xla_hlo_importer_))) {", "     signalPassFailure();", "   }", " }", "@@ -44,7 +44,12 @@ def LegalizeTF : Pass<\"xla-legalize-tf\", \"mlir::func::FuncOp\"> {", "     Option<\"prefer_tf2xla_\", \"prefer-tf2xla\", \"bool\",", "         /*default=*/\"false\",", "         \"Prioritize tf2xla fallback legalization over MLIR legalization \"", "-        \"patterns\">", "+        \"patterns\">,", "+    Option<\"use_tf2xla_hlo_importer_\", \"use-tf2xla-hlo-importer\",", "+       \"bool\", /*default=*/\"false\",", "+        \"Use the experimental HLO to MHLO importer for per-op fallback calls \"", "+        \" from MLIR bridge to TF2XLA.\"", "+        \"Users should not set this flag and ideally this goes away.\">", "   ];", " ", "   let constructor = \"mlir::mhlo::createLegalizeTFPass()\";", "@@ -1283,6 +1283,8 @@ cc_library(", "         \"//tensorflow/compiler/mlir/tensorflow:translate_lib\",", "         \"//tensorflow/core:framework\",", "         \"//tensorflow/core:protos_all_cc\",", "+        \"//tensorflow/core/platform:status\",", "+        \"//tensorflow/lite/python/metrics:converter_error_data_proto_cc\",", "         \"//tensorflow/lite/toco:toco_flags_proto_cc\",", "         \"//tensorflow/lite/tools/optimize:quantize_weights\",", "         \"//tensorflow/lite/tools/optimize:reduced_precision_support\",", "@@ -0,0 +1,195 @@", "+# RUN: not tf_tfl_translate -tf-input-arrays=input0 -tf-input-shapes=-1 -tf-input-data-types=DT_FLOAT -tf-output-arrays=add %s 2>&1 | FileCheck %s", "+# CHECK: error: The Graph contains unsupported `StatefulPartionedCallOp`(s)", "+", "+node {", "+  name: \"input0\"", "+  op: \"Placeholder\"", "+  attr {", "+    key: \"dtype\"", "+    value {", "+      type: DT_FLOAT", "+    }", "+  }", "+}", "+node {", "+  name: \"args_0\"", "+  op: \"_Arg\"", "+  attr {", "+    key: \"T\"", "+    value {", "+      type: DT_RESOURCE", "+    }", "+  }", "+  attr {", "+    key: \"index\"", "+    value {", "+      i: 0", "+    }", "+  }", "+}", "+node {", "+  name: \"spc1\"", "+  op: \"StatefulPartitionedCall\"", "+  input: \"input0\"", "+  input: \"args_0\"", "+  attr {", "+    key: \"Tin\"", "+    value {", "+      list {", "+        type: DT_FLOAT", "+        type: DT_RESOURCE", "+      }", "+    }", "+  }", "+  attr {", "+    key: \"Tout\"", "+    value {", "+      list {", "+        type: DT_FLOAT", "+        type: DT_RESOURCE", "+      }", "+    }", "+  }", "+  attr {", "+    key: \"config\"", "+    value {", "+      s: \"\"", "+    }", "+  }", "+  attr {", "+    key: \"config_proto\"", "+    value {", "+      s: \"\"", "+    }", "+  }", "+  attr {", "+    key: \"executor_type\"", "+    value {", "+      s: \"\"", "+    }", "+  }", "+  attr {", "+    key: \"f\"", "+    value {", "+      func {", "+        name: \"function\"", "+      }", "+    }", "+  }", "+}", "+node {", "+  name: \"spc2\"", "+  op: \"StatefulPartitionedCall\"", "+  input: \"input0\"", "+  input: \"args_0\"", "+  attr {", "+    key: \"Tin\"", "+    value {", "+      list {", "+        type: DT_FLOAT", "+        type: DT_RESOURCE", "+      }", "+    }", "+  }", "+  attr {", "+    key: \"Tout\"", "+    value {", "+      list {", "+        type: DT_FLOAT", "+        type: DT_RESOURCE", "+      }", "+    }", "+  }", "+  attr {", "+    key: \"config\"", "+    value {", "+      s: \"\"", "+    }", "+  }", "+  attr {", "+    key: \"config_proto\"", "+    value {", "+      s: \"\"", "+    }", "+  }", "+  attr {", "+    key: \"executor_type\"", "+    value {", "+      s: \"\"", "+    }", "+  }", "+  attr {", "+    key: \"f\"", "+    value {", "+      func {", "+        name: \"function\"", "+      }", "+    }", "+  }", "+}", "+node {", "+  name: \"add\"", "+  op: \"Add\"", "+  input: \"spc1\"", "+  input: \"spc2\"", "+  attr {", "+    key: \"T\"", "+    value {", "+      type: DT_FLOAT", "+    }", "+  }", "+}", "+library {", "+  function {", "+    signature {", "+      name: \"function\"", "+      input_arg {", "+        name: \"inputs\"", "+        type: DT_FLOAT", "+      }", "+      input_arg {", "+        name: \"statefulpartitionedcall_args_1\"", "+        type: DT_RESOURCE", "+      }", "+      output_arg {", "+        name: \"identity\"", "+        type: DT_FLOAT", "+      }", "+      is_stateful: true", "+    }", "+    node_def {", "+      name: \"Identity\"", "+      op: \"Identity\"", "+      input: \"inputs\"", "+      attr {", "+        key: \"T\"", "+        value {", "+          type: DT_FLOAT", "+        }", "+      }", "+    }", "+    ret {", "+      key: \"identity\"", "+      value: \"Identity:output:0\"", "+    }", "+    arg_attr {", "+      key: 0", "+      value {", "+        attr {", "+          key: \"_user_specified_name\"", "+          value {", "+            s: \"inputs\"", "+          }", "+        }", "+      }", "+    }", "+    arg_attr {", "+      key: 1", "+      value {", "+      }", "+    }", "+  }", "+}", "+versions {", "+  producer: 121", "+}", "@@ -24,6 +24,7 @@ limitations under the License.", " #include <vector>", " ", " #include \"absl/types/span.h\"", "+#include \"llvm/Support/Casting.h\"", " #include \"llvm/Support/raw_ostream.h\"", " #include \"mlir/Dialect/Func/IR/FuncOps.h\"  // from @llvm-project", " #include \"mlir/IR/Attributes.h\"  // from @llvm-project", "@@ -49,6 +50,7 @@ limitations under the License.", " #include \"tensorflow/compiler/mlir/quantization/tensorflow/quantize_passes.h\"", " #include \"tensorflow/compiler/mlir/quantization/tensorflow/quantize_preprocess.h\"", " #include \"tensorflow/compiler/mlir/tensorflow/ir/tf_executor.h\"", "+#include \"tensorflow/compiler/mlir/tensorflow/ir/tf_ops.h\"", " #include \"tensorflow/compiler/mlir/tensorflow/transforms/passes.h\"", " #include \"tensorflow/compiler/mlir/tensorflow/transforms/tf_saved_model_freeze_variables.h\"", " #include \"tensorflow/compiler/mlir/tensorflow/transforms/tf_saved_model_passes.h\"", "@@ -57,6 +59,8 @@ limitations under the License.", " #include \"tensorflow/core/framework/op.h\"", " #include \"tensorflow/core/framework/op_def.pb.h\"", " #include \"tensorflow/core/framework/types.pb.h\"", "+#include \"tensorflow/core/platform/status.h\"", "+#include \"tensorflow/lite/python/metrics/converter_error_data.pb.h\"", " #include \"tensorflow/lite/tools/optimize/quantize_weights.h\"", " #include \"tensorflow/lite/tools/optimize/reduced_precision_support.h\"", " #include \"tensorflow/tsl/platform/statusor.h\"", "@@ -94,6 +98,25 @@ mlir::LogicalResult IsValidGraph(mlir::ModuleOp module) {", "   return mlir::success();", " }", " ", "+mlir::LogicalResult GraphContainsStatefulPartitionedOp(mlir::ModuleOp module) {", "+  auto result = module.walk([&](Operation* op) {", "+    return llvm::isa_and_nonnull<mlir::TF::StatefulPartitionedCallOp>(op)", "+               ? mlir::WalkResult::interrupt()", "+               : mlir::WalkResult::advance();", "+  });", "+  if (result.wasInterrupted()) {", "+    // StatefulPartitionedCall ops are not supported by the tflite runtime.", "+    mlir::TFL::AttachErrorCode(", "+        module.emitError(", "+            \"The Graph contains unsupported `StatefulPartionedCallOp`(s), will \"", "+            \"retry with `guarantee_all_funcs_used_once`\"),", "+        tflite::metrics::ConverterErrorData::", "+            ERROR_STATEFUL_PARTITIONED_CALL_IN_FINAL_IR);", "+    return mlir::failure();", "+  }", "+  return mlir::success();", "+}", "+", " // Util that registers 'extra_tf_opdefs' to the TF global registry.", " // Return OK on success, failure if registering failed.", " Status RegisterExtraTfOpDefs(absl::Span<const std::string> extra_tf_opdefs) {", "@@ -357,6 +380,10 @@ Status ConvertTFExecutorToTFLOrFlatbuffer(", "     return status;", "   }", " ", "+  if (failed(GraphContainsStatefulPartitionedOp(module))) {", "+    return statusHandler.ConsumeStatus();", "+  }", "+", "   if (export_to_mlir) {", "     llvm::raw_string_ostream os(*result);", "     module.print(os);", "@@ -23,6 +23,7 @@ limitations under the License.", " #include \"mlir/Dialect/Func/IR/FuncOps.h\"", " #include \"mlir/Dialect/MemRef/IR/MemRef.h\"", " #include \"mlir/Dialect/Vector/IR/VectorOps.h\"", "+#include \"mlir/Dialect/Vector/Transforms/LoweringPatterns.h\"", " #include \"mlir/Dialect/Vector/Transforms/VectorRewritePatterns.h\"", " #include \"mlir/Dialect/X86Vector/Transforms.h\"", " #include \"mlir/Transforms/DialectConversion.h\"", "@@ -64,11 +65,12 @@ LogicalResult rewriteVectorContract(MLIRContext* ctx, FuncOp funcOp) {", "   vector::populateVectorToVectorCanonicalizationPatterns(patterns);", " ", "   // Currently we always lower vector.contract into vector.outerproduct.", "-  patterns.add<vector::ContractionOpToOuterProductOpLowering,", "-               vector::ContractionOpLowering>(", "+  vector::populateVectorContractLoweringPatterns(", "+      patterns,", "       vector::VectorTransformsOptions().setVectorTransformsOptions(", "           vector::VectorContractLowering::OuterProduct),", "-      ctx, 2);", "+      /*benefit=*/2,", "+      /*disableOuterProductLowering*/ true);", "   vector::populateVectorTransferPermutationMapLoweringPatterns(patterns);", " ", "   return applyPatternsAndFoldGreedily(funcOp, std::move(patterns));", "@@ -18,6 +18,7 @@ limitations under the License.", " #include \"mlir/Dialect/Arith/IR/Arith.h\"", " #include \"mlir/Dialect/Tensor/IR/Tensor.h\"", " #include \"mlir/Dialect/Vector/IR/VectorOps.h\"", "+#include \"mlir/Dialect/Vector/Transforms/LoweringPatterns.h\"", " #include \"mlir/IR/BuiltinAttributes.h\"", " #include \"mlir/IR/OpDefinition.h\"", " ", "@@ -30,6 +30,7 @@ limitations under the License.", " #include \"mlir/Dialect/GPU/IR/GPUDialect.h\"", " #include \"mlir/Dialect/LLVMIR/NVVMDialect.h\"", " #include \"mlir/Dialect/LLVMIR/ROCDLDialect.h\"", "+#include \"mlir/Dialect/Vector/Transforms/LoweringPatterns.h\"", " #include \"mlir/Dialect/Vector/Transforms/VectorRewritePatterns.h\"", " #include \"mlir/Transforms/DialectConversion.h\"", " #include \"mlir/Transforms/GreedyPatternRewriteDriver.h\"", "@@ -63,10 +64,12 @@ static void populateAllCommonVectorProgressiveLoweringPatterns(", "     RewritePatternSet& patterns) {", "   vector::populateVectorToVectorCanonicalizationPatterns(patterns);", "   vector::populateVectorBroadcastLoweringPatterns(patterns);", "-  vector::populateVectorContractLoweringPatterns(patterns);", "+  vector::populateVectorContractLoweringPatterns(", "+      patterns, vector::VectorTransformsOptions());", "   vector::populateVectorMaskOpLoweringPatterns(patterns);", "   vector::populateVectorShapeCastLoweringPatterns(patterns);", "-  vector::populateVectorTransposeLoweringPatterns(patterns);", "+  vector::populateVectorTransposeLoweringPatterns(", "+      patterns, vector::VectorTransformsOptions());", "   // Vector transfer ops with rank > 1 should be lowered with VectorToSCF.", "   vector::populateVectorTransferLoweringPatterns(patterns,", "                                                  /*maxTransferRank=*/1);", "@@ -1,26 +0,0 @@", "-diff --git a/mlir/lib/IR/AffineMap.cpp b/mlir/lib/IR/AffineMap.cpp", "-index 9ac181f46b57..6c9034d44634 100644", "---- a/mlir/lib/IR/AffineMap.cpp", "-+++ b/mlir/lib/IR/AffineMap.cpp", "-@@ -744,13 +744,18 @@ static AffineMap projectCommonImpl(AffineMap map,", "-   replacements.reserve(numDimOrSym);", "- ", "-   auto createNewDimOrSym = (isDim) ? getAffineDimExpr : getAffineSymbolExpr;", "--  auto replaceDims = [](AffineExpr e, ArrayRef<AffineExpr> replacements) {", "-+", "-+  using replace_fn_ty =", "-+      std::function<AffineExpr(AffineExpr, ArrayRef<AffineExpr>)>;", "-+  replace_fn_ty replaceDims = [](AffineExpr e,", "-+                                 ArrayRef<AffineExpr> replacements) {", "-     return e.replaceDims(replacements);", "-   };", "--  auto replaceSymbols = [](AffineExpr e, ArrayRef<AffineExpr> replacements) {", "-+  replace_fn_ty replaceSymbols = [](AffineExpr e,", "-+                                    ArrayRef<AffineExpr> replacements) {", "-     return e.replaceSymbols(replacements);", "-   };", "--  auto replaceNewDimOrSym = (isDim) ? replaceDims : replaceSymbols;", "-+  replace_fn_ty replaceNewDimOrSym = (isDim) ? replaceDims : replaceSymbols;", "- ", "-   MLIRContext *context = map.getContext();", "-   int64_t newNumDimOrSym = 0;", "@@ -1,1679 +1,12 @@", " Auto generated patch. Do not edit or delete it, even if empty.", "-diff -ruN --strip-trailing-cr a/clang/include/clang/Serialization/ASTWriter.h b/clang/include/clang/Serialization/ASTWriter.h", "---- a/clang/include/clang/Serialization/ASTWriter.h", "-+++ b/clang/include/clang/Serialization/ASTWriter.h", "-@@ -514,6 +514,7 @@", "-   void WriteTypeAbbrevs();", "-   void WriteType(QualType T);", "- ", "-+  bool isLookupResultExternal(StoredDeclsList &Result, DeclContext *DC);", "-   bool isLookupResultEntirelyExternal(StoredDeclsList &Result, DeclContext *DC);", "- ", "-   void GenerateNameLookupTable(const DeclContext *DC,", "-diff -ruN --strip-trailing-cr a/clang/lib/Serialization/ASTWriter.cpp b/clang/lib/Serialization/ASTWriter.cpp", "---- a/clang/lib/Serialization/ASTWriter.cpp", "-+++ b/clang/lib/Serialization/ASTWriter.cpp", "-@@ -3849,6 +3849,12 @@", "- ", "- } // namespace", "- ", "-+bool ASTWriter::isLookupResultExternal(StoredDeclsList &Result,", "-+                                       DeclContext *DC) {", "-+  return Result.hasExternalDecls() &&", "-+         DC->hasNeedToReconcileExternalVisibleStorage();", "-+}", "-+", "- bool ASTWriter::isLookupResultEntirelyExternal(StoredDeclsList &Result,", "-                                                DeclContext *DC) {", "-   for (auto *D : Result.getLookupResult())", "-@@ -3891,7 +3897,8 @@", "-     // don't need to write an entry for the name at all. If we can't", "-     // write out a lookup set without performing more deserialization,", "-     // just skip this entry.", "--    if (isLookupResultEntirelyExternal(Result, DC))", "-+    if (isLookupResultExternal(Result, DC) &&", "-+        isLookupResultEntirelyExternal(Result, DC))", "-       continue;", "- ", "-     // We also skip empty results. If any of the results could be external and", "-diff -ruN --strip-trailing-cr a/clang/test/Modules/pr61065.cppm b/clang/test/Modules/pr61065.cppm", "---- a/clang/test/Modules/pr61065.cppm", "-+++ b/clang/test/Modules/pr61065.cppm", "-@@ -1,55 +0,0 @@", "--// From https://github.com/llvm/llvm-project/issues/61065", "--// RUN: rm -rf %t", "--// RUN: mkdir -p %t", "--// RUN: split-file %s %t", "--//", "--// RUN: %clang_cc1 -std=c++20 %t/a.cppm -emit-module-interface -o %t/a.pcm", "--// RUN: %clang_cc1 -std=c++20 %t/b.cppm -emit-module-interface -o %t/b.pcm \\", "--// RUN:     -fprebuilt-module-path=%t", "--// RUN: %clang_cc1 -std=c++20 %t/c.cppm -emit-module-interface -o %t/c.pcm \\", "--// RUN:     -fprebuilt-module-path=%t", "--// RUN: %clang_cc1 -std=c++20 %t/d.cpp -fsyntax-only -verify -fprebuilt-module-path=%t", "--", "--//--- a.cppm", "--export module a;", "--", "--struct base {", "--\tbase(int) {}", "--};", "--", "--export struct a : base {", "--\tusing base::base;", "--};", "--", "--//--- b.cppm", "--export module b;", "--", "--import a;", "--", "--a b() {", "--\treturn a(1);", "--}", "--", "--//--- c.cppm", "--export module c;", "--", "--import a;", "--import b;", "--", "--struct noncopyable {", "--\tnoncopyable(noncopyable const &) = delete;", "--    noncopyable() = default;", "--};", "--", "--export struct c {", "--\tnoncopyable c0;", "--\ta c1 = 43;", "--    c() = default;", "--};", "--", "--//--- d.cpp", "--// expected-no-diagnostics", "--import c;", "--void d() {", "--    c _;", "--}", "-diff -ruN --strip-trailing-cr a/llvm/include/llvm/ExecutionEngine/JITLink/ELF_aarch32.h b/llvm/include/llvm/ExecutionEngine/JITLink/ELF_aarch32.h", "---- a/llvm/include/llvm/ExecutionEngine/JITLink/ELF_aarch32.h", "-+++ b/llvm/include/llvm/ExecutionEngine/JITLink/ELF_aarch32.h", "-@@ -1,38 +0,0 @@", "--//===---- ELF_aarch32.h - JIT link functions for arm/thumb -----*- C++ -*--===//", "--//", "--// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.", "--// See https://llvm.org/LICENSE.txt for license information.", "--// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception", "--//", "--//===----------------------------------------------------------------------===//", "--//", "--// jit-link functions for ELF/aarch32.", "--//", "--//===----------------------------------------------------------------------===//", "--", "--#ifndef LLVM_EXECUTIONENGINE_JITLINK_ELF_AARCH32", "--#define LLVM_EXECUTIONENGINE_JITLINK_ELF_AARCH32", "--", "--#include \"llvm/ExecutionEngine/JITLink/JITLink.h\"", "--#include \"llvm/ExecutionEngine/JITLink/aarch32.h\"", "--", "--namespace llvm {", "--namespace jitlink {", "--", "--/// Create a LinkGraph from an ELF/arm relocatable object", "--///", "--/// Note: The graph does not take ownership of the underlying buffer, nor copy", "--/// its contents. The caller is responsible for ensuring that the object buffer", "--/// outlives the graph.", "--Expected<std::unique_ptr<LinkGraph>>", "--createLinkGraphFromELFObject_aarch32(MemoryBufferRef ObjectBuffer);", "--", "--/// jit-link the given object buffer, which must be an ELF arm/thumb object", "--/// file.", "--void link_ELF_aarch32(std::unique_ptr<LinkGraph> G,", "--                      std::unique_ptr<JITLinkContext> Ctx);", "--", "--} // end namespace jitlink", "--} // end namespace llvm", "--", "--#endif // LLVM_EXECUTIONENGINE_JITLINK_ELF_AARCH32", "-diff -ruN --strip-trailing-cr a/llvm/include/llvm/ExecutionEngine/JITLink/aarch32.h b/llvm/include/llvm/ExecutionEngine/JITLink/aarch32.h", "---- a/llvm/include/llvm/ExecutionEngine/JITLink/aarch32.h", "-+++ b/llvm/include/llvm/ExecutionEngine/JITLink/aarch32.h", "-@@ -1,293 +0,0 @@", "--//===------ aarch32.h - Generic JITLink arm/thumb utilities -----*- C++ -*-===//", "--//", "--// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.", "--// See https://llvm.org/LICENSE.txt for license information.", "--// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception", "--//", "--//===----------------------------------------------------------------------===//", "--//", "--// Generic utilities for graphs representing arm/thumb objects.", "--//", "--//===----------------------------------------------------------------------===//", "--", "--#ifndef LLVM_EXECUTIONENGINE_JITLINK_AARCH32", "--#define LLVM_EXECUTIONENGINE_JITLINK_AARCH32", "--", "--#include \"TableManager.h\"", "--#include \"llvm/ExecutionEngine/JITLink/JITLink.h\"", "--#include \"llvm/ExecutionEngine/Orc/Shared/ExecutorAddress.h\"", "--#include \"llvm/Support/ARMBuildAttributes.h\"", "--#include \"llvm/Support/Error.h\"", "--", "--namespace llvm {", "--namespace jitlink {", "--namespace aarch32 {", "--", "--/// JITLink-internal AArch32 fixup kinds", "--enum EdgeKind_aarch32 : Edge::Kind {", "--", "--  ///", "--  /// Relocations of class Data", "--  ///", "--  FirstDataRelocation = Edge::FirstRelocation,", "--", "--  /// Plain 32-bit value relocation in target endianness", "--  Data_Delta32 = FirstDataRelocation,", "--", "--  LastDataRelocation = Data_Delta32,", "--", "--  ///", "--  /// Relocations of class Arm (covers fixed-width 4-byte instruction subset)", "--  ///", "--  FirstArmRelocation,", "--", "--  /// TODO: Arm_Call is here only as a placeholder for now.", "--  Arm_Call = FirstArmRelocation,", "--", "--  LastArmRelocation = Arm_Call,", "--", "--  ///", "--  /// Relocations of class Thumb16 and Thumb32 (covers Thumb instruction subset)", "--  ///", "--  FirstThumbRelocation,", "--", "--  /// Write immediate value for PC-relative branch with link (can bridge between", "--  /// Arm and Thumb).", "--  Thumb_Call = FirstThumbRelocation,", "--", "--  /// Write immediate value for (unconditional) PC-relative branch without link.", "--  Thumb_Jump24,", "--", "--  /// Write immediate value to the lower halfword of the destination register", "--  Thumb_MovwAbsNC,", "--", "--  /// Write immediate value to the top halfword of the destination register", "--  Thumb_MovtAbs,", "--", "--  LastThumbRelocation = Thumb_MovtAbs,", "--};", "--", "--/// Flags enum for AArch32-specific symbol properties", "--enum TargetFlags_aarch32 : TargetFlagsType {", "--  ThumbSymbol = 1 << 0,", "--};", "--", "--/// Human-readable name for a given CPU architecture kind", "--const char *getCPUArchName(ARMBuildAttrs::CPUArch K);", "--", "--/// Get a human-readable name for the given AArch32 edge kind.", "--const char *getEdgeKindName(Edge::Kind K);", "--", "--/// AArch32 uses stubs for a number of purposes, like branch range extension", "--/// or interworking between Arm and Thumb instruction subsets.", "--///", "--/// Stub implementations vary depending on CPU architecture (v4, v6, v7),", "--/// instruction subset and branch type (absolute/PC-relative).", "--///", "--/// For each kind of stub, the StubsFlavor defines one concrete form that is", "--/// used throughout the LinkGraph.", "--///", "--/// Stubs are often called \"veneers\" in the official docs and online.", "--///", "--enum StubsFlavor {", "--  Unsupported = 0,", "--  Thumbv7,", "--};", "--", "--/// JITLink sub-arch configuration for Arm CPU models", "--struct ArmConfig {", "--  bool J1J2BranchEncoding = false;", "--  StubsFlavor Stubs = Unsupported;", "--};", "--", "--/// Obtain the sub-arch configuration for a given Arm CPU model.", "--inline ArmConfig getArmConfigForCPUArch(ARMBuildAttrs::CPUArch CPUArch) {", "--  ArmConfig ArmCfg;", "--  switch (CPUArch) {", "--  case ARMBuildAttrs::v7:", "--  case ARMBuildAttrs::v8_A:", "--    ArmCfg.J1J2BranchEncoding = true;", "--    ArmCfg.Stubs = Thumbv7;", "--    break;", "--  default:", "--    DEBUG_WITH_TYPE(\"jitlink\", {", "--      dbgs() << \"  Warning: ARM config not defined for CPU architecture \"", "--             << getCPUArchName(CPUArch);", "--    });", "--    break;", "--  }", "--  return ArmCfg;", "--}", "--", "--/// Immutable pair of halfwords, Hi and Lo, with overflow check", "--struct HalfWords {", "--  constexpr HalfWords() : Hi(0), Lo(0) {}", "--  constexpr HalfWords(uint32_t Hi, uint32_t Lo) : Hi(Hi), Lo(Lo) {", "--    assert(isUInt<16>(Hi) && \"Overflow in first half-word\");", "--    assert(isUInt<16>(Lo) && \"Overflow in second half-word\");", "--  }", "--  const uint16_t Hi; // First halfword", "--  const uint16_t Lo; // Second halfword", "--};", "--", "--/// Collection of named constants per fixup kind. It may contain but is not", "--/// limited to the following entries:", "--///", "--///   Opcode      - Values of the op-code bits in the instruction, with", "--///                 unaffected bits nulled", "--///   OpcodeMask  - Mask with all bits set that encode the op-code", "--///   ImmMask     - Mask with all bits set that encode the immediate value", "--///   RegMask     - Mask with all bits set that encode the register", "--///", "--template <EdgeKind_aarch32 Kind> struct FixupInfo {};", "--", "--template <> struct FixupInfo<Thumb_Jump24> {", "--  static constexpr HalfWords Opcode{0xf000, 0x8000};", "--  static constexpr HalfWords OpcodeMask{0xf800, 0x8000};", "--  static constexpr HalfWords ImmMask{0x07ff, 0x2fff};", "--  static constexpr uint16_t LoBitConditional = 0x1000;", "--};", "--", "--template <> struct FixupInfo<Thumb_Call> {", "--  static constexpr HalfWords Opcode{0xf000, 0xc000};", "--  static constexpr HalfWords OpcodeMask{0xf800, 0xc000};", "--  static constexpr HalfWords ImmMask{0x07ff, 0x2fff};", "--  static constexpr uint16_t LoBitH = 0x0001;", "--  static constexpr uint16_t LoBitNoBlx = 0x1000;", "--};", "--", "--template <> struct FixupInfo<Thumb_MovtAbs> {", "--  static constexpr HalfWords Opcode{0xf2c0, 0x0000};", "--  static constexpr HalfWords OpcodeMask{0xfbf0, 0x8000};", "--  static constexpr HalfWords ImmMask{0x040f, 0x70ff};", "--  static constexpr HalfWords RegMask{0x0000, 0x0f00};", "--};", "--", "--template <>", "--struct FixupInfo<Thumb_MovwAbsNC> : public FixupInfo<Thumb_MovtAbs> {", "--  static constexpr HalfWords Opcode{0xf240, 0x0000};", "--};", "--", "--/// Helper function to read the initial addend for Data-class relocations.", "--Expected<int64_t> readAddendData(LinkGraph &G, Block &B, const Edge &E);", "--", "--/// Helper function to read the initial addend for Arm-class relocations.", "--Expected<int64_t> readAddendArm(LinkGraph &G, Block &B, const Edge &E);", "--", "--/// Helper function to read the initial addend for Thumb-class relocations.", "--Expected<int64_t> readAddendThumb(LinkGraph &G, Block &B, const Edge &E,", "--                                  const ArmConfig &ArmCfg);", "--", "--/// Read the initial addend for a REL-type relocation. It's the value encoded", "--/// in the immediate field of the fixup location by the compiler.", "--inline Expected<int64_t> readAddend(LinkGraph &G, Block &B, const Edge &E,", "--                                    const ArmConfig &ArmCfg) {", "--  Edge::Kind Kind = E.getKind();", "--  if (Kind <= LastDataRelocation)", "--    return readAddendData(G, B, E);", "--", "--  if (Kind <= LastArmRelocation)", "--    return readAddendArm(G, B, E);", "--", "--  if (Kind <= LastThumbRelocation)", "--    return readAddendThumb(G, B, E, ArmCfg);", "--", "--  llvm_unreachable(\"Relocation must be of class Data, Arm or Thumb\");", "--}", "--", "--/// Helper function to apply the fixup for Data-class relocations.", "--Error applyFixupData(LinkGraph &G, Block &B, const Edge &E);", "--", "--/// Helper function to apply the fixup for Arm-class relocations.", "--Error applyFixupArm(LinkGraph &G, Block &B, const Edge &E);", "--", "--/// Helper function to apply the fixup for Thumb-class relocations.", "--Error applyFixupThumb(LinkGraph &G, Block &B, const Edge &E,", "--                      const ArmConfig &ArmCfg);", "--", "--/// Apply fixup expression for edge to block content.", "--inline Error applyFixup(LinkGraph &G, Block &B, const Edge &E,", "--                        const ArmConfig &ArmCfg) {", "--  Edge::Kind Kind = E.getKind();", "--", "--  if (Kind <= LastDataRelocation)", "--    return applyFixupData(G, B, E);", "--", "--  if (Kind <= LastArmRelocation)", "--    return applyFixupArm(G, B, E);", "--", "--  if (Kind <= LastThumbRelocation)", "--    return applyFixupThumb(G, B, E, ArmCfg);", "--", "--  llvm_unreachable(\"Relocation must be of class Data, Arm or Thumb\");", "--}", "--", "--/// Stubs builder for a specific StubsFlavor", "--///", "--/// Right now we only have one default stub kind, but we want to extend this", "--/// and allow creation of specific kinds in the future (e.g. branch range", "--/// extension or interworking).", "--///", "--/// Let's keep it simple for the moment and not wire this through a GOT.", "--///", "--template <StubsFlavor Flavor>", "--class StubsManager : public TableManager<StubsManager<Flavor>> {", "--public:", "--  StubsManager() = default;", "--", "--  /// Name of the object file section that will contain all our stubs.", "--  static StringRef getSectionName() { return \"__llvm_jitlink_STUBS\"; }", "--", "--  /// Implements link-graph traversal via visitExistingEdges().", "--  bool visitEdge(LinkGraph &G, Block *B, Edge &E) {", "--    if (E.getTarget().isDefined())", "--      return false;", "--", "--    switch (E.getKind()) {", "--    case Thumb_Call:", "--    case Thumb_Jump24: {", "--      DEBUG_WITH_TYPE(\"jitlink\", {", "--        dbgs() << \"  Fixing \" << G.getEdgeKindName(E.getKind()) << \" edge at \"", "--               << B->getFixupAddress(E) << \" (\" << B->getAddress() << \" + \"", "--               << formatv(\"{0:x}\", E.getOffset()) << \")\\n\";", "--      });", "--      E.setTarget(this->getEntryForTarget(G, E.getTarget()));", "--      return true;", "--    }", "--    }", "--    return false;", "--  }", "--", "--  /// Create a branch range extension stub for the class's flavor.", "--  Symbol &createEntry(LinkGraph &G, Symbol &Target);", "--", "--private:", "--  /// Create a new node in the link-graph for the given stub template.", "--  template <size_t Size>", "--  Block &addStub(LinkGraph &G, const uint8_t (&Code)[Size],", "--                 uint64_t Alignment) {", "--    ArrayRef<char> Template(reinterpret_cast<const char *>(Code), Size);", "--    return G.createContentBlock(getStubsSection(G), Template,", "--                                orc::ExecutorAddr(), Alignment, 0);", "--  }", "--", "--  /// Get or create the object file section that will contain all our stubs.", "--  Section &getStubsSection(LinkGraph &G) {", "--    if (!StubsSection)", "--      StubsSection = &G.createSection(getSectionName(),", "--                                      orc::MemProt::Read | orc::MemProt::Exec);", "--    return *StubsSection;", "--  }", "--", "--  Section *StubsSection = nullptr;", "--};", "--", "--/// Create a branch range extension stub with Thumb encoding for v7 CPUs.", "--template <>", "--Symbol &StubsManager<Thumbv7>::createEntry(LinkGraph &G, Symbol &Target);", "--", "--} // namespace aarch32", "--} // namespace jitlink", "--} // namespace llvm", "--", "--#endif // LLVM_EXECUTIONENGINE_JITLINK_AARCH32", "-diff -ruN --strip-trailing-cr a/llvm/lib/ExecutionEngine/JITLink/CMakeLists.txt b/llvm/lib/ExecutionEngine/JITLink/CMakeLists.txt", "---- a/llvm/lib/ExecutionEngine/JITLink/CMakeLists.txt", "-+++ b/llvm/lib/ExecutionEngine/JITLink/CMakeLists.txt", "-@@ -20,7 +20,6 @@", "-   # ELF", "-   ELF.cpp", "-   ELFLinkGraphBuilder.cpp", "--  ELF_aarch32.cpp", "-   ELF_aarch64.cpp", "-   ELF_i386.cpp", "-   ELF_loongarch.cpp", "-@@ -34,7 +33,6 @@", "-   COFF_x86_64.cpp", "- ", "-   # Architectures:", "--  aarch32.cpp", "-   aarch64.cpp", "-   i386.cpp", "-   loongarch.cpp", "-diff -ruN --strip-trailing-cr a/llvm/lib/ExecutionEngine/JITLink/ELF.cpp b/llvm/lib/ExecutionEngine/JITLink/ELF.cpp", "---- a/llvm/lib/ExecutionEngine/JITLink/ELF.cpp", "-+++ b/llvm/lib/ExecutionEngine/JITLink/ELF.cpp", "-@@ -13,7 +13,6 @@", "- #include \"llvm/ExecutionEngine/JITLink/ELF.h\"", "- ", "- #include \"llvm/BinaryFormat/ELF.h\"", "--#include \"llvm/ExecutionEngine/JITLink/ELF_aarch32.h\"", "- #include \"llvm/ExecutionEngine/JITLink/ELF_aarch64.h\"", "- #include \"llvm/ExecutionEngine/JITLink/ELF_i386.h\"", "- #include \"llvm/ExecutionEngine/JITLink/ELF_loongarch.h\"", "-@@ -70,8 +69,6 @@", "-   switch (*TargetMachineArch) {", "-   case ELF::EM_AARCH64:", "-     return createLinkGraphFromELFObject_aarch64(ObjectBuffer);", "--  case ELF::EM_ARM:", "--    return createLinkGraphFromELFObject_aarch32(ObjectBuffer);", "-   case ELF::EM_LOONGARCH:", "-     return createLinkGraphFromELFObject_loongarch(ObjectBuffer);", "-   case ELF::EM_RISCV:", "-@@ -93,12 +90,6 @@", "-   case Triple::aarch64:", "-     link_ELF_aarch64(std::move(G), std::move(Ctx));", "-     return;", "--  case Triple::arm:", "--  case Triple::armeb:", "--  case Triple::thumb:", "--  case Triple::thumbeb:", "--    link_ELF_aarch32(std::move(G), std::move(Ctx));", "--    return;", "-   case Triple::loongarch32:", "-   case Triple::loongarch64:", "-     link_ELF_loongarch(std::move(G), std::move(Ctx));", "-diff -ruN --strip-trailing-cr a/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h b/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h", "---- a/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h", "-+++ b/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h", "-@@ -127,12 +127,6 @@", "-   Error graphifySections();", "-   Error graphifySymbols();", "- ", "--  /// Override in derived classes to suppress certain sections in the link", "--  /// graph.", "--  virtual bool excludeSection(const typename ELFT::Shdr &Sect) const {", "--    return false;", "--  }", "--", "-   /// Traverse all matching ELFT::Rela relocation records in the given section.", "-   /// The handler function Func should be callable with this signature:", "-   ///   Error(const typename ELFT::Rela &,", "-@@ -327,13 +321,6 @@", "-     auto Name = Obj.getSectionName(Sec, SectionStringTab);", "-     if (!Name)", "-       return Name.takeError();", "--    if (excludeSection(Sec)) {", "--      LLVM_DEBUG({", "--        dbgs() << \"    \" << SecIndex << \": Skipping section \\\"\" << *Name", "--               << \"\\\" explicitly\\n\";", "--      });", "--      continue;", "--    }", "- ", "-     // Skip null sections.", "-     if (Sec.sh_type == ELF::SHT_NULL) {", "-@@ -577,10 +564,6 @@", "-     LLVM_DEBUG(dbgs() << \"    skipped (dwarf section)\\n\\n\");", "-     return Error::success();", "-   }", "--  if (excludeSection(**FixupSection)) {", "--    LLVM_DEBUG(dbgs() << \"    skipped (fixup section excluded explicitly)\\n\\n\");", "--    return Error::success();", "--  }", "- ", "-   // Lookup the link-graph node corresponding to the target section name.", "-   auto *BlockToFix = getGraphBlock(RelSect.sh_info);", "-@@ -627,10 +610,6 @@", "-     LLVM_DEBUG(dbgs() << \"    skipped (dwarf section)\\n\\n\");", "-     return Error::success();", "-   }", "--  if (excludeSection(**FixupSection)) {", "--    LLVM_DEBUG(dbgs() << \"    skipped (fixup section excluded explicitly)\\n\\n\");", "--    return Error::success();", "--  }", "- ", "-   // Lookup the link-graph node corresponding to the target section name.", "-   auto *BlockToFix = getGraphBlock(RelSect.sh_info);", "-diff -ruN --strip-trailing-cr a/llvm/lib/ExecutionEngine/JITLink/ELF_aarch32.cpp b/llvm/lib/ExecutionEngine/JITLink/ELF_aarch32.cpp", "---- a/llvm/lib/ExecutionEngine/JITLink/ELF_aarch32.cpp", "-+++ b/llvm/lib/ExecutionEngine/JITLink/ELF_aarch32.cpp", "-@@ -1,299 +0,0 @@", "--//===----- ELF_aarch32.cpp - JIT linker implementation for arm/thumb ------===//", "--//", "--// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.", "--// See https://llvm.org/LICENSE.txt for license information.", "--// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception", "--//", "--//===----------------------------------------------------------------------===//", "--//", "--// ELF/aarch32 jit-link implementation.", "--//", "--//===----------------------------------------------------------------------===//", "--", "--#include \"llvm/ExecutionEngine/JITLink/ELF_aarch32.h\"", "--", "--#include \"llvm/BinaryFormat/ELF.h\"", "--#include \"llvm/ExecutionEngine/JITLink/JITLink.h\"", "--#include \"llvm/ExecutionEngine/JITLink/aarch32.h\"", "--#include \"llvm/Object/ELF.h\"", "--#include \"llvm/Object/ELFObjectFile.h\"", "--#include \"llvm/Support/Endian.h\"", "--#include \"llvm/Support/ErrorHandling.h\"", "--#include \"llvm/TargetParser/ARMTargetParser.h\"", "--", "--#include \"ELFLinkGraphBuilder.h\"", "--#include \"JITLinkGeneric.h\"", "--", "--#define DEBUG_TYPE \"jitlink\"", "--", "--using namespace llvm::object;", "--", "--namespace llvm {", "--namespace jitlink {", "--", "--/// Translate from ELF relocation type to JITLink-internal edge kind.", "--Expected<aarch32::EdgeKind_aarch32> getJITLinkEdgeKind(uint32_t ELFType) {", "--  switch (ELFType) {", "--  case ELF::R_ARM_REL32:", "--    return aarch32::Data_Delta32;", "--  case ELF::R_ARM_CALL:", "--    return aarch32::Arm_Call;", "--  case ELF::R_ARM_THM_CALL:", "--    return aarch32::Thumb_Call;", "--  case ELF::R_ARM_THM_JUMP24:", "--    return aarch32::Thumb_Jump24;", "--  case ELF::R_ARM_THM_MOVW_ABS_NC:", "--    return aarch32::Thumb_MovwAbsNC;", "--  case ELF::R_ARM_THM_MOVT_ABS:", "--    return aarch32::Thumb_MovtAbs;", "--  }", "--", "--  return make_error<JITLinkError>(", "--      \"Unsupported aarch32 relocation \" + formatv(\"{0:d}: \", ELFType) +", "--      object::getELFRelocationTypeName(ELF::EM_ARM, ELFType));", "--}", "--", "--/// Translate from JITLink-internal edge kind back to ELF relocation type.", "--Expected<uint32_t> getELFRelocationType(Edge::Kind Kind) {", "--  switch (static_cast<aarch32::EdgeKind_aarch32>(Kind)) {", "--  case aarch32::Data_Delta32:", "--    return ELF::R_ARM_REL32;", "--  case aarch32::Arm_Call:", "--    return ELF::R_ARM_CALL;", "--  case aarch32::Thumb_Call:", "--    return ELF::R_ARM_THM_CALL;", "--  case aarch32::Thumb_Jump24:", "--    return ELF::R_ARM_THM_JUMP24;", "--  case aarch32::Thumb_MovwAbsNC:", "--    return ELF::R_ARM_THM_MOVW_ABS_NC;", "--  case aarch32::Thumb_MovtAbs:", "--    return ELF::R_ARM_THM_MOVT_ABS;", "--  }", "--", "--  return make_error<JITLinkError>(formatv(\"Invalid aarch32 edge {0:d}: \",", "--                                          Kind));", "--}", "--", "--/// Get a human-readable name for the given ELF AArch32 edge kind.", "--const char *getELFAArch32EdgeKindName(Edge::Kind R) {", "--  // No ELF-specific edge kinds yet", "--  return aarch32::getEdgeKindName(R);", "--}", "--", "--class ELFJITLinker_aarch32 : public JITLinker<ELFJITLinker_aarch32> {", "--  friend class JITLinker<ELFJITLinker_aarch32>;", "--", "--public:", "--  ELFJITLinker_aarch32(std::unique_ptr<JITLinkContext> Ctx,", "--                       std::unique_ptr<LinkGraph> G, PassConfiguration PassCfg,", "--                       aarch32::ArmConfig ArmCfg)", "--      : JITLinker(std::move(Ctx), std::move(G), std::move(PassCfg)),", "--        ArmCfg(std::move(ArmCfg)) {}", "--", "--private:", "--  aarch32::ArmConfig ArmCfg;", "--", "--  Error applyFixup(LinkGraph &G, Block &B, const Edge &E) const {", "--    return aarch32::applyFixup(G, B, E, ArmCfg);", "--  }", "--};", "--", "--template <support::endianness DataEndianness>", "--class ELFLinkGraphBuilder_aarch32", "--    : public ELFLinkGraphBuilder<ELFType<DataEndianness, false>> {", "--private:", "--  using ELFT = ELFType<DataEndianness, false>;", "--  using Base = ELFLinkGraphBuilder<ELFT>;", "--", "--  bool excludeSection(const typename ELFT::Shdr &Sect) const override {", "--    // TODO: An .ARM.exidx (Exception Index table) entry is 8-bytes in size and", "--    // consists of 2 words. It might be sufficient to process only relocations", "--    // in the the second word (offset 4). Please find more details in: Exception", "--    // Handling ABI for the Arm\u00ae Architecture -> Index table entries", "--    if (Sect.sh_type == ELF::SHT_ARM_EXIDX)", "--      return true;", "--    return false;", "--  }", "--", "--  Error addRelocations() override {", "--    LLVM_DEBUG(dbgs() << \"Processing relocations:\\n\");", "--    using Self = ELFLinkGraphBuilder_aarch32<DataEndianness>;", "--    for (const auto &RelSect : Base::Sections) {", "--      if (Error Err = Base::forEachRelRelocation(RelSect, this,", "--                                                 &Self::addSingleRelRelocation))", "--        return Err;", "--    }", "--    return Error::success();", "--  }", "--", "--  Error addSingleRelRelocation(const typename ELFT::Rel &Rel,", "--                               const typename ELFT::Shdr &FixupSect,", "--                               Block &BlockToFix) {", "--    uint32_t SymbolIndex = Rel.getSymbol(false);", "--    auto ObjSymbol = Base::Obj.getRelocationSymbol(Rel, Base::SymTabSec);", "--    if (!ObjSymbol)", "--      return ObjSymbol.takeError();", "--", "--    Symbol *GraphSymbol = Base::getGraphSymbol(SymbolIndex);", "--    if (!GraphSymbol)", "--      return make_error<StringError>(", "--          formatv(\"Could not find symbol at given index, did you add it to \"", "--                  \"JITSymbolTable? index: {0}, shndx: {1} Size of table: {2}\",", "--                  SymbolIndex, (*ObjSymbol)->st_shndx,", "--                  Base::GraphSymbols.size()),", "--          inconvertibleErrorCode());", "--", "--    uint32_t Type = Rel.getType(false);", "--    Expected<aarch32::EdgeKind_aarch32> Kind = getJITLinkEdgeKind(Type);", "--    if (!Kind)", "--      return Kind.takeError();", "--", "--    auto FixupAddress = orc::ExecutorAddr(FixupSect.sh_addr) + Rel.r_offset;", "--    Edge::OffsetT Offset = FixupAddress - BlockToFix.getAddress();", "--    Edge E(*Kind, Offset, *GraphSymbol, 0);", "--", "--    Expected<int64_t> Addend =", "--        aarch32::readAddend(*Base::G, BlockToFix, E, ArmCfg);", "--    if (!Addend)", "--      return Addend.takeError();", "--", "--    E.setAddend(*Addend);", "--    LLVM_DEBUG({", "--      dbgs() << \"    \";", "--      printEdge(dbgs(), BlockToFix, E, getELFAArch32EdgeKindName(*Kind));", "--      dbgs() << \"\\n\";", "--    });", "--", "--    BlockToFix.addEdge(std::move(E));", "--    return Error::success();", "--  }", "--", "--  aarch32::ArmConfig ArmCfg;", "--", "--protected:", "--  TargetFlagsType makeTargetFlags(const typename ELFT::Sym &Sym) override {", "--    if (Sym.getValue() & 0x01)", "--      return aarch32::ThumbSymbol;", "--    return TargetFlagsType{};", "--  }", "--", "--  orc::ExecutorAddrDiff getRawOffset(const typename ELFT::Sym &Sym,", "--                                     TargetFlagsType Flags) override {", "--    assert((makeTargetFlags(Sym) & Flags) == Flags);", "--    static constexpr uint64_t ThumbBit = 0x01;", "--    return Sym.getValue() & ~ThumbBit;", "--  }", "--", "--public:", "--  ELFLinkGraphBuilder_aarch32(StringRef FileName, const ELFFile<ELFT> &Obj,", "--                              Triple TT, aarch32::ArmConfig ArmCfg)", "--      : ELFLinkGraphBuilder<ELFT>(Obj, std::move(TT), FileName,", "--                                  getELFAArch32EdgeKindName),", "--        ArmCfg(std::move(ArmCfg)) {}", "--};", "--", "--template <aarch32::StubsFlavor Flavor>", "--Error buildTables_ELF_aarch32(LinkGraph &G) {", "--  LLVM_DEBUG(dbgs() << \"Visiting edges in graph:\\n\");", "--", "--  aarch32::StubsManager<Flavor> PLT;", "--  visitExistingEdges(G, PLT);", "--  return Error::success();", "--}", "--", "--Expected<std::unique_ptr<LinkGraph>>", "--createLinkGraphFromELFObject_aarch32(MemoryBufferRef ObjectBuffer) {", "--  LLVM_DEBUG({", "--    dbgs() << \"Building jitlink graph for new input \"", "--           << ObjectBuffer.getBufferIdentifier() << \"...\\n\";", "--  });", "--", "--  auto ELFObj = ObjectFile::createELFObjectFile(ObjectBuffer);", "--  if (!ELFObj)", "--    return ELFObj.takeError();", "--", "--  // Find out what exact AArch32 instruction set and features we target.", "--  auto TT = (*ELFObj)->makeTriple();", "--  ARM::ArchKind AK = ARM::parseArch(TT.getArchName());", "--  if (AK == ARM::ArchKind::INVALID)", "--    return make_error<JITLinkError>(", "--        \"Failed to build ELF link graph: Invalid ARM ArchKind\");", "--", "--  // Resolve our internal configuration for the target. If at some point the", "--  // CPUArch alone becomes too unprecise, we can find more details in the", "--  // Tag_CPU_arch_profile.", "--  aarch32::ArmConfig ArmCfg;", "--  using namespace ARMBuildAttrs;", "--  auto Arch = static_cast<CPUArch>(ARM::getArchAttr(AK));", "--  switch (Arch) {", "--  case v7:", "--  case v8_A:", "--    ArmCfg = aarch32::getArmConfigForCPUArch(Arch);", "--    assert(ArmCfg.Stubs != aarch32::Unsupported &&", "--           \"Provide a config for each supported CPU\");", "--    break;", "--  default:", "--    return make_error<JITLinkError>(", "--        \"Failed to build ELF link graph: Unsupported CPU arch \" +", "--        StringRef(aarch32::getCPUArchName(Arch)));", "--  }", "--", "--  // Populate the link-graph.", "--  switch (TT.getArch()) {", "--  case Triple::arm:", "--  case Triple::thumb: {", "--    auto &ELFFile = cast<ELFObjectFile<ELF32LE>>(**ELFObj).getELFFile();", "--    return ELFLinkGraphBuilder_aarch32<support::little>(", "--               (*ELFObj)->getFileName(), ELFFile, TT, ArmCfg)", "--        .buildGraph();", "--  }", "--  case Triple::armeb:", "--  case Triple::thumbeb: {", "--    auto &ELFFile = cast<ELFObjectFile<ELF32BE>>(**ELFObj).getELFFile();", "--    return ELFLinkGraphBuilder_aarch32<support::big>((*ELFObj)->getFileName(),", "--                                                     ELFFile, TT, ArmCfg)", "--        .buildGraph();", "--  }", "--  default:", "--    return make_error<JITLinkError>(", "--        \"Failed to build ELF/aarch32 link graph: Invalid target triple \" +", "--        TT.getTriple());", "--  }", "--}", "--", "--void link_ELF_aarch32(std::unique_ptr<LinkGraph> G,", "--                      std::unique_ptr<JITLinkContext> Ctx) {", "--  const Triple &TT = G->getTargetTriple();", "--", "--  using namespace ARMBuildAttrs;", "--  ARM::ArchKind AK = ARM::parseArch(TT.getArchName());", "--  auto CPU = static_cast<CPUArch>(ARM::getArchAttr(AK));", "--  aarch32::ArmConfig ArmCfg = aarch32::getArmConfigForCPUArch(CPU);", "--", "--  PassConfiguration PassCfg;", "--  if (Ctx->shouldAddDefaultTargetPasses(TT)) {", "--    // Add a mark-live pass.", "--    if (auto MarkLive = Ctx->getMarkLivePass(TT))", "--      PassCfg.PrePrunePasses.push_back(std::move(MarkLive));", "--    else", "--      PassCfg.PrePrunePasses.push_back(markAllSymbolsLive);", "--", "--    switch (ArmCfg.Stubs) {", "--    case aarch32::Thumbv7:", "--      PassCfg.PostPrunePasses.push_back(", "--          buildTables_ELF_aarch32<aarch32::Thumbv7>);", "--      break;", "--    case aarch32::Unsupported:", "--      llvm_unreachable(\"Check before building graph\");", "--    }", "--  }", "--", "--  if (auto Err = Ctx->modifyPassConfig(*G, PassCfg))", "--    return Ctx->notifyFailed(std::move(Err));", "--", "--  ELFJITLinker_aarch32::link(std::move(Ctx), std::move(G), std::move(PassCfg),", "--                             std::move(ArmCfg));", "--}", "--", "--} // namespace jitlink", "--} // namespace llvm", "-diff -ruN --strip-trailing-cr a/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp b/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp", "---- a/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp", "-+++ b/llvm/lib/ExecutionEngine/JITLink/aarch32.cpp", "-@@ -1,514 +0,0 @@", "--//===--------- aarch32.cpp - Generic JITLink arm/thumb utilities ----------===//", "--//", "--// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.", "--// See https://llvm.org/LICENSE.txt for license information.", "--// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception", "--//", "--//===----------------------------------------------------------------------===//", "--//", "--// Generic utilities for graphs representing arm/thumb objects.", "--//", "--//===----------------------------------------------------------------------===//", "--", "--#include \"llvm/ExecutionEngine/JITLink/aarch32.h\"", "--", "--#include \"llvm/ADT/StringExtras.h\"", "--#include \"llvm/BinaryFormat/ELF.h\"", "--#include \"llvm/ExecutionEngine/JITLink/JITLink.h\"", "--#include \"llvm/Object/ELFObjectFile.h\"", "--#include \"llvm/Support/Endian.h\"", "--#include \"llvm/Support/MathExtras.h\"", "--", "--#define DEBUG_TYPE \"jitlink\"", "--", "--namespace llvm {", "--namespace jitlink {", "--namespace aarch32 {", "--", "--using namespace support;", "--using namespace support::endian;", "--", "--/// Encode 22-bit immediate value for branch instructions without J1J2 range", "--/// extension (formats B T4, BL T1 and BLX T2).", "--///", "--///   00000:Imm11H:Imm11L:0 -> [ 00000:Imm11H, 00000:Imm11L ]", "--///                                            J1^ ^J2 will always be 1", "--///", "--HalfWords encodeImmBT4BlT1BlxT2(int64_t Value) {", "--  constexpr uint32_t J1J2 = 0x2800;", "--  uint32_t Imm11H = (Value >> 12) & 0x07ff;", "--  uint32_t Imm11L = (Value >> 1) & 0x07ff;", "--  return HalfWords{Imm11H, Imm11L | J1J2};", "--}", "--", "--/// Decode 22-bit immediate value for branch instructions without J1J2 range", "--/// extension (formats B T4, BL T1 and BLX T2).", "--///", "--///   [ 00000:Imm11H, 00000:Imm11L ] -> 00000:Imm11H:Imm11L:0", "--///                   J1^ ^J2 will always be 1", "--///", "--int64_t decodeImmBT4BlT1BlxT2(uint32_t Hi, uint32_t Lo) {", "--  uint32_t Imm11H = Hi & 0x07ff;", "--  uint32_t Imm11L = Lo & 0x07ff;", "--  return SignExtend64<22>(Imm11H << 12 | Imm11L << 1);", "--}", "--", "--/// Encode 25-bit immediate value for branch instructions with J1J2 range", "--/// extension (formats B T4, BL T1 and BLX T2).", "--///", "--///   S:I1:I2:Imm10:Imm11:0 -> [ 00000:S:Imm10, 00:J1:0:J2:Imm11 ]", "--///", "--HalfWords encodeImmBT4BlT1BlxT2_J1J2(int64_t Value) {", "--  uint32_t S = (Value >> 14) & 0x0400;", "--  uint32_t J1 = (((~(Value >> 10)) ^ (Value >> 11)) & 0x2000);", "--  uint32_t J2 = (((~(Value >> 11)) ^ (Value >> 13)) & 0x0800);", "--  uint32_t Imm10 = (Value >> 12) & 0x03ff;", "--  uint32_t Imm11 = (Value >> 1) & 0x07ff;", "--  return HalfWords{S | Imm10, J1 | J2 | Imm11};", "--}", "--", "--/// Decode 25-bit immediate value for branch instructions with J1J2 range", "--/// extension (formats B T4, BL T1 and BLX T2).", "--///", "--///   [ 00000:S:Imm10, 00:J1:0:J2:Imm11] -> S:I1:I2:Imm10:Imm11:0", "--///", "--int64_t decodeImmBT4BlT1BlxT2_J1J2(uint32_t Hi, uint32_t Lo) {", "--  uint32_t S = Hi & 0x0400;", "--  uint32_t I1 = ~((Lo ^ (Hi << 3)) << 10) & 0x00800000;", "--  uint32_t I2 = ~((Lo ^ (Hi << 1)) << 11) & 0x00400000;", "--  uint32_t Imm10 = Hi & 0x03ff;", "--  uint32_t Imm11 = Lo & 0x07ff;", "--  return SignExtend64<25>(S << 14 | I1 | I2 | Imm10 << 12 | Imm11 << 1);", "--}", "--", "--/// Encode 16-bit immediate value for move instruction formats MOVT T1 and", "--/// MOVW T3.", "--///", "--///   Imm4:Imm1:Imm3:Imm8 -> [ 00000:i:000000:Imm4, 0:Imm3:0000:Imm8 ]", "--///", "--HalfWords encodeImmMovtT1MovwT3(uint16_t Value) {", "--  uint32_t Imm4 = (Value >> 12) & 0x0f;", "--  uint32_t Imm1 = (Value >> 11) & 0x01;", "--  uint32_t Imm3 = (Value >> 8) & 0x07;", "--  uint32_t Imm8 = Value & 0xff;", "--  return HalfWords{Imm1 << 10 | Imm4, Imm3 << 12 | Imm8};", "--}", "--", "--/// Decode 16-bit immediate value from move instruction formats MOVT T1 and", "--/// MOVW T3.", "--///", "--///   [ 00000:i:000000:Imm4, 0:Imm3:0000:Imm8 ] -> Imm4:Imm1:Imm3:Imm8", "--///", "--uint16_t decodeImmMovtT1MovwT3(uint32_t Hi, uint32_t Lo) {", "--  uint32_t Imm4 = Hi & 0x0f;", "--  uint32_t Imm1 = (Hi >> 10) & 0x01;", "--  uint32_t Imm3 = (Lo >> 12) & 0x07;", "--  uint32_t Imm8 = Lo & 0xff;", "--  uint32_t Imm16 = Imm4 << 12 | Imm1 << 11 | Imm3 << 8 | Imm8;", "--  assert(Imm16 <= 0xffff && \"Decoded value out-of-range\");", "--  return Imm16;", "--}", "--", "--/// Encode register ID for instruction formats MOVT T1 and MOVW T3.", "--///", "--///   Rd4 -> [0000000000000000, 0000:Rd4:00000000]", "--///", "--HalfWords encodeRegMovtT1MovwT3(int64_t Value) {", "--  uint32_t Rd4 = (Value & 0x0f) << 8;", "--  return HalfWords{0, Rd4};", "--}", "--", "--/// Decode register ID from instruction formats MOVT T1 and MOVW T3.", "--///", "--///   [0000000000000000, 0000:Rd4:00000000] -> Rd4", "--///", "--int64_t decodeRegMovtT1MovwT3(uint32_t Hi, uint32_t Lo) {", "--  uint32_t Rd4 = (Lo >> 8) & 0x0f;", "--  return Rd4;", "--}", "--", "--/// 32-bit Thumb instructions are stored as two little-endian halfwords.", "--/// An instruction at address A encodes bytes A+1, A in the first halfword (Hi),", "--/// followed by bytes A+3, A+2 in the second halfword (Lo).", "--struct WritableThumbRelocation {", "--  /// Create a writable reference to a Thumb32 fixup.", "--  WritableThumbRelocation(char *FixupPtr)", "--      : Hi{*reinterpret_cast<support::ulittle16_t *>(FixupPtr)},", "--        Lo{*reinterpret_cast<support::ulittle16_t *>(FixupPtr + 2)} {}", "--", "--  support::ulittle16_t &Hi; // First halfword", "--  support::ulittle16_t &Lo; // Second halfword", "--};", "--", "--struct ThumbRelocation {", "--  /// Create a read-only reference to a Thumb32 fixup.", "--  ThumbRelocation(const char *FixupPtr)", "--      : Hi{*reinterpret_cast<const support::ulittle16_t *>(FixupPtr)},", "--        Lo{*reinterpret_cast<const support::ulittle16_t *>(FixupPtr + 2)} {}", "--", "--  /// Create a read-only Thumb32 fixup from a writeable one.", "--  ThumbRelocation(WritableThumbRelocation &Writable)", "--      : Hi{Writable.Hi}, Lo(Writable.Lo) {}", "--", "--  const support::ulittle16_t &Hi; // First halfword", "--  const support::ulittle16_t &Lo; // Second halfword", "--};", "--", "--Error makeUnexpectedOpcodeError(const LinkGraph &G, const ThumbRelocation &R,", "--                                Edge::Kind Kind) {", "--  return make_error<JITLinkError>(", "--      formatv(\"Invalid opcode [ 0x{0:x4}, 0x{1:x4} ] for relocation: {2}\", R.Hi,", "--              R.Lo, G.getEdgeKindName(Kind)));", "--}", "--", "--template <EdgeKind_aarch32 Kind> bool checkOpcode(const ThumbRelocation &R) {", "--  uint16_t Hi = R.Hi & FixupInfo<Kind>::OpcodeMask.Hi;", "--  uint16_t Lo = R.Lo & FixupInfo<Kind>::OpcodeMask.Lo;", "--  return Hi == FixupInfo<Kind>::Opcode.Hi && Lo == FixupInfo<Kind>::Opcode.Lo;", "--}", "--", "--template <EdgeKind_aarch32 Kind>", "--bool checkRegister(const ThumbRelocation &R, HalfWords Reg) {", "--  uint16_t Hi = R.Hi & FixupInfo<Kind>::RegMask.Hi;", "--  uint16_t Lo = R.Lo & FixupInfo<Kind>::RegMask.Lo;", "--  return Hi == Reg.Hi && Lo == Reg.Lo;", "--}", "--", "--template <EdgeKind_aarch32 Kind>", "--bool writeRegister(WritableThumbRelocation &R, HalfWords Reg) {", "--  static constexpr HalfWords Mask = FixupInfo<Kind>::RegMask;", "--  assert((Mask.Hi & Reg.Hi) == Reg.Hi && (Mask.Hi & Reg.Hi) == Reg.Hi &&", "--         \"Value bits exceed bit range of given mask\");", "--  R.Hi = (R.Hi & ~Mask.Hi) | Reg.Hi;", "--  R.Lo = (R.Lo & ~Mask.Lo) | Reg.Lo;", "--}", "--", "--template <EdgeKind_aarch32 Kind>", "--void writeImmediate(WritableThumbRelocation &R, HalfWords Imm) {", "--  static constexpr HalfWords Mask = FixupInfo<Kind>::ImmMask;", "--  assert((Mask.Hi & Imm.Hi) == Imm.Hi && (Mask.Hi & Imm.Hi) == Imm.Hi &&", "--         \"Value bits exceed bit range of given mask\");", "--  R.Hi = (R.Hi & ~Mask.Hi) | Imm.Hi;", "--  R.Lo = (R.Lo & ~Mask.Lo) | Imm.Lo;", "--}", "--", "--Expected<int64_t> readAddendData(LinkGraph &G, Block &B, const Edge &E) {", "--  endianness Endian = G.getEndianness();", "--  assert(Endian != native && \"Declare as little or big explicitly\");", "--", "--  Edge::Kind Kind = E.getKind();", "--  const char *BlockWorkingMem = B.getContent().data();", "--  const char *FixupPtr = BlockWorkingMem + E.getOffset();", "--", "--  switch (Kind) {", "--  case Data_Delta32:", "--    return SignExtend64<32>((Endian == little) ? read32<little>(FixupPtr)", "--                                               : read32<big>(FixupPtr));", "--  default:", "--    return make_error<JITLinkError>(", "--        \"In graph \" + G.getName() + \", section \" + B.getSection().getName() +", "--        \" can not read implicit addend for aarch32 edge kind \" +", "--        G.getEdgeKindName(E.getKind()));", "--  }", "--}", "--", "--Expected<int64_t> readAddendArm(LinkGraph &G, Block &B, const Edge &E) {", "--  Edge::Kind Kind = E.getKind();", "--", "--  switch (Kind) {", "--  case Arm_Call:", "--    return make_error<JITLinkError>(", "--        \"Addend extraction for relocation type not yet implemented: \" +", "--        StringRef(G.getEdgeKindName(Kind)));", "--  default:", "--    return make_error<JITLinkError>(", "--        \"In graph \" + G.getName() + \", section \" + B.getSection().getName() +", "--        \" can not read implicit addend for aarch32 edge kind \" +", "--        G.getEdgeKindName(E.getKind()));", "--  }", "--}", "--", "--Expected<int64_t> readAddendThumb(LinkGraph &G, Block &B, const Edge &E,", "--                                  const ArmConfig &ArmCfg) {", "--  ThumbRelocation R(B.getContent().data() + E.getOffset());", "--  Edge::Kind Kind = E.getKind();", "--", "--  switch (Kind) {", "--  case Thumb_Call:", "--    if (!checkOpcode<Thumb_Call>(R))", "--      return makeUnexpectedOpcodeError(G, R, Kind);", "--    return LLVM_LIKELY(ArmCfg.J1J2BranchEncoding)", "--               ? decodeImmBT4BlT1BlxT2_J1J2(R.Hi, R.Lo)", "--               : decodeImmBT4BlT1BlxT2(R.Hi, R.Lo);", "--", "--  case Thumb_Jump24:", "--    if (!checkOpcode<Thumb_Jump24>(R))", "--      return makeUnexpectedOpcodeError(G, R, Kind);", "--    if (R.Lo & FixupInfo<Thumb_Jump24>::LoBitConditional)", "--      return make_error<JITLinkError>(\"Relocation expects an unconditional \"", "--                                      \"B.W branch instruction: \" +", "--                                      StringRef(G.getEdgeKindName(Kind)));", "--    return LLVM_LIKELY(ArmCfg.J1J2BranchEncoding)", "--                  ? decodeImmBT4BlT1BlxT2_J1J2(R.Hi, R.Lo)", "--                  : decodeImmBT4BlT1BlxT2(R.Hi, R.Lo);", "--", "--  case Thumb_MovwAbsNC:", "--    if (!checkOpcode<Thumb_MovwAbsNC>(R))", "--      return makeUnexpectedOpcodeError(G, R, Kind);", "--    // Initial addend is interpreted as a signed value", "--    return SignExtend64<16>(decodeImmMovtT1MovwT3(R.Hi, R.Lo));", "--", "--  case Thumb_MovtAbs:", "--    if (!checkOpcode<Thumb_MovtAbs>(R))", "--      return makeUnexpectedOpcodeError(G, R, Kind);", "--    // Initial addend is interpreted as a signed value", "--    return SignExtend64<16>(decodeImmMovtT1MovwT3(R.Hi, R.Lo));", "--", "--  default:", "--    return make_error<JITLinkError>(", "--        \"In graph \" + G.getName() + \", section \" + B.getSection().getName() +", "--        \" can not read implicit addend for aarch32 edge kind \" +", "--        G.getEdgeKindName(E.getKind()));", "--  }", "--}", "--", "--Error applyFixupData(LinkGraph &G, Block &B, const Edge &E) {", "--  using namespace support;", "--", "--  char *BlockWorkingMem = B.getAlreadyMutableContent().data();", "--  char *FixupPtr = BlockWorkingMem + E.getOffset();", "--", "--  auto Write32 = [FixupPtr, Endian = G.getEndianness()](int64_t Value) {", "--    assert(Endian != native && \"Must be explicit: little or big\");", "--    assert(isInt<32>(Value) && \"Must be in signed 32-bit range\");", "--    uint32_t Imm = static_cast<int32_t>(Value);", "--    if (LLVM_LIKELY(Endian == little))", "--      endian::write32<little>(FixupPtr, Imm);", "--    else", "--      endian::write32<big>(FixupPtr, Imm);", "--  };", "--", "--  Edge::Kind Kind = E.getKind();", "--  uint64_t FixupAddress = (B.getAddress() + E.getOffset()).getValue();", "--  int64_t Addend = E.getAddend();", "--  Symbol &TargetSymbol = E.getTarget();", "--  uint64_t TargetAddress = TargetSymbol.getAddress().getValue();", "--  assert(!TargetSymbol.hasTargetFlags(ThumbSymbol));", "--", "--  // Regular data relocations have size 4, alignment 1 and write the full 32-bit", "--  // result to the place; no need for overflow checking. There are three", "--  // exceptions: R_ARM_ABS8, R_ARM_ABS16, R_ARM_PREL31", "--  switch (Kind) {", "--  case Data_Delta32: {", "--    int64_t Value = TargetAddress - FixupAddress + Addend;", "--    if (!isInt<32>(Value))", "--      return makeTargetOutOfRangeError(G, B, E);", "--    Write32(Value);", "--    return Error::success();", "--  }", "--  default:", "--    return make_error<JITLinkError>(", "--        \"In graph \" + G.getName() + \", section \" + B.getSection().getName() +", "--        \" encountered unfixable aarch32 edge kind \" +", "--        G.getEdgeKindName(E.getKind()));", "--  }", "--}", "--", "--Error applyFixupArm(LinkGraph &G, Block &B, const Edge &E) {", "--  Edge::Kind Kind = E.getKind();", "--", "--  switch (Kind) {", "--  case Arm_Call:", "--    return make_error<JITLinkError>(", "--        \"Fix-up for relocation type not yet implemented: \" +", "--        StringRef(G.getEdgeKindName(Kind)));", "--  default:", "--    return make_error<JITLinkError>(", "--        \"In graph \" + G.getName() + \", section \" + B.getSection().getName() +", "--        \" encountered unfixable aarch32 edge kind \" +", "--        G.getEdgeKindName(E.getKind()));", "--  }", "--}", "--", "--Error applyFixupThumb(LinkGraph &G, Block &B, const Edge &E,", "--                      const ArmConfig &ArmCfg) {", "--  WritableThumbRelocation R(B.getAlreadyMutableContent().data() +", "--                            E.getOffset());", "--", "--  Edge::Kind Kind = E.getKind();", "--  uint64_t FixupAddress = (B.getAddress() + E.getOffset()).getValue();", "--  int64_t Addend = E.getAddend();", "--  Symbol &TargetSymbol = E.getTarget();", "--  uint64_t TargetAddress = TargetSymbol.getAddress().getValue();", "--  if (TargetSymbol.hasTargetFlags(ThumbSymbol))", "--    TargetAddress |= 0x01;", "--", "--  switch (Kind) {", "--  case Thumb_Jump24: {", "--    if (!checkOpcode<Thumb_Jump24>(R))", "--      return makeUnexpectedOpcodeError(G, R, Kind);", "--    if (R.Lo & FixupInfo<Thumb_Jump24>::LoBitConditional)", "--      return make_error<JITLinkError>(\"Relocation expects an unconditional \"", "--                                      \"B.W branch instruction: \" +", "--                                      StringRef(G.getEdgeKindName(Kind)));", "--    if (!(TargetSymbol.hasTargetFlags(ThumbSymbol)))", "--      return make_error<JITLinkError>(\"Branch relocation needs interworking \"", "--                                      \"stub when bridging to ARM: \" +", "--                                      StringRef(G.getEdgeKindName(Kind)));", "--", "--    int64_t Value = TargetAddress - FixupAddress + Addend;", "--    if (LLVM_LIKELY(ArmCfg.J1J2BranchEncoding)) {", "--      if (!isInt<25>(Value))", "--        return makeTargetOutOfRangeError(G, B, E);", "--      writeImmediate<Thumb_Jump24>(R, encodeImmBT4BlT1BlxT2_J1J2(Value));", "--    } else {", "--      if (!isInt<22>(Value))", "--        return makeTargetOutOfRangeError(G, B, E);", "--      writeImmediate<Thumb_Jump24>(R, encodeImmBT4BlT1BlxT2(Value));", "--    }", "--", "--    return Error::success();", "--  }", "--", "--  case Thumb_Call: {", "--    if (!checkOpcode<Thumb_Call>(R))", "--      return makeUnexpectedOpcodeError(G, R, Kind);", "--", "--    int64_t Value = TargetAddress - FixupAddress + Addend;", "--", "--    // The call instruction itself is Thumb. The call destination can either be", "--    // Thumb or Arm. We use BL to stay in Thumb and BLX to change to Arm.", "--    bool TargetIsArm = !TargetSymbol.hasTargetFlags(ThumbSymbol);", "--    bool InstrIsBlx = (R.Lo & FixupInfo<Thumb_Call>::LoBitNoBlx) == 0;", "--    if (TargetIsArm != InstrIsBlx) {", "--      if (LLVM_LIKELY(TargetIsArm)) {", "--        // Change opcode BL -> BLX and fix range value (account for 4-byte", "--        // aligned destination while instruction may only be 2-byte aligned", "--        // and clear Thumb bit).", "--        R.Lo = R.Lo & ~FixupInfo<Thumb_Call>::LoBitNoBlx;", "--        R.Lo = R.Lo & ~FixupInfo<Thumb_Call>::LoBitH;", "--        Value = alignTo(Value, 4);", "--      } else {", "--        // Change opcode BLX -> BL and set Thumb bit", "--        R.Lo = R.Lo & ~FixupInfo<Thumb_Call>::LoBitNoBlx;", "--        Value |= 0x01;", "--      }", "--    }", "--", "--    if (LLVM_LIKELY(ArmCfg.J1J2BranchEncoding)) {", "--      if (!isInt<25>(Value))", "--        return makeTargetOutOfRangeError(G, B, E);", "--      writeImmediate<Thumb_Call>(R, encodeImmBT4BlT1BlxT2_J1J2(Value));", "--    } else {", "--      if (!isInt<22>(Value))", "--        return makeTargetOutOfRangeError(G, B, E);", "--      writeImmediate<Thumb_Call>(R, encodeImmBT4BlT1BlxT2(Value));", "--    }", "--", "--    assert(((R.Lo & FixupInfo<Thumb_Call>::LoBitNoBlx) ||", "--            (R.Lo & FixupInfo<Thumb_Call>::LoBitH) == 0) &&", "--           \"Opcode BLX implies H bit is clear (avoid UB in BLX T2)\");", "--    return Error::success();", "--  }", "--", "--  case Thumb_MovwAbsNC: {", "--    if (!checkOpcode<Thumb_MovwAbsNC>(R))", "--      return makeUnexpectedOpcodeError(G, R, Kind);", "--    uint16_t Value = (TargetAddress + Addend) & 0xffff;", "--    writeImmediate<Thumb_MovwAbsNC>(R, encodeImmMovtT1MovwT3(Value));", "--    return Error::success();", "--  }", "--", "--  case Thumb_MovtAbs: {", "--    if (!checkOpcode<Thumb_MovtAbs>(R))", "--      return makeUnexpectedOpcodeError(G, R, Kind);", "--    uint16_t Value = ((TargetAddress + Addend) >> 16) & 0xffff;", "--    writeImmediate<Thumb_MovtAbs>(R, encodeImmMovtT1MovwT3(Value));", "--    return Error::success();", "--  }", "--", "--  default:", "--    return make_error<JITLinkError>(", "--        \"In graph \" + G.getName() + \", section \" + B.getSection().getName() +", "--        \" encountered unfixable aarch32 edge kind \" +", "--        G.getEdgeKindName(E.getKind()));", "--  }", "--}", "--", "--const uint8_t Thumbv7ABS[] = {", "--    0x40, 0xf2, 0x00, 0x0c, // movw r12, #0x0000    ; lower 16-bit", "--    0xc0, 0xf2, 0x00, 0x0c, // movt r12, #0x0000    ; upper 16-bit", "--    0x60, 0x47              // bx   r12", "--};", "--", "--template <>", "--Symbol &StubsManager<Thumbv7>::createEntry(LinkGraph &G, Symbol &Target) {", "--  constexpr uint64_t Alignment = 4;", "--  Block &B = addStub(G, Thumbv7ABS, Alignment);", "--  LLVM_DEBUG({", "--    const char *StubPtr = B.getContent().data();", "--    HalfWords Reg12 = encodeRegMovtT1MovwT3(12);", "--    assert(checkRegister<Thumb_MovwAbsNC>(StubPtr, Reg12) &&", "--           checkRegister<Thumb_MovtAbs>(StubPtr + 4, Reg12) &&", "--           \"Linker generated stubs may only corrupt register r12 (IP)\");", "--  });", "--  B.addEdge(Thumb_MovwAbsNC, 0, Target, 0);", "--  B.addEdge(Thumb_MovtAbs, 4, Target, 0);", "--  Symbol &Stub = G.addAnonymousSymbol(B, 0, B.getSize(), true, false);", "--  Stub.setTargetFlags(ThumbSymbol);", "--  return Stub;", "--}", "--", "--const char *getEdgeKindName(Edge::Kind K) {", "--#define KIND_NAME_CASE(K)                                                      \\", "--  case K:                                                                      \\", "--    return #K;", "--", "--  switch (K) {", "--    KIND_NAME_CASE(Data_Delta32)", "--    KIND_NAME_CASE(Arm_Call)", "--    KIND_NAME_CASE(Thumb_Call)", "--    KIND_NAME_CASE(Thumb_Jump24)", "--    KIND_NAME_CASE(Thumb_MovwAbsNC)", "--    KIND_NAME_CASE(Thumb_MovtAbs)", "--  default:", "--    return getGenericEdgeKindName(K);", "--  }", "--#undef KIND_NAME_CASE", "--}", "--", "--const char *getCPUArchName(ARMBuildAttrs::CPUArch K) {", "--#define CPUARCH_NAME_CASE(K)                                                   \\", "--  case K:                                                                      \\", "--    return #K;", "--", "--  using namespace ARMBuildAttrs;", "--  switch (K) {", "--    CPUARCH_NAME_CASE(Pre_v4)", "--    CPUARCH_NAME_CASE(v4)", "--    CPUARCH_NAME_CASE(v4T)", "--    CPUARCH_NAME_CASE(v5T)", "--    CPUARCH_NAME_CASE(v5TE)", "--    CPUARCH_NAME_CASE(v5TEJ)", "--    CPUARCH_NAME_CASE(v6)", "--    CPUARCH_NAME_CASE(v6KZ)", "--    CPUARCH_NAME_CASE(v6T2)", "--    CPUARCH_NAME_CASE(v6K)", "--    CPUARCH_NAME_CASE(v7)", "--    CPUARCH_NAME_CASE(v6_M)", "--    CPUARCH_NAME_CASE(v6S_M)", "--    CPUARCH_NAME_CASE(v7E_M)", "--    CPUARCH_NAME_CASE(v8_A)", "--    CPUARCH_NAME_CASE(v8_R)", "--    CPUARCH_NAME_CASE(v8_M_Base)", "--    CPUARCH_NAME_CASE(v8_M_Main)", "--    CPUARCH_NAME_CASE(v8_1_M_Main)", "--    CPUARCH_NAME_CASE(v9_A)", "--  }", "--  llvm_unreachable(\"Missing CPUArch in switch?\");", "--#undef CPUARCH_NAME_CASE", "--}", "--", "--} // namespace aarch32", "--} // namespace jitlink", "--} // namespace llvm", "-diff -ruN --strip-trailing-cr a/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp b/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp", "---- a/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp", "-+++ b/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp", "-@@ -8,7 +8,6 @@", "- ", "- #include \"llvm/ExecutionEngine/Orc/ObjectLinkingLayer.h\"", "- #include \"llvm/ExecutionEngine/JITLink/EHFrameSupport.h\"", "--#include \"llvm/ExecutionEngine/JITLink/aarch32.h\"", "- #include \"llvm/ExecutionEngine/Orc/DebugObjectManagerPlugin.h\"", "- #include \"llvm/ExecutionEngine/Orc/ObjectFileInterface.h\"", "- #include \"llvm/ExecutionEngine/Orc/Shared/ObjectFormats.h\"", "-@@ -41,10 +40,7 @@", "- }", "- ", "- JITTargetAddress getJITSymbolPtrForSymbol(Symbol &Sym) {", "--  uint64_t CallableAddr = Sym.getAddress().getValue();", "--  if (Sym.isCallable() && Sym.hasTargetFlags(aarch32::ThumbSymbol))", "--    CallableAddr |= 0x01; // thumb bit", "--  return CallableAddr;", "-+  return Sym.getAddress().getValue();", "- }", "- ", "- JITSymbolFlags getJITSymbolFlagsForSymbol(Symbol &Sym) {", "-diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp b/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp", "---- a/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp", "-+++ b/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp", "-@@ -1032,13 +1032,13 @@", "-     // latter is so that we can specially handle calls that have identical stack", "-     // id sequences (either due to cloning or artificially because of the MIB", "-     // context pruning).", "--    std::sort(Calls.begin(), Calls.end(),", "--              [](const CallContextInfo &A, const CallContextInfo &B) {", "--                auto &IdsA = std::get<1>(A);", "--                auto &IdsB = std::get<1>(B);", "--                return IdsA.size() > IdsB.size() ||", "--                       (IdsA.size() == IdsB.size() && IdsA < IdsB);", "--              });", "-+    std::stable_sort(Calls.begin(), Calls.end(),", "-+                     [](const CallContextInfo &A, const CallContextInfo &B) {", "-+                       auto &IdsA = std::get<1>(A);", "-+                       auto &IdsB = std::get<1>(B);", "-+                       return IdsA.size() > IdsB.size() ||", "-+                              (IdsA.size() == IdsB.size() && IdsA < IdsB);", "-+                     });", "- ", "-     // Find the node for the last stack id, which should be the same", "-     // across all calls recorded for this id, and is the id for this", "-diff -ruN --strip-trailing-cr a/llvm/test/ExecutionEngine/JITLink/AArch32/ELF_thumbv7_printf.s b/llvm/test/ExecutionEngine/JITLink/AArch32/ELF_thumbv7_printf.s", "---- a/llvm/test/ExecutionEngine/JITLink/AArch32/ELF_thumbv7_printf.s", "-+++ b/llvm/test/ExecutionEngine/JITLink/AArch32/ELF_thumbv7_printf.s", "-@@ -1,46 +0,0 @@", "--// RUN: llvm-mc -triple=thumbv7-none-linux-gnueabi -arm-add-build-attributes -filetype=obj -o %t.o %s", "--// RUN: llvm-jitlink -noexec -slab-address 0x76ff0000 -slab-allocate 10Kb -slab-page-size 4096 -abs printf=0x76bbe880 -show-entry-es %t.o | FileCheck %s", "--", "--// Check that main is a thumb symbol (with LSB set) and printf is arm (with LSB clear)", "--//", "--// CHECK-LABEL: Symbol table:", "--// CHECK-NEXT:    \"main\":   0x{{[0-9a-f]+[13579bdf]}} [Callable] Ready", "--// CHECK-NEXT:    \"printf\": 0x76bbe880 [Data] Ready", "--", "--\t.globl\tmain", "--\t.p2align\t2", "--\t.type\tmain,%function", "--\t.code\t16", "--\t.thumb_func", "--main:", "--\t.fnstart", "--\t.save\t{r7, lr}", "--\tpush\t{r7, lr}", "--\t.setfp\tr7, sp", "--\tmov\tr7, sp", "--\t.pad\t#8", "--\tsub\tsp, #8", "--\tmovs\tr0, #0", "--\tstr\tr0, [sp]", "--\tstr\tr0, [sp, #4]", "--\tldr\tr0, .LCPI0_0", "--.LPC0_0:", "--\tadd\tr0, pc", "--\tbl\tprintf", "--\tldr\tr0, [sp]", "--\tadd\tsp, #8", "--\tpop\t{r7, pc}", "--", "--\t.p2align\t2", "--.LCPI0_0:", "--\t.long\t.L.str-(.LPC0_0+4)", "--", "--\t.size\tmain, .-main", "--\t.cantunwind", "--\t.fnend", "--", "--\t.type\t.L.str,%object", "--\t.section\t.rodata.str1.1,\"aMS\",%progbits,1", "--.L.str:", "--\t.asciz\t\"Hello AArch32!\\n\"", "--\t.size\t.L.str, 12", "-diff -ruN --strip-trailing-cr a/llvm/test/ExecutionEngine/JITLink/AArch32/lit.local.cfg b/llvm/test/ExecutionEngine/JITLink/AArch32/lit.local.cfg", "---- a/llvm/test/ExecutionEngine/JITLink/AArch32/lit.local.cfg", "-+++ b/llvm/test/ExecutionEngine/JITLink/AArch32/lit.local.cfg", "-@@ -1,2 +0,0 @@", "--if not 'ARM' in config.root.targets:", "--  config.unsupported = True", "-diff -ruN --strip-trailing-cr a/llvm/unittests/ExecutionEngine/JITLink/AArch32Tests.cpp b/llvm/unittests/ExecutionEngine/JITLink/AArch32Tests.cpp", "---- a/llvm/unittests/ExecutionEngine/JITLink/AArch32Tests.cpp", "-+++ b/llvm/unittests/ExecutionEngine/JITLink/AArch32Tests.cpp", "-@@ -1,200 +0,0 @@", "--//===------- AArch32Tests.cpp - Unit tests for the AArch32 backend --------===//", "--//", "--// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.", "--// See https://llvm.org/LICENSE.txt for license information.", "--// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception", "--//", "--//===----------------------------------------------------------------------===//", "--", "--#include <llvm/BinaryFormat/ELF.h>", "--#include <llvm/ExecutionEngine/JITLink/aarch32.h>", "--", "--#include \"gtest/gtest.h\"", "--", "--using namespace llvm;", "--using namespace llvm::jitlink;", "--using namespace llvm::jitlink::aarch32;", "--using namespace llvm::support;", "--using namespace llvm::support::endian;", "--", "--struct MutableHalfWords {", "--  MutableHalfWords(HalfWords Preset) : Hi(Preset.Hi), Lo(Preset.Lo) {}", "--", "--  void patch(HalfWords Value, HalfWords Mask) {", "--    Hi = (Hi & ~Mask.Hi) | Value.Hi;", "--    Lo = (Lo & ~Mask.Lo) | Value.Lo;", "--  }", "--", "--  uint16_t Hi; // First halfword", "--  uint16_t Lo; // Second halfword", "--};", "--", "--namespace llvm {", "--namespace jitlink {", "--", "--Expected<aarch32::EdgeKind_aarch32> getJITLinkEdgeKind(uint32_t ELFType);", "--Expected<uint32_t> getELFRelocationType(Edge::Kind Kind);", "--", "--} // namespace jitlink", "--} // namespace llvm", "--", "--TEST(AArch32_ELF, EdgeKinds) {", "--  // Fails: Invalid ELF type -> JITLink kind", "--  Expected<uint32_t> ErrKind = getJITLinkEdgeKind(ELF::R_ARM_NONE);", "--  EXPECT_TRUE(errorToBool(ErrKind.takeError()));", "--", "--  // Fails: Invalid JITLink kind -> ELF type", "--  Expected<uint32_t> ErrType = getELFRelocationType(Edge::Invalid);", "--  EXPECT_TRUE(errorToBool(ErrType.takeError()));", "--", "--  for (Edge::Kind K = FirstDataRelocation; K < LastThumbRelocation; K += 1) {", "--    Expected<uint32_t> ELFType = getELFRelocationType(K);", "--    EXPECT_FALSE(errorToBool(ELFType.takeError()))", "--        << \"Failed to translate JITLink kind -> ELF type\";", "--", "--    Expected<Edge::Kind> JITLinkKind = getJITLinkEdgeKind(*ELFType);", "--    EXPECT_FALSE(errorToBool(JITLinkKind.takeError()))", "--        << \"Failed to translate ELF type -> JITLink kind\";", "--", "--    EXPECT_EQ(*JITLinkKind, K) << \"Round-trip value inconsistent?\";", "--  }", "--}", "--", "--namespace llvm {", "--namespace jitlink {", "--namespace aarch32 {", "--", "--HalfWords encodeImmBT4BlT1BlxT2(int64_t Value);", "--HalfWords encodeImmBT4BlT1BlxT2_J1J2(int64_t Value);", "--HalfWords encodeImmMovtT1MovwT3(uint16_t Value);", "--HalfWords encodeRegMovtT1MovwT3(int64_t Value);", "--", "--int64_t decodeImmBT4BlT1BlxT2(uint32_t Hi, uint32_t Lo);", "--int64_t decodeImmBT4BlT1BlxT2_J1J2(uint32_t Hi, uint32_t Lo);", "--uint16_t decodeImmMovtT1MovwT3(uint32_t Hi, uint32_t Lo);", "--int64_t decodeRegMovtT1MovwT3(uint32_t Hi, uint32_t Lo);", "--", "--} // namespace aarch32", "--} // namespace jitlink", "--} // namespace llvm", "--", "--// Big-endian for v7 and v8 (and v6 unless in legacy backwards compatible mode", "--// be32) have little-endian instructions and big-endian data. In ELF relocatable", "--// objects big-endian instructions may still be encountered. A be8 supporting", "--// linker is expected to endian-reverse instructions for the executable.", "--template <endianness Endian>", "--static HalfWords makeHalfWords(std::array<uint8_t, 4> Mem) {", "--  return HalfWords{read16<Endian>(Mem.data()), read16<Endian>(Mem.data() + 2)};", "--}", "--", "--/// 25-bit branch with link (with J1J2 range extension)", "--TEST(AArch32_Relocations, Thumb_Call_J1J2) {", "--  static_assert(isInt<25>(16777215), \"Max value\");", "--  static_assert(isInt<25>(-16777215), \"Min value\");", "--  static_assert(!isInt<25>(16777217), \"First overflow\");", "--  static_assert(!isInt<25>(-16777217), \"First underflow\");", "--", "--  constexpr HalfWords ImmMask = FixupInfo<Thumb_Call>::ImmMask;", "--", "--  static std::array<HalfWords, 3> MemPresets{", "--      makeHalfWords<little>({0xff, 0xf7, 0xfe, 0xef}), // common", "--      makeHalfWords<little>({0x00, 0x00, 0x00, 0x00}), // zeros", "--      makeHalfWords<little>({0xff, 0xff, 0xff, 0xff}), // ones", "--  };", "--", "--  auto EncodeDecode = [ImmMask](int64_t In, MutableHalfWords &Mem) {", "--    Mem.patch(encodeImmBT4BlT1BlxT2_J1J2(In), ImmMask);", "--    return decodeImmBT4BlT1BlxT2_J1J2(Mem.Hi, Mem.Lo);", "--  };", "--", "--  for (MutableHalfWords Mem : MemPresets) {", "--    HalfWords UnaffectedBits(Mem.Hi & ~ImmMask.Hi, Mem.Lo & ~ImmMask.Lo);", "--", "--    EXPECT_EQ(EncodeDecode(1, Mem), 0);                 // Zero value", "--    EXPECT_EQ(EncodeDecode(0x41, Mem), 0x40);           // Common value", "--    EXPECT_EQ(EncodeDecode(16777215, Mem), 16777214);   // Maximum value", "--    EXPECT_EQ(EncodeDecode(-16777215, Mem), -16777216); // Minimum value", "--    EXPECT_NE(EncodeDecode(16777217, Mem), 16777217);   // First overflow", "--    EXPECT_NE(EncodeDecode(-16777217, Mem), -16777217); // First underflow", "--", "--    EXPECT_TRUE(UnaffectedBits.Hi == (Mem.Hi & ~ImmMask.Hi) &&", "--                UnaffectedBits.Lo == (Mem.Lo & ~ImmMask.Lo))", "--        << \"Diff outside immediate field\";", "--  }", "--}", "--", "--/// 22-bit branch with link (without J1J2 range extension)", "--TEST(AArch32_Relocations, Thumb_Call_Bare) {", "--  static_assert(isInt<22>(2097151), \"Max value\");", "--  static_assert(isInt<22>(-2097151), \"Min value\");", "--  static_assert(!isInt<22>(2097153), \"First overflow\");", "--  static_assert(!isInt<22>(-2097153), \"First underflow\");", "--", "--  constexpr HalfWords ImmMask = FixupInfo<Thumb_Call>::ImmMask;", "--", "--  static std::array<HalfWords, 3> MemPresets{", "--      makeHalfWords<little>({0xff, 0xf7, 0xfe, 0xef}), // common", "--      makeHalfWords<little>({0x00, 0x00, 0x00, 0x00}), // zeros", "--      makeHalfWords<little>({0xff, 0xff, 0xff, 0xff}), // ones", "--  };", "--", "--  auto EncodeDecode = [ImmMask](int64_t In, MutableHalfWords &Mem) {", "--    Mem.patch(encodeImmBT4BlT1BlxT2_J1J2(In), ImmMask);", "--    return decodeImmBT4BlT1BlxT2_J1J2(Mem.Hi, Mem.Lo);", "--  };", "--", "--  for (MutableHalfWords Mem : MemPresets) {", "--    HalfWords UnaffectedBits(Mem.Hi & ~ImmMask.Hi, Mem.Lo & ~ImmMask.Lo);", "--", "--    EXPECT_EQ(EncodeDecode(1, Mem), 0);               // Zero value", "--    EXPECT_EQ(EncodeDecode(0x41, Mem), 0x40);         // Common value", "--    EXPECT_EQ(EncodeDecode(2097151, Mem), 2097150);   // Maximum value", "--    EXPECT_EQ(EncodeDecode(-2097151, Mem), -2097152); // Minimum value", "--    EXPECT_NE(EncodeDecode(2097153, Mem), 2097153);   // First overflow", "--    EXPECT_NE(EncodeDecode(-2097153, Mem), -2097153); // First underflow", "--", "--    EXPECT_TRUE(UnaffectedBits.Hi == (Mem.Hi & ~ImmMask.Hi) &&", "--                UnaffectedBits.Lo == (Mem.Lo & ~ImmMask.Lo))", "--        << \"Diff outside immediate field\";", "--  }", "--}", "--", "--/// Write immediate value to the top halfword of the destination register", "--TEST(AArch32_Relocations, Thumb_MovtAbs) {", "--  static_assert(isUInt<16>(65535), \"Max value\");", "--  static_assert(!isUInt<16>(65536), \"First overflow\");", "--", "--  constexpr HalfWords ImmMask = FixupInfo<Thumb_MovtAbs>::ImmMask;", "--  constexpr HalfWords RegMask = FixupInfo<Thumb_MovtAbs>::RegMask;", "--", "--  static std::array<uint8_t, 3> Registers{0, 5, 12};", "--  static std::array<HalfWords, 3> MemPresets{", "--      makeHalfWords<little>({0xff, 0xf7, 0xfe, 0xef}), // common", "--      makeHalfWords<little>({0x00, 0x00, 0x00, 0x00}), // zeros", "--      makeHalfWords<little>({0xff, 0xff, 0xff, 0xff}), // ones", "--  };", "--", "--  auto EncodeDecode = [ImmMask](uint32_t In, MutableHalfWords &Mem) {", "--    Mem.patch(encodeImmMovtT1MovwT3(In), ImmMask);", "--    return decodeImmMovtT1MovwT3(Mem.Hi, Mem.Lo);", "--  };", "--", "--  for (MutableHalfWords Mem : MemPresets) {", "--    for (uint8_t Reg : Registers) {", "--      HalfWords UnaffectedBits(Mem.Hi & ~(ImmMask.Hi | RegMask.Hi),", "--                               Mem.Lo & ~(ImmMask.Lo | RegMask.Lo));", "--", "--      Mem.patch(encodeRegMovtT1MovwT3(Reg), RegMask);", "--      EXPECT_EQ(EncodeDecode(0x76bb, Mem), 0x76bb);   // Common value", "--      EXPECT_EQ(EncodeDecode(0, Mem), 0);             // Minimum value", "--      EXPECT_EQ(EncodeDecode(0xffff, Mem), 0xffff);   // Maximum value", "--      EXPECT_NE(EncodeDecode(0x10000, Mem), 0x10000); // First overflow", "--", "--      // Destination register as well as unaffacted bits should be intact", "--      EXPECT_EQ(decodeRegMovtT1MovwT3(Mem.Hi, Mem.Lo), Reg);", "--      EXPECT_TRUE(UnaffectedBits.Hi == (Mem.Hi & ~(ImmMask.Hi | RegMask.Hi)) &&", "--                  UnaffectedBits.Lo == (Mem.Lo & ~(ImmMask.Lo | RegMask.Lo)))", "--          << \"Diff outside immediate/register field\";", "--    }", "--  }", "--}", "-diff -ruN --strip-trailing-cr a/llvm/unittests/ExecutionEngine/JITLink/CMakeLists.txt b/llvm/unittests/ExecutionEngine/JITLink/CMakeLists.txt", "---- a/llvm/unittests/ExecutionEngine/JITLink/CMakeLists.txt", "-+++ b/llvm/unittests/ExecutionEngine/JITLink/CMakeLists.txt", "-@@ -8,7 +8,6 @@", "-   )", "- ", "- add_llvm_unittest(JITLinkTests", "--    AArch32Tests.cpp", "-     EHFrameSupportTests.cpp", "-     LinkGraphTests.cpp", "-   )", "+diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/BUILD.bazel b/utils/bazel/llvm-project-overlay/libc/BUILD.bazel", "+--- a/utils/bazel/llvm-project-overlay/libc/BUILD.bazel", "++++ b/utils/bazel/llvm-project-overlay/libc/BUILD.bazel", "+@@ -210,6 +210,7 @@", "+     deps = [", "+         \":__support_cpp_type_traits\",", "+         \":__support_macros_attributes\",", "++        \":__support_macros_properties_architectures\",", "+         \":libc_root\",", "+     ],", "+ )", "@@ -4,8 +4,8 @@ load(\"//third_party:repo.bzl\", \"tf_http_archive\")", " ", " def repo(name):", "     \"\"\"Imports LLVM.\"\"\"", "-    LLVM_COMMIT = \"c640a146c4caa3cca559e308e2e7ecc78c45140d\"", "-    LLVM_SHA256 = \"40f70bdf85c955d609086dee109f600ed1001d79eb9d34d30d7966c58ab63485\"", "+    LLVM_COMMIT = \"410a239996725e68b431e7e3e43e270290be93d2\"", "+    LLVM_SHA256 = \"6b94b2c156d20068120d61d651967777333c566fe2c5770b72eda0c6df447c9a\"", " ", "     tf_http_archive(", "         name = name,", "@@ -21,7 +21,6 @@ def repo(name):", "             \"//third_party/llvm:build.patch\",", "             \"//third_party/llvm:mathextras.patch\",", "             \"//third_party/llvm:toolchains.patch\",", "-            \"//third_party/llvm:affinemap.patch\",", "         ],", "         link_files = {\"//third_party/llvm:run_lit.sh\": \"mlir/run_lit.sh\"},", "     )", "@@ -510,7 +510,7 @@ TEST(TestOpaqueDelegate, PrepareCopyFromFree) {", " ", "   std::unique_ptr<tflite::FlatBufferModel> model =", "       tflite::FlatBufferModel::BuildFromFile(", "-          \"third_party/tensorflow/lite/testdata/add.bin\");", "+          \"tensorflow/lite/testdata/add.bin\");", "   ASSERT_NE(model, nullptr);", "   constexpr int kNumTensorElements = 1 * 8 * 8 * 3;", " ", "@@ -581,7 +581,7 @@ TEST(TestOpaqueDelegate, PrepareCopyFromFree) {", " TEST(TestDelegateKernel, WithoutName) {", "   std::unique_ptr<tflite::FlatBufferModel> model =", "       tflite::FlatBufferModel::BuildFromFile(", "-          \"third_party/tensorflow/lite/testdata/add.bin\");", "+          \"tensorflow/lite/testdata/add.bin\");", "   ASSERT_NE(model, nullptr);", " ", "   tflite::ops::builtin::BuiltinOpResolver resolver;", "@@ -36,7 +36,7 @@ namespace {", " TEST(TestOpaqueDelegate, AddDelegate) {", "   std::unique_ptr<tflite::FlatBufferModel> model =", "       tflite::FlatBufferModel::BuildFromFile(", "-          \"third_party/tensorflow/lite/testdata/add.bin\");", "+          \"tensorflow/lite/testdata/add.bin\");", "   ASSERT_NE(model, nullptr);", " ", "   TfLiteOpaqueDelegateBuilder opaque_delegate_builder{};", "@@ -83,7 +83,7 @@ class TestOpaqueMacros : public ::testing::Test {", "   }", "   void SetUp() override {", "     model_ = tflite::FlatBufferModel::BuildFromFile(", "-        \"third_party/tensorflow/lite/testdata/add.bin\", &reporter_);", "+        \"tensorflow/lite/testdata/add.bin\", &reporter_);", "     ASSERT_NE(model_, nullptr);", "   }", "   void TearDown() override { TfLiteOpaqueDelegateDelete(opaque_delegate_); }", "@@ -111,7 +111,7 @@ TEST_F(TestOpaqueMacros, TF_LITE_OPAQUE_ENSURE_REPORTS) {", "   };", "   EnsureDelegationFails();", "   const std::string txt_regex(", "-      \".*third_party/tensorflow/lite/delegates/\"", "+      \".*tensorflow/lite/delegates/\"", "       \"opaque_delegate_test\\\\.cc.*false was not true.*\");", " #ifndef TF_LITE_STRIP_ERROR_STRINGS", "   EXPECT_THAT(reporter_.error_messages(), ContainsRegex(txt_regex));", "@@ -128,7 +128,7 @@ TEST_F(TestOpaqueMacros, TF_LITE_OPAQUE_ENSURE_SILENT) {", "   };", "   EnsureDelegationSucceeds();", "   const std::string txt_regex(", "-      \".*third_party/tensorflow/lite/delegates/\"", "+      \".*tensorflow/lite/delegates/\"", "       \"opaque_delegate_test\\\\.cc.*was not true.*\");", "   EXPECT_THAT(reporter_.error_messages(), Not(ContainsRegex(txt_regex)));", " }", "@@ -141,7 +141,7 @@ TEST_F(TestOpaqueMacros, TF_LITE_OPAQUE_ENSURE_EQ_REPORTS) {", "   };", "   EnsureDelegationFails();", "   const std::string txt_regex(", "-      \".*third_party/tensorflow/lite/delegates/\"", "+      \".*tensorflow/lite/delegates/\"", "       \"opaque_delegate_test\\\\.cc.*true != false.*\");", " #ifndef TF_LITE_STRIP_ERROR_STRINGS", "   EXPECT_THAT(reporter_.error_messages(), ContainsRegex(txt_regex));", "@@ -158,7 +158,7 @@ TEST_F(TestOpaqueMacros, TF_LITE_OPAQUE_ENSURE_EQ_SILENT) {", "   };", "   EnsureDelegationSucceeds();", "   const std::string txt_regex(", "-      \".*third_party/tensorflow/lite/delegates/\"", "+      \".*tensorflow/lite/delegates/\"", "       \"opaque_delegate_test\\\\.cc.* != *\");", "   EXPECT_THAT(reporter_.error_messages(), Not(ContainsRegex(txt_regex)));", " }", "@@ -171,7 +171,7 @@ TEST_F(TestOpaqueMacros, TF_LITE_OPAQUE_ENSURE_MSG_REPORTS) {", "   };", "   EnsureDelegationFails();", "   const std::string txt_regex(", "-      \".*third_party/tensorflow/lite/delegates/\"", "+      \".*tensorflow/lite/delegates/\"", "       \"opaque_delegate_test\\\\.cc.*custom error msg.*\");", " #ifndef TF_LITE_STRIP_ERROR_STRINGS", "   EXPECT_THAT(reporter_.error_messages(), ContainsRegex(txt_regex));", "@@ -188,7 +188,7 @@ TEST_F(TestOpaqueMacros, TF_LITE_OPAQUE_ENSURE_MSG_SILENT) {", "   };", "   EnsureDelegationSucceeds();", "   const std::string txt_regex(", "-      \".*third_party/tensorflow/lite/delegates/\"", "+      \".*tensorflow/lite/delegates/\"", "       \"opaque_delegate_test\\\\.cc.*\");", "   EXPECT_THAT(reporter_.error_messages(), Not(ContainsRegex(txt_regex)));", " }", "@@ -202,7 +202,7 @@ TEST_F(TestOpaqueMacros, TF_LITE_OPAQUE_ENSURE_TYPES_EQ_REPORTS) {", "   };", "   EnsureDelegationFails();", "   const std::string txt_regex(", "-      \".*third_party/tensorflow/lite/delegates/\"", "+      \".*tensorflow/lite/delegates/\"", "       \"opaque_delegate_test\\\\.cc.*kTfLiteFloat32 != kTfLiteInt32.*\");", " #ifndef TF_LITE_STRIP_ERROR_STRINGS", "   EXPECT_THAT(reporter_.error_messages(), ContainsRegex(txt_regex));", "@@ -220,7 +220,7 @@ TEST_F(TestOpaqueMacros, TF_LITE_OPAQUE_ENSURE_TYPES_EQ_SILENT) {", "   };", "   EnsureDelegationSucceeds();", "   const std::string txt_regex(", "-      \".*third_party/tensorflow/lite/delegates/\"", "+      \".*tensorflow/lite/delegates/\"", "       \"opaque_delegate_test\\\\.cc.*!=.*\");", "   EXPECT_THAT(reporter_.error_messages(), Not(ContainsRegex(txt_regex)));", " }", "@@ -233,7 +233,7 @@ TEST_F(TestOpaqueMacros, TF_LITE_OPAQUE_ENSURE_NEAR_REPORTS) {", "   };", "   EnsureDelegationFails();", "   const std::string txt_regex(", "-      \".*third_party/tensorflow/lite/delegates/\"", "+      \".*tensorflow/lite/delegates/\"", "       \"opaque_delegate_test\\\\.cc.*1 not near 10.*\");", " #ifndef TF_LITE_STRIP_ERROR_STRINGS", "   EXPECT_THAT(reporter_.error_messages(), ContainsRegex(txt_regex));", "@@ -250,7 +250,7 @@ TEST_F(TestOpaqueMacros, TF_LITE_OPAQUE_ENSURE_NEAR_SILENT) {", "   };", "   EnsureDelegationSucceeds();", "   const std::string txt_regex(", "-      \".*third_party/tensorflow/lite/delegates/\"", "+      \".*tensorflow/lite/delegates/\"", "       \"opaque_delegate_test\\\\.cc.*10 not near 10.*\");", "   EXPECT_THAT(reporter_.error_messages(), Not(ContainsRegex(txt_regex)));", " }", "@@ -80,6 +80,7 @@ tf_cc_test(", "     name = \"buffer_map_test\",", "     size = \"small\",", "     srcs = [\"buffer_map_test.cc\"],", "+    tags = [\"no_oss\"],  # TODO(b/275077206): Enable when fixed.", "     deps = [", "         \":buffer_map\",", "         \":buffer_map_util\",", "@@ -75,18 +75,15 @@ cc_test(", "     data = [\":c_api_test_builtin_op_models\"],", "     deps = [", "         \":simple_opaque_delegate\",", "-        \"//tensorflow/lite:kernel_api\",", "+        \"//tensorflow/core/platform:resource_loader\",", "         \"//tensorflow/lite/core/shims:builtin_ops\",", "         \"//tensorflow/lite/core/shims:c_api\",", "         \"//tensorflow/lite/core/shims:c_api_experimental\",", "         \"//tensorflow/lite/core/shims:c_api_types\",", "         \"//tensorflow/lite/core/shims:common\",", "-        \"//tensorflow/lite/core/shims:framework\",", "         \"//tensorflow/lite/delegates:delegate_test_util\",", "         \"//tensorflow/lite/delegates/utils/experimental/sample_stable_delegate\",", "         \"//tensorflow/lite/kernels:kernel_util\",", "-        \"@com_google_absl//absl/container:flat_hash_map\",", "-        \"@com_google_absl//absl/container:flat_hash_set\",", "         \"@com_google_googletest//:gtest_main\",", "     ],", " )", "@@ -20,6 +20,7 @@ limitations under the License.", " #include <vector>", " ", " #include <gtest/gtest.h>", "+#include \"tensorflow/core/platform/resource_loader.h\"", " #include \"tensorflow/lite/core/shims/c/c_api.h\"", " #include \"tensorflow/lite/core/shims/c/c_api_opaque.h\"", " #include \"tensorflow/lite/core/shims/c/c_api_types.h\"", "@@ -44,8 +45,9 @@ TEST_F(TestDelegate, TestDataAddBin_SingleInputSingleOutput_FullyDelegated) {", "   //", "   // Create the model and the interpreter", "   //", "-  TfLiteModel* model =", "-      TfLiteModelCreateFromFile(\"third_party/tensorflow/lite/testdata/add.bin\");", "+  TfLiteModel* model = TfLiteModelCreateFromFile(", "+      tensorflow::GetDataDependencyFilepath(\"tensorflow/lite/testdata/add.bin\")", "+          .c_str());", "   ASSERT_NE(model, nullptr);", "   TfLiteInterpreterOptions* options = TfLiteInterpreterOptionsCreate();", "   ASSERT_NE(options, nullptr);", "@@ -121,8 +123,9 @@ TEST(DelegateTest,", "       TfLiteOpaqueDelegateFactory::Create(", "           std::make_unique<example::SampleStableDelegate>());", " ", "-  TfLiteModel* model =", "-      TfLiteModelCreateFromFile(\"third_party/tensorflow/lite/testdata/add.bin\");", "+  TfLiteModel* model = TfLiteModelCreateFromFile(", "+      tensorflow::GetDataDependencyFilepath(\"tensorflow/lite/testdata/add.bin\")", "+          .c_str());", "   ASSERT_NE(model, nullptr);", " ", "   TfLiteInterpreterOptions* options = TfLiteInterpreterOptionsCreate();", "@@ -198,8 +201,10 @@ TEST(DelegateTest, TestDataMultiAddBin_MultiInputMultiOutput_FullyDelegated) {", "       TfLiteOpaqueDelegateFactory::Create(", "           std::make_unique<example::SampleStableDelegate>());", " ", "-  TfLiteModel* model = TfLiteModelCreateFromFile(", "-      \"third_party/tensorflow/lite/testdata/multi_add.bin\");", "+  TfLiteModel* model =", "+      TfLiteModelCreateFromFile(tensorflow::GetDataDependencyFilepath(", "+                                    \"tensorflow/lite/testdata/multi_add.bin\")", "+                                    .c_str());", "   ASSERT_NE(model, nullptr);", " ", "   TfLiteInterpreterOptions* options = TfLiteInterpreterOptionsCreate();", "@@ -377,23 +382,22 @@ TEST_F(TestDelegate, SetBufferHandle) {", "   // A 'Prepare' callback that blindly replaces the full execution plan.", "   // We do this because all that we are interested is to verify the buffer", "   // handle-related code.", "-  opaque_delegate_builder.Prepare =", "-      [](TfLiteOpaqueContext* opaque_context,", "-         TfLiteOpaqueDelegate* opaque_delegate, void* data) {", "-        auto* simple_opaque_delegate =", "-            reinterpret_cast<SimpleOpaqueDelegateInterface*>(data);", "-        TF_LITE_ENSURE_STATUS(", "-            simple_opaque_delegate->Initialize(opaque_context));", "-        TfLiteIntArray* execution_plan;", "-        TF_LITE_ENSURE_STATUS(TfLiteOpaqueContextGetExecutionPlan(", "-            opaque_context, &execution_plan));", "-        TfLiteRegistrationExternal* delegate_kernel_registration =", "-            CreateDelegateKernelRegistrationImpl(simple_opaque_delegate);", "-", "-        return TfLiteOpaqueContextReplaceNodeSubsetsWithDelegateKernels(", "-            opaque_context, delegate_kernel_registration, execution_plan,", "-            opaque_delegate);", "-      };", "+  opaque_delegate_builder.Prepare = [](TfLiteOpaqueContext* opaque_context,", "+                                       TfLiteOpaqueDelegate* opaque_delegate,", "+                                       void* data) {", "+    auto* simple_opaque_delegate =", "+        reinterpret_cast<SimpleOpaqueDelegateInterface*>(data);", "+    TF_LITE_ENSURE_STATUS(simple_opaque_delegate->Initialize(opaque_context));", "+    TfLiteIntArray* execution_plan;", "+    TF_LITE_ENSURE_STATUS(", "+        TfLiteOpaqueContextGetExecutionPlan(opaque_context, &execution_plan));", "+    TfLiteRegistrationExternal* delegate_kernel_registration =", "+        CreateDelegateKernelRegistrationImpl(simple_opaque_delegate);", "+", "+    return TfLiteOpaqueContextReplaceNodeSubsetsWithDelegateKernels(", "+        opaque_context, delegate_kernel_registration, execution_plan,", "+        opaque_delegate);", "+  };", "   opaque_delegate_builder.flags = kTfLiteDelegateFlagsNone;", "   opaque_delegate_builder.data = &my_simple_delegate;", "   opaque_delegate_builder.CopyFromBufferHandle =", "@@ -406,21 +410,23 @@ TEST_F(TestDelegate, SetBufferHandle) {", "                                                  tensor);", "     return kTfLiteOk;", "   };", "-  opaque_delegate_builder.FreeBufferHandle =", "-      [](TfLiteOpaqueContext* context, TfLiteOpaqueDelegate* delegate,", "-         void* data, TfLiteBufferHandle* handle) {", "-        auto* simple_opaque_delegate =", "-            reinterpret_cast<MySimpleOpaqueDelegateWithBufferHandleSupport*>(", "-                data);", "-        simple_opaque_delegate->FreeBufferHandle(context, delegate, handle);", "-      };", "+  opaque_delegate_builder.FreeBufferHandle = [](TfLiteOpaqueContext* context,", "+                                                TfLiteOpaqueDelegate* delegate,", "+                                                void* data,", "+                                                TfLiteBufferHandle* handle) {", "+    auto* simple_opaque_delegate =", "+        reinterpret_cast<MySimpleOpaqueDelegateWithBufferHandleSupport*>(data);", "+    simple_opaque_delegate->FreeBufferHandle(context, delegate, handle);", "+  };", "   TfLiteDelegate tflite_delegate{};", "   tflite_delegate.opaque_delegate_builder = &opaque_delegate_builder;", " ", "   // Load a model and build an interpreter.", "   std::unique_ptr<tflite::FlatBufferModel> model =", "       tflite::FlatBufferModel::BuildFromFile(", "-          \"third_party/tensorflow/lite/testdata/add.bin\");", "+          tensorflow::GetDataDependencyFilepath(", "+              \"tensorflow/lite/testdata/add.bin\")", "+              .c_str());", "   ASSERT_NE(model, nullptr);", "   tflite::ops::builtin::BuiltinOpResolver resolver;", "   tflite::InterpreterBuilder builder(*model, resolver);", "@@ -490,7 +496,9 @@ TEST(DelegateTest,", "       TfLiteOpaqueDelegateFactory::Create(", "           std::make_unique<example::SampleStableDelegate>());", "   TfLiteModel* model = TfLiteModelCreateFromFile(", "-      \"third_party/tensorflow/lite/testdata/conv_huge_im2col.bin\");", "+      tensorflow::GetDataDependencyFilepath(", "+          \"tensorflow/lite/testdata/conv_huge_im2col.bin\")", "+          .c_str());", "   ASSERT_NE(model, nullptr);", " ", "   TfLiteInterpreterOptions* options = TfLiteInterpreterOptionsCreate();", "@@ -2355,6 +2355,7 @@ cc_test(", " cc_test(", "     name = \"weights_cache_test\",", "     srcs = [\"weights_cache_test.cc\"],", "+    tags = [\"no_oss\"],  # TODO(b/275078251): enable when fixed.", "     deps = [", "         \":conv_2d_tester\",", "         \":test_main\",", "@@ -14,6 +14,8 @@ limitations under the License.", " ==============================================================================*/", " #include \"tensorflow/lite/profiling/subgraph_tensor_profiler.h\"", " ", "+#include <cstring>", "+", " #include \"tensorflow/lite/core/c/common.h\"", " #include \"tensorflow/lite/core/subgraph.h\"", " ", "@@ -415,118 +415,165 @@ struct numeric_limits_float8 {", " template <>", " struct numeric_limits_float8<float8_e4m3fn>", "     : public numeric_limits_float8_base {", "+ private:", "+  static inline constexpr const int kExponentBias = 7;", "+  static inline constexpr const int kMantissaBits = 3;", "+", "+ public:", "   // NOLINTBEGIN: these names must match std::numeric_limits.", "   static inline constexpr const int digits = 4;", "   static inline constexpr const int digits10 = 0;      // floor(3 * log10(2));", "   static inline constexpr const int max_digits10 = 3;  // ceil(4 * log10(2) + 1)", "-  static inline constexpr const int min_exponent = -5;", "+  static inline constexpr const int min_exponent = (1 - kExponentBias) + 1;", "   static inline constexpr const int min_exponent10 = -1;", "-  static inline constexpr const int max_exponent = 9;  // Extended format.", "+  static inline constexpr const int max_exponent =", "+      (0b1111 - 7) + 1;  // Extended format.", "   static inline constexpr const int max_exponent10 = 2;", "   static inline constexpr const bool is_iec559 = false;", "   static inline constexpr const bool has_infinity = false;", "   static inline constexpr const bool has_signaling_NaN = false;", "   // NOLINTEND", " ", "-  static constexpr float8_e4m3fn min() { return float8_e4m3fn::FromRep(0x08); }", "+  // 1.0 * 2^(0b0001 - 7) = 1.0 * 2^-6 = 0.015625", "+  static constexpr float8_e4m3fn min() {", "+    return float8_e4m3fn::FromRep(0b0'0001 << kMantissaBits);", "+  }", "+  // -(1 + 0b110 * 2^-3) * 2^(0b1111 - 7) = -1.75 * 2^8 = 448", "   static constexpr float8_e4m3fn lowest() {", "-    return float8_e4m3fn::FromRep(0xFE);", "+    return float8_e4m3fn::FromRep(0b1'1111'110);", "   }", "-  static constexpr float8_e4m3fn max() { return float8_e4m3fn::FromRep(0x7E); }", "+  // (1 + 0b110 * 2^-3) * 2**(0b1111 - 7) = 1.75 * 2^8 = 448", "+  static constexpr float8_e4m3fn max() {", "+    return float8_e4m3fn::FromRep(0b0'1111'110);", "+  }", "+  // 1.0 * 2^-3 = 0.125", "   static constexpr float8_e4m3fn epsilon() {", "-    return float8_e4m3fn::FromRep(0x20);", "+    return float8_e4m3fn::FromRep((-kMantissaBits + kExponentBias)", "+                                  << kMantissaBits);", "   }", "+  // 1.0 * 2^-1 = 0.5", "   static constexpr float8_e4m3fn round_error() {", "-    return float8_e4m3fn::FromRep(0x30);", "+    return float8_e4m3fn::FromRep((-1 + kExponentBias) << kMantissaBits);", "   }", "   static constexpr float8_e4m3fn infinity() {", "-    return float8_e4m3fn::FromRep(0x7F);", "-  }  // NaN.", "+    return float8_e4m3fn::FromRep(0b0'1111'111);", "+  }", "+  // NaN.", "   static constexpr float8_e4m3fn quiet_NaN() {", "-    return float8_e4m3fn::FromRep(0x7F);", "+    return float8_e4m3fn::FromRep(0b0'1111'111);", "   }", "   static constexpr float8_e4m3fn signaling_NaN() {", "-    return float8_e4m3fn::FromRep(0x7F);", "+    return float8_e4m3fn::FromRep(0b0'1111'111);", "   }", "+  // 1.0 * 2^(-7 - 3 + 1) = 1.0 * 2^-9 = 0.001953125", "   static constexpr float8_e4m3fn denorm_min() {", "-    return float8_e4m3fn::FromRep(0x01);", "+    return float8_e4m3fn::FromRep(0b0'0000'001);", "   }", " };", " ", " template <>", " struct numeric_limits_float8<float8_e4m3b11>", "     : public numeric_limits_float8_base {", "+ private:", "+  static inline constexpr const int kExponentBias = 11;", "+  static inline constexpr const int kMantissaBits = 3;", "+", "+ public:", "   // NOLINTBEGIN: these names must match std::numeric_limits.", "   static inline constexpr const int digits = 4;", "   static inline constexpr const int digits10 = 0;      // floor(3 * log10(2));", "   static inline constexpr const int max_digits10 = 3;  // ceil(4 * log10(2) + 1)", "-  static inline constexpr const int min_exponent = (1 - 11) + 1;", "+  static inline constexpr const int min_exponent = (1 - kExponentBias) + 1;", "   static inline constexpr const int min_exponent10 = -2;", "   static inline constexpr const int max_exponent =", "-      (0b1111 - 11) + 1;  // Extended format.", "+      (0b1111 - kExponentBias) + 1;  // Extended format.", "   static inline constexpr const int max_exponent10 = 1;", "   static inline constexpr const bool is_iec559 = false;", "   static inline constexpr const bool has_infinity = false;", "   static inline constexpr const bool has_signaling_NaN = false;", "   // NOLINTEND", " ", "+  // 1.0 * 2^(0b0001 - 11) = 1.0 * 2^-10 = 0.0009765625", "   static constexpr float8_e4m3b11 min() {", "-    return float8_e4m3b11::FromRep(0x08);", "+    return float8_e4m3b11::FromRep(1 << kMantissaBits);", "   }", "+  // -(1 + 0b111 * 2^-3) * 2^(0b1111 - 11) = -1.875 * 2^4 = -30", "   static constexpr float8_e4m3b11 lowest() {", "-    return float8_e4m3b11::FromRep(0xFF);", "+    return float8_e4m3b11::FromRep(0b1'1111'111);", "   }", "+  // (1 + 0b111 * 2^-3) * 2^(0b1111 - 11) = 1.875 * 2^4 = 30", "   static constexpr float8_e4m3b11 max() {", "-    return float8_e4m3b11::FromRep(0x7F);", "+    return float8_e4m3b11::FromRep(0b0'1111'111);", "   }", "+  // 1.0 * 2^-3 = 0.125", "   static constexpr float8_e4m3b11 epsilon() {", "-    constexpr int kExponentBias = 11;", "-    constexpr int kMantissaBits = 3;", "-    return float8_e4m3b11::FromRep((kExponentBias - kMantissaBits)", "+    return float8_e4m3b11::FromRep((-kMantissaBits + kExponentBias)", "                                    << kMantissaBits);", "   }", "+  // 1.0 * 2^-1 = 0.5", "   static constexpr float8_e4m3b11 round_error() {", "-    constexpr int kExponentBias = 11;", "-    constexpr int kMantissaBits = 3;", "-    return float8_e4m3b11::FromRep((kExponentBias - 1) << kMantissaBits);", "+    return float8_e4m3b11::FromRep((-1 + kExponentBias) << kMantissaBits);", "   }", "   static constexpr float8_e4m3b11 infinity() {", "-    return float8_e4m3b11::FromRep(0x80);", "-  }  // NaN.", "+    return float8_e4m3b11::FromRep(0b1'0000'000);", "+  }", "+  // NaN.", "   static constexpr float8_e4m3b11 quiet_NaN() {", "-    return float8_e4m3b11::FromRep(0x80);", "+    return float8_e4m3b11::FromRep(0b1'0000'000);", "   }", "   static constexpr float8_e4m3b11 signaling_NaN() {", "-    return float8_e4m3b11::FromRep(0x80);", "+    return float8_e4m3b11::FromRep(0b1'0000'000);", "   }", "+  // 1.0 * 2^(-11 - 3 + 1) = 1.0 * 2^-13 = 0.0001220703125", "   static constexpr float8_e4m3b11 denorm_min() {", "-    return float8_e4m3b11::FromRep(0x01);", "+    return float8_e4m3b11::FromRep(0b0'0000'001);", "   }", " };", " ", " template <>", " struct numeric_limits_float8<float8_e5m2> : public numeric_limits_float8_base {", "+ private:", "+  static inline constexpr const int kExponentBias = 15;", "+  static inline constexpr const int kMantissaBits = 2;", "+", "+ public:", "   // NOLINTBEGIN: these names must match std::numeric_limits.", "   static inline constexpr const int digits = 3;", "   static inline constexpr const int digits10 = 0;      // floor(2 * log10(2))", "   static inline constexpr const int max_digits10 = 2;  // ceil(3 * log10(2) + 1)", "-  static inline constexpr const int min_exponent = -13;", "+  static inline constexpr const int min_exponent = (1 - kExponentBias) + 1;", "   static inline constexpr const int min_exponent10 = -4;", "-  static inline constexpr const int max_exponent = 16;", "+  static inline constexpr const int max_exponent = 0b11111 - kExponentBias;", "   static inline constexpr const int max_exponent10 = 4;", "   static inline constexpr const bool is_iec559 = true;", "   static inline constexpr const bool has_infinity = true;", "   static inline constexpr const bool has_signaling_NaN = true;", "   // NOLINTEND", " ", "-  static constexpr float8_e5m2 min() { return float8_e5m2::FromRep(0x04); }", "-  static constexpr float8_e5m2 lowest() { return float8_e5m2::FromRep(0xFB); }", "-  static constexpr float8_e5m2 max() { return float8_e5m2::FromRep(0x7B); }", "-  static constexpr float8_e5m2 epsilon() { return float8_e5m2::FromRep(0x34); }", "+  // 1.0 * 2^(0b00001 - 15) = 1.0 * 2^-14 = 0.00006103515625", "+  static constexpr float8_e5m2 min() {", "+    return float8_e5m2::FromRep(1 << kMantissaBits);", "+  }", "+  // -(1 + 0b11 * 2^-2) * 2^(0b11110 - 15) = -1.75 * 2^15 = -57344", "+  static constexpr float8_e5m2 lowest() {", "+    return float8_e5m2::FromRep(0b1'11110'11);", "+  }", "+  // (1 + 0b11 * 2^-2) * 2^(0b11110 - 15) = 1.75 * 2^15 = 57344", "+  static constexpr float8_e5m2 max() {", "+    return float8_e5m2::FromRep(0b0'11110'11);", "+  }", "+  // 1.0 * 2^-2 = 0.25", "+  static constexpr float8_e5m2 epsilon() {", "+    return float8_e5m2::FromRep((-kMantissaBits + kExponentBias)", "+                                << kMantissaBits);", "+  }", "+  // 1.0 * 2^-1 = 0.5", "   static constexpr float8_e5m2 round_error() {", "-    return float8_e5m2::FromRep(0x38);", "+    return float8_e5m2::FromRep((-1 + kExponentBias) << kMantissaBits);", "+  }", "+  static constexpr float8_e5m2 infinity() {", "+    return float8_e5m2::FromRep(0b0'11111'00);", "   }", "-  static constexpr float8_e5m2 infinity() { return float8_e5m2::FromRep(0x7C); }", "   static constexpr float8_e5m2 quiet_NaN() {", "     // IEEE 754-2019 6.2.1: \"All binary NaN bit strings have the sign bit S set", "     // to 0 or 1 and all the bits of the biased exponent field E set to 1", "@@ -539,8 +586,9 @@ struct numeric_limits_float8<float8_e5m2> : public numeric_limits_float8_base {", "     // the first bit of the trailing significand field being 0.\"", "     return float8_e5m2::FromRep(0b0'11111'01);", "   }", "+  // 1.0 * 2^(-15 - 2 + 1) = 1.0 * 2^-16 = 0.0000152587890625", "   static constexpr float8_e5m2 denorm_min() {", "-    return float8_e5m2::FromRep(0x01);", "+    return float8_e5m2::FromRep(0b0'00000'01);", "   }", " };", " ", "@@ -244,6 +244,34 @@ func.func private @some_func(%arg: tensor<i1>) -> tensor<i32> {", " ", " module attributes {tf_saved_model.semantics} {", " ", "+// Test not hoisting callees in xla launch functions.", "+", "+// CHECK-LABEL: func private @xla_func", "+func.func private @xla_func(%arg0: tensor<1x3xf32>) -> tensor<1x3xf32>", "+  attributes {tf._input_shapes = [#tf_type.shape<1x3>, #tf_type.shape<*>], tf.signature.is_stateful} {", "+  // CHECK-NOT: tf._TfrtGetResource", "+  %0 = \"tf.VarHandleOp\"() {device = \"/device:CPU:0\", container = \"\", shared_name = \"variable\"} : () -> tensor<!tf_type.resource<tensor<1x3xf32>>>", "+  %1 = \"tf.ReadVariableOp\"(%0) {device = \"/device:CPU:0\"} : (tensor<!tf_type.resource<tensor<1x3xf32>>>) -> tensor<1x3xf32>", "+  %2 = \"tf.AddV2\"(%arg0, %1) {device = \"/device:CPU:0\"} : (tensor<1x3xf32>, tensor<1x3xf32>) -> tensor<1x3xf32>", "+  %3 = \"tf.Identity\"(%2) {device = \"/device:CPU:0\"} : (tensor<1x3xf32>) -> tensor<1x3xf32>", "+  func.return %3 : tensor<1x3xf32>", "+}", "+", "+// CHECK-LABEL: func @main", "+func.func @main(%arg0: tensor<1x3xf32> {tf_saved_model.index_path = [\"input\"]}) -> (tensor<*xf32> {tf_saved_model.index_path = [\"r\"]}) ", "+  attributes {tf_saved_model.exported_names = [\"main\"]} {", "+  %0 = \"tf.VarHandleOp\"() {device = \"/device:CPU:0\", container = \"\", shared_name = \"variable\"} : () -> tensor<!tf_type.resource<tensor<1x3xf32>>>", "+  %1 = \"tf.XlaLaunch\"(%arg0, %0) {device = \"/device:GPU:0\", function = @xla_func, operand_segment_sizes = array<i32: 0, 2, 0>} : (tensor<1x3xf32>, tensor<!tf_type.resource<tensor<1x3xf32>>>) -> tensor<*xf32>", "+  func.return  %1 : tensor<*xf32>", "+", "+}", "+", "+}", "+", "+// -----", "+", "+module attributes {tf_saved_model.semantics} {", "+", " // Test not hoisting in TPU functions.", " ", " // CHECK-LABEL: func @_tfrt_resource_init", "@@ -260,4 +288,4 @@ func.func private @func2(%arg: tensor<i1>) -> tensor<i32> {", "   func.return %r : tensor<i32>", " }", " ", "-}", "+}", "\\ No newline at end of file", "@@ -275,24 +275,32 @@ void HoistInvariantOpsInFunction(", "   }", " }", " ", "+void FindCalleesRecursiveForOp(const mlir::SymbolTable &symbol_table,", "+                               mlir::Operation *op,", "+                               llvm::StringSet<> &callees) {", "+  for (const auto &named_attr : op->getAttrs()) {", "+    if (auto symbol_attr =", "+            named_attr.getValue().dyn_cast<mlir::FlatSymbolRefAttr>()) {", "+      auto symbol = symbol_attr.getValue();", "+      if (!callees.contains(symbol)) {", "+        callees.insert(symbol);", "+", "+        auto func = symbol_table.lookup<mlir::func::FuncOp>(symbol);", "+        if (!func) continue;", "+", "+        func.walk([&](mlir::Operation *op) {", "+          FindCalleesRecursiveForOp(symbol_table, op, callees);", "+        });", "+      }", "+    }", "+  }", "+}", "+", " void FindCalleesRecursive(const mlir::SymbolTable &symbol_table,", "                           mlir::func::FuncOp func, llvm::StringSet<> &callees) {", "   assert(func);", "   func.walk([&](mlir::Operation *op) {", "-    for (const auto &named_attr : op->getAttrs()) {", "-      if (auto symbol_attr =", "-              named_attr.getValue().dyn_cast<mlir::FlatSymbolRefAttr>()) {", "-        auto symbol = symbol_attr.getValue();", "-        if (!callees.contains(symbol)) {", "-          callees.insert(symbol);", "-", "-          auto func = symbol_table.lookup<mlir::func::FuncOp>(symbol);", "-          if (!func) continue;", "-", "-          FindCalleesRecursive(symbol_table, func, callees);", "-        }", "-      }", "-    }", "+    FindCalleesRecursiveForOp(symbol_table, op, callees);", "   });", " }", " ", "@@ -307,6 +315,11 @@ void HoistInvariantOps(mlir::ModuleOp module) {", "   // Find all callees referenced in the initialization functions.", "   llvm::StringSet<> init_callees;", " ", "+  // Recursively find all callees referenced in the tf.XlaLaunch op.", "+  // At and after the point of calling this pass, the MLIR xla function is no", "+  // longer used. So there is no point to do hoisting for xla functions.", "+  llvm::StringSet<> xla_launch_callees;", "+", "   module.walk([&](mlir::Operation *op) {", "     if (llvm::isa<mlir::TF::VarHandleOp, mlir::TF::HashTableV2Op>(op)) {", "       auto func = op->getParentOfType<mlir::func::FuncOp>();", "@@ -315,6 +328,11 @@ void HoistInvariantOps(mlir::ModuleOp module) {", "     } else if (auto func = llvm::dyn_cast<mlir::func::FuncOp>(op)) {", "       if (!IsSessionInitializer(func)) return;", "       FindCalleesRecursive(symbol_table, func, init_callees);", "+    } else if (op->getName().getStringRef().str() == \"tf.XlaLaunch\") {", "+      // TODO(b/275095412): Clean up MLIR XLA functions after they are written", "+      // back to function library, so that we don't need to do special handling", "+      // for those functions here.", "+      FindCalleesRecursiveForOp(symbol_table, op, xla_launch_callees);", "     }", "   });", " ", "@@ -352,7 +370,8 @@ void HoistInvariantOps(mlir::ModuleOp module) {", "     // including recursive ones, of an init functions, because otherwise the", "     // hoisted values won't be initialized when this function is called.", "     if (IsSessionInitializer(func) ||", "-        init_callees.contains(func.getSymName()) || func == init_func_op)", "+        init_callees.contains(func.getSymName()) || func == init_func_op ||", "+        xla_launch_callees.contains(func.getSymName()))", "       continue;", " ", "     // Skips hoisting if this function runs on TPU. This is will happen when", "@@ -92,7 +92,8 @@ xla::Status CompileAndPrintLlvmIr(const std::string& hlo_text,", "             llvm_module.get(), cuda_compute_capability, hlo_module->config()));", "     std::cout << ptx << std::endl;", " #else", "-    return {tsl::error::UNIMPLEMENTED, \"Feature not yet implemented in ROCm\"};", "+    return {absl::StatusCode::kUnimplemented,", "+            \"Feature not yet implemented in ROCm\"};", " #endif", "   }", "   return xla::OkStatus();", "@@ -280,14 +280,14 @@ class MklCPUAllocator : public Allocator {", "   }", " ", "   static inline void* CallocHook(size_t num, size_t size) {", "-    Status s = Status(error::Code::UNIMPLEMENTED,", "+    Status s = Status(absl::StatusCode::kUnimplemented,", "                       \"Unimplemented case for hooking MKL function.\");", "     TF_CHECK_OK(s);  // way to assert with an error message", "     return nullptr;  // return a value and make static code analyzers happy", "   }", " ", "   static inline void* ReallocHook(void* ptr, size_t size) {", "-    Status s = Status(error::Code::UNIMPLEMENTED,", "+    Status s = Status(absl::StatusCode::kUnimplemented,", "                       \"Unimplemented case for hooking MKL function.\");", "     TF_CHECK_OK(s);  // way to assert with an error message", "     return nullptr;  // return a value and make static code analyzers happy", "@@ -2407,7 +2407,7 @@ Status MklLayoutRewritePass::SetUpInputs(", "     // TODO(nhasabni): implement this function just for same of completion.", "     // We do not use interleaved ordering right now.", "     return Status(", "-        error::Code::UNIMPLEMENTED,", "+        absl::StatusCode::kUnimplemented,", "         \"Interleaved ordering of tensors is currently not supported.\");", "   } else {", "     CHECK_EQ(kTensorOrdering, MklTfTensorOrdering::TENSORS_CONTIGUOUS);", "@@ -3068,7 +3068,7 @@ Status MklLayoutRewritePass::MergeConv2DWithBiasAdd(std::unique_ptr<Graph>* g,", "   if (data_format_pred != data_format_succ || T_pred != T_succ ||", "       pred->assigned_device_name() != succ->assigned_device_name() ||", "       pred->def().device() != succ->def().device()) {", "-    return Status(error::Code::INVALID_ARGUMENT,", "+    return Status(absl::StatusCode::kInvalidArgument,", "                   \"data_format or T attribute or devices of Conv2D and \"", "                   \"BiasAdd do not match. Will skip node merge optimization\");", "   }", "@@ -3089,7 +3089,7 @@ Status MklLayoutRewritePass::MergeConv2DWithBiasAdd(std::unique_ptr<Graph>* g,", "   const int kFirstOutputSlot = 0;", "   for (const Edge* e : pred->out_edges()) {", "     if (e->src_output() == kFirstOutputSlot && e->dst() != succ) {", "-      return Status(error::Code::INVALID_ARGUMENT,", "+      return Status(absl::StatusCode::kInvalidArgument,", "                     \"Conv2D does not feed to BiasAdd, or \"", "                     \"it feeds BiasAdd but has multiple outputs. \"", "                     \"Will skip node merge optimization\");", "@@ -3229,7 +3229,7 @@ Status MklLayoutRewritePass::MergePadWithConv2D(std::unique_ptr<Graph>* g,", "   if (T_pred != T_succ ||", "       pred->assigned_device_name() != succ->assigned_device_name() ||", "       pred->def().device() != succ->def().device()) {", "-    return Status(error::Code::INVALID_ARGUMENT,", "+    return Status(absl::StatusCode::kInvalidArgument,", "                   \"T attribute or devices of Conv2D and \"", "                   \"Pad do not match. Will skip node merge optimization\");", "   }", "@@ -3250,7 +3250,7 @@ Status MklLayoutRewritePass::MergePadWithConv2D(std::unique_ptr<Graph>* g,", "   const int kFirstOutputSlot = 0;", "   for (const Edge* e : pred->out_edges()) {", "     if (e->src_output() == kFirstOutputSlot && e->dst() != succ) {", "-      return Status(error::Code::INVALID_ARGUMENT,", "+      return Status(absl::StatusCode::kInvalidArgument,", "                     \"Pad does not feed to Conv2D, or \"", "                     \"it feeds Conv2D but has multiple outputs. \"", "                     \"Will skip node merge optimization\");", "@@ -3398,7 +3398,7 @@ Status MklLayoutRewritePass::MergeConv2DBackpropFilterWithBiasAddGrad(", "   if (data_format_b != data_format_f || T_b != T_f ||", "       badd->assigned_device_name() != fltr->assigned_device_name() ||", "       badd->def().device() != fltr->def().device()) {", "-    return Status(error::Code::INVALID_ARGUMENT,", "+    return Status(absl::StatusCode::kInvalidArgument,", "                   \"data_format or T attribute or devices of \"", "                   \"Conv2DBackpropFilter and BiasAddGrad do not match. \"", "                   \"Will skip node merge optimization\");", "@@ -3537,7 +3537,7 @@ Status MklLayoutRewritePass::MergeNode(std::unique_ptr<Graph>* g, Node* m,", "     return this->MergeConv2DBackpropFilterWithBiasAddGrad(g, m, n);", "   }", " ", "-  return Status(error::Code::UNIMPLEMENTED,", "+  return Status(absl::StatusCode::kUnimplemented,", "                 \"Unimplemented case for node merge optimization.\");", " }", " ", "@@ -3734,7 +3734,7 @@ Status MklLayoutRewritePass::RewriteNode(std::unique_ptr<Graph>* g,", "   } else if (ri->rewrite_cause == kRewriteForOpNameChange) {", "     ret_status = RewriteNodeForJustOpNameChange(g, orig_node, &new_node, ri);", "   } else {", "-    ret_status = Status(error::Code::INVALID_ARGUMENT,", "+    ret_status = Status(absl::StatusCode::kInvalidArgument,", "                         \"Unsupported rewrite cause found.\"", "                         \"RewriteNode will fail.\");", "   }", "@@ -1068,7 +1068,7 @@ Status ZenLayoutRewritePass::AreAllInferenceOps(std::unique_ptr<Graph> *g) {", "     for (auto op = tf_training_ops_.cbegin(); op != tf_training_ops_.cend();", "          ++op) {", "       if (n->type_string().find(*op) != string::npos) {", "-        return Status(error::Code::UNIMPLEMENTED,", "+        return Status(absl::StatusCode::kUnimplemented,", "                       \"Training operation found! Currently TF-ZenDNN \"", "                       \"does not support training. Set environment \"", "                       \"variable TF_ENABLE_ZENDNN_OPTS to '0' for training.\");", "@@ -710,7 +710,8 @@ CostGraphDef* OwnedProtoRunGraphResponse::mutable_cost_graph() {", " }", " ", " Status OwnedProtoRunGraphResponse::status() const {", "-  return Status(response_.status_code(), response_.status_error_message());", "+  return Status(static_cast<absl::StatusCode>(response_.status_code()),", "+                response_.status_error_message());", " }", " ", " absl::StatusCode OwnedProtoRunGraphResponse::status_code() const {", "@@ -785,7 +786,8 @@ CostGraphDef* NonOwnedProtoRunGraphResponse::mutable_cost_graph() {", " }", " ", " Status NonOwnedProtoRunGraphResponse::status() const {", "-  return Status(response_->status_code(), response_->status_error_message());", "+  return Status(static_cast<absl::StatusCode>(response_->status_code()),", "+                response_->status_error_message());", " }", " ", " absl::StatusCode NonOwnedProtoRunGraphResponse::status_code() const {", "@@ -900,7 +902,8 @@ RunMetadata* OwnedProtoRunStepResponse::mutable_metadata() {", " }", " ", " Status OwnedProtoRunStepResponse::status() const {", "-  return Status(response_.status_code(), response_.status_error_message());", "+  return Status(static_cast<absl::StatusCode>(response_.status_code()),", "+                response_.status_error_message());", " }", " ", " absl::StatusCode OwnedProtoRunStepResponse::status_code() const {", "@@ -956,7 +959,8 @@ RunMetadata* NonOwnedProtoRunStepResponse::mutable_metadata() {", " }", " ", " Status NonOwnedProtoRunStepResponse::status() const {", "-  return Status(response_->status_code(), response_->status_error_message());", "+  return Status(static_cast<absl::StatusCode>(response_->status_code()),", "+                response_->status_error_message());", " }", " ", " absl::StatusCode NonOwnedProtoRunStepResponse::status_code() const {", "@@ -708,7 +708,7 @@ class MklConcatOp : public OpKernel {", "           // When memory::format_tag::nc, dst_dims are already in oneDNN order", "           dst_md = memory::desc(dst_dims, MklDnnType<T>(), mkl_common_format);", "         } else {", "-          TF_CHECK_OK(Status(error::Code::FAILED_PRECONDITION,", "+          TF_CHECK_OK(Status(absl::StatusCode::kFailedPrecondition,", "                              \"Unsupported tensor dimension or\"", "                              \"oneDNN memory format\"));", "         }", "@@ -2087,7 +2087,7 @@ class MklQuantizedConvOp", "                                                         output_tensor);", "       const Tensor& summand = context->input(this->get_input_add_idx());", "       if (summand.dtype() != DT_FLOAT)", "-        TF_CHECK_OK(Status(error::Code::FAILED_PRECONDITION,", "+        TF_CHECK_OK(Status(absl::StatusCode::kFailedPrecondition,", "                            \"Current fusion requires summand to be float\"));", "       // We need to compute scale for the summand", "       const float min_input =", "@@ -653,7 +653,7 @@ inline Status ConvertMklToTF(OpKernelContext* context,", "       bool status = input.CheckReorderToOpMem(output_tf_md, output_tf_tensor,", "                                               net, net_args, cpu_engine);", "       if (!status) {", "-        return Status(error::Code::INTERNAL,", "+        return Status(absl::StatusCode::kInternal,", "                       \"ConvertMklToTF(): Failed to create reorder for input\");", "       }", "       ExecutePrimitive(net, &net_args, cpu_engine, context);", "@@ -663,7 +663,7 @@ inline Status ConvertMklToTF(OpKernelContext* context,", "           output_tf_tensor->CopyFrom(input_mkl_tensor, output_tf_shape);", "       if (!status) {", "         return Status(", "-            error::Code::INTERNAL,", "+            absl::StatusCode::kInternal,", "             \"ConvertMklToTF(): Failed to forward input tensor to output\");", "       }", "     }", "@@ -1061,7 +1061,8 @@ inline memory::format_tag MklTensorFormatToMklDnnDataFormat(", " inline MklTensorFormat TFDataFormatToMklDnn3DDataFormat(TensorFormat format) {", "   if (format == FORMAT_NHWC) return MklTensorFormat::FORMAT_NDHWC;", "   if (format == FORMAT_NCHW) return MklTensorFormat::FORMAT_NCDHW;", "-  TF_CHECK_OK(Status(error::Code::INVALID_ARGUMENT, \"Unsupported data format\"));", "+  TF_CHECK_OK(", "+      Status(absl::StatusCode::kInvalidArgument, \"Unsupported data format\"));", "   return MklTensorFormat::FORMAT_INVALID;", " }", " ", "@@ -1073,7 +1074,8 @@ inline MklTensorFormat TFDataFormatToMklDnn3DDataFormat(TensorFormat format) {", " inline MklTensorFormat TFDataFormatToMklDnnDataFormat(TensorFormat format) {", "   if (format == FORMAT_NHWC) return MklTensorFormat::FORMAT_NHWC;", "   if (format == FORMAT_NCHW) return MklTensorFormat::FORMAT_NCHW;", "-  TF_CHECK_OK(Status(error::Code::INVALID_ARGUMENT, \"Unsupported data format\"));", "+  TF_CHECK_OK(", "+      Status(absl::StatusCode::kInvalidArgument, \"Unsupported data format\"));", "   return MklTensorFormat::FORMAT_INVALID;", " }", " ", "@@ -1089,7 +1091,8 @@ inline TensorFormat MklDnnDataFormatToTFDataFormat(MklTensorFormat format) {", "   if (format == MklTensorFormat::FORMAT_NCHW ||", "       format == MklTensorFormat::FORMAT_NCDHW)", "     return FORMAT_NCHW;", "-  TF_CHECK_OK(Status(error::Code::INVALID_ARGUMENT, \"Unsupported data format\"));", "+  TF_CHECK_OK(", "+      Status(absl::StatusCode::kInvalidArgument, \"Unsupported data format\"));", " ", "   // Return to prevent compiler warnings, otherwise TF_CHECK_OK will ensure", "   // that we don't come here.", "@@ -1255,7 +1258,7 @@ inline Status CreateBlockedMemDescHelper(const memory::dims& dim,", "   } catch (dnnl::error& e) {", "     delete[] input_dims;", "     delete[] input_strides;", "-    return Status(error::Code::INTERNAL,", "+    return Status(absl::StatusCode::kInternal,", "                   tensorflow::strings::StrCat(", "                       \"Failed to create blocked memory descriptor.\",", "                       \"Status: \", e.status, \", message: \", e.message));", "@@ -163,7 +163,7 @@ void CoordinationServiceRpcHandler::ReportErrorToServiceAsync(", "   done(service_->ReportTaskError(", "       request->error_origin(),", "       MakeCoordinationError(", "-          Status{static_cast<error::Code>(request->error_code()),", "+          Status{static_cast<absl::StatusCode>(request->error_code()),", "                  request->error_message()},", "           request->error_origin(),", "           /*is_reported_error=*/true)));", "@@ -37,7 +37,7 @@ Status TryDlopenCUDALibraries() {", "       !cufft_status.status().ok() || !curand_status.status().ok() ||", "       !cusolver_status.status().ok() || !cusparse_status.status().ok() ||", "       !cudnn_status.status().ok() || !cublaslt_status.status().ok()) {", "-    return Status(error::INTERNAL,", "+    return Status(absl::StatusCode::kInternal,", "                   absl::StrCat(\"Cannot dlopen all CUDA libraries.\"));", "   } else {", "     return tsl::OkStatus();", "@@ -51,7 +51,7 @@ Status TryDlopenROCmLibraries() {", "   auto rocrand_status = GetRocrandDsoHandle();", "   if (!rocblas_status.status().ok() || !miopen_status.status().ok() ||", "       !rocfft_status.status().ok() || !rocrand_status.status().ok()) {", "-    return Status(error::INTERNAL,", "+    return Status(absl::StatusCode::kInternal,", "                   absl::StrCat(\"Cannot dlopen all ROCm libraries.\"));", "   } else {", "     return tsl::OkStatus();", "@@ -73,7 +73,7 @@ Status TryDlopenTensorRTLibraries() {", "   auto nvinfer_status = GetNvInferDsoHandle();", "   auto nvinferplugin_status = GetNvInferPluginDsoHandle();", "   if (!nvinfer_status.status().ok() || !nvinferplugin_status.status().ok()) {", "-    return Status(error::INTERNAL,", "+    return Status(absl::StatusCode::kInternal,", "                   absl::StrCat(\"Cannot dlopen all TensorRT libraries.\"));", "   } else {", "     return tsl::OkStatus();", "@@ -65,7 +65,7 @@ StatusOr<void*> GetDsoHandle(const string& name, const string& version) {", "   }", " #endif", "   VLOG(1) << message;", "-  return Status(error::FAILED_PRECONDITION, message);", "+  return Status(absl::StatusCode::kFailedPrecondition, message);", " }", " }  // namespace", " ", "@@ -195,17 +195,6 @@ void Status::MaybeAddSourceLocation(SourceLocation loc) {", "   state_->source_locations.push_back(loc);", " }", " ", "-Status::Status(tsl::error::Code code, absl::string_view msg,", "-               SourceLocation loc) {", "-  assert(code != absl::StatusCode::kOk);", "-  state_ = std::make_unique<State>();", "-  state_->code = static_cast<absl::StatusCode>(code);", "-  state_->msg = std::string(msg);", "-  MaybeAddSourceLocation(loc);", "-  VLOG(5) << \"Generated non-OK status: \\\"\" << *this << \"\\\". \"", "-          << CurrentStackTrace();", "-}", "-", " Status::Status(absl::StatusCode code, absl::string_view msg,", "                SourceLocation loc) {", "   assert(code != absl::StatusCode::kOk);", "@@ -104,14 +104,6 @@ class Status {", "   /// human-readable string containing more detailed information.", "   Status(absl::StatusCode code, absl::string_view msg,", "          SourceLocation loc = SourceLocation::current());", "-  // Deprecated constructor using the Tensorflow protobuf enum error code.", "-#ifndef SWIG", "-  ABSL_DEPRECATED(", "-      \"Use `Status(absl::StatusCode, ...) instead of Status(tsl::errors::Code, \"", "-      \"...).\")", "-#endif", "-  Status(tsl::error::Code code, absl::string_view msg,", "-         SourceLocation loc = SourceLocation::current());", " ", "   /// Copy the specified status.", "   Status(const Status& s);", "@@ -139,7 +139,8 @@ class WindowsRandomAccessFile : public RandomAccessFile {", "         dst += r;", "         n -= r;", "       } else if (r == 0) {", "-        s = Status(error::OUT_OF_RANGE, \"Read fewer bytes than requested\");", "+        s = Status(absl::StatusCode::kOutOfRange,", "+                   \"Read fewer bytes than requested\");", "       } else if (errno == EINTR || errno == EAGAIN) {", "         // Retry", "       } else {", "@@ -647,7 +648,7 @@ Status WindowsFileSystem::IsDirectory(const string& fname,", "   if (PathIsDirectoryW(ws_final_fname.c_str())) {", "     return OkStatus();", "   }", "-  return Status(tsl::error::FAILED_PRECONDITION, \"Not a directory\");", "+  return Status(absl::StatusCode::kFailedPrecondition, \"Not a directory\");", " }", " ", " Status WindowsFileSystem::RenameFile(const string& src, const string& target,", "@@ -517,7 +517,7 @@ DotFusionAnalysis::DotFusionAnalysis(const HloInstruction* root) {", "         DimensionOrder::FromDotOperand(*root, operand_number);", "     while (parameter->opcode() != HloOpcode::kParameter) {", "       CHECK_EQ(parameter->operand_count(), 1);", "-      dim_order.HandleInstruction(parameter).ok();", "+      dim_order.HandleInstruction(parameter).IgnoreError();", "       TF_CHECK_OK(RequireTritonGemmSupportedDimOrder(dim_order));", "       parameter = parameter->operand(0);", "     }", "@@ -166,6 +166,7 @@ cc_test(", "         \"nnapi_delegate_test.cc\",", "     ],", "     tags = [", "+        \"no_oss\",  # TODO(b/273558651): Enable after updating flatbuffer version.", "         \"no_windows\",", "         \"tflite_not_portable_ios\",", "     ],", "@@ -2193,7 +2193,10 @@ cc_test(", "     name = \"squeeze_test\",", "     size = \"small\",", "     srcs = [\"squeeze_test.cc\"],", "-    tags = [\"tflite_nnapi\"],", "+    tags = [", "+        \"no_oss\",  # TODO(b/273558651): Enable after updating flatbuffer version.", "+        \"tflite_nnapi\",", "+    ],", "     deps = [", "         \":test_main\",", "         \":test_util\",", "@@ -148,6 +148,9 @@ tf_cc_test(", "     srcs = [", "         \"import_test.cc\",", "     ],", "+    tags = [", "+        \"no_oss\",  # TODO(b/273558651): Enable after updating flatbuffer version.", "+    ],", "     deps = [", "         \":import\",", "         \"//tensorflow/core:ops\",", "@@ -147,6 +147,30 @@ struct GemmOpCapture : public OpCapturePattern {", "   }", " };", " ", "+struct MemrefOpCapture : public OpCapturePattern {", "+  FailureOr<OpCapturePattern::Capture> match(Operation* op) final {", "+    if (auto memcpy = llvm::dyn_cast<mlir::gpu::MemcpyOp>(op)) {", "+      // We use a heuristic to identify the direction of the memcpy operation,", "+      // if the operand was allocated by alloca op or is a global memref, then", "+      // it must be a memref on the host.", "+      auto IsHostMemRef = [](Value value) {", "+        auto* op = value.getDefiningOp();", "+        return llvm::isa_and_nonnull<memref::AllocaOp, memref::GetGlobalOp>(op);", "+      };", "+", "+      auto IsDeviceToDevice = [&](mlir::gpu::MemcpyOp op) {", "+        return !IsHostMemRef(op.getDst()) && !IsHostMemRef(op.getSrc());", "+      };", "+", "+      // Device-to-host Memcpy cannot be captured by CUDA graphs.", "+      if (IsDeviceToDevice(memcpy)) {", "+        return kMove;", "+      }", "+    }", "+    return failure();", "+  }", "+};", "+", " // Capture pure operations by cloning them into graph capture function.", " struct ConstantOpCapture : public CloneOp<arith::ConstantOp> {};", " struct ViewOpCapture : public CloneOp<memref::ViewOp> {};", "@@ -389,6 +413,7 @@ void OutlineCudaGraphsPass::runOnOperation() {", "   patterns.emplace_back(new ConstantOpCapture());", "   patterns.emplace_back(new GemmOpCapture());", "   patterns.emplace_back(new ViewOpCapture());", "+  patterns.emplace_back(new MemrefOpCapture());", " ", "   unsigned ordinal = 1;  // entry point will be exported with ordinal 0", "   for (auto& seq : CollectCaptureSequences(getAnalysis<DominanceInfo>(),", "@@ -508,3 +508,30 @@ module attributes {gpu.container_module} {", " // CHECK-NEXT: lmhlo_gpu.conv_forward", " // CHECK-NEXT: gpu.launch_func @gpu_module::@fn0", " // CHECK-NEXT: return", "+", "+// -----", "+// Check that d2d memcpy are captured.", "+", "+module attributes {gpu.container_module} {", "+", "+  // CHECK: @func(%[[ARG0:.*]]: memref<100xi8>)", "+  func.func @func(%arg0: memref<100xi8>) {", "+    %c0 = arith.constant 0 : index", "+    %dst = memref.view %arg0[%c0][] : memref<100xi8> to memref<10xf32>", "+    %src = memref.view %arg0[%c0][] : memref<100xi8> to memref<10xf32>", "+", "+    // CHECK: call @xla.gpu.cuda.graph.launch(%[[ARG0]])", "+    // CHECK-SAME: {capture = @xla.gpu.cuda.graph.capture}", "+    gpu.memcpy %dst, %src : memref<10xf32>, memref<10xf32>", "+    gpu.memcpy %dst, %src : memref<10xf32>, memref<10xf32>", "+", "+    // CHECK: return", "+    return", "+  }", "+  func.func private @external()", "+}", "+", "+// CHECK: func @xla.gpu.cuda.graph.capture", "+// CHECK: gpu.memcpy", "+// CHECK: gpu.memcpy", "+// CHECK-NEXT: return", "@@ -33,7 +33,9 @@ limitations under the License.", " #include \"absl/strings/str_format.h\"", " #include \"absl/synchronization/mutex.h\"", " #include \"absl/synchronization/notification.h\"", "+#include \"third_party/gpus/cuda/include/cuda.h\"", " #include \"third_party/gpus/cuda/include/cuda_runtime_api.h\"", "+#include \"third_party/gpus/cuda/include/driver_types.h\"", " #include \"tensorflow/compiler/xla/stream_executor/cuda/cuda_diagnostics.h\"", " #include \"tensorflow/compiler/xla/stream_executor/platform/logging.h\"", " #include \"tensorflow/compiler/xla/stream_executor/platform/port.h\"", "@@ -1196,9 +1198,40 @@ GpuDriver::CreateMemoryHandle(GpuContext* context, uint64_t bytes) {", "                                                    CUstream stream) {", "   ScopedActivateContext activation(context);", "   CUresult result;", "-  // CreatedContexts::GetAnyContext() doesn't works when ptr == 0.", "-  // This happens when the size is 0.", "+", "+  // Check if the stream is doing graph capture.", "+  cudaStreamCaptureStatus stream_capture_status;", "+  cudaError_t err =", "+      cudaStreamGetCaptureInfo(stream, &stream_capture_status, /*pId=*/nullptr);", "+  if (err != cudaSuccess) {", "+    LOG(ERROR) << \"Failed to get stream capture info: \"", "+               << cudaGetErrorString(err);", "+    return false;", "+  }", "+", "   if (gpu_dst == 0 || gpu_src == 0) {", "+    // CreatedContexts::GetAnyContext() doesn't works when ptr == 0.", "+    // This happens when the size is 0.", "+    result = cuMemcpyDtoDAsync(gpu_dst, gpu_src, size, stream);", "+  } else if (stream_capture_status == cudaStreamCaptureStatusActive) {", "+    // cuMemcpyPeerAsync is not supported during graph capture, so we use", "+    // cuMemcpyDtoDAsync instead. This is only valid if UVA is supported.", "+", "+    // Check if UVA is enabled.", "+    for (int i = 0; i < GetDeviceCount(); ++i) {", "+      GpuDeviceAttribute attribute = CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING;", "+      auto result = GetDeviceAttribute(attribute, i);", "+      if (!result.ok()) {", "+        LOG(ERROR) << \"Failed to get device attribute\";", "+        return false;", "+      }", "+", "+      if (result.value() == 0) {", "+        LOG(ERROR) << \"Unified addressing is not enabled\";", "+        return false;", "+      }", "+    }", "+", "     result = cuMemcpyDtoDAsync(gpu_dst, gpu_src, size, stream);", "   } else {", "     // Any context work here.", "@@ -16,6 +16,7 @@ limitations under the License.", " ", " #include <unordered_map>", " ", "+#include \"tensorflow/core/activity_watcher/activity.h\"", " #include \"tensorflow/core/framework/dataset.pb.h\"", " #include \"tensorflow/core/framework/device_base.h\"", " #include \"tensorflow/core/framework/function.h\"", "@@ -946,6 +947,13 @@ string DatasetBaseIterator::BuildTraceMeName() {", " Status DatasetBaseIterator::GetNext(IteratorContext* ctx,", "                                     std::vector<Tensor>* out_tensors,", "                                     bool* end_of_sequence) {", "+  activity_watcher::ActivityScope activity_scope([&]() {", "+    activity_watcher::Activity::Attributes attributes;", "+    attributes[\"iterator_prefix\"] = prefix();", "+    return std::make_unique<activity_watcher::Activity>(", "+        \"Iterator::GetNext\", activity_watcher::ActivityCategory::kDatasetOp,", "+        std::move(attributes));", "+  });", "   profiler::TraceMe activity([&] { return BuildTraceMeName(); },", "                              profiler::TraceMeLevel::kInfo);", "   DVLOG(3) << prefix() << \" GetNext enter\";", "@@ -57,6 +57,7 @@ cc_library(", " # When using mlir based HloLowering, the following utils will sometimes be needed to define used symbols.", " cc_library(", "     name = \"runtime_mlir_utils\",", "+    visibility = [\"//visibility:public\"],", "     deps = [", "         \"@llvm-project//mlir:mlir_c_runner_utils\",", "     ],", "@@ -394,7 +394,11 @@ TfLiteStatus Interpreter::ModifyGraphWithDelegateImpl(", "     TfLiteDelegate* delegate) {", "   TfLiteStatus status = kTfLiteOk;", "   for (auto& subgraph : subgraphs_) {", "-    if (IsValidationSubgraph(subgraph->GetName().c_str())) {", "+    if (IsValidationSubgraph(subgraph->GetName().c_str()) ||", "+        subgraph->IsDelegationSkippable()) {", "+      TFLITE_LOG(TFLITE_LOG_INFO,", "+                 \"Skipping calling ModifyGraphWithDelegate on Subgraph %i: %s\",", "+                 subgraph->GetSubgraphIndex(), subgraph->GetName().c_str());", "       continue;", "     }", "     status = subgraph->ModifyGraphWithDelegate(delegate);", "@@ -3,8 +3,13 @@", " ", " load(\"//tensorflow/core/platform:rules_cc.bzl\", \"cc_library\")", " load(\"//tensorflow:tensorflow.bzl\", \"tf_cc_test\")", "-load(\"@llvm-project//mlir:tblgen.bzl\", \"gentbl_cc_library\")", "-load(\"//tensorflow:tensorflow.default.bzl\", \"get_compatible_with_cloud\")", "+", "+package_group(", "+    name = \"tensorflow_mlir_tf2xla\",", "+    packages = [", "+        \"//tensorflow/compiler/mlir/tf2xla/...\",", "+    ],", "+)", " ", " package(", "     # copybara:uncomment default_applicable_licenses = [\"//tensorflow:license\"],", "@@ -48,9 +53,9 @@ cc_library(", "         \"//tensorflow/compiler/mlir/tensorflow:translate_utils\",", "         \"//tensorflow/compiler/mlir/tf2xla:mlir_bridge_rollout_policy\",", "         \"//tensorflow/compiler/mlir/tf2xla:tf_xla_passes\",", "-        \"//tensorflow/compiler/mlir/tf2xla:xla_legalize_targets\",", "         \"//tensorflow/compiler/mlir/tf2xla:xla_legalize_tf\",", "         \"//tensorflow/compiler/mlir/tf2xla:xla_legalize_tf_with_tf2xla\",", "+        \"//tensorflow/compiler/mlir/tf2xla/transforms:xla_legalize_targets\",", "         \"//tensorflow/compiler/tf2xla:common\",", "         \"//tensorflow/compiler/tf2xla:layout_util\",", "         \"//tensorflow/compiler/tf2xla:xla_argument\",", "@@ -110,428 +115,20 @@ alias(", "     actual = \":compile_mlir_util_no_tf_dialect_passes\",", " )", " ", "-gentbl_cc_library(", "-    name = \"legalize_tf_patterns_inc_gen\",", "-    compatible_with = get_compatible_with_cloud(),", "-    tbl_outs = [", "-        (", "-            [\"-gen-rewriters\"],", "-            \"transforms/generated_legalize_tf.inc\",", "-        ),", "-    ],", "-    tblgen = \"@llvm-project//mlir:mlir-tblgen\",", "-    td_file = \"transforms/legalize_tf_patterns.td\",", "-    deps = [", "-        \"//tensorflow/compiler/mlir/tensorflow:tensorflow_ops_td_files\",", "-        \"//tensorflow/compiler/xla/mlir_hlo:hlo_ops_td_files\",", "-        \"@llvm-project//llvm:Support\",", "-        \"@llvm-project//mlir:FuncTdFiles\",", "-        \"@llvm-project//mlir:TensorOpsTdFiles\",", "-    ],", "-)", "-", "-gentbl_cc_library(", "-    name = \"xla_legalize_tf_passes_inc_gen\",", "-    compatible_with = get_compatible_with_cloud(),", "-    tbl_outs = [", "-        (", "-            [", "-                \"-gen-pass-decls\",", "-                \"-name=LegalizeTf\",", "-            ],", "-            \"transforms/xla_legalize_tf_passes.h.inc\",", "-        ),", "-    ],", "-    tblgen = \"@llvm-project//mlir:mlir-tblgen\",", "-    td_file = \"transforms/xla_legalize_tf_passes.td\",", "-    deps = [", "-        \"@llvm-project//mlir:PassBaseTdFiles\",", "-    ],", "-)", "-", "-gentbl_cc_library(", "-    name = \"tf_xla_passes_inc_gen\",", "-    compatible_with = get_compatible_with_cloud(),", "-    tbl_outs = [", "-        (", "-            [", "-                \"-gen-pass-decls\",", "-                \"-name=TfXla\",", "-            ],", "-            \"transforms/tf_xla_passes.h.inc\",", "-        ),", "-    ],", "-    tblgen = \"@llvm-project//mlir:mlir-tblgen\",", "-    td_file = \"transforms/tf_xla_passes.td\",", "-    deps = [", "-        \"//tensorflow/compiler/mlir/tensorflow:tensorflow_ops_td_files\",", "-        \"//tensorflow/compiler/xla/mlir_hlo:hlo_ops_td_files\",", "-        \"@llvm-project//llvm:Support\",", "-        \"@llvm-project//mlir:FuncTdFiles\",", "-        \"@llvm-project//mlir:PassBaseTdFiles\",", "-        \"@llvm-project//mlir:SparseTensorDialect\",", "-        \"@llvm-project//mlir:TensorOpsTdFiles\",", "-    ],", "-)", "-", "-cc_library(", "-    name = \"tf_xla_passes\",", "-    srcs = [", "-        \"transforms/xla_legalize_tf_passes.h.inc\",", "-    ],", "-    hdrs = [", "-        \"transforms/passes.h\",", "-    ],", "-    deps = [", "-        \":tf_xla_passes_inc_gen\",", "-        \":xla_legalize_tf\",", "-        \"//tensorflow/compiler/xla/mlir_hlo\",", "-        \"@llvm-project//llvm:Support\",", "-        \"@llvm-project//mlir:FuncDialect\",", "-        \"@llvm-project//mlir:IR\",", "-        \"@llvm-project//mlir:MemRefDialect\",", "-        \"@llvm-project//mlir:Pass\",", "-        \"@llvm-project//mlir:SparseTensorDialect\",", "-        \"@llvm-project//mlir:Support\",", "-        \"@llvm-project//mlir:TransformUtils\",", "-    ],", "-)", "-", "-cc_library(", "-    name = \"legalize_utils\",", "-    srcs = [\"transforms/utils.cc\"],", "-    hdrs = [\"transforms/utils.h\"],", "-    deps = [", "-        \"//tensorflow/compiler/xla/mlir_hlo\",", "-        \"@llvm-project//llvm:Support\",", "-        \"@llvm-project//mlir:IR\",", "-    ],", "-)", "-", "-cc_library(", "-    name = \"test_utils\",", "-    testonly = True,", "-    srcs = [\"transforms/test_utils.cc\"],", "-    hdrs = [\"transforms/test_utils.h\"],", "-    deps = [", "-        \"//tensorflow/compiler/mlir/tensorflow\",", "-        \"//tensorflow/compiler/mlir/tensorflow:serialize_mlir_module_utils\",", "-        \"//tensorflow/compiler/mlir/tensorflow:tensorflow_passes\",", "-        \"//tensorflow/core/lib/monitoring:cell_reader\",", "-        \"//tensorflow/core/platform:errors\",", "-        \"//tensorflow/tsl/lib/core:status_test_util\",", "-        \"//tensorflow/tsl/platform:statusor\",", "-        \"@com_google_absl//absl/strings\",", "-        \"@com_google_googletest//:gtest_main\",", "-        \"@llvm-project//llvm:Support\",", "-        \"@llvm-project//mlir:FuncDialect\",", "-        \"@llvm-project//mlir:Pass\",", "-    ],", "-)", "-", "-cc_library(", "-    name = \"legalize_tf\",", "-    srcs = [", "-        \"transforms/generated_legalize_tf.inc\",", "-        \"transforms/legalize_tf.cc\",", "-    ],", "-    hdrs = [", "-        \"transforms/passes.h\",", "-    ],", "-    deps = [", "-        \":legalize_tf_patterns_inc_gen\",", "-        \":legalize_utils\",", "-        \":tf_xla_passes_inc_gen\",", "-        \":xla_legalize_tf_passes_inc_gen\",", "-        \"//tensorflow/compiler/mlir/tensorflow\",", "-        \"//tensorflow/compiler/mlir/tensorflow:dynamic_shape_utils\",", "-        \"//tensorflow/compiler/xla:xla_data_proto_cc\",", "-        \"//tensorflow/compiler/xla/client:padding\",", "-        \"//tensorflow/compiler/xla/client:sharding_builder\",", "-        \"//tensorflow/compiler/xla/client/lib:conv_grad_size_util\",", "-        \"//tensorflow/compiler/xla/mlir_hlo\",", "-        \"//tensorflow/compiler/xla/mlir_hlo:convert_op_folder\",", "-        \"//tensorflow/compiler/xla/translate/hlo_to_mhlo:attribute_importer\",", "-        \"//tensorflow/core:framework\",", "-        \"//tensorflow/core/kernels:conv_grad_shape_utils\",", "-        \"//tensorflow/tsl/platform:bfloat16\",", "-        \"//tensorflow/tsl/platform:status\",", "-        \"@llvm-project//llvm:Support\",", "-        \"@llvm-project//mlir:ArithDialect\",", "-        \"@llvm-project//mlir:Dialect\",", "-        \"@llvm-project//mlir:FuncDialect\",", "-        \"@llvm-project//mlir:IR\",", "-        \"@llvm-project//mlir:MemRefDialect\",", "-        \"@llvm-project//mlir:Pass\",", "-        \"@llvm-project//mlir:ShapeDialect\",", "-        \"@llvm-project//mlir:Support\",", "-        \"@llvm-project//mlir:TensorDialect\",", "-        \"@llvm-project//mlir:TransformUtils\",", "-        \"@stablehlo//:chlo_ops\",", "-    ],", "-)", "-", "-cc_library(", "-    name = \"xla_legalize_targets\",", "-    srcs = [", "-        \"transforms/xla_legalize_targets.cc\",", "-    ],", "-    hdrs = [", "-        \"transforms/xla_legalize_targets.h\",", "-    ],", "-    deps = [", "-        \"//tensorflow/compiler/mlir/tensorflow\",", "-        \"//tensorflow/compiler/xla/mlir_hlo\",", "-        \"@llvm-project//mlir:ArithDialect\",", "-        \"@llvm-project//mlir:FuncDialect\",", "-        \"@llvm-project//mlir:IR\",", "-        \"@llvm-project//mlir:ShapeDialect\",", "-        \"@llvm-project//mlir:TensorDialect\",", "-        \"@llvm-project//mlir:TransformUtils\",", "-        \"@stablehlo//:chlo_ops\",", "-    ],", "-)", "-", "-tf_cc_test(", "-    name = \"xla_legalize_targets_test\",", "-    srcs = [\"transforms/xla_legalize_targets_test.cc\"],", "-    deps = [", "-        \":xla_legalize_targets\",", "-        \"//tensorflow/compiler/mlir/tensorflow\",", "-        \"@com_google_googletest//:gtest_main\",", "-        \"@llvm-project//mlir:ArithDialect\",", "-        \"@llvm-project//mlir:FuncDialect\",", "-        \"@llvm-project//mlir:IR\",", "-        \"@llvm-project//mlir:ShapeDialect\",", "-        \"@llvm-project//mlir:TensorDialect\",", "-        \"@llvm-project//mlir:TransformUtils\",", "-        \"@stablehlo//:chlo_ops\",", "-    ],", "-)", "-", "-tf_cc_test(", "-    name = \"verify_tfxla_legalization_test\",", "-    srcs = [\"transforms/verify_tfxla_legalization_test.cc\"],", "-    deps = [", "-        \":legalize_tf\",", "-        \"//tensorflow/compiler/mlir/tensorflow\",", "-        \"//tensorflow/compiler/mlir/tensorflow:serialize_mlir_module_utils\",", "-        \"//tensorflow/compiler/mlir/tensorflow:tensorflow_passes\",", "-        \"//tensorflow/core/lib/monitoring:cell_reader\",", "-        \"//tensorflow/core/platform:errors\",", "-        \"//tensorflow/tsl/lib/core:status_test_util\",", "-        \"//tensorflow/tsl/platform:statusor\",", "-        \"@com_google_absl//absl/strings\",", "-        \"@com_google_googletest//:gtest_main\",", "-        \"@llvm-project//llvm:Support\",", "-        \"@llvm-project//mlir:FuncDialect\",", "-        \"@llvm-project//mlir:Pass\",", "-    ],", "-)", "-", "-cc_library(", "-    name = \"xla_legalize_tf\",", "-    srcs = [", "-        \"transforms/convert_mhlo_quant_to_int.cc\",", "-        \"transforms/infeed_ops_xla_adjust_layout.cc\",", "-        \"transforms/legalize_tf_collective.cc\",", "-        \"transforms/legalize_tf_communication.cc\",", "-        \"transforms/legalize_tf_types.cc\",", "-        \"transforms/tf_xla_passes.h.inc\",", "-        \"transforms/tfxla_device_specific_transforms.cc\",", "-        \"transforms/verify_tfxla_legalization.cc\",", "-        \"transforms/xla_legalize_tf.cc\",", "-        \"transforms/xla_legalize_tf_passes.h.inc\",", "-    ],", "-    hdrs = [", "-        \"transforms/passes.h\",", "-    ],", "-    deps = [", "-        \":legalize_tf\",", "-        \":legalize_utils\",", "-        \":xla_legalize_targets\",", "-        \":xla_legalize_tf_no_fallback\",", "-        \":xla_legalize_tf_passes_inc_gen\",", "-        \":xla_legalize_tf_with_tf2xla\",", "-        \"//tensorflow/compiler/mlir/tensorflow\",", "-        \"//tensorflow/compiler/mlir/tensorflow:lower_tf_lib\",", "-        \"//tensorflow/compiler/mlir/tensorflow:mangling_util\",", "-        \"//tensorflow/compiler/mlir/tensorflow:set_tpu_infeed_layout\",", "-        \"//tensorflow/compiler/mlir/tensorflow:tensorflow_types\",", "-        \"//tensorflow/compiler/tf2xla/kernels:rng_converter_utils\",", "-        \"//tensorflow/compiler/xla:shape_util\",", "-        \"//tensorflow/compiler/xla:side_effect_util\",", "-        \"//tensorflow/compiler/xla:xla_data_proto_cc\",", "-        \"//tensorflow/compiler/xla/client:padding\",", "-        \"//tensorflow/compiler/xla/client:sharding_builder\",", "-        \"//tensorflow/compiler/xla/mlir_hlo\",", "-        \"//tensorflow/compiler/xla/mlir_hlo:chlo_legalize_to_hlo\",", "-        \"//tensorflow/compiler/xla/mlir_hlo:convert_op_folder\",", "-        \"//tensorflow/compiler/xla/stream_executor/tpu:c_api_conversions\",", "-        \"//tensorflow/compiler/xla/stream_executor/tpu:tpu_api\",", "-        \"//tensorflow/compiler/xla/translate/hlo_to_mhlo:attribute_importer\",", "-        \"//tensorflow/compiler/xla/translate/mhlo_to_hlo:type_to_shape\",", "-        \"//tensorflow/core:framework\",", "-        \"//tensorflow/core:lib\",", "-        \"//tensorflow/core:protos_all_cc\",", "-        \"//tensorflow/core/util/quantization:uniform_quant_ops_params\",", "-        \"@com_google_absl//absl/strings\",", "-        \"@com_google_absl//absl/types:span\",", "-        \"@llvm-project//llvm:Support\",", "-        \"@llvm-project//mlir:ArithDialect\",", "-        \"@llvm-project//mlir:FuncDialect\",", "-        \"@llvm-project//mlir:IR\",", "-        \"@llvm-project//mlir:MemRefDialect\",", "-        \"@llvm-project//mlir:Pass\",", "-        \"@llvm-project//mlir:QuantOps\",", "-        \"@llvm-project//mlir:ShapeDialect\",", "-        \"@llvm-project//mlir:SparseTensorDialect\",", "-        \"@llvm-project//mlir:Support\",", "-        \"@llvm-project//mlir:TensorDialect\",", "-        \"@llvm-project//mlir:Transforms\",", "-        \"@stablehlo//:chlo_ops\",", "-    ],", "-)", "-", "-cc_library(", "-    name = \"xla_legalize_tf_no_fallback\",", "-    srcs = [", "-        \"transforms/xla_legalize_tf_no_fallback.cc\",", "-        \"transforms/xla_legalize_tf_passes.h.inc\",", "-    ],", "-    hdrs = [", "-        \"transforms/passes.h\",", "-    ],", "-    deps = [", "-        \":legalize_tf\",", "-        \":tf_xla_passes_inc_gen\",", "-        \":xla_legalize_tf_passes_inc_gen\",", "-        \"//tensorflow/compiler/mlir/tensorflow\",", "-        \"//tensorflow/compiler/mlir/tensorflow:lower_tf_lib\",", "-        \"//tensorflow/compiler/xla/mlir_hlo\",", "-        \"@llvm-project//llvm:Support\",", "-        \"@llvm-project//mlir:ArithDialect\",", "-        \"@llvm-project//mlir:FuncDialect\",", "-        \"@llvm-project//mlir:IR\",", "-        \"@llvm-project//mlir:MemRefDialect\",", "-        \"@llvm-project//mlir:Pass\",", "-        \"@llvm-project//mlir:ShapeDialect\",", "-        \"@llvm-project//mlir:SparseTensorDialect\",", "-        \"@llvm-project//mlir:Support\",", "-        \"@llvm-project//mlir:TensorDialect\",", "-        \"@llvm-project//mlir:Transforms\",", "-        \"@stablehlo//:chlo_ops\",", "-    ],", "-)", "-", "-cc_library(", "-    name = \"tf2xla_rewriter\",", "-    srcs = [", "-        \"transforms/tf2xla_rewriter.cc\",", "-    ],", "-    hdrs = [", "-        \"transforms/tf2xla_rewriter.h\",", "-    ],", "-    visibility = [\"//visibility:private\"],", "-    deps = [", "-        \":legalize_tf\",", "-        \"//tensorflow/compiler/mlir:op_or_arg_name_mapper\",", "-        \"//tensorflow/compiler/mlir/tensorflow\",", "-        \"//tensorflow/compiler/mlir/tensorflow:convert_tensor\",", "-        \"//tensorflow/compiler/mlir/tensorflow:convert_type\",", "-        \"//tensorflow/compiler/mlir/tensorflow:export_tf_dialect_op\",", "-        \"//tensorflow/compiler/mlir/tensorflow:tpu_embedding_ops_registry\",", "-        \"//tensorflow/compiler/mlir/tensorflow:translate_utils\",", "-        \"//tensorflow/compiler/tf2xla:xla_compilation_device\",", "-        \"//tensorflow/compiler/tf2xla:xla_context\",", "-        \"//tensorflow/compiler/tf2xla:xla_expression\",", "-        \"//tensorflow/compiler/tf2xla:xla_helpers\",", "-        \"//tensorflow/compiler/tf2xla:xla_op_registry\",", "-        \"//tensorflow/compiler/xla:xla_data_proto_cc\",", "-        \"//tensorflow/compiler/xla/client:xla_builder\",", "-        \"//tensorflow/compiler/xla/mlir_hlo\",", "-        \"//tensorflow/compiler/xla/translate/hlo_to_mhlo:mlir_hlo_builder\",", "-        \"//tensorflow/core:core_cpu\",", "-        \"//tensorflow/core:core_cpu_base\",", "-        \"//tensorflow/core:framework\",", "-        \"//tensorflow/core:framework_types_hdr\",", "-        \"//tensorflow/core:protos_all_cc\",", "-        \"//tensorflow/core/framework:allocator\",", "-        \"//tensorflow/core/protobuf:for_core_protos_cc\",", "-        \"//tensorflow/tsl/platform:env\",", "-        \"//tensorflow/tsl/platform:status\",", "-        \"//tensorflow/tsl/platform:statusor\",", "-        \"@com_google_absl//absl/container:inlined_vector\",", "-        \"@com_google_absl//absl/memory\",", "-        \"@com_google_absl//absl/strings\",", "-        \"@llvm-project//llvm:Support\",", "-        \"@llvm-project//mlir:FuncDialect\",", "-        \"@llvm-project//mlir:IR\",", "-        \"@llvm-project//mlir:Pass\",", "-        \"@llvm-project//mlir:SparseTensorDialect\",", "-        \"@llvm-project//mlir:Support\",", "-        \"@llvm-project//mlir:TensorDialect\",", "-        \"@llvm-project//mlir:TransformUtils\",", "-    ],", "-)", "-", "-tf_cc_test(", "-    name = \"tf2xla_rewriter_test\",", "-    srcs = [", "-        \"transforms/tf2xla_rewriter_test.cc\",", "-    ],", "-    deps = [", "-        \":test_utils\",", "-        \":tf2xla_rewriter\",", "-        \"@com_google_googletest//:gtest_main\",", "-    ],", "-)", "-", "-cc_library(", "-    name = \"xla_legalize_tf_with_tf2xla\",", "-    srcs = [", "-        \"transforms/legalize_tf_with_tf2xla.cc\",", "-    ],", "-    hdrs = [", "-        \"transforms/passes.h\",", "-    ],", "-    deps = [", "-        \":tf2xla_rewriter\",", "-        \":tf_xla_passes_inc_gen\",", "-        \":xla_legalize_tf_passes_inc_gen\",", "-        \"//tensorflow/compiler/mlir:op_or_arg_name_mapper\",", "-        \"//tensorflow/compiler/mlir/tensorflow\",", "-        \"//tensorflow/compiler/mlir/tensorflow:convert_tensor\",", "-        \"//tensorflow/compiler/mlir/tensorflow:convert_type\",", "-        \"//tensorflow/compiler/mlir/tensorflow:export_tf_dialect_op\",", "-        \"//tensorflow/compiler/mlir/tensorflow:tensorflow_ops\",", "-        \"//tensorflow/compiler/mlir/tensorflow:tpu_embedding_ops_registry\",", "-        \"//tensorflow/compiler/mlir/tensorflow:translate_utils\",", "-        \"//tensorflow/compiler/tf2xla:xla_compilation_device\",", "-        \"//tensorflow/compiler/tf2xla:xla_context\",", "-        \"//tensorflow/compiler/tf2xla:xla_expression\",", "-        \"//tensorflow/compiler/tf2xla:xla_helpers\",", "-        \"//tensorflow/compiler/tf2xla:xla_op_registry\",", "-        \"//tensorflow/compiler/xla/client:xla_builder\",", "-        \"//tensorflow/compiler/xla/mlir_hlo\",", "-        \"//tensorflow/compiler/xla/stream_executor:timer\",", "-        \"//tensorflow/compiler/xla/translate/hlo_to_mhlo:mlir_hlo_builder\",", "-        \"//tensorflow/core:core_cpu_lib\",", "-        \"//tensorflow/core:framework\",", "-        \"//tensorflow/core:lib\",", "-        \"//tensorflow/core:lib_internal\",", "-        \"//tensorflow/core:protos_all_cc\",", "-        \"//tensorflow/core:session_options\",", "-        \"@com_google_absl//absl/container:inlined_vector\",", "-        \"@com_google_absl//absl/memory\",", "-        \"@com_google_absl//absl/strings\",", "-        \"@llvm-project//llvm:Support\",", "-        \"@llvm-project//mlir:FuncDialect\",", "-        \"@llvm-project//mlir:IR\",", "-        \"@llvm-project//mlir:Pass\",", "-        \"@llvm-project//mlir:SparseTensorDialect\",", "-        \"@llvm-project//mlir:Support\",", "-        \"@llvm-project//mlir:TensorDialect\",", "-        \"@llvm-project//mlir:TransformUtils\",", "-    ],", "-)", "+# Targets in the transform package we alias here to avoid updating all clients.", "+aliased_targets = [", "+    \"legalize_tf\",", "+    \"legalize_utils\",", "+    \"tf_xla_passes\",", "+    \"xla_legalize_tf\",", "+    \"xla_legalize_tf_no_fallback\",", "+    \"xla_legalize_tf_with_tf2xla\",", "+]", "+", "+[", "+    alias(", "+        name = target,", "+        actual = \"//tensorflow/compiler/mlir/tf2xla/transforms:%s\" % target,", "+    )", "+    for target in aliased_targets", "+]", "@@ -0,0 +1,441 @@", "+# Description:", "+#    TF2XLA Bridge transforms", "+", "+load(\"//tensorflow/core/platform:rules_cc.bzl\", \"cc_library\")", "+load(\"//tensorflow:tensorflow.bzl\", \"tf_cc_test\")", "+load(\"@llvm-project//mlir:tblgen.bzl\", \"gentbl_cc_library\")", "+load(\"//tensorflow:tensorflow.default.bzl\", \"get_compatible_with_cloud\")", "+", "+package(", "+    # copybara:uncomment default_applicable_licenses = [\"//tensorflow:license\"],", "+    default_visibility = [", "+        \"//tensorflow/compiler/mlir/tf2xla:tensorflow_mlir_tf2xla\",", "+    ],", "+    licenses = [\"notice\"],", "+)", "+", "+gentbl_cc_library(", "+    name = \"legalize_tf_patterns_inc_gen\",", "+    compatible_with = get_compatible_with_cloud(),", "+    tbl_outs = [", "+        (", "+            [\"-gen-rewriters\"],", "+            \"generated_legalize_tf.inc\",", "+        ),", "+    ],", "+    tblgen = \"@llvm-project//mlir:mlir-tblgen\",", "+    td_file = \"legalize_tf_patterns.td\",", "+    deps = [", "+        \"//tensorflow/compiler/mlir/tensorflow:tensorflow_ops_td_files\",", "+        \"//tensorflow/compiler/xla/mlir_hlo:hlo_ops_td_files\",", "+        \"@llvm-project//llvm:Support\",", "+        \"@llvm-project//mlir:FuncTdFiles\",", "+        \"@llvm-project//mlir:TensorOpsTdFiles\",", "+    ],", "+)", "+", "+gentbl_cc_library(", "+    name = \"xla_legalize_tf_passes_inc_gen\",", "+    compatible_with = get_compatible_with_cloud(),", "+    tbl_outs = [", "+        (", "+            [", "+                \"-gen-pass-decls\",", "+                \"-name=LegalizeTf\",", "+            ],", "+            \"xla_legalize_tf_passes.h.inc\",", "+        ),", "+    ],", "+    tblgen = \"@llvm-project//mlir:mlir-tblgen\",", "+    td_file = \"xla_legalize_tf_passes.td\",", "+    deps = [", "+        \"@llvm-project//mlir:PassBaseTdFiles\",", "+    ],", "+)", "+", "+gentbl_cc_library(", "+    name = \"tf_xla_passes_inc_gen\",", "+    compatible_with = get_compatible_with_cloud(),", "+    tbl_outs = [", "+        (", "+            [", "+                \"-gen-pass-decls\",", "+                \"-name=TfXla\",", "+            ],", "+            \"tf_xla_passes.h.inc\",", "+        ),", "+    ],", "+    tblgen = \"@llvm-project//mlir:mlir-tblgen\",", "+    td_file = \"tf_xla_passes.td\",", "+    deps = [", "+        \"//tensorflow/compiler/mlir/tensorflow:tensorflow_ops_td_files\",", "+        \"//tensorflow/compiler/xla/mlir_hlo:hlo_ops_td_files\",", "+        \"@llvm-project//llvm:Support\",", "+        \"@llvm-project//mlir:FuncTdFiles\",", "+        \"@llvm-project//mlir:PassBaseTdFiles\",", "+        \"@llvm-project//mlir:SparseTensorDialect\",", "+        \"@llvm-project//mlir:TensorOpsTdFiles\",", "+    ],", "+)", "+", "+cc_library(", "+    name = \"tf_xla_passes\",", "+    srcs = [", "+        \"xla_legalize_tf_passes.h.inc\",", "+    ],", "+    hdrs = [", "+        \"passes.h\",", "+    ],", "+    deps = [", "+        \":tf_xla_passes_inc_gen\",", "+        \":xla_legalize_tf\",", "+        \"//tensorflow/compiler/xla/mlir_hlo\",", "+        \"@llvm-project//llvm:Support\",", "+        \"@llvm-project//mlir:FuncDialect\",", "+        \"@llvm-project//mlir:IR\",", "+        \"@llvm-project//mlir:MemRefDialect\",", "+        \"@llvm-project//mlir:Pass\",", "+        \"@llvm-project//mlir:SparseTensorDialect\",", "+        \"@llvm-project//mlir:Support\",", "+        \"@llvm-project//mlir:TransformUtils\",", "+    ],", "+)", "+", "+cc_library(", "+    name = \"legalize_utils\",", "+    srcs = [\"utils.cc\"],", "+    hdrs = [\"utils.h\"],", "+    deps = [", "+        \"//tensorflow/compiler/xla/mlir_hlo\",", "+        \"@llvm-project//llvm:Support\",", "+        \"@llvm-project//mlir:IR\",", "+    ],", "+)", "+", "+cc_library(", "+    name = \"test_utils\",", "+    testonly = True,", "+    srcs = [\"test_utils.cc\"],", "+    hdrs = [\"test_utils.h\"],", "+    deps = [", "+        \"//tensorflow/compiler/mlir/tensorflow\",", "+        \"//tensorflow/compiler/mlir/tensorflow:serialize_mlir_module_utils\",", "+        \"//tensorflow/compiler/mlir/tensorflow:tensorflow_passes\",", "+        \"//tensorflow/core/lib/monitoring:cell_reader\",", "+        \"//tensorflow/core/platform:errors\",", "+        \"//tensorflow/tsl/lib/core:status_test_util\",", "+        \"//tensorflow/tsl/platform:statusor\",", "+        \"@com_google_absl//absl/strings\",", "+        \"@com_google_googletest//:gtest_main\",", "+        \"@llvm-project//llvm:Support\",", "+        \"@llvm-project//mlir:FuncDialect\",", "+        \"@llvm-project//mlir:Pass\",", "+    ],", "+)", "+", "+cc_library(", "+    name = \"legalize_tf\",", "+    srcs = [", "+        \"generated_legalize_tf.inc\",", "+        \"legalize_tf.cc\",", "+    ],", "+    hdrs = [", "+        \"passes.h\",", "+    ],", "+    deps = [", "+        \":legalize_tf_patterns_inc_gen\",", "+        \":legalize_utils\",", "+        \":tf_xla_passes_inc_gen\",", "+        \":xla_legalize_tf_passes_inc_gen\",", "+        \"//tensorflow/compiler/mlir/tensorflow\",", "+        \"//tensorflow/compiler/mlir/tensorflow:dynamic_shape_utils\",", "+        \"//tensorflow/compiler/xla:xla_data_proto_cc\",", "+        \"//tensorflow/compiler/xla/client:padding\",", "+        \"//tensorflow/compiler/xla/client:sharding_builder\",", "+        \"//tensorflow/compiler/xla/client/lib:conv_grad_size_util\",", "+        \"//tensorflow/compiler/xla/mlir_hlo\",", "+        \"//tensorflow/compiler/xla/mlir_hlo:convert_op_folder\",", "+        \"//tensorflow/compiler/xla/translate/hlo_to_mhlo:attribute_importer\",", "+        \"//tensorflow/core:framework\",", "+        \"//tensorflow/core/kernels:conv_grad_shape_utils\",", "+        \"//tensorflow/tsl/platform:bfloat16\",", "+        \"//tensorflow/tsl/platform:status\",", "+        \"@llvm-project//llvm:Support\",", "+        \"@llvm-project//mlir:ArithDialect\",", "+        \"@llvm-project//mlir:Dialect\",", "+        \"@llvm-project//mlir:FuncDialect\",", "+        \"@llvm-project//mlir:IR\",", "+        \"@llvm-project//mlir:MemRefDialect\",", "+        \"@llvm-project//mlir:Pass\",", "+        \"@llvm-project//mlir:ShapeDialect\",", "+        \"@llvm-project//mlir:Support\",", "+        \"@llvm-project//mlir:TensorDialect\",", "+        \"@llvm-project//mlir:TransformUtils\",", "+        \"@stablehlo//:chlo_ops\",", "+    ],", "+)", "+", "+cc_library(", "+    name = \"xla_legalize_targets\",", "+    srcs = [", "+        \"xla_legalize_targets.cc\",", "+    ],", "+    hdrs = [", "+        \"xla_legalize_targets.h\",", "+    ],", "+    deps = [", "+        \"//tensorflow/compiler/mlir/tensorflow\",", "+        \"//tensorflow/compiler/xla/mlir_hlo\",", "+        \"@llvm-project//mlir:ArithDialect\",", "+        \"@llvm-project//mlir:FuncDialect\",", "+        \"@llvm-project//mlir:IR\",", "+        \"@llvm-project//mlir:ShapeDialect\",", "+        \"@llvm-project//mlir:TensorDialect\",", "+        \"@llvm-project//mlir:TransformUtils\",", "+        \"@stablehlo//:chlo_ops\",", "+    ],", "+)", "+", "+tf_cc_test(", "+    name = \"xla_legalize_targets_test\",", "+    srcs = [\"xla_legalize_targets_test.cc\"],", "+    deps = [", "+        \":xla_legalize_targets\",", "+        \"//tensorflow/compiler/mlir/tensorflow\",", "+        \"@com_google_googletest//:gtest_main\",", "+        \"@llvm-project//mlir:ArithDialect\",", "+        \"@llvm-project//mlir:FuncDialect\",", "+        \"@llvm-project//mlir:IR\",", "+        \"@llvm-project//mlir:ShapeDialect\",", "+        \"@llvm-project//mlir:TensorDialect\",", "+        \"@llvm-project//mlir:TransformUtils\",", "+        \"@stablehlo//:chlo_ops\",", "+    ],", "+)", "+", "+tf_cc_test(", "+    name = \"verify_tfxla_legalization_test\",", "+    srcs = [\"verify_tfxla_legalization_test.cc\"],", "+    deps = [", "+        \":xla_legalize_tf\",", "+        \"//tensorflow/compiler/mlir/tensorflow\",", "+        \"//tensorflow/compiler/mlir/tensorflow:serialize_mlir_module_utils\",", "+        \"//tensorflow/compiler/mlir/tensorflow:tensorflow_passes\",", "+        \"//tensorflow/core/lib/monitoring:cell_reader\",", "+        \"//tensorflow/core/platform:errors\",", "+        \"//tensorflow/tsl/lib/core:status_test_util\",", "+        \"//tensorflow/tsl/platform:statusor\",", "+        \"@com_google_absl//absl/strings\",", "+        \"@com_google_googletest//:gtest_main\",", "+        \"@llvm-project//llvm:Support\",", "+        \"@llvm-project//mlir:FuncDialect\",", "+        \"@llvm-project//mlir:Pass\",", "+    ],", "+)", "+", "+cc_library(", "+    name = \"xla_legalize_tf\",", "+    srcs = [", "+        \"convert_mhlo_quant_to_int.cc\",", "+        \"infeed_ops_xla_adjust_layout.cc\",", "+        \"legalize_tf_collective.cc\",", "+        \"legalize_tf_communication.cc\",", "+        \"legalize_tf_types.cc\",", "+        \"tf_xla_passes.h.inc\",", "+        \"tfxla_device_specific_transforms.cc\",", "+        \"verify_tfxla_legalization.cc\",", "+        \"xla_legalize_tf.cc\",", "+        \"xla_legalize_tf_passes.h.inc\",", "+    ],", "+    hdrs = [", "+        \"passes.h\",", "+    ],", "+    deps = [", "+        \":legalize_tf\",", "+        \":legalize_utils\",", "+        \":xla_legalize_targets\",", "+        \":xla_legalize_tf_no_fallback\",", "+        \":xla_legalize_tf_passes_inc_gen\",", "+        \":xla_legalize_tf_with_tf2xla\",", "+        \"//tensorflow/compiler/mlir/tensorflow\",", "+        \"//tensorflow/compiler/mlir/tensorflow:lower_tf_lib\",", "+        \"//tensorflow/compiler/mlir/tensorflow:mangling_util\",", "+        \"//tensorflow/compiler/mlir/tensorflow:set_tpu_infeed_layout\",", "+        \"//tensorflow/compiler/mlir/tensorflow:tensorflow_types\",", "+        \"//tensorflow/compiler/tf2xla/kernels:rng_converter_utils\",", "+        \"//tensorflow/compiler/xla:shape_util\",", "+        \"//tensorflow/compiler/xla:side_effect_util\",", "+        \"//tensorflow/compiler/xla:xla_data_proto_cc\",", "+        \"//tensorflow/compiler/xla/client:padding\",", "+        \"//tensorflow/compiler/xla/client:sharding_builder\",", "+        \"//tensorflow/compiler/xla/mlir_hlo\",", "+        \"//tensorflow/compiler/xla/mlir_hlo:chlo_legalize_to_hlo\",", "+        \"//tensorflow/compiler/xla/mlir_hlo:convert_op_folder\",", "+        \"//tensorflow/compiler/xla/stream_executor/tpu:c_api_conversions\",", "+        \"//tensorflow/compiler/xla/stream_executor/tpu:tpu_api\",", "+        \"//tensorflow/compiler/xla/translate/hlo_to_mhlo:attribute_importer\",", "+        \"//tensorflow/compiler/xla/translate/mhlo_to_hlo:type_to_shape\",", "+        \"//tensorflow/core:framework\",", "+        \"//tensorflow/core:lib\",", "+        \"//tensorflow/core:protos_all_cc\",", "+        \"//tensorflow/core/util/quantization:uniform_quant_ops_params\",", "+        \"@com_google_absl//absl/strings\",", "+        \"@com_google_absl//absl/types:span\",", "+        \"@llvm-project//llvm:Support\",", "+        \"@llvm-project//mlir:ArithDialect\",", "+        \"@llvm-project//mlir:FuncDialect\",", "+        \"@llvm-project//mlir:IR\",", "+        \"@llvm-project//mlir:MemRefDialect\",", "+        \"@llvm-project//mlir:Pass\",", "+        \"@llvm-project//mlir:QuantOps\",", "+        \"@llvm-project//mlir:ShapeDialect\",", "+        \"@llvm-project//mlir:SparseTensorDialect\",", "+        \"@llvm-project//mlir:Support\",", "+        \"@llvm-project//mlir:TensorDialect\",", "+        \"@llvm-project//mlir:Transforms\",", "+        \"@stablehlo//:chlo_ops\",", "+    ],", "+)", "+", "+cc_library(", "+    name = \"xla_legalize_tf_no_fallback\",", "+    srcs = [", "+        \"xla_legalize_tf_no_fallback.cc\",", "+        \"xla_legalize_tf_passes.h.inc\",", "+    ],", "+    hdrs = [", "+        \"passes.h\",", "+    ],", "+    deps = [", "+        \":legalize_tf\",", "+        \":tf_xla_passes_inc_gen\",", "+        \":xla_legalize_tf_passes_inc_gen\",", "+        \"//tensorflow/compiler/mlir/tensorflow\",", "+        \"//tensorflow/compiler/mlir/tensorflow:lower_tf_lib\",", "+        \"//tensorflow/compiler/xla/mlir_hlo\",", "+        \"@llvm-project//llvm:Support\",", "+        \"@llvm-project//mlir:ArithDialect\",", "+        \"@llvm-project//mlir:FuncDialect\",", "+        \"@llvm-project//mlir:IR\",", "+        \"@llvm-project//mlir:MemRefDialect\",", "+        \"@llvm-project//mlir:Pass\",", "+        \"@llvm-project//mlir:ShapeDialect\",", "+        \"@llvm-project//mlir:SparseTensorDialect\",", "+        \"@llvm-project//mlir:Support\",", "+        \"@llvm-project//mlir:TensorDialect\",", "+        \"@llvm-project//mlir:Transforms\",", "+        \"@stablehlo//:chlo_ops\",", "+    ],", "+)", "+", "+cc_library(", "+    name = \"tf2xla_rewriter\",", "+    srcs = [", "+        \"tf2xla_rewriter.cc\",", "+    ],", "+    hdrs = [", "+        \"tf2xla_rewriter.h\",", "+    ],", "+    visibility = [\"//visibility:private\"],", "+    deps = [", "+        \":legalize_tf\",", "+        \"//tensorflow/compiler/mlir:op_or_arg_name_mapper\",", "+        \"//tensorflow/compiler/mlir/tensorflow\",", "+        \"//tensorflow/compiler/mlir/tensorflow:convert_tensor\",", "+        \"//tensorflow/compiler/mlir/tensorflow:convert_type\",", "+        \"//tensorflow/compiler/mlir/tensorflow:export_tf_dialect_op\",", "+        \"//tensorflow/compiler/mlir/tensorflow:tpu_embedding_ops_registry\",", "+        \"//tensorflow/compiler/mlir/tensorflow:translate_utils\",", "+        \"//tensorflow/compiler/tf2xla:xla_compilation_device\",", "+        \"//tensorflow/compiler/tf2xla:xla_context\",", "+        \"//tensorflow/compiler/tf2xla:xla_expression\",", "+        \"//tensorflow/compiler/tf2xla:xla_helpers\",", "+        \"//tensorflow/compiler/tf2xla:xla_op_registry\",", "+        \"//tensorflow/compiler/xla:xla_data_proto_cc\",", "+        \"//tensorflow/compiler/xla/client:xla_builder\",", "+        \"//tensorflow/compiler/xla/mlir_hlo\",", "+        \"//tensorflow/compiler/xla/translate/hlo_to_mhlo:mlir_hlo_builder\",", "+        \"//tensorflow/core:core_cpu\",", "+        \"//tensorflow/core:core_cpu_base\",", "+        \"//tensorflow/core:framework\",", "+        \"//tensorflow/core:framework_types_hdr\",", "+        \"//tensorflow/core:protos_all_cc\",", "+        \"//tensorflow/core/framework:allocator\",", "+        \"//tensorflow/core/protobuf:for_core_protos_cc\",", "+        \"//tensorflow/tsl/platform:env\",", "+        \"//tensorflow/tsl/platform:status\",", "+        \"//tensorflow/tsl/platform:statusor\",", "+        \"@com_google_absl//absl/container:inlined_vector\",", "+        \"@com_google_absl//absl/memory\",", "+        \"@com_google_absl//absl/strings\",", "+        \"@llvm-project//llvm:Support\",", "+        \"@llvm-project//mlir:FuncDialect\",", "+        \"@llvm-project//mlir:IR\",", "+        \"@llvm-project//mlir:Pass\",", "+        \"@llvm-project//mlir:SparseTensorDialect\",", "+        \"@llvm-project//mlir:Support\",", "+        \"@llvm-project//mlir:TensorDialect\",", "+        \"@llvm-project//mlir:TransformUtils\",", "+    ],", "+)", "+", "+tf_cc_test(", "+    name = \"tf2xla_rewriter_test\",", "+    srcs = [", "+        \"tf2xla_rewriter_test.cc\",", "+    ],", "+    deps = [", "+        \":test_utils\",", "+        \":tf2xla_rewriter\",", "+        \"@com_google_googletest//:gtest_main\",", "+    ],", "+)", "+", "+cc_library(", "+    name = \"xla_legalize_tf_with_tf2xla\",", "+    srcs = [", "+        \"legalize_tf_with_tf2xla.cc\",", "+    ],", "+    hdrs = [", "+        \"passes.h\",", "+    ],", "+    deps = [", "+        \":tf2xla_rewriter\",", "+        \":tf_xla_passes_inc_gen\",", "+        \":xla_legalize_tf_passes_inc_gen\",", "+        \"//tensorflow/compiler/mlir:op_or_arg_name_mapper\",", "+        \"//tensorflow/compiler/mlir/tensorflow\",", "+        \"//tensorflow/compiler/mlir/tensorflow:convert_tensor\",", "+        \"//tensorflow/compiler/mlir/tensorflow:convert_type\",", "+        \"//tensorflow/compiler/mlir/tensorflow:export_tf_dialect_op\",", "+        \"//tensorflow/compiler/mlir/tensorflow:tensorflow_ops\",", "+        \"//tensorflow/compiler/mlir/tensorflow:tpu_embedding_ops_registry\",", "+        \"//tensorflow/compiler/mlir/tensorflow:translate_utils\",", "+        \"//tensorflow/compiler/tf2xla:xla_compilation_device\",", "+        \"//tensorflow/compiler/tf2xla:xla_context\",", "+        \"//tensorflow/compiler/tf2xla:xla_expression\",", "+        \"//tensorflow/compiler/tf2xla:xla_helpers\",", "+        \"//tensorflow/compiler/tf2xla:xla_op_registry\",", "+        \"//tensorflow/compiler/xla/client:xla_builder\",", "+        \"//tensorflow/compiler/xla/mlir_hlo\",", "+        \"//tensorflow/compiler/xla/stream_executor:timer\",", "+        \"//tensorflow/compiler/xla/translate/hlo_to_mhlo:mlir_hlo_builder\",", "+        \"//tensorflow/core:core_cpu_lib\",", "+        \"//tensorflow/core:framework\",", "+        \"//tensorflow/core:lib\",", "+        \"//tensorflow/core:lib_internal\",", "+        \"//tensorflow/core:protos_all_cc\",", "+        \"//tensorflow/core:session_options\",", "+        \"@com_google_absl//absl/container:inlined_vector\",", "+        \"@com_google_absl//absl/memory\",", "+        \"@com_google_absl//absl/strings\",", "+        \"@llvm-project//llvm:Support\",", "+        \"@llvm-project//mlir:FuncDialect\",", "+        \"@llvm-project//mlir:IR\",", "+        \"@llvm-project//mlir:Pass\",", "+        \"@llvm-project//mlir:SparseTensorDialect\",", "+        \"@llvm-project//mlir:Support\",", "+        \"@llvm-project//mlir:TensorDialect\",", "+        \"@llvm-project//mlir:TransformUtils\",", "+    ],", "+)", "@@ -793,7 +793,7 @@ LogicalResult legalizeTF(Operation *op, bool legalize_chlo,", "     // Add TF->HLO legalization patterns via TF2XLA fallback.", "     PopulateLegalizeTfWithTf2XlaPatterns(", "         tf2xla_fallback_device_type.value(), patterns, context, converter,", "-        prefer_tf2xla, use_tf2xla_hlo_importer);", "+        prefer_tf2xla, /*is_module_pass=*/false, use_tf2xla_hlo_importer);", "   }", " ", "   // Populate with CHLO->HLO lowerings to account for TF ops legalized to", "@@ -14,6 +14,7 @@", " # ==============================================================================", " \"\"\"Tests for tf.framework.extension_type_field.\"\"\"", " ", "+import sys", " import typing", " from absl.testing import parameterized", " import numpy as np", "@@ -30,6 +31,13 @@ from tensorflow.python.ops.ragged import ragged_tensor", " from tensorflow.python.platform import googletest", " ", " ", "+if sys.version_info >= (3, 9):", "+  _TUPLE = tuple", "+else:", "+  # Remove this branch once TF drops support for Python < 3.9.", "+  _TUPLE = typing.Tuple", "+", "+", " @test_util.run_all_in_graph_and_eager_modes", " class ExtensionTypeFieldTest(test_util.TensorFlowTestCase,", "                              parameterized.TestCase):", "@@ -49,9 +57,8 @@ class ExtensionTypeFieldTest(test_util.TensorFlowTestCase,", "       ('seq', typing.Tuple[typing.Union[int, float], ...], (33, 12.8, 9, 0)),", "       ('seq', typing.Tuple[typing.Union[int, float],", "                            ...], [33, 12.8, 9, 0], (33, 12.8, 9, 0)),", "-      # ('seq', tuple[typing.Union[int, float], ...], (33, 12.8, 9, 0)),", "-      # ('seq', tuple[typing.Union[int, float], ...], [33, 12.8, 9, 0],", "-      #         (33, 12.8, 9, 0)),", "+      ('seq', _TUPLE[typing.Union[int, float], ...], (33, 12.8, 9, 0)),", "+      ('seq', _TUPLE[typing.Union[int, float], ...], (33, 12.8, 9, 0)),", "       ('s', tensor_shape.TensorShape, [1, 2], tensor_shape.TensorShape([1, 2])),", "       ('dtype', dtypes.DType, np.int32, dtypes.int32),", "   ])", "@@ -81,6 +88,9 @@ class ExtensionTypeFieldTest(test_util.TensorFlowTestCase,", "       ('seq', typing.Tuple[typing.Union[int, float], ...], [33, 12.8, 'zero'],", "        (r'default value for seq\\[2\\]: expected '", "         r\"typing.Union\\[int, float\\], got 'str'\")),", "+      ('seq', _TUPLE[typing.Union[int, float], ...], [33, 12.8, 'zero'],", "+       (r'default value for seq\\[2\\]: expected '", "+        r\"typing.Union\\[int, float\\], got 'str'\")),", "       ('t', tensor_spec.TensorSpec(None, dtypes.int32),", "        lambda: constant_op.constant(0.0),", "        'Unsupported type annotation TensorSpec.*'),", "@@ -146,11 +156,16 @@ class ValidateFieldPyTypeTest(test_util.TensorFlowTestCase,", "       dict(tp=typing.Union[int, float]),", "       dict(tp=typing.Tuple[int, ...]),", "       dict(tp=typing.Tuple[int, int]),", "+      dict(tp=_TUPLE[int, ...]),", "+      dict(tp=_TUPLE[int, int]),", "       dict(tp=typing.Mapping[int, int]),", "       dict(tp=typing.Mapping[str, int]),", "       dict(tp=typing.Union[int, 'A'], allow_forward_references=True),", "       dict(tp=typing.Mapping['A', int], allow_forward_references=True),", "       dict(tp=typing.Union[int, typing.Tuple[typing.Tuple[int, int], ...]]),", "+      dict(tp=typing.Union[int, _TUPLE[_TUPLE[int, int], ...]]),", "+      dict(tp=typing.Union[int, _TUPLE[typing.Tuple[int, int], ...]]),", "+      dict(tp=typing.Union[int, typing.Tuple[_TUPLE[int, int], ...]]),", "   ])", "   def testValidPytype(self, tp, allow_forward_references=False):", "     extension_type_field.validate_field_value_type(", "@@ -165,6 +180,9 @@ class ValidateFieldPyTypeTest(test_util.TensorFlowTestCase,", "       dict(", "           tp=typing.Tuple[typing.Tuple[int, int, dict], ...],", "           error=\"Unsupported type annotation 'dict'\"),", "+      dict(", "+          tp=_TUPLE[_TUPLE[int, int, dict], ...],", "+          error=\"Unsupported type annotation 'dict'\"),", "       dict(tp='A', error='Unresolved forward reference .*'),", "       dict(tp=typing.Union[int, 'A'], error='Unresolved forward reference .*'),", "       dict(tp=typing.Mapping[ops.Tensor, int],", "@@ -211,12 +229,17 @@ class FieldValueConverterTest(test_util.TensorFlowTestCase,", "        ragged_tensor.RaggedTensor),", "       ([1, 2, 3], typing.Tuple[int, ...], (1, 2, 3)),", "       ((1, 2, 3), typing.Tuple[int, int, int], (1, 2, 3)),", "+      ([1, 2, 3], _TUPLE[int, ...], (1, 2, 3)),", "+      ((1, 2, 3), _TUPLE[int, int, int], (1, 2, 3)),", "       ({", "           'a': 12", "       }, typing.Mapping[str, int]),", "       ({", "           'a': (12, 3.0)", "       }, typing.Mapping[str, typing.Tuple[int, float]]),", "+      ({", "+          'a': (12, 3.0)", "+      }, typing.Mapping[str, _TUPLE[int, float]]),", "       (tensor_shape.TensorShape([1, 2]), tensor_shape.TensorShape,", "        tensor_shape.TensorShape([1, 2])),", "       ([1, 2], tensor_shape.TensorShape, tensor_shape.TensorShape([1, 2])),", "@@ -244,12 +267,17 @@ class FieldValueConverterTest(test_util.TensorFlowTestCase,", "       (ragged_tensor.RaggedTensorSpec([5, None]), ragged_tensor.RaggedTensor),", "       ([1, 2, 3], typing.Tuple[int, ...], (1, 2, 3)),", "       ((1, 2, 3), typing.Tuple[int, int, int], (1, 2, 3)),", "+      ([1, 2, 3], _TUPLE[int, ...], (1, 2, 3)),", "+      ((1, 2, 3), _TUPLE[int, int, int], (1, 2, 3)),", "       ({", "           'a': 12", "       }, typing.Mapping[str, int]),", "       ({", "           'a': (12, 3.0)", "       }, typing.Mapping[str, typing.Tuple[int, float]]),", "+      ({", "+          'a': (12, 3.0)", "+      }, typing.Mapping[str, _TUPLE[int, float]]),", "       (tensor_shape.TensorShape([1, 2]), tensor_shape.TensorShape,", "        tensor_shape.TensorShape([1, 2])),", "       ([1, 2], tensor_shape.TensorShape, tensor_shape.TensorShape([1, 2])),", "@@ -274,6 +302,8 @@ class FieldValueConverterTest(test_util.TensorFlowTestCase,", "       (12, float, \"x: expected 'float', got 'int'\"),", "       ([1, 2, 3.0], typing.Tuple[int, ...],", "        r\"x\\[2\\]: expected 'int', got 'float'\"),", "+      ([1, 2, 3.0], _TUPLE[int, ...],", "+       r\"x\\[2\\]: expected 'int', got 'float'\"),", "       ('foo', tensor_shape.TensorShape,", "        \"x: expected 'tf.TensorShape', got 'str'\"),", "       ('foo', dtypes.DType, \"x: expected 'tf.DType', got 'str'\"),", "@@ -289,6 +319,8 @@ class FieldValueConverterTest(test_util.TensorFlowTestCase,", "         extension_type_field.ExtensionTypeField('x', int),", "         extension_type_field.ExtensionTypeField(", "             'y', typing.Tuple[typing.Union[int, bool], ...]),", "+        extension_type_field.ExtensionTypeField(", "+            'y', _TUPLE[typing.Union[int, bool], ...]),", "         extension_type_field.ExtensionTypeField('z', ops.Tensor)", "     ]", "     field_values = {'x': 1, 'y': [1, True, 3], 'z': [[1, 2], [3, 4], [5, 6]]}", "@@ -304,6 +336,8 @@ class FieldValueConverterTest(test_util.TensorFlowTestCase,", "         extension_type_field.ExtensionTypeField('x', int),", "         extension_type_field.ExtensionTypeField(", "             'y', typing.Tuple[typing.Union[int, bool], ...]),", "+        extension_type_field.ExtensionTypeField(", "+            'y', _TUPLE[typing.Union[int, bool], ...]),", "         extension_type_field.ExtensionTypeField('z', ops.Tensor)", "     ]", "     field_values = {", "@@ -16,8 +16,8 @@ cc_library(", "         \"//tensorflow/compiler/xla/runtime:async_runtime\",", "         \"//tensorflow/tsl/platform:platform_port\",", "         \"@com_google_absl//absl/base:dynamic_annotations\",", "+        \"@com_google_absl//absl/functional:any_invocable\",", "         \"@llvm-project//llvm:OrcJIT\",", "-        \"@llvm-project//llvm:Support\",", "         \"@llvm-project//mlir:mlir_async_runtime_api\",", "         \"@tf_runtime//:async_value\",", "     ],", "@@ -22,7 +22,7 @@ limitations under the License.", " #include <ostream>", " #include <string_view>", " #include <thread>  // NOLINT TODO(ezhulenev): Remove this header.", "-#include <type_traits>", "+#include <utility>", " ", " #include \"absl/base/dynamic_annotations.h\"", " #include \"mlir/ExecutionEngine/AsyncRuntime.h\"  // from @llvm-project", "@@ -50,19 +50,20 @@ AsyncValueRef<Chain> ConvertAsyncTokenToChain(AsyncRuntime::Token *token) {", " ", " void ExtractAsyncValue(", "     AsyncRuntime::Value *value, AsyncValue *dst,", "-    llvm::function_ref<void(void *storage, AsyncValue *dst)> emplace_fn) {", "+    absl::AnyInvocable<void(void *storage, AsyncValue *dst)> emplace_fn) {", "   auto *async_value = AsyncRuntime::GetAsyncValue(value);", " ", "   // Fast path if async value is already available.", "   if (async_value->IsAvailable()) {", "     auto *storage = AsyncRuntime::GetStorage(value);", "-    emplace_fn(storage, dst);", "+    std::move(emplace_fn)(storage, dst);", "     AsyncRuntime::DropRef(AsyncRuntime::ToAsyncRuntimeObject(value));", "     return;", "   }", " ", "   // Wait for the async value completion, and emplace the `dst`.", "-  async_value->AndThen([value, emplace_fn, dst = FormRef(dst)]() {", "+  async_value->AndThen([value, emplace_fn = std::move(emplace_fn),", "+                        dst = FormRef(dst)]() mutable {", "     auto *storage = AsyncRuntime::GetStorage(value);", "     emplace_fn(storage, dst.get());", "     AsyncRuntime::DropRef(AsyncRuntime::ToAsyncRuntimeObject(value));", "@@ -16,6 +16,7 @@ limitations under the License.", " #ifndef TENSORFLOW_COMPILER_XLA_MLIR_RUNTIME_UTILS_ASYNC_RUNTIME_API_H_", " #define TENSORFLOW_COMPILER_XLA_MLIR_RUNTIME_UTILS_ASYNC_RUNTIME_API_H_", " ", "+#include \"absl/functional/any_invocable.h\"", " #include \"llvm/ExecutionEngine/Orc/Core.h\"", " #include \"llvm/ExecutionEngine/Orc/Mangling.h\"", " #include \"tensorflow/compiler/xla/runtime/async_runtime.h\"", "@@ -35,7 +36,7 @@ tsl::AsyncValueRef<tsl::Chain> ConvertAsyncTokenToChain(", " // reference on the runtime value after it is no longer needed.", " void ExtractAsyncValue(", "     AsyncRuntime::Value* value, tsl::AsyncValue* dst,", "-    llvm::function_ref<void(void*, tsl::AsyncValue*)> emplace_fn);", "+    absl::AnyInvocable<void(void*, tsl::AsyncValue*)> emplace_fn);", " ", " // A version of the `ExtractAsyncValue` function defined above that takes an", " // additional opaque pointer that will be passed to the emplace function when", "@@ -251,6 +251,26 @@ struct ReturnAsyncI32 {", "   AsyncValuePtr<int32_t> ptr;", " };", " ", "+template <typename MemrefImpl>", "+struct FetchMemrefDescFromAsyncValue {", "+  void operator()(AsyncValue* value, MemrefDesc&& desc) const;", "+};", "+", "+template <>", "+struct FetchMemrefDescFromAsyncValue<OwnedMemref> {", "+  void operator()(AsyncValue* value, MemrefDesc&& desc) const {", "+    value->get<OwnedMemref>().desc = std::move(desc);", "+  }", "+};", "+", "+template <>", "+struct FetchMemrefDescFromAsyncValue<MemrefDesc> {", "+  void operator()(AsyncValue* value, MemrefDesc&& desc) const {", "+    value->get<MemrefDesc>() = std::move(desc);", "+  }", "+};", "+", "+template <typename MemrefImpl>", " struct ReturnAsyncMemref {", "   LogicalResult operator()(unsigned result_index, const Type* type,", "                            const Type* runtime_type, void* result_ptr) const {", "@@ -264,15 +284,16 @@ struct ReturnAsyncMemref {", "     auto* memref = llvm::dyn_cast<MemrefType>(&value_type->value_type());", " ", "     if (memref) {", "-      // TODO(ezhulenev): Emplace function captures `memref` by reference, and", "-      // if `value` is not available, then it will lead to asan errors. We need", "-      // an `ExtractAsyncValue` that can take absl::AnyInvocable callback, that", "-      // will capture all referenced values. Alternative solution is a large", "-      // switch statement that will dispatch for different types and ranks.", "-      ExtractAsyncValue(value, ptr.value(), [&](void* data, AsyncValue* dst) {", "-        auto desc = ConvertReturnedMemref<MemrefDesc>(*this, memref, data);", "-        if (succeeded(desc)) dst->get<OwnedMemref>().desc = std::move(*desc);", "-      });", "+      ExtractAsyncValue(", "+          value, ptr.value(),", "+          [converter = *this, m = *memref](void* data, AsyncValue* dst) {", "+            auto desc = ConvertReturnedMemref<MemrefDesc>(converter, &m, data);", "+            if (succeeded(desc)) {", "+              FetchMemrefDescFromAsyncValue<MemrefImpl>()(dst,", "+                                                          std::move(*desc));", "+              dst->SetStateConcrete();", "+            }", "+          });", "       return success();", "     }", " ", "@@ -286,9 +307,12 @@ struct ReturnAsyncMemref {", "     return MemrefDesc(element_type, base_ptr, offset, sizes, strides);", "   }", " ", "-  AsyncValuePtr<OwnedMemref> ptr;", "+  AsyncValuePtr<MemrefImpl> ptr;", " };", " ", "+using ReturnAsyncOwnedMemref = ReturnAsyncMemref<OwnedMemref>;", "+using ReturnAsyncMemrefDesc = ReturnAsyncMemref<MemrefDesc>;", "+", " // Execute all tasks in the caller thread immediately.", " class InlineAsyncTaskRunner : public AsyncTaskRunner {", "  public:", "@@ -588,7 +612,7 @@ TEST(ExecutableTest, AsyncMemrefArg) {", "   AsyncValueRef<OwnedMemref> result =", "       MakeConstructedAsyncValueRef<OwnedMemref>();", "   ResultConverterSet converter(AssertNoError,", "-                               ReturnAsyncMemref{result.AsPtr()});", "+                               ReturnAsyncOwnedMemref{result.AsPtr()});", "   std::vector<float> input = {42.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0};", "   MemrefDesc memref{", "       PrimitiveType::F32, input.data(), 0, {4, 2}, {4, 2} /*fake strides*/};", "@@ -626,7 +650,7 @@ TEST(ExecutableTest, AsyncMemrefRet) {", "   AsyncValueRef<OwnedMemref> result =", "       MakeConstructedAsyncValueRef<OwnedMemref>();", "   ResultConverterSet converter(AssertNoError,", "-                               ReturnAsyncMemref{result.AsPtr()});", "+                               ReturnAsyncOwnedMemref{result.AsPtr()});", " ", "   ScalarArg arg0(static_cast<int64_t>(32));", " ", "@@ -639,6 +663,90 @@ TEST(ExecutableTest, AsyncMemrefRet) {", "   EXPECT_TRUE(std::all_of(data, data + 32, [](float v) { return v == 42.0f; }));", " }", " ", "+TEST(ExecutableTest, AsyncMemrefInputsAndRets) {", "+  absl::string_view module = R\"(", "+    func.func private @custom_call(%arg0: memref<2x2xf32>,", "+                                   %arg1: memref<2x2xf32>)", "+      attributes { rt.dynamic, rt.custom_call = \"test.double\" }", "+", "+    async.func @test(%input: !async.value<memref<2x2xf32>>,", "+                     %output: memref<2x2xf32>)", "+      -> !async.value<memref<2x2xf32>> {", "+      %token, %result = execute -> !async.value<memref<2x2xf32>> {", "+        %0 = async.await %input : !async.value<memref<2x2xf32>>", "+        func.call @custom_call(%0, %output)", "+            : (memref<2x2xf32>, memref<2x2xf32>) -> ()", "+        async.yield %output : memref<2x2xf32>", "+      }", "+      %1 = async.await %result : !async.value<memref<2x2xf32>>", "+      return %1 : memref<2x2xf32>", "+    }", "+  )\";", "+", "+  // Doubles every element in the array.", "+  auto test_double = [&](MemrefView input, MemrefView output) {", "+    float* in = reinterpret_cast<float*>(input.data);", "+    float* out = reinterpret_cast<float*>(output.data);", "+    for (int i = 0; i < 4; ++i) {", "+      out[i] = in[i] * 2;", "+    }", "+    return success();", "+  };", "+", "+  CustomCallRegistry registry = {[&](DynamicCustomCallRegistry& registry) {", "+    registry.Register(CustomCall::Bind(\"test.double\")", "+                          .Arg<MemrefView>()  // input", "+                          .Arg<MemrefView>()  // output", "+                          .To(test_double));", "+  }};", "+", "+  // Allocates storage and sets the initial data.", "+  // In this test case, this buffer is shared across all inputs and outputs,", "+  // which mimics the buffer reuse behavior in XLA.", "+  std::array<float, 4> storage = {1.0, 2.0, 3.0, 4.0};", "+  std::array<int64_t, 2> sizes = {2, 2};", "+  const auto& fake_strides = sizes;", "+", "+  // Constructs inputs and output for the first run.", "+  AsyncValueRef<MemrefDesc> input_1 =", "+      tsl::MakeAvailableAsyncValueRef<MemrefDesc>(", "+          PrimitiveType::F32, storage.data(), 0, sizes, fake_strides);", "+  // Wraps the output fed in the parameter packs as an async output.", "+  auto result_1 = MakeConstructedAsyncValueRef<MemrefDesc>(", "+      PrimitiveType::F32, storage.data(), 0, sizes, fake_strides);", "+  ResultConverterSet first_converter(AssertNoError,", "+                                     ReturnAsyncMemrefDesc{result_1.AsPtr()});", "+", "+  Arguments<AsyncMemrefArg, MemrefDesc> args_1(2);", "+  args_1.emplace_back(AsyncMemrefArg(input_1));", "+  args_1.push_back(", "+      MemrefDesc(PrimitiveType::F32, storage.data(), 0, sizes, fake_strides));", "+", "+  LazyAsyncTaskRunner runner;", "+  auto exec_ref =", "+      CompileAndExecute(module, args_1, first_converter, &runner, registry,", "+                        /*use_lazy_runner=*/true);", "+  ASSERT_TRUE(exec_ref.ok());", "+  result_1.AndThen([exec_ref = *std::move(exec_ref)] {});", "+", "+  // Constructs inputs and output for the second run.", "+  auto result_2 = MakeConstructedAsyncValueRef<MemrefDesc>(", "+      MemrefDesc(PrimitiveType::F32, storage.data(), 0, sizes, fake_strides));", "+  ResultConverterSet second_converter(AssertNoError,", "+                                      ReturnAsyncMemrefDesc{result_2.AsPtr()});", "+  Arguments<AsyncMemrefArg, MemrefDesc> args_2(2);", "+  args_2.emplace_back(AsyncMemrefArg(result_1));", "+  args_2.push_back(", "+      MemrefDesc(PrimitiveType::F32, storage.data(), 0, sizes, fake_strides));", "+  exec_ref =", "+      CompileAndExecute(module, args_2, second_converter, &runner, registry,", "+                        /*use_lazy_runner=*/true);", "+  result_2.AndThen([exec_ref = *std::move(exec_ref)] {});", "+  tsl::BlockUntilReady(result_2.GetAsyncValue());", "+", "+  EXPECT_THAT(storage, testing::ElementsAre(4.0, 8.0, 12.0, 16.0));", "+}", "+", " TEST(ExecutableTest, AsyncWaiting) {", "   absl::string_view module = R\"(", "     async.func @test2(%arg0: i32, %arg1: i32) -> !async.value<i32> {", "@@ -26,6 +26,7 @@ limitations under the License.", " #include \"tensorflow/core/common_runtime/function_optimization_registry.h\"", " #include \"tensorflow/core/common_runtime/function_utils.h\"", " #include \"tensorflow/core/common_runtime/optimization_registry.h\"", "+#include \"tensorflow/core/common_runtime/optimized_function_graph_info.h\"", " #include \"tensorflow/core/common_runtime/partitioning_utils.h\"", " #include \"tensorflow/core/common_runtime/placer.h\"", " #include \"tensorflow/core/common_runtime/replicate_per_replica_nodes.h\"", "@@ -342,7 +343,10 @@ StatusOr<OptimizedFunctionGraphInfo> OptimizeFunctionGraph(", "     const FunctionLibraryRuntime::InstantiateOptions& options,", "     const DeviceSet& dev_set, const FunctionLibraryDefinition* input_lib_def,", "     const std::vector<CompositeDevice*>& composite_devices, Device* cpu_device,", "-    Device* default_device, Env* env) {", "+    Device* default_device, Env* env,", "+    OptimizedFunctionGraphInfo::Source optimization_source) {", "+  const uint64_t graph_optimization_start_time_usesc =", "+      Env::Default()->NowMicros();", "   const FunctionLibraryDefinition* lib_def =", "       options.lib_def == nullptr ? input_lib_def : options.lib_def;", " ", "@@ -495,12 +499,17 @@ StatusOr<OptimizedFunctionGraphInfo> OptimizeFunctionGraph(", " ", "   graph->mutable_flib_def()->set_default_registry(nullptr);", "   graph->mutable_flib_def()->Clear();", "+  const uint64_t graph_optimization_duration_secs =", "+      (Env::Default()->NowMicros() - graph_optimization_start_time_usesc) /", "+      1000000;", "   return OptimizedFunctionGraphInfo{function_name,", "                                     std::move(graph),", "                                     std::move(reachable_lib_def),", "                                     node_name_to_control_ret,", "                                     std::move(ret_types),", "-                                    ret_nodes.size()};", "+                                    ret_nodes.size(),", "+                                    graph_optimization_duration_secs,", "+                                    optimization_source};", " }", " ", " StatusOr<std::unique_ptr<std::unordered_map<string, std::unique_ptr<Graph>>>>", "@@ -59,7 +59,8 @@ StatusOr<OptimizedFunctionGraphInfo> OptimizeFunctionGraph(", "     const FunctionLibraryRuntime::InstantiateOptions& options,", "     const DeviceSet& dev_set, const FunctionLibraryDefinition* input_lib_def,", "     const std::vector<CompositeDevice*>& composite_devices, Device* cpu_device,", "-    Device* default_device, Env* env);", "+    Device* default_device, Env* env,", "+    OptimizedFunctionGraphInfo::Source source);", " ", " // Pre-processes, partitions and post-optimizes the input graph; returns", " // subgraph result (maps from device name to the subgraph); returns error if any", "@@ -24,6 +24,7 @@ limitations under the License.", " #include \"tensorflow/core/common_runtime/device_factory.h\"", " #include \"tensorflow/core/common_runtime/device_set.h\"", " #include \"tensorflow/core/common_runtime/function_testlib.h\"", "+#include \"tensorflow/core/common_runtime/optimized_function_graph_info.h\"", " #include \"tensorflow/core/platform/test.h\"", " #include \"tensorflow/core/public/session_options.h\"", " #include \"tensorflow/tsl/lib/core/status_test_util.h\"", "@@ -62,10 +63,10 @@ TEST(OptimizeFunctionGraphTest,", " ", "   // Try to optimize a function called \"FindDevice\" which does not exist in", "   // library.", "-  const StatusOr<OptimizedFunctionGraphInfo> aot_result =", "-      OptimizeFunctionGraph(\"FindDevice\", {}, opts, device_set, lib_def.get(),", "-                            /*composite_devices=*/{}, devices[0].get(),", "-                            devices[0].get(), Env::Default());", "+  const StatusOr<OptimizedFunctionGraphInfo> aot_result = OptimizeFunctionGraph(", "+      \"FindDevice\", {}, opts, device_set, lib_def.get(),", "+      /*composite_devices=*/{}, devices[0].get(), devices[0].get(),", "+      Env::Default(), OptimizedFunctionGraphInfo::kAot);", "   EXPECT_TRUE(errors::IsInvalidArgument(aot_result.status()))", "       << \"Actual status: \" << aot_result.status();", "   EXPECT_TRUE(absl::StrContains(aot_result.status().error_message(),", "@@ -91,16 +92,17 @@ TEST(OptimizeFunctionGraphTest, OptimizeFunctionGraphReturnsCorrectResult) {", "     device_set.AddDevice(device.get());", "   }", " ", "-  const StatusOr<OptimizedFunctionGraphInfo> aot_result =", "-      OptimizeFunctionGraph(\"FindDevice\", {}, opts, device_set, lib_def.get(),", "-                            /*composite_devices=*/{}, devices[0].get(),", "-                            devices[1].get(), Env::Default());", "+  const StatusOr<OptimizedFunctionGraphInfo> aot_result = OptimizeFunctionGraph(", "+      \"FindDevice\", {}, opts, device_set, lib_def.get(),", "+      /*composite_devices=*/{}, devices[0].get(), devices[1].get(),", "+      Env::Default(), OptimizedFunctionGraphInfo::kAot);", "   TF_EXPECT_OK(aot_result.status());", "   EXPECT_EQ(aot_result->name, \"FindDevice\");", "   // FindDevice function has one return node.", "   EXPECT_EQ(aot_result->num_return_nodes, 1);", "   // Return node type is string.", "   EXPECT_THAT(aot_result->ret_types, ElementsAre(DT_STRING));", "+  EXPECT_EQ(aot_result->source, OptimizedFunctionGraphInfo::kAot);", " }", " ", " }  // namespace", "@@ -31,6 +31,15 @@ namespace tensorflow {", " // converted to and from", " // third_party/tensorflow/core/framework/optimized_function_graph.proto.", " struct OptimizedFunctionGraphInfo {", "+  // enum for distinguishing the origin where the proto is created.", "+  //", "+  // kAot: proto is created in ahead-of-time environment, which can be different", "+  // from the environment where the graph is actually executed.", "+  //", "+  // kJit: proto is created in just-in-time execution, which has the same", "+  // environment as the one the graph is actually executed.", "+  enum Source { kAot, kJit };", "+", "   // Function name.", "   string name;", "   // Optimized function graph.", "@@ -43,6 +52,10 @@ struct OptimizedFunctionGraphInfo {", "   DataTypeVector ret_types;", "   // Number of return nodes.", "   size_t num_return_nodes;", "+  // Time spent on running the graph optimization passes for this funciton.", "+  uint64_t optimization_time_sec;", "+  // Indicates the source environment where this proto is generated.", "+  Source source;", " ", "   // Converts from the struct to OptimizedFunctionGraph proto.", "   static OptimizedFunctionGraph ToProto(const OptimizedFunctionGraphInfo& info);", "@@ -32,6 +32,7 @@ limitations under the License.", " #include \"tensorflow/core/common_runtime/int32_fulltype.h\"", " #include \"tensorflow/core/common_runtime/optimization_registry.h\"", " #include \"tensorflow/core/common_runtime/optimize_function_graph_utils.h\"", "+#include \"tensorflow/core/common_runtime/optimized_function_graph_info.h\"", " #include \"tensorflow/core/common_runtime/partitioning_utils.h\"", " #include \"tensorflow/core/common_runtime/placer.h\"", " #include \"tensorflow/core/common_runtime/rendezvous_util.h\"", "@@ -571,7 +572,8 @@ Status ProcessFunctionLibraryRuntime::InstantiateMultiDevice(", "       optimized_graph_proto == nullptr", "           ? OptimizeFunctionGraph(function_name, attrs, options, *dev_set,", "                                   lib_def_, composite_devices, cpu_device,", "-                                  default_device, env_)", "+                                  default_device, env_,", "+                                  OptimizedFunctionGraphInfo::kJit)", "           : OptimizedFunctionGraphInfo::FromProto(*optimized_graph_proto);", "   if (!optimized_graph_info.ok()) return optimized_graph_info.status();", " ", "@@ -932,8 +932,18 @@ void TrimOrGenerateStrategiesBasedOnExistingSharding(", "             }", "             // Set resharding cost to be 0 because there is only one choice and", "             // the cost do not matter.", "-            resharding_costs.push_back(std::vector<double>(", "-                strategy_map.at(operand)->leaf_vector.size(), 0.0));", "+            size_t resharding_costs_length;", "+            if (ins->opcode() == HloOpcode::kGetTupleElement) {", "+              CHECK(strategy_map.at(operand)->is_tuple);", "+              resharding_costs_length = strategy_map.at(operand)", "+                                            ->childs[ins->tuple_index()]", "+                                            ->leaf_vector.size();", "+            } else {", "+              resharding_costs_length =", "+                  strategy_map.at(operand)->leaf_vector.size();", "+            }", "+            resharding_costs.push_back(", "+                std::vector<double>(resharding_costs_length, 0.0));", "           }", "         }", "         double memory_cost =", "@@ -232,7 +232,8 @@ primitive types. In particular, the shape of a string Tensor dictates the number", " and arrangement of strings in the Tensor, with each element itself being a", " variable length string. In this sense, the (byte) size of the Tensor cannot be", " computed from the shape and type alone, and consequently strings cannot be", "-provided as a single, flat `ByteBuffer` argument.", "+provided as a single, flat `ByteBuffer` argument. You can see some examples in", "+this [page](https://www.tensorflow.org/lite/api_docs/java/org/tensorflow/lite/Interpreter).", " ", " If other data types, including boxed types like `Integer` and `Float`, are used,", " an `IllegalArgumentException` will be thrown.", "@@ -91,6 +91,7 @@ dtensor_test(", "     deps = [", "         \":test_util\",", "         \"//tensorflow/dtensor/python:api\",", "+        \"//tensorflow/dtensor/python:config\",", "         \"//tensorflow/dtensor/python:d_variable\",", "         \"//tensorflow/dtensor/python:dtensor_device\",", "         \"//tensorflow/dtensor/python:layout\",", "@@ -122,6 +123,7 @@ dtensor_test(", "     deps = [", "         \":test_util\",", "         \"//tensorflow/dtensor/python:api\",", "+        \"//tensorflow/dtensor/python:config\",", "         \"//tensorflow/dtensor/python:d_variable\",", "         \"//tensorflow/dtensor/python:dtensor_device\",", "         \"//tensorflow/dtensor/python:layout\",", "@@ -21,9 +21,11 @@ import numpy as np", " ", " # pylint: disable=g-direct-tensorflow-import", " from tensorflow.dtensor.python import api", "+from tensorflow.dtensor.python import config", " from tensorflow.dtensor.python import d_variable", " from tensorflow.dtensor.python import dtensor_device", " from tensorflow.dtensor.python import layout as layout_lib", "+from tensorflow.dtensor.python.tests import test_backend_util", " from tensorflow.dtensor.python.tests import test_util", " from tensorflow.python.eager.polymorphic_function import polymorphic_function", " from tensorflow.python.framework import constant_op", "@@ -192,7 +194,6 @@ class CollectiveTest(test_util.DTensorBaseTest):", " ", "   # Regression test for b/184401449.", "   def testDeviceIdTensorOnSplitHost(self):", "-    self.skipForPathways('Reason for failure is yet to be investigated.')", "     if not test_util.is_tpu_present():", "       self.skipTest('This test only runs on TPUs.')", "     self.skipForDeviceType(['TPU'],", "@@ -204,30 +205,31 @@ class CollectiveTest(test_util.DTensorBaseTest):", "     mesh = layout_lib.Mesh(_MESH_DIMS, global_ids, local_ids,", "                            test_util.create_device_list((2, 4), 'TPU'),", "                            'tpu_mesh')", "-    device = dtensor_device.DTensorDevice(meshes=[mesh])", "     # This works because on 2x2, global device IDs are equal to physical TPU", "     # core IDs: both are range(8). So local device IDs happen to be usable here.", "     # TODO(b/180046115): Add a device.get_tpu_core_ids method and translate", "     # device IDs to core IDs before setting the list here.", "-    device.set_tpu_core_ids('tpu_mesh', local_ids)", "+    if not config.backend_is_pw():", "+      device = dtensor_device.DTensorDevice(meshes=[mesh])", "+      device.set_tpu_core_ids('tpu_mesh', local_ids)", "+    else:", "+      test_backend_util.config_test_mesh(mesh)", "     layout_x = Layout.batch_sharded(mesh, _MESH_DIM_X, 2)", "     layout_y = Layout.batch_sharded(mesh, _MESH_DIM_Y, 2)", " ", "     # Create a 2x4 batch-sharded d-tensor, with batch IDs in its first column", "     # and zeros in other columns.", "-    # pylint: disable=g-complex-comprehension", "-    replica_ids = [", "-        constant_op.constant([loc[_MESH_DIM_X], 0, 0, 0],", "-                             dtype=dtypes.int32,", "-                             shape=[1, 4])", "-        for loc in mesh.local_device_locations()", "-    ]", "-    # pylint: enable=g-complex-comprehension", "-    replica_ids = device.pack(replica_ids, layout_x)", "+    replica_ids = constant_op.constant(", "+        np.array([[0, 0, 0, 0], [1, 0, 0, 0]]), dtype=dtypes.int32", "+    )", "+    replica_ids = api.relayout(replica_ids, layout_x)", " ", "     # Create a 4x4 y-sharded d-tensor filled with ones.", "-    ones = [array_ops.ones([1, 4], dtype=dtypes.int32)] * 8", "-    ones = device.pack(ones, layout_y)", "+    ones = constant_op.constant(", "+        np.array([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]),", "+        dtype=dtypes.int32,", "+    )", "+    ones = api.relayout(ones, layout_y)", " ", "     # If `a` has a layout of [x, unsharded], and `b` has a layout of", "     # [y, unsharded], the matmul will slice `a` to [x, y], do a local matmul,", "@@ -238,7 +240,7 @@ class CollectiveTest(test_util.DTensorBaseTest):", "     # function) to produce correct `begin` values for slicing `a`.", "     #", "     # Although this function only contains a single op, running it in op-by-op", "-    # mode doesn't produce the intented effect because the output of", "+    # mode doesn't produce the intended effect because the output of", "     # math_ops.matmul would have a layout of [y, unsharded] instead of", "     # [x, unsharded].", "     @polymorphic_function.function", "@@ -255,8 +257,8 @@ class CollectiveTest(test_util.DTensorBaseTest):", "         for loc in mesh.local_device_locations()", "     ]", " ", "-    self.assertEqual(device.fetch_layout(dtensor_result), layout_x)", "-    dtensor_result = [t.numpy() for t in device.unpack(dtensor_result)]", "+    self.assertEqual(api.fetch_layout(dtensor_result), layout_x)", "+    dtensor_result = [t.numpy() for t in api.unpack(dtensor_result)]", "     self.assertAllEqual(expected_result, dtensor_result)", " ", "   def testDifferentShapesBetweenCalls(self):", "@@ -768,13 +768,22 @@ struct PJRT_Chunk {", " // `xla::CopyToDeviceStream`.", " typedef struct PJRT_CopyToDeviceStream PJRT_CopyToDeviceStream;", " ", "-// Returns bool because the caller can't create PJRT_Error, which should be", "-// returned by C API only. False indicates an error. The callback must call", "+struct PJRT_TransferMetadata;", "+", "+// Returns PJRT_Error* with an error status. The status carries a callback's", "+// error status code and message.", "+typedef PJRT_Error* (*PJRT_CallbackError)(PJRT_Error_Code code,", "+                                          const char* message,", "+                                          size_t message_size);", "+", "+// Returns PJRT_Error* created by PJRT_CallbackError in case of error.", "+// Otherwise, returns nullptr. The callback must call", " // `chunk->deleter(chunk->data, chunk->deleter_arg)` when it's finished with", " // `chunk`.", "-// TODO(b/267255088) need to bubble up the callback error message to the caller.", "-typedef bool (*PJRT_SendCallback)(PJRT_Chunk* chunk, size_t total_size_in_bytes,", "-                                  bool done, void* user_arg);", "+typedef PJRT_Error* (*PJRT_SendCallback)(PJRT_Chunk* chunk,", "+                                         PJRT_CallbackError* callback_error,", "+                                         size_t total_size_in_bytes, bool done,", "+                                         void* user_arg);", " typedef void (*PJRT_RecvCallback)(PJRT_CopyToDeviceStream* stream,", "                                   void* user_arg);", " ", "@@ -716,14 +716,23 @@ static xla::SendCallback CSendCallbackToCpp(", "           xla::PjRtChunk input, size_t total_size_in_bytes,", "           bool done) -> xla::Status {", "         PJRT_Chunk c_chunk = ConvertFromCppChunk(std::move(input));", "-", "-        // TODO(b/267255088) retrieve up the callback error message.", "-        bool success = callback(&c_chunk, total_size_in_bytes, done, user_arg);", "-        if (success) {", "+        // PJRT_CallbackError creates PJRT_Error in the implementation, but", "+        // using the caller's callback status code & message. This way, the", "+        // caller avoids creating PJRT_Error itself, and the PJRT_Error is fully", "+        // managed in the implementation layer.", "+        PJRT_CallbackError c_callback_error =", "+            [](PJRT_Error_Code code, const char* message, size_t message_size) {", "+              return new PJRT_Error{", "+                  xla::Status(static_cast<absl::StatusCode>(code),", "+                              std::string(message, message_size))};", "+            };", "+", "+        std::unique_ptr<PJRT_Error> error(callback(", "+            &c_chunk, &c_callback_error, total_size_in_bytes, done, user_arg));", "+        if (error == nullptr) {", "           return tsl::OkStatus();", "         }", "-        return xla::Status(absl::StatusCode::kUnknown,", "-                           \"PJRT_SendCallback returned false (error).\");", "+        return error->status;", "       }};", " }", " ", "@@ -739,9 +739,10 @@ Convert2DCBuffersToCppBuffers(PJRT_Buffer*** c_lists, size_t outer_size,", " PJRT_SendCallbackInfo CppSendCallbackToC(", "     const xla::SendCallback& cpp_send_callback,", "     PjRtCApiLoadedExecutable::SendCallbackFunction* send_callback_function) {", "-  *send_callback_function = [&send_callback = cpp_send_callback.callback](", "-                                PJRT_Chunk* chunk, size_t total_size_in_bytes,", "-                                bool done) -> bool {", "+  *send_callback_function =", "+      [&send_callback = cpp_send_callback.callback](", "+          PJRT_Chunk* chunk, PJRT_CallbackError* callback_error,", "+          size_t total_size_in_bytes, bool done) -> PJRT_Error* {", "     // PJRT C API doesn't support", "     // use_major_to_minor_data_layout_for_callbacks = false", "     xla::Shape dummy_shape;", "@@ -749,16 +750,18 @@ PJRT_SendCallbackInfo CppSendCallbackToC(", "                                        ::pjrt::ConvertToCppChunk(*chunk),", "                                        total_size_in_bytes, done);", "     if (!status.ok()) {", "-      return false;", "+      return (*callback_error)(pjrt::StatusCodeToPjrtErrorCode(status.code()),", "+                               status.error_message().data(),", "+                               status.error_message().size());", "     }", "-    return true;", "+    return nullptr;", "   };", "   return PJRT_SendCallbackInfo{", "       /*channel_id=*/cpp_send_callback.channel_id,", "       /*user_arg=*/send_callback_function,", "       /*send_callback=*/", "-      [](PJRT_Chunk* chunk, size_t total_size_in_bytes, bool done,", "-         void* user_arg) -> bool {", "+      [](PJRT_Chunk* chunk, PJRT_CallbackError* callback_error,", "+         size_t total_size_in_bytes, bool done, void* user_arg) -> PJRT_Error* {", "         // PJRT_SendCallback, `send_callback` is internal C interface callback", "         // representation that cpatures the client C++ callback in void*", "         // `user_arg` and reinterprets in the lower-level runtime for execution.", "@@ -767,7 +770,8 @@ PJRT_SendCallbackInfo CppSendCallbackToC(", "         PjRtCApiLoadedExecutable::SendCallbackFunction* send_callback =", "             reinterpret_cast<PjRtCApiLoadedExecutable::SendCallbackFunction*>(", "                 user_arg);", "-        return (*send_callback)(chunk, total_size_in_bytes, done);", "+        return (*send_callback)(chunk, callback_error, total_size_in_bytes,", "+                                done);", "       }};", " }", " ", "@@ -414,7 +414,8 @@ class PjRtCApiLoadedExecutable : public PjRtLoadedExecutable {", "   bool IsReturnedFutureSupported() const override { return true; }", " ", "   // std::function version of PJRT_SendCallback", "-  using SendCallbackFunction = std::function<bool(PJRT_Chunk*, size_t, bool)>;", "+  using SendCallbackFunction = std::function<PJRT_Error*(", "+      PJRT_Chunk*, PJRT_CallbackError*, size_t, bool)>;", "   // std::function version of PJRT_RecvCallback", "   using RecvCallbackFunction = std::function<void(PJRT_CopyToDeviceStream*)>;", " ", "@@ -26,7 +26,6 @@ limitations under the License.", " #include \"tensorflow/core/common_runtime/function_optimization_registry.h\"", " #include \"tensorflow/core/common_runtime/function_utils.h\"", " #include \"tensorflow/core/common_runtime/optimization_registry.h\"", "-#include \"tensorflow/core/common_runtime/optimized_function_graph_info.h\"", " #include \"tensorflow/core/common_runtime/partitioning_utils.h\"", " #include \"tensorflow/core/common_runtime/placer.h\"", " #include \"tensorflow/core/common_runtime/replicate_per_replica_nodes.h\"", "@@ -343,10 +342,7 @@ StatusOr<OptimizedFunctionGraphInfo> OptimizeFunctionGraph(", "     const FunctionLibraryRuntime::InstantiateOptions& options,", "     const DeviceSet& dev_set, const FunctionLibraryDefinition* input_lib_def,", "     const std::vector<CompositeDevice*>& composite_devices, Device* cpu_device,", "-    Device* default_device, Env* env,", "-    OptimizedFunctionGraphInfo::Source optimization_source) {", "-  const uint64_t graph_optimization_start_time_usesc =", "-      Env::Default()->NowMicros();", "+    Device* default_device, Env* env) {", "   const FunctionLibraryDefinition* lib_def =", "       options.lib_def == nullptr ? input_lib_def : options.lib_def;", " ", "@@ -499,17 +495,12 @@ StatusOr<OptimizedFunctionGraphInfo> OptimizeFunctionGraph(", " ", "   graph->mutable_flib_def()->set_default_registry(nullptr);", "   graph->mutable_flib_def()->Clear();", "-  const uint64_t graph_optimization_duration_secs =", "-      (Env::Default()->NowMicros() - graph_optimization_start_time_usesc) /", "-      1000000;", "   return OptimizedFunctionGraphInfo{function_name,", "                                     std::move(graph),", "                                     std::move(reachable_lib_def),", "                                     node_name_to_control_ret,", "                                     std::move(ret_types),", "-                                    ret_nodes.size(),", "-                                    graph_optimization_duration_secs,", "-                                    optimization_source};", "+                                    ret_nodes.size()};", " }", " ", " StatusOr<std::unique_ptr<std::unordered_map<string, std::unique_ptr<Graph>>>>", "@@ -59,8 +59,7 @@ StatusOr<OptimizedFunctionGraphInfo> OptimizeFunctionGraph(", "     const FunctionLibraryRuntime::InstantiateOptions& options,", "     const DeviceSet& dev_set, const FunctionLibraryDefinition* input_lib_def,", "     const std::vector<CompositeDevice*>& composite_devices, Device* cpu_device,", "-    Device* default_device, Env* env,", "-    OptimizedFunctionGraphInfo::Source source);", "+    Device* default_device, Env* env);", " ", " // Pre-processes, partitions and post-optimizes the input graph; returns", " // subgraph result (maps from device name to the subgraph); returns error if any", "@@ -24,7 +24,6 @@ limitations under the License.", " #include \"tensorflow/core/common_runtime/device_factory.h\"", " #include \"tensorflow/core/common_runtime/device_set.h\"", " #include \"tensorflow/core/common_runtime/function_testlib.h\"", "-#include \"tensorflow/core/common_runtime/optimized_function_graph_info.h\"", " #include \"tensorflow/core/platform/test.h\"", " #include \"tensorflow/core/public/session_options.h\"", " #include \"tensorflow/tsl/lib/core/status_test_util.h\"", "@@ -63,10 +62,10 @@ TEST(OptimizeFunctionGraphTest,", " ", "   // Try to optimize a function called \"FindDevice\" which does not exist in", "   // library.", "-  const StatusOr<OptimizedFunctionGraphInfo> aot_result = OptimizeFunctionGraph(", "-      \"FindDevice\", {}, opts, device_set, lib_def.get(),", "-      /*composite_devices=*/{}, devices[0].get(), devices[0].get(),", "-      Env::Default(), OptimizedFunctionGraphInfo::kAot);", "+  const StatusOr<OptimizedFunctionGraphInfo> aot_result =", "+      OptimizeFunctionGraph(\"FindDevice\", {}, opts, device_set, lib_def.get(),", "+                            /*composite_devices=*/{}, devices[0].get(),", "+                            devices[0].get(), Env::Default());", "   EXPECT_TRUE(errors::IsInvalidArgument(aot_result.status()))", "       << \"Actual status: \" << aot_result.status();", "   EXPECT_TRUE(absl::StrContains(aot_result.status().error_message(),", "@@ -92,17 +91,16 @@ TEST(OptimizeFunctionGraphTest, OptimizeFunctionGraphReturnsCorrectResult) {", "     device_set.AddDevice(device.get());", "   }", " ", "-  const StatusOr<OptimizedFunctionGraphInfo> aot_result = OptimizeFunctionGraph(", "-      \"FindDevice\", {}, opts, device_set, lib_def.get(),", "-      /*composite_devices=*/{}, devices[0].get(), devices[1].get(),", "-      Env::Default(), OptimizedFunctionGraphInfo::kAot);", "+  const StatusOr<OptimizedFunctionGraphInfo> aot_result =", "+      OptimizeFunctionGraph(\"FindDevice\", {}, opts, device_set, lib_def.get(),", "+                            /*composite_devices=*/{}, devices[0].get(),", "+                            devices[1].get(), Env::Default());", "   TF_EXPECT_OK(aot_result.status());", "   EXPECT_EQ(aot_result->name, \"FindDevice\");", "   // FindDevice function has one return node.", "   EXPECT_EQ(aot_result->num_return_nodes, 1);", "   // Return node type is string.", "   EXPECT_THAT(aot_result->ret_types, ElementsAre(DT_STRING));", "-  EXPECT_EQ(aot_result->source, OptimizedFunctionGraphInfo::kAot);", " }", " ", " }  // namespace", "@@ -31,15 +31,6 @@ namespace tensorflow {", " // converted to and from", " // third_party/tensorflow/core/framework/optimized_function_graph.proto.", " struct OptimizedFunctionGraphInfo {", "-  // enum for distinguishing the origin where the proto is created.", "-  //", "-  // kAot: proto is created in ahead-of-time environment, which can be different", "-  // from the environment where the graph is actually executed.", "-  //", "-  // kJit: proto is created in just-in-time execution, which has the same", "-  // environment as the one the graph is actually executed.", "-  enum Source { kAot, kJit };", "-", "   // Function name.", "   string name;", "   // Optimized function graph.", "@@ -52,10 +43,6 @@ struct OptimizedFunctionGraphInfo {", "   DataTypeVector ret_types;", "   // Number of return nodes.", "   size_t num_return_nodes;", "-  // Time spent on running the graph optimization passes for this funciton.", "-  uint64_t optimization_time_sec;", "-  // Indicates the source environment where this proto is generated.", "-  Source source;", " ", "   // Converts from the struct to OptimizedFunctionGraph proto.", "   static OptimizedFunctionGraph ToProto(const OptimizedFunctionGraphInfo& info);", "@@ -32,7 +32,6 @@ limitations under the License.", " #include \"tensorflow/core/common_runtime/int32_fulltype.h\"", " #include \"tensorflow/core/common_runtime/optimization_registry.h\"", " #include \"tensorflow/core/common_runtime/optimize_function_graph_utils.h\"", "-#include \"tensorflow/core/common_runtime/optimized_function_graph_info.h\"", " #include \"tensorflow/core/common_runtime/partitioning_utils.h\"", " #include \"tensorflow/core/common_runtime/placer.h\"", " #include \"tensorflow/core/common_runtime/rendezvous_util.h\"", "@@ -572,8 +571,7 @@ Status ProcessFunctionLibraryRuntime::InstantiateMultiDevice(", "       optimized_graph_proto == nullptr", "           ? OptimizeFunctionGraph(function_name, attrs, options, *dev_set,", "                                   lib_def_, composite_devices, cpu_device,", "-                                  default_device, env_,", "-                                  OptimizedFunctionGraphInfo::kJit)", "+                                  default_device, env_)", "           : OptimizedFunctionGraphInfo::FromProto(*optimized_graph_proto);", "   if (!optimized_graph_info.ok()) return optimized_graph_info.status();", " ", "@@ -2412,7 +2412,6 @@ tf_xla_py_test(", "     deps = [", "         \":xla_test\",", "         \"//tensorflow/compiler/tf2xla/python:xla\",", "-        \"//tensorflow/compiler/xla/python:xla_extension\",", "         \"//tensorflow/python:framework\",", "         \"//tensorflow/python:platform_test\",", "         \"//tensorflow/python:training\",", "@@ -31,14 +31,10 @@ from tensorflow.python.platform import googletest", " ", " def serialize(module_str: str) -> Tuple[str, int]:", "   # TODO(b/274838200): error importing xla_extension in OSS", "-  try:", "-    from tensorflow.compiler.xla.python import xla_extension  # pylint: disable=g-import-not-at-top", "-  except ImportError:", "-    return module_str, 3", "-", "-  target_version = '0.9.0'  # TODO(gleasonk): use APIs to get this", "-  return xla_extension.mlir.serialize_portable_artifact(", "-      module_str, target_version), 4", "+  # target_version = '0.9.0'  # TODO(gleasonk): use APIs to get this", "+  # return xla_extension.mlir.serialize_portable_artifact(", "+  #     module_str, target_version), 4", "+  return module_str, 3", " ", " ", " class XlaCallModuleOpTest(xla_test.XLATestCase):", "@@ -64,7 +64,7 @@ const int VERSION_START_PLATFORMS = 3;", " // Version 4 supports StableHLO with compatibility guarantees.", " // Used from 03/2023.", " const int VERSION_START_STABLE_HLO_COMPATIBILITY = 4;", "-const int VERSION_MINIMUM_SUPPORTED = VERSION_START_PLATFORMS;", "+const int VERSION_MINIMUM_SUPPORTED = VERSION_START_STABLE_HLO;", " const int VERSION_MAXIMUM_SUPPORTED = VERSION_START_STABLE_HLO_COMPATIBILITY;", " ", " // Computes a dimension value from the dim_arg specification.", "@@ -190,7 +190,7 @@ NodeColors NodeColorsForScheme(ColorScheme color) {", "     case kRed:", "       return NodeColors{\"filled\", \"#ffcdd2\", \"#cb9ca1\", \"black\"};", "     case kWhite:", "-      return NodeColors{\"filled\", \"white\", \"black\", \"black\"};", "+      return NodeColors{\"filled\", \"white\", \"#9e9e9e\", \"black\"};", "     case kYellow:", "       return NodeColors{\"filled\", \"#fff9c4\", \"#cbc693\", \"black\"};", "     case kDashedBorder:", "@@ -1024,6 +1024,7 @@ ColorScheme HloDotDumper::GetInstructionColor(const HloInstruction* instr) {", "     case HloOpcode::kXor:", "     case HloOpcode::kPower:", "     case HloOpcode::kReal:", "+    case HloOpcode::kReducePrecision:", "     case HloOpcode::kRemainder:", "     case HloOpcode::kRng:", "     case HloOpcode::kRngGetAndUpdateState:", "@@ -1046,52 +1047,30 @@ ColorScheme HloDotDumper::GetInstructionColor(const HloInstruction* instr) {", "     case HloOpcode::kSubtract:", "     case HloOpcode::kTan:", "     case HloOpcode::kTanh:", "-      // De-emphasize scalar-shaped elementwise ops -- they're generally", "-      // uninteresting.", "-      if (ShapeUtil::IsEffectiveScalar(instr->shape())) {", "-        return kWhite;", "-      }", "-      return kYellow;", "-    case HloOpcode::kBitcast:", "-    case HloOpcode::kGetTupleElement:", "-    case HloOpcode::kAfterAll:", "+      return kWhite;", "     case HloOpcode::kAddDependency:", "-    case HloOpcode::kTuple:", "+    case HloOpcode::kAfterAll:", "+    case HloOpcode::kGetTupleElement:", "     case HloOpcode::kOptimizationBarrier:", "+    case HloOpcode::kPad:", "+    case HloOpcode::kTuple:", "       return kWhite;", "     case HloOpcode::kConstant:", "       // Constants aren't usually shown as their own nodes, but they'll be", "       // present if e.g. they're the root of a computation.", "       return kWhite;", "     case HloOpcode::kBroadcast:", "-      // De-emphasize nodes which broadcast a scalar within a fusion node --", "-      // these are essentially free.", "-      if (instr->IsFused() &&", "-          ShapeUtil::IsEffectiveScalar(instr->operand(0)->shape())) {", "-        return kWhite;", "-      }", "-      return kGreen;", "+    case HloOpcode::kDynamicUpdateSlice:", "+      return kYellow;", "     case HloOpcode::kConcatenate:", "     case HloOpcode::kDynamicSlice:", "-    case HloOpcode::kGather:", "-    case HloOpcode::kPad:", "     case HloOpcode::kReshape:", "     case HloOpcode::kDynamicReshape:", "     case HloOpcode::kReverse:", "     case HloOpcode::kTranspose:", "-      // De-emphasize scalar-shaped data movement ops and all data movement ops", "-      // inside fusion nodes, both of which are essentially free.", "-      if (ShapeUtil::IsEffectiveScalar(instr->shape()) || instr->IsFused()) {", "-        return kWhite;", "-      }", "-      return kGreen;", "-    case HloOpcode::kDynamicUpdateSlice:", "-      // Unlike the data-movement ops above, dynamic-update-slice is not ~free", "-      // inside of fusion nodes, so we de-emphasize it only if it's", "-      // scalar-shaped.", "-      if (ShapeUtil::IsEffectiveScalar(instr->shape())) {", "-        return kWhite;", "-      }", "+      // These data-movement ops can be expensive; emphasize them.  (Yes, even", "+      // concat can be expensive, at least on GPU, as it can create warp", "+      // divergence.)", "       return kGreen;", "     case HloOpcode::kCopy:", "     case HloOpcode::kCopyStart:", "@@ -1099,6 +1078,13 @@ ColorScheme HloDotDumper::GetInstructionColor(const HloInstruction* instr) {", "       // Emphasize copy nodes, which are either physical transposes (and thus", "       // significant), or copies of read-only buffers (and thus dead weight).", "       return kGreen;", "+    case HloOpcode::kBitcast:", "+      // Unfused bitcast is free, but fused bitcast should count as a non-free", "+      // data-movement op (e.g. requires linearization of indices on GPU).", "+      if (!instr->IsFused()) {", "+        return kWhite;", "+      }", "+      return kGreen;", "     case HloOpcode::kAsyncStart:", "     case HloOpcode::kAsyncUpdate:", "     case HloOpcode::kAsyncDone:", "@@ -1109,8 +1095,6 @@ ColorScheme HloDotDumper::GetInstructionColor(const HloInstruction* instr) {", "     case HloOpcode::kTriangularSolve:", "     case HloOpcode::kCholesky:", "       return kDarkBlue;", "-    case HloOpcode::kReducePrecision:", "-      return kRed;", "     case HloOpcode::kParameter:", "       return parameter_color;", "     case HloOpcode::kBatchNormGrad:", "@@ -1120,6 +1104,7 @@ ColorScheme HloDotDumper::GetInstructionColor(const HloInstruction* instr) {", "     case HloOpcode::kReduceWindow:", "     case HloOpcode::kScatter:  // scatter is a kind of reduction", "     case HloOpcode::kSelectAndScatter:", "+    case HloOpcode::kGather:  // not a reduction, but goes with scatter", "       return kPurple;", "     case HloOpcode::kDomain:", "     case HloOpcode::kFusion:", "@@ -1,5 +1,5 @@", " load(\"//tensorflow:tensorflow.bzl\", \"if_google\", \"if_not_windows\", \"if_oss\", \"tf_cc_test\")", "-load(\"//tensorflow/lite:build_def.bzl\", \"tflite_cc_shared_object\", \"tflite_copts\", \"tflite_copts_warnings\", \"tflite_self_contained_libs_test_suite\")", "+load(\"//tensorflow/lite:build_def.bzl\", \"tflite_cc_shared_object\", \"tflite_copts\", \"tflite_copts_warnings\", \"tflite_linkopts_no_undefined\", \"tflite_self_contained_libs_test_suite\")", " load(\"//tensorflow/lite:special_rules.bzl\", \"SPECIAL_RULES_DEPS\", \"internal_visibility_allowlist\", \"tflite_portable_test_suite\")", " load(\"//tensorflow:tensorflow.default.bzl\", \"get_compatible_with_portable\")", " load(\"@bazel_skylib//:bzl_library.bzl\", \"bzl_library\")", "@@ -1307,13 +1307,12 @@ tflite_cc_shared_object(", "     # Until we have more granular symbol export for the C++ API on Windows,", "     # export all symbols.", "     features = [\"windows_export_all_symbols\"],", "-    linkopts = select({", "+    linkopts = tflite_linkopts_no_undefined() + select({", "         \"//tensorflow:macos\": [", "             \"-Wl,-exported_symbols_list,$(location //tensorflow/lite:tflite_exported_symbols.lds)\",", "         ],", "         \"//tensorflow:windows\": [],", "         \"//conditions:default\": [", "-            \"-Wl,-z,defs\",", "             \"-Wl,--version-script,$(location //tensorflow/lite:tflite_version_script.lds)\",", "         ],", "     }),", "@@ -1488,7 +1488,6 @@ cc_library(", "         \"gml_st/transforms/cpu_tiling/transform_conv_for_cpu.cc\",", "         \"gml_st/transforms/cpu_tiling/transform_dot_for_cpu.cc\",", "         \"gml_st/transforms/cpu_tiling/transform_elementwise_for_cpu.cc\",", "-        \"gml_st/transforms/cpu_tiling/transform_matmul_for_cpu.cc\",", "         \"gml_st/transforms/cpu_tiling/transform_mmt4d_for_cpu.cc\",", "         \"gml_st/transforms/cpu_tiling/transform_pack_for_cpu.cc\",", "         \"gml_st/transforms/cpu_tiling/transform_reduce_for_cpu.cc\",", "@@ -39,7 +39,6 @@ add_mlir_library(GmlStPasses", "   cpu_tiling/transform_conv_for_cpu.cc", "   cpu_tiling/transform_dot_for_cpu.cc", "   cpu_tiling/transform_elementwise_for_cpu.cc", "-  cpu_tiling/transform_matmul_for_cpu.cc", "   cpu_tiling/transform_mmt4d_for_cpu.cc", "   cpu_tiling/transform_pack_for_cpu.cc", "   cpu_tiling/transform_reduce_for_cpu.cc", "@@ -41,76 +41,6 @@ GmlStCPUTilingOptions getDefaultCPUPipelineOptions(StringRef cpuName,", "   return opts;", " }", " ", "-namespace {", "-", "-int64_t roundDownToPowerOfTwo(int64_t n) {", "-  if ((n & (n - 1)) == 0) return n;", "-  n |= n >> 1;", "-  n |= n >> 2;", "-  n |= n >> 4;", "-  n |= n >> 8;", "-  n |= n >> 16;", "-  n |= n >> 32;", "-  return (n + 1) >> 1;", "-}", "-", "-// Tiling heuristic that was tuned for static power-of-two sized shapes on", "-// Skylake.", "-MatmulSizes skylakeTilingHeuristic(MatmulSizes sizes) {", "-  if (sizes.m == 1) {", "-    return {1, sizes.n, 1};", "-  }", "-", "-  if (sizes.n == 1) {", "-    if (sizes.k <= 8) {", "-      return {1, 1, 1};", "-    }", "-    return {std::min<int64_t>(8, sizes.m), 1, 4};", "-  }", "-", "-  MatmulSizes result;", "-  result.k = sizes.k <= 8 ? 1 : 4;", "-  result.n = std::min<int64_t>(8, sizes.n) << (sizes.m <= 16 ? 1 : 0);", "-  result.m = std::min<int64_t>(32, sizes.m) << (sizes.n <= 4 ? 1 : 0);", "-  return result;", "-}", "-", "-// Tiling heuristic that was tuned for static power-of-two sized shapes on Zen", "-// v2 (\"Rome\").", "-MatmulSizes znver2TilingHeuristic(MatmulSizes sizes) {", "-  MatmulSizes result;", "-  result.k = sizes.n == 1 ? 8 : 1;", "-  if (sizes.n == 1) {", "-    result.m = sizes.k >= 32 ? 16 : 8;", "-  } else {", "-    result.m = sizes.n <= 8 ? 8 : 4;", "-  }", "-  if (sizes.m == 1) {", "-    result.n = std::min<int64_t>(64, sizes.n) * (sizes.k <= 64 ? 1 : 2);", "-  } else {", "-    result.n = std::min<int64_t>(16, sizes.n);", "-  }", "-  return result;", "-}", "-", "-std::function<MatmulSizes(MatmulSizes)> wrapHeuristic(", "-    const std::function<MatmulSizes(MatmulSizes)>& heuristic,", "-    MatmulSizes dynamicDefault) {", "-  return [=](MatmulSizes sizes) {", "-    if (sizes.n < 0 || sizes.m < 0 || sizes.k < 0) {", "-      return dynamicDefault;", "-    }", "-", "-    sizes.m = roundDownToPowerOfTwo(sizes.m);", "-    sizes.n = roundDownToPowerOfTwo(sizes.n);", "-    sizes.k = roundDownToPowerOfTwo(sizes.k);", "-", "-    return heuristic(sizes);", "-  };", "-}", "-", "-}  // namespace", "-", " void addCPUTilingPipeline(OpPassManager& pm,", "                           const GmlStCPUTilingOptions& options) {", "   using func::FuncOp;", "@@ -129,28 +59,15 @@ void addCPUTilingPipeline(OpPassManager& pm,", "     pm.addPass(createCSEPass());", "   }", " ", "-  if (options.lowerToMmt4d) {", "-    pm.addNestedPass<FuncOp>(createPackMatmulPass());", "-  }", "+  if (options.lowerToMmt4d) pm.addNestedPass<FuncOp>(createPackMatmulPass());", " ", "   pm.addNestedPass<FuncOp>(createTransformConvForCpuPass());", "   pm.addNestedPass<FuncOp>(createTransformScatterForCpuPass());", "   pm.addNestedPass<FuncOp>(createTransformReduceForCpuPass(", "       options.vectorSize, options.reduction1DTileSize,", "       options.reduction2DTileSizes));", "-  std::function<MatmulSizes(MatmulSizes)> tilingHeuristic;", "-  if (!options.matmulTileSizes.empty()) {", "-    MatmulSizes fixedSizes{options.matmulTileSizes[0],", "-                           options.matmulTileSizes[1],", "-                           options.matmulTileSizes[2]};", "-    tilingHeuristic = [=](MatmulSizes) { return fixedSizes; };", "-  } else {", "-    tilingHeuristic = options.cpuName.starts_with(\"znver\")", "-                          ? wrapHeuristic(znver2TilingHeuristic, {16, 8, 8})", "-                          : wrapHeuristic(skylakeTilingHeuristic, {16, 16, 4});", "-  }", "-  pm.addNestedPass<FuncOp>(createTransformDotForCpuPass(tilingHeuristic));", "-  pm.addNestedPass<FuncOp>(createTransformMatmulForCpuPass(tilingHeuristic));", "+  pm.addNestedPass<FuncOp>(", "+      createTransformDotForCpuPass(options.matmulTileSizes));", "   pm.addNestedPass<FuncOp>(createTransformMmt4DForCpuPass());", "   pm.addNestedPass<FuncOp>(createTransformPackForCpuPass());", "   pm.addNestedPass<FuncOp>(createTransformElementwiseForCpuPass(", "@@ -168,6 +85,8 @@ void addCPUTilingPipeline(OpPassManager& pm,", "   // Tile remaining ops by size one and scalarize what we can.", "   pm.addNestedPass<FuncOp>(createTileByOnePass());", "   pm.addNestedPass<FuncOp>(createScalarizationPass());", "+", "+  pm.addPass(createCanonicalizerPass());", " }", " ", " void addDefaultCPUTilingPipeline(OpPassManager& pm, StringRef cpuName,", "@@ -23,6 +23,7 @@ limitations under the License.", " #include <utility>", " ", " #include \"gml_st/IR/gml_st_ops.h\"", "+#include \"gml_st/transforms/fusion/fusion.h\"", " #include \"gml_st/transforms/passes.h\"", " #include \"gml_st/transforms/peeling/peeling.h\"", " #include \"gml_st/transforms/tiling/tiling.h\"", "@@ -38,6 +39,7 @@ limitations under the License.", " #include \"mlir/Dialect/Tensor/IR/TensorTilingInterfaceImpl.h\"", " #include \"mlir/Pass/Pass.h\"  // IWYU pragma: keep", " #include \"mlir/Transforms/GreedyPatternRewriteDriver.h\"", "+#include \"thlo/IR/thlo_ops.h\"", " ", " namespace mlir::gml_st {", " namespace {", "@@ -45,40 +47,90 @@ namespace {", " #define GEN_PASS_DEF_TRANSFORMDOTFORCPUPASS", " #include \"gml_st/transforms/passes.h.inc\"", " ", "-constexpr llvm::StringRef kDotTransformedLabel = \"__dot_transformed_label__\";", "+struct MatmulSizes {", "+  // [m, k] x [k, n]", "+  int64_t m;", "+  int64_t n;", "+  int64_t k;", "+};", " ", "-FailureOr<scf::SCFTilingResult> tileReductionDim(PatternRewriter &rewriter,", "-                                                 Operation *op,", "-                                                 ArrayRef<int64_t> tileSizes) {", "-  scf::SCFTilingOptions opts;", "-  opts.setTileSizes(tileSizes);", "+using MatmulTileSizeComputationFn = std::function<MatmulSizes(MatmulSizes)>;", "+", "+int64_t roundDownToPowerOfTwo(int64_t n) {", "+  if ((n & (n - 1)) == 0) return n;", "+  n |= n >> 1;", "+  n |= n >> 2;", "+  n |= n >> 4;", "+  n |= n >> 8;", "+  n |= n >> 16;", "+  n |= n >> 32;", "+  return (n + 1) >> 1;", "+}", " ", "-  auto tilingResult = scf::tileUsingSCFForOp(rewriter, op, opts);", "-  if (failed(tilingResult)) return failure();", "+// Tiling heuristic that was tuned for static power-of-two sized shapes on", "+// Skylake.", "+MatmulSizes skylakeTilingHeuristic(MatmulSizes sizes) {", "+  if (sizes.m == 1) {", "+    return {1, sizes.n, 1};", "+  }", " ", "-  // Update the results if tiling occurred.", "-  if (!tilingResult->loops.empty()) {", "-    rewriter.replaceOp(op, tilingResult->replacements);", "-    op = tilingResult->tiledOps.front();", "+  if (sizes.n == 1) {", "+    if (sizes.k <= 8) {", "+      return {1, 1, 1};", "+    }", "+    return {std::min<int64_t>(8, sizes.m), 1, 4};", "   }", " ", "-  setLabel(op, kDotTransformedLabel);", "-  return tilingResult;", "+  MatmulSizes result;", "+  result.k = sizes.k <= 8 ? 1 : 4;", "+  result.n = std::min<int64_t>(8, sizes.n) << (sizes.m <= 16 ? 1 : 0);", "+  result.m = std::min<int64_t>(32, sizes.m) << (sizes.n <= 4 ? 1 : 0);", "+  return result;", " }", " ", "-FailureOr<GMLSTTilingResult> tileParallelDims(PatternRewriter &rewriter,", "-                                              Operation *op,", "-                                              ArrayRef<int64_t> tileSizes) {", "-  auto tilingResult = tileUsingSCFForallOp(rewriter, cast<TilingInterface>(op),", "-                                           getSCFTilingOptions(tileSizes));", "-  if (failed(tilingResult)) return failure();", "-", "-  // Update the results if tiling occurred.", "-  if (tilingResult->loop != nullptr) {", "-    rewriter.replaceOp(op, tilingResult->loop->getResults());", "+// Tiling heuristic that was tuned for static power-of-two sized shapes on Zen", "+// v2 (\"Rome\").", "+MatmulSizes znver2TilingHeuristic(MatmulSizes sizes) {", "+  MatmulSizes result;", "+  result.k = sizes.n == 1 ? 8 : 1;", "+  if (sizes.n == 1) {", "+    result.m = sizes.k >= 32 ? 16 : 8;", "+  } else {", "+    result.m = sizes.n <= 8 ? 8 : 4;", "   }", "+  if (sizes.m == 1) {", "+    result.n = std::min<int64_t>(64, sizes.n) * (sizes.k <= 64 ? 1 : 2);", "+  } else {", "+    result.n = std::min<int64_t>(16, sizes.n);", "+  }", "+  return result;", "+}", "+", "+std::function<MatmulSizes(MatmulSizes)> wrapHeuristic(", "+    const std::function<MatmulSizes(MatmulSizes)> &heuristic,", "+    MatmulSizes dynamicDefault) {", "+  return [=](MatmulSizes sizes) {", "+    if (sizes.n < 0 || sizes.m < 0 || sizes.k < 0) {", "+      return dynamicDefault;", "+    }", " ", "-  return tilingResult;", "+    sizes.m = roundDownToPowerOfTwo(sizes.m);", "+    sizes.n = roundDownToPowerOfTwo(sizes.n);", "+    sizes.k = roundDownToPowerOfTwo(sizes.k);", "+", "+    return heuristic(sizes);", "+  };", "+}", "+", "+MatmulSizes getMatmulSizes(linalg::MatmulOp op) {", "+  // [m, k] x [k, n]", "+  ShapedType lhsTy = op->getOperand(0).getType().cast<ShapedType>();", "+  ShapedType rhsTy = op->getOperand(1).getType().cast<ShapedType>();", "+  MatmulSizes sizes;", "+  sizes.m = lhsTy.getDimSize(0);", "+  sizes.k = rhsTy.getDimSize(0);", "+  sizes.n = rhsTy.getDimSize(1);", "+  return sizes;", " }", " ", " MatmulSizes getMatmulSizes(linalg::VecmatOp op) {", "@@ -111,6 +163,11 @@ MatmulSizes getMatmulSizes(linalg::DotOp op) {", "   return sizes;", " }", " ", "+SmallVector<int64_t> dropZeros(ArrayRef<int64_t> tileSizes) {", "+  return to_vector(llvm::make_filter_range(", "+      tileSizes, [](int64_t size) { return size != 0; }));", "+}", "+", " /// Pattern to tile dot operations (linalg.matvec, linalg.vecmat, linalg.dot)", " /// and peel the generated loops.", " template <typename DotTy>", "@@ -129,7 +186,7 @@ struct DotTransformPattern : public OpRewritePattern<DotTy> {", " ", "   LogicalResult matchAndRewrite(DotTy dotOp,", "                                 PatternRewriter &rewriter) const override {", "-    if (hasLabel(dotOp, kDotTransformedLabel)) {", "+    if (hasLabel(dotOp, kTransformedLabel)) {", "       return rewriter.notifyMatchFailure(dotOp,", "                                          \"has already been transformed.\");", "     }", "@@ -137,40 +194,81 @@ struct DotTransformPattern : public OpRewritePattern<DotTy> {", "       return rewriter.notifyMatchFailure(", "           dotOp, \"has already been tiled by another pass.\");", "     }", "-", "+    auto producerFilterFn = [](Operation *op) {", "+      return isa<linalg::FillOp, thlo::ReverseOp, tensor::CastOp>(op);", "+    };", "+    auto consumerFilterFn = [](Operation *op) {", "+      if (auto mapOp = dyn_cast<linalg::MapOp>(op))", "+        return mapOp.getNumDpsInputs() == 1;", "+      return isa<thlo::ReverseOp>(op);", "+    };", "+", "+    auto cluster = getFusionCluster(dotOp, producerFilterFn, consumerFilterFn);", "+    auto fusionCluster = cluster.operations;", "+    auto *tilingRoot = cluster.root;", "+", "+    // First level tiling: parallel dimension.", "     auto tileSizes = tileSizeFn(getMatmulSizes(dotOp));", "-    auto tilingParallelDimsResult = tileParallelDims(", "-        rewriter, dotOp.getOperation(), parallelDimTileSizeFn(tileSizes));", "-    if (failed(tilingParallelDimsResult)) return failure();", "+    auto parallelDimsTileSizes = parallelDimTileSizeFn(tileSizes);", "+    if (!isa<DotTy>(tilingRoot))", "+      parallelDimsTileSizes = dropZeros(parallelDimsTileSizes);", " ", "-    scf::ForallOp forallOp = tilingParallelDimsResult->loop;", "-    if (forallOp != nullptr) {", "-      dotOp = cast<DotTy>(tilingParallelDimsResult->tiledOps.back());", "-    }", "-", "-    // Second level tiling: reduction dimension.", "-    auto tilingReductionDimResult = tileReductionDim(", "-        rewriter, dotOp.getOperation(), reductionDimTileSizeFn(tileSizes));", "-    if (failed(tilingReductionDimResult)) return failure();", "+    auto tilingParallelDimsResult = tileUsingSCFForallOpAndFuseGreedily(", "+        rewriter, tilingRoot, getSCFTilingOptions(parallelDimsTileSizes),", "+        [&](Operation *op) { return fusionCluster.contains(op); });", "+    if (failed(tilingParallelDimsResult)) return failure();", " ", "-    if (!tilingReductionDimResult->loops.empty()) {", "-      dotOp = cast<DotTy>(tilingReductionDimResult->tiledOps.back());", "+    if (!tilingParallelDimsResult->loop) {", "+      return tileAndPeelReductionDim(", "+          rewriter, dotOp, reductionDimTileSizeFn(tileSizes), producerFilterFn);", "     }", "-    // Peel parallel loops.", "-    if (forallOp != nullptr) {", "-      (void)peelAllLoops(forallOp, rewriter);", "+    auto peeledParallelLoop =", "+        peelAllLoops(tilingParallelDimsResult->loop, rewriter);", "+", "+    // Process main parallel loop.", "+    scf::ForallOp mainParallelLoop = peeledParallelLoop.mainLoop;", "+    if (mainParallelLoop) {", "+      auto tiledDotOp = *mainParallelLoop.getBody()->getOps<DotTy>().begin();", "+      if (failed(tileAndPeelReductionDim(rewriter, tiledDotOp,", "+                                         reductionDimTileSizeFn(tileSizes),", "+                                         producerFilterFn))) {", "+        return failure();", "+      }", "     }", " ", "-    // Peel reduction loop inside the main parallel loop, label the main loop as", "-    // \"perfectly tiled\" one, to enable vectorization after canonicalization.", "-    auto peelingResult =", "-        peelSCFForOp(rewriter, tilingReductionDimResult->loops.front());", "-    setLabel(peelingResult.mainLoop, kPerfectlyTiledLoopLabel);", "-", "+    // Process tail parallel loop.", "+    for (scf::ForallOp tailParallelLoop : peeledParallelLoop.tailLoops) {", "+      for (auto tiledDotOp : llvm::to_vector(", "+               tailParallelLoop.getBody()->template getOps<DotTy>())) {", "+        auto reductionDimTilingResult = tileUsingSCFForOpAndFuseGreedily(", "+            rewriter, tiledDotOp,", "+            getSCFTilingOptions(reductionDimTileSizeFn(tileSizes)),", "+            producerFilterFn);", "+        if (failed(reductionDimTilingResult)) return failure();", "+      }", "+    }", "     return success();", "   }", " ", "  private:", "+  LogicalResult tileAndPeelReductionDim(", "+      PatternRewriter &rewriter, DotTy reduceOp,", "+      ArrayRef<int64_t> reductionDimTileSizes,", "+      llvm::function_ref<bool(Operation *)> producerFilterFn) const {", "+    FailureOr<scf::SCFTilingResult> reductionDimTilingResult =", "+        tileUsingSCFForOpAndFuseGreedily(", "+            rewriter, reduceOp, getSCFTilingOptions(reductionDimTileSizes),", "+            producerFilterFn);", "+    if (failed(reductionDimTilingResult)) return failure();", "+", "+    SCFForPeelingResult reductionDimPeelingResult =", "+        peelSCFForOp(rewriter, reductionDimTilingResult->loops.front());", "+    if (reductionDimPeelingResult.mainLoop) {", "+      setLabel(reductionDimPeelingResult.mainLoop, kPerfectlyTiledLoopLabel);", "+    }", "+    return success();", "+  }", "+", "   MatmulTileSizeComputationFn tileSizeFn;", "   std::function<SmallVector<int64_t>(MatmulSizes)> parallelDimTileSizeFn;", "   std::function<SmallVector<int64_t>(MatmulSizes)> reductionDimTileSizeFn;", "@@ -248,9 +346,16 @@ struct TransformDotForCpuPass", "     // - for linalg.vecmat: only the second and last elements of tileSizes are", "     // used.", "     // - for linalg.dot: only the last element of tileSizes is used.", "-", "     RewritePatternSet patterns(ctx);", "     patterns.add<MatVecToVecMatPattern>(ctx, 2);", "+    patterns.add<DotTransformPattern<linalg::MatmulOp>>(", "+        ctx, tileSizeFn,", "+        [&](MatmulSizes sizes) -> SmallVector<int64_t> {", "+          return {sizes.m, sizes.n, 0};", "+        },", "+        [&](MatmulSizes sizes) -> SmallVector<int64_t> {", "+          return {0, 0, sizes.k};", "+        });", "     patterns.add<DotTransformPattern<linalg::MatvecOp>>(", "         ctx, tileSizeFn,", "         [&](MatmulSizes sizes) -> SmallVector<int64_t> {", "@@ -273,25 +378,36 @@ struct TransformDotForCpuPass", "         [&](MatmulSizes sizes) -> SmallVector<int64_t> { return {sizes.k}; });", " ", "     populateCollapseForallOpDimensionsPattern(patterns);", "-    if (failed(applyPatternsAndFoldGreedily(f, std::move(patterns)))) {", "+    if (failed(applyPatternsAndFoldGreedily(f, std::move(patterns))))", "       return signalPassFailure();", "-    }", " ", "     // Ensure we drop the marker in the end.", "     f.walk([](Operation *op) {", "-      if (isa<linalg::MatvecOp, linalg::VecmatOp, linalg::DotOp>(op))", "-        removeLabel(op, kDotTransformedLabel);", "+      if (isa<linalg::MatmulOp, linalg::MatvecOp, linalg::VecmatOp,", "+              linalg::DotOp>(op))", "+        removeLabel(op, kTransformedLabel);", "     });", "   }", " ", "   MatmulTileSizeComputationFn tileSizeFn;", " };", "+", " }  // namespace", " ", " std::unique_ptr<mlir::OperationPass<mlir::func::FuncOp>>", "-createTransformDotForCpuPass(MatmulTileSizeComputationFn tileSizeFn) {", "+createTransformDotForCpuPass(ArrayRef<int64_t> tileSizes, StringRef cpuName) {", "+  std::function<MatmulSizes(MatmulSizes)> tilingHeuristic;", "+  if (!tileSizes.empty()) {", "+    assert(tileSizes.size() == 3 && \"Expected exactly 3 tile sizes for matmul\");", "+    MatmulSizes fixedSizes{tileSizes[0], tileSizes[1], tileSizes[2]};", "+    tilingHeuristic = [=](MatmulSizes) { return fixedSizes; };", "+  } else {", "+    tilingHeuristic = cpuName.starts_with(\"znver\")", "+                          ? wrapHeuristic(znver2TilingHeuristic, {16, 8, 8})", "+                          : wrapHeuristic(skylakeTilingHeuristic, {16, 16, 4});", "+  }", "   return std::make_unique<mlir::gml_st::TransformDotForCpuPass>(", "-      std::move(tileSizeFn));", "+      std::move(tilingHeuristic));", " }", " ", " }  // namespace mlir::gml_st", "@@ -1,168 +0,0 @@", "-/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.", "-", "-Licensed under the Apache License, Version 2.0 (the \"License\");", "-you may not use this file except in compliance with the License.", "-You may obtain a copy of the License at", "-", "-    http://www.apache.org/licenses/LICENSE-2.0", "-", "-Unless required by applicable law or agreed to in writing, software", "-distributed under the License is distributed on an \"AS IS\" BASIS,", "-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.", "-See the License for the specific language governing permissions and", "-limitations under the License.", "-==============================================================================*/", "-", "-#include <memory>", "-#include <utility>", "-", "-#include \"gml_st/transforms/fusion/fusion.h\"", "-#include \"gml_st/transforms/passes.h\"", "-#include \"gml_st/transforms/peeling/peeling.h\"", "-#include \"gml_st/transforms/tiling/tiling.h\"", "-#include \"gml_st/transforms/transforms.h\"", "-#include \"mlir/Dialect/Arith/IR/Arith.h\"", "-#include \"mlir/Dialect/Linalg/IR/Linalg.h\"", "-#include \"mlir/Dialect/Linalg/Transforms/TilingInterfaceImpl.h\"", "-#include \"mlir/Dialect/SCF/Transforms/TileUsingInterface.h\"", "-#include \"mlir/Dialect/SCF/Transforms/Transforms.h\"", "-#include \"mlir/Dialect/Tensor/IR/Tensor.h\"", "-#include \"mlir/Pass/Pass.h\"", "-#include \"mlir/Transforms/GreedyPatternRewriteDriver.h\"", "-", "-namespace mlir::gml_st {", "-namespace {", "-", "-#define GEN_PASS_DEF_TRANSFORMMATMULFORCPUPASS", "-#include \"gml_st/transforms/passes.h.inc\"", "-", "-/// Pattern to tile `linalg.matmul`, fuse `linalg.fill` into generated", "-/// `gml_st.parallel`, and peel the generated loops.", "-struct MatmulTransformPattern : public OpRewritePattern<linalg::MatmulOp> {", "-  using OpRewritePattern<linalg::MatmulOp>::OpRewritePattern;", "-", "-  MatmulTransformPattern(MLIRContext *context,", "-                         MatmulTileSizeComputationFn tileSizeFn,", "-                         PatternBenefit benefit = 1)", "-      : OpRewritePattern<linalg::MatmulOp>(context, benefit),", "-        tileSizeFn(std::move(tileSizeFn)) {}", "-", "-  LogicalResult matchAndRewrite(linalg::MatmulOp matmulOp,", "-                                PatternRewriter &rewriter) const override {", "-    if (hasLabel(matmulOp, kTransformedLabel))", "-      return rewriter.notifyMatchFailure(matmulOp,", "-                                         \"has already been transformed.\");", "-", "-    auto cluster = findMapFusionCluster(matmulOp);", "-    auto fusionCluster = cluster.operations;", "-    auto *tilingRoot = cluster.root;", "-", "-    auto lhsTy = matmulOp.getOperandTypes()[0].cast<ShapedType>();", "-    auto resultTy = matmulOp.getResultTypes()[0].cast<ShapedType>();", "-", "-    auto tileSize = tileSizeFn(", "-        {resultTy.getDimSize(0), resultTy.getDimSize(1), lhsTy.getDimSize(1)});", "-", "-    // Tiling of linalg.map requires two dimensions, linalg.matmul requires", "-    // three.", "-    SmallVector<int64_t> parallelDimsTileSizes{tileSize.m, tileSize.n};", "-    if (isa<linalg::MatmulOp>(tilingRoot)) parallelDimsTileSizes.push_back(0);", "-", "-    // First level tiling: parallel dimensions.", "-    auto tilingParallelDimsResult = tileUsingSCFForallOpAndFuseGreedily(", "-        rewriter, tilingRoot, getSCFTilingOptions(parallelDimsTileSizes),", "-        [&](Operation *op) { return fusionCluster.contains(op); });", "-    if (failed(tilingParallelDimsResult)) return failure();", "-", "-    // Second level tiling: reduction dimension for matmuls.", "-    SmallVector<scf::SCFTilingResult> tilingReductionDimsResults;", "-    for (auto op : llvm::to_vector(tilingParallelDimsResult->loop.getBody()", "-                                       ->getOps<linalg::MatmulOp>())) {", "-      auto result = tileMatmulReductionDims(rewriter, op, tileSize);", "-      if (failed(result)) return failure();", "-      tilingReductionDimsResults.push_back(*result);", "-    }", "-", "-    // Peel parallel loops.", "-    //", "-    // We only want to peel (1) the parallel loop then (2) our kernel.", "-    auto peelingResult = peelAllLoops(tilingParallelDimsResult->loop, rewriter);", "-", "-    // Peel reduction loop inside the main parallel loop, label the main loop as", "-    // \"perfectly tiled\" one, to enable vectorization after canonicalization.", "-    for (auto &res : tilingReductionDimsResults) {", "-      if (res.loops.size() == 1) {", "-        auto peelingResult = peelSCFForOp(rewriter, res.loops.front());", "-        setLabel(peelingResult.mainLoop, kPerfectlyTiledLoopLabel);", "-      }", "-    }", "-    return success();", "-  }", "-", "- private:", "-  FailureOr<scf::SCFTilingResult> tileMatmulReductionDims(", "-      PatternRewriter &rewriter, linalg::MatmulOp matmulOp,", "-      const MatmulSizes &tileSize) const {", "-    SmallVector<int64_t> reductionDimsTileSizes{0, 0, tileSize.k};", "-    scf::SCFTilingOptions opts;", "-    opts.setTileSizes(reductionDimsTileSizes);", "-    auto tilingReductionDimsResult =", "-        scf::tileUsingSCFForOp(rewriter, matmulOp.getOperation(), opts);", "-    if (failed(tilingReductionDimsResult)) return failure();", "-", "-    // Update the results if tiling occurred.", "-    if (!tilingReductionDimsResult->loops.empty()) {", "-      rewriter.replaceOp(matmulOp, tilingReductionDimsResult->replacements);", "-      matmulOp =", "-          cast<linalg::MatmulOp>(tilingReductionDimsResult->tiledOps.front());", "-    }", "-", "-    setLabel(matmulOp, kTransformedLabel);", "-    return tilingReductionDimsResult;", "-  }", "-", "-  MatmulTileSizeComputationFn tileSizeFn;", "-};", "-", "-struct TransformMatmulForCpuPass", "-    : public impl::TransformMatmulForCpuPassBase<TransformMatmulForCpuPass> {", "-  TransformMatmulForCpuPass() = default;", "-", "-  explicit TransformMatmulForCpuPass(MatmulTileSizeComputationFn tileSizeFn)", "-      : tileSizeFn(tileSizeFn ? std::move(tileSizeFn)", "-                              : [](MatmulSizes) -> MatmulSizes {", "-          return {4, 4, 4};", "-        }) {}", "-", "-  void getDependentDialects(DialectRegistry &registry) const final {", "-    registry.insert<arith::ArithDialect, linalg::LinalgDialect, scf::SCFDialect,", "-                    tensor::TensorDialect>();", "-    linalg::registerTilingInterfaceExternalModels(registry);", "-  }", "-", "-  void runOnOperation() override {", "-    func::FuncOp f = getOperation();", "-    MLIRContext *ctx = &getContext();", "-", "-    RewritePatternSet patterns(ctx);", "-    patterns.add<MatmulTransformPattern>(ctx, tileSizeFn);", "-    if (failed(applyPatternsAndFoldGreedily(f, std::move(patterns))))", "-      return signalPassFailure();", "-", "-    // Ensure we drop the marker in the end.", "-    f.walk([](linalg::MatmulOp op) { removeLabel(op, kTransformedLabel); });", "-  }", "-", "- private:", "-  MatmulTileSizeComputationFn tileSizeFn;", "-};", "-", "-}  // namespace", "-", "-std::unique_ptr<mlir::OperationPass<mlir::func::FuncOp>>", "-createTransformMatmulForCpuPass(MatmulTileSizeComputationFn tileSizeFn) {", "-  return std::make_unique<mlir::gml_st::TransformMatmulForCpuPass>(", "-      std::move(tileSizeFn));", "-}", "-", "-}  // namespace mlir::gml_st", "@@ -123,7 +123,6 @@ struct TransformPackForCpuPass", "     // canonicalize tiled ops.", "     {", "       RewritePatternSet patterns(ctx);", "-      linalg::populateLinalgTilingCanonicalizationPatterns(patterns);", "       patterns.add<linalg::GeneralizeOuterUnitDimsPackOpPattern>(ctx);", "       patterns.add<linalg::GeneralizeOuterUnitDimsUnPackOpPattern>(ctx);", "       if (failed(applyPatternsAndFoldGreedily(func, std::move(patterns))))", "@@ -277,11 +277,14 @@ struct Reduce2DTransformPattern : public OpRewritePattern<linalg::ReduceOp> {", "     if (reduceOp.getDimensions().size() != 1) return failure();", "     int64_t reductionDim = reduceOp.getDimensions()[0];", " ", "-    if (reduceOp->getParentOfType<scf::ForallOp>()) return failure();", "     if (hasLabel(reduceOp, kTransformedLabel)) {", "       return rewriter.notifyMatchFailure(reduceOp,", "                                          \"has already been transformed.\");", "     }", "+    if (isa<scf::ForallOp, scf::ForOp>(reduceOp->getParentOp())) {", "+      return rewriter.notifyMatchFailure(", "+          reduceOp, \"has already been tiled by another pass.\");", "+    }", "     if (failed(validateOp(reduceOp, rewriter, /*expectedRank=*/2)))", "       return failure();", " ", "@@ -289,10 +292,14 @@ struct Reduce2DTransformPattern : public OpRewritePattern<linalg::ReduceOp> {", "       return isa<linalg::BroadcastOp, linalg::FillOp, linalg::MapOp,", "                  linalg::TransposeOp, tensor::CastOp>(op);", "     };", "+    auto consumerFilterFn = [](Operation *op) {", "+      return isa<linalg::MapOp, thlo::ReverseOp>(op);", "+    };", "     auto fusionClusterFn = [&](Operation *op) {", "       return producerFilterFn(op) || isa<linalg::ReduceOp>(op);", "     };", "-    auto cluster = getFusionCluster(reduceOp, producerFilterFn);", "+    auto cluster =", "+        getFusionCluster(reduceOp, producerFilterFn, consumerFilterFn);", "     auto fusionCluster = cluster.operations;", "     auto *tilingRoot = cluster.root;", " ", "@@ -357,46 +364,6 @@ struct Reduce2DTransformPattern : public OpRewritePattern<linalg::ReduceOp> {", "   }", " ", "  private:", "-  // Find a cluster of operations that can be tiled and fused together around", "-  // the root op.", "-  FusionCluster getFusionCluster(", "-      linalg::ReduceOp reduceOp,", "-      llvm::function_ref<bool(Operation *)> filterFn) const {", "-    // Find a chain of MapOp users and use the last one as a root of cluster.", "-    SetVector<Operation *> resultOps;", "-    Operation *rootOp = reduceOp.getOperation();", "-", "-    while (true) {", "-      auto users = llvm::to_vector(rootOp->getUsers());", "-", "-      if (users.size() != 1) break;", "-      if (!isa<linalg::MapOp, thlo::ReverseOp>(users[0])) break;", "-      resultOps.insert(rootOp);", "-", "-      rootOp = users[0];", "-    }", "-", "-    // Run DFS to find all MapOps, TransposeOps, BroadcastOps that can be", "-    // fused in the root op.", "-    SmallVector<Operation *> remainingProducers;", "-    remainingProducers.reserve(reduceOp.getDpsInputOperands().size());", "-    resultOps.insert(reduceOp.getOperation());", "-    for (Value operand : reduceOp.getOperands())", "-      remainingProducers.push_back(operand.getDefiningOp());", "-", "-    while (!remainingProducers.empty()) {", "-      Operation *curOp = remainingProducers.pop_back_val();", "-      if (!curOp || resultOps.contains(curOp)) continue;", "-      auto linalgOp = dyn_cast<linalg::LinalgOp>(curOp);", "-      if (linalgOp && !isa<linalg::ReduceOp>(curOp) && filterFn(curOp)) {", "-        resultOps.insert(curOp);", "-        for (Value operand : reduceOp.getOperands())", "-          remainingProducers.push_back(operand.getDefiningOp());", "-      }", "-    }", "-    return {resultOps, rootOp, {}};", "-  }", "-", "   LogicalResult tileAndPeelReductionDim(", "       PatternRewriter &rewriter, linalg::ReduceOp reduceOp,", "       int64_t reductionDim,", "@@ -33,6 +33,7 @@ limitations under the License.", " #include \"mlir/Dialect/Tensor/IR/Tensor.h\"", " #include \"mlir/Dialect/Utils/StructuredOpsUtils.h\"", " #include \"mlir/IR/PatternMatch.h\"", "+#include \"mlir/Interfaces/DestinationStyleOpInterface.h\"", " #include \"mlir/Interfaces/SideEffectInterfaces.h\"", " #include \"mlir/Transforms/InliningUtils.h\"", " #include \"mlir/Transforms/RegionUtils.h\"", "@@ -251,6 +252,12 @@ LogicalResult fuseGreedilyOneOpIntoBlock(", "     // Filter candidates that we don't want to fuse.", "     if (filterFn && !filterFn(fusionCandidate)) return;", " ", "+    // `linalg.fill` after tiling mostly becomes a scalar or a vector constant.", "+    // It is beneficial to fuse it.", "+    if (isa<linalg::FillOp>(fusionCandidate)) {", "+      fusionCandidates.insert(fusionCandidate);", "+      return;", "+    }", "     // Check that the candidate doesn't have users that will block fusion.", "     if (!llvm::all_of(fusionCandidate->getUsers(), [](Operation* op) {", "           // Fusion candidates can only be fused into tensor.extract_slice or", "@@ -260,9 +267,9 @@ LogicalResult fuseGreedilyOneOpIntoBlock(", "                  isa<tensor::DimOp>(op) ||", "                  // Trivially dead ops will be removed.", "                  isOpTriviallyDead(op);", "-        }))", "+        })) {", "       return;", "-", "+    }", "     fusionCandidates.insert(fusionCandidate);", "   });", " ", "@@ -279,9 +286,13 @@ LogicalResult fuseGreedilyOneOpIntoBlock(", "     reifyDimOpsUsers(rewriter, fusionCandidate);", " ", "     // After the previous steps, extractSliceOp should be only one user of the", "-    // fusion candidate. Otherwise this candidate should not be fused.", "+    // fusion candidate. Otherwise this candidate should not be fused. We always", "+    // want to fuse linalg.fill.", "     auto fusionCandidateUsers = llvm::to_vector(fusionCandidate->getUsers());", "-    if (fusionCandidateUsers.size() != 1) continue;", "+    if (fusionCandidateUsers.size() != 1 &&", "+        !isa<linalg::FillOp>(fusionCandidate)) {", "+      continue;", "+    }", " ", "     Operation* candidateUser = fusionCandidateUsers.front();", " ", "@@ -475,38 +486,37 @@ void fuseGreedily(PatternRewriter& rewriter, Block& block,", "     ;", " }", " ", "-FusionCluster findMapFusionCluster(Operation* op) {", "-  // Find the root operation in the chain of elementwise ops. Current approach", "-  // doesn't work well if maps don't form a chain.", "+// Cluster producers and consumers around the root op.", "+FusionCluster getFusionCluster(", "+    Operation* op, llvm::function_ref<bool(Operation*)> producerFilterFn,", "+    llvm::function_ref<bool(Operation*)> consumerFilterFn) {", "+  // Find a chain of users and use the last one as a root of cluster.", "+  SetVector<Operation*> resultOps;", "+", "   Operation* rootOp = op;", "   while (true) {", "     auto users = llvm::to_vector(rootOp->getUsers());", " ", "     if (users.size() != 1) break;", "-    if (!isa<linalg::MapOp>(users[0])) break;", "+", "+    if (!consumerFilterFn(users[0])) break;", "+    resultOps.insert(rootOp);", " ", "     rootOp = users[0];", "   }", " ", "-  // Run a graph search to find all linalg.map and that can be fused in", "-  // the root op.", "-  SetVector<Operation*> resultOps;", "-  SmallVector<Operation*> remainingProducers{rootOp};", "+  // Run DFS to find all ops that satisfy producerFilterFn.", "+  SmallVector<Operation*> remainingProducers;", "+  for (Value operand : op->getOperands())", "+    remainingProducers.push_back(operand.getDefiningOp());", " ", "   while (!remainingProducers.empty()) {", "     Operation* curOp = remainingProducers.pop_back_val();", "-    if (!curOp) continue;", "-", "-    if (auto mapOp = dyn_cast<linalg::MapOp>(curOp)) {", "-      resultOps.insert(curOp);", "-      for (auto* operand : mapOp.getDpsInputOperands())", "-        remainingProducers.push_back(operand->get().getDefiningOp());", "-    } else if (curOp->getName() == op->getName()) {", "-      for (auto* u : curOp->getUsers()) {", "-        // Do not fuse curOp that is used by another op of the same type.", "-        if (u->getName() == op->getName()) continue;", "-      }", "+    if (!curOp || resultOps.contains(curOp)) continue;", "+    if (curOp == op || producerFilterFn(curOp)) {", "       resultOps.insert(curOp);", "+      for (Value operand : curOp->getOperands())", "+        remainingProducers.push_back(operand.getDefiningOp());", "     }", "   }", "   return {resultOps, rootOp, {}};", "@@ -518,13 +528,13 @@ FailureOr<GMLSTTilingResult> tileUsingSCFForallOpAndFuseGreedily(", "   auto tilingResult =", "       tileUsingSCFForallOp(rewriter, cast<TilingInterface>(op), opts);", "   if (failed(tilingResult)) return failure();", "-  rewriter.replaceOp(op, tilingResult->loop->getResults());", " ", "   for (Operation* tiledOp : tilingResult->tiledOps)", "     setLabel(tiledOp, kTransformedLabel);", " ", "   // If tiling created an `scf.forall` loop, we fuse.", "   if (tilingResult->loop != nullptr) {", "+    rewriter.replaceOp(op, tilingResult->loop->getResults());", "     // Fuse ops into the loop.", "     fuseGreedily(rewriter, *tilingResult->tiledOps.front()->getBlock(),", "                  fuseFilterFn);", "@@ -32,13 +32,10 @@ struct FusionCluster {", "   // Map from Value of the fusion cluster argument to the root dimensions.", "   llvm::SmallVector<std::pair<Value, SmallVector<int64_t>>> argDimsMapping;", " };", "-", "-// Find a cluster of operations that can be tiled and fused together around", "-// the root op. We want to fuse output of the fusion op with elementwise ops. In", "-// general case a cluster is a tree that can have multiple leaf-node ops,", "-// e.g. map(op, map(op)).", "-// First element of the cluster is always the root for tiling.", "-FusionCluster findMapFusionCluster(Operation *op);", "+// Cluster producers and consumers around the root op.", "+FusionCluster getFusionCluster(", "+    Operation *op, llvm::function_ref<bool(Operation *)> producerFilterFn,", "+    llvm::function_ref<bool(Operation *)> consumerFilterFn);", " ", " // Creates gml_st.fusion op with a region with ops from the fusion cluster.", " // Operands of the ops in the region are replaced with region arguments to", "@@ -32,15 +32,6 @@ limitations under the License.", " namespace mlir {", " namespace gml_st {", " ", "-struct MatmulSizes {", "-  // [m, k] x [k, n]", "-  int64_t m;", "-  int64_t n;", "-  int64_t k;", "-};", "-", "-using MatmulTileSizeComputationFn = std::function<MatmulSizes(MatmulSizes)>;", "-", " /// Pass to fuse producers into a tiled consumer.", " std::unique_ptr<OperationPass<func::FuncOp>> createFusionPass(", "     StringRef producer = \"\", StringRef consumer = \"\");", "@@ -91,11 +82,7 @@ std::unique_ptr<OperationPass<func::FuncOp>> createTransformScatterForCpuPass();", " ", " /// Pass to transform a dot operation for CPU backend.", " std::unique_ptr<OperationPass<func::FuncOp>> createTransformDotForCpuPass(", "-    MatmulTileSizeComputationFn tileSizeFn = nullptr);", "-", "-/// Pass to transform a linalg.matmul op for CPU backend.", "-std::unique_ptr<OperationPass<func::FuncOp>> createTransformMatmulForCpuPass(", "-    MatmulTileSizeComputationFn tileSizeFn = nullptr);", "+    ArrayRef<int64_t> tileSizes = {}, StringRef cpuName = \"\");", " ", " /// Pass to transform tensor.pack/unpack ops for CPU backend.", " std::unique_ptr<OperationPass<func::FuncOp>> createTransformPackForCpuPass();", "@@ -120,16 +120,9 @@ def TransformScatterForCpuPass :", " def TransformDotForCpuPass :", "     Pass<\"xla-cpu-transform-dot\", \"mlir::func::FuncOp\"> {", "   let summary = \"Transform dot ops for running on CPU\";", "-", "   let constructor = \"createTransformDotForCpuPass()\";", " }", " ", "-def TransformMatmulForCpuPass :", "-    Pass<\"xla-cpu-transform-matmul\", \"mlir::func::FuncOp\"> {", "-  let summary = \"Transform matmul ops for running on CPU\";", "-  let constructor = \"createTransformMatmulForCpuPass()\";", "-}", "-", " def TransformPackForCpuPass :", "     Pass<\"xla-cpu-transform-pack\", \"mlir::func::FuncOp\"> {", "   let summary = \"Transform tensor.pack/unpack ops for running on CPU\";", "@@ -18,7 +18,7 @@ func.func @matvec(%lhs: tensor<33x17xf32>, %rhs: tensor<17xf32>,", " // CHECK:         scf.for {{.*}} %[[C0]] to %[[C32]] step %[[C4]]", " // CHECK:           scf.for {{.*}} %[[C0]] to %[[C12]] step %[[C6]]", " // CHECK:             vector.contract {{.*}} vector<4x6xf32>", "-// CHECK-NEXT:        scf.yield %{{.*}} : {{.*}}, vector<4xf32>", "+// CHECK-NEXT:        scf.yield %{{.*}} : vector<4xf32>", " // CHECK:           vector.contract", " // CHECK:           vector.transfer_write", " // CHECK:         scf.for {{.*}} %[[C0]] to %[[C17]] step %[[C6]]", "@@ -43,7 +43,7 @@ func.func @vecmat(%lhs: tensor<17xf32>, %rhs: tensor<17x33xf32>,", " // CHECK:         scf.for {{.*}} %[[C0]] to %[[C30]] step %[[C5]]", " // CHECK:           scf.for {{.*}} %[[C0]] to %[[C12]] step %[[C6]]", " // CHECK:             vector.contract {{.*}} vector<6x5xf32>", "-// CHECK-NEXT:        scf.yield %{{.*}} : {{.*}}, vector<5xf32>", "+// CHECK-NEXT:        scf.yield %{{.*}} : vector<5xf32>", " // CHECK:           vector.contract", " // CHECK:           vector.transfer_write", " // CHECK:         scf.for {{.*}} %[[C0]] to %[[C17]] step %[[C6]]", "@@ -65,7 +65,7 @@ func.func @dot(%lhs: tensor<19xf32>, %rhs: tensor<19xf32>,", " // CHECK:         scf.for {{.*}} %[[C0]] to %[[C18]] step %[[C6]]", " // CHECK:           vector.contract {{.*}} vector<6xf32>", " // CHECK-NEXT:      vector.broadcast", "-// CHECK-NEXT:      scf.yield %{{.*}} : {{.*}}, vector<f32>", "+// CHECK-NEXT:      scf.yield %{{.*}} : vector<f32>", " // CHECK:         arith.mulf", " // CHECK:         arith.addf", " ", "@@ -1,77 +1,46 @@", " // RUN: mlir-hlo-opt %s --split-input-file \\", "-// RUN:   --gml-st-cpu-tiling-pipeline=matmul-tile-sizes=4,4,4 | FileCheck %s", "+// RUN:   --gml-st-cpu-tiling-pipeline=matmul-tile-sizes=4,4,4 \\", "+// RUN: | FileCheck %s", "+", "+func.func @map_matmul(%lhs0: tensor<16x16xf32>, %rhs0: tensor<16x16xf32>,", "+    %lhs1: tensor<16x32xf32>, %rhs1: tensor<32x16xf32>) -> tensor<16x16xf32> {", "+  %init = tensor.empty() : tensor<16x16xf32>", " ", "-func.func @map_matmul(%arg0: tensor<?x?xf32>,", "-    %arg1: tensor<?x?xf32>, %arg2: tensor<?x?xf32>) -> tensor<?x?xf32> {", "-  %c0 = arith.constant 0 : index", "-  %c1 = arith.constant 1 : index", "-  %dim0 = tensor.dim %arg0, %c0 : tensor<?x?xf32>", "-  %dim1 = tensor.dim %arg1, %c1 : tensor<?x?xf32>", "-  %init = tensor.empty(%dim0, %dim1) : tensor<?x?xf32>", "   %cst = arith.constant 0.000000e+00 : f32", "   %filled = linalg.fill ins(%cst : f32)", "-              outs(%init : tensor<?x?xf32>) -> tensor<?x?xf32>", "-  %4 = linalg.matmul ins(%arg0, %arg1 : tensor<?x?xf32>, tensor<?x?xf32>)", "-                     outs(%filled : tensor<?x?xf32>) -> tensor<?x?xf32>", "-  %5 = linalg.matmul ins(%arg0, %arg2 : tensor<?x?xf32>, tensor<?x?xf32>)", "-                     outs(%filled : tensor<?x?xf32>) -> tensor<?x?xf32>", "+              outs(%init : tensor<16x16xf32>) -> tensor<16x16xf32>", "+", "+  %4 = linalg.matmul ins(%lhs0, %rhs0 : tensor<16x16xf32>, tensor<16x16xf32>)", "+                     outs(%filled : tensor<16x16xf32>) -> tensor<16x16xf32>", "+  %5 = linalg.matmul ins(%lhs1, %rhs1 : tensor<16x32xf32>, tensor<32x16xf32>)", "+                     outs(%filled : tensor<16x16xf32>) -> tensor<16x16xf32>", "   %6 = linalg.map { math.absf }", "-         ins(%5 : tensor<?x?xf32>)", "-         outs(%init : tensor<?x?xf32>)", "+         ins(%5 : tensor<16x16xf32>)", "+         outs(%init : tensor<16x16xf32>)", " ", "   %result = linalg.map { arith.addf }", "-              ins(%4, %6 : tensor<?x?xf32>, tensor<?x?xf32>)", "-              outs(%init : tensor<?x?xf32>)", "-  return %result : tensor<?x?xf32>", "+              ins(%4, %6 : tensor<16x16xf32>, tensor<16x16xf32>)", "+              outs(%init : tensor<16x16xf32>)", "+  return %result : tensor<16x16xf32>", " }", " ", " // CHECK-LABEL: @map_matmul", " ", "+// Fuse this linalg.fill.", "+", "+// CHECK-NOT:  linalg.fill", " // CHECK:      scf.for", " // CHECK:        scf.for", " // CHECK-COUNT-2:     vector.transfer_read", " // CHECK:             vector.contract", " // CHECK:          scf.yield", " // CHECK:        scf.for", "-// CHECK:          linalg.matmul", "-// CHECK:          scf.yield", "-// CHECK:        scf.for", " // CHECK-COUNT-2:     vector.transfer_read", " // CHECK:             vector.contract", " // CHECK:          scf.yield", "-// CHECK:        scf.for", "-// CHECK:          linalg.matmul", "-// CHECK:          scf.yield", " // CHECK:        math.absf %{{.*}} : vector<4x4xf32>", "-// CHECK:        arith.addf %{{.*}} : vector<4x4xf32>", " // CHECK:        vector.transfer_write", " ", " // CHECK:      scf.for", " // CHECK:        scf.for", "-// CHECK:          linalg.matmul", "-// CHECK:          scf.yield", "-// CHECK:        scf.for", "-// CHECK:          linalg.matmul", "-// CHECK:          scf.yield", "-// CHECK:        scf.for", "-// CHECK:          scf.for", "-// CHECK:            math.absf", "-// CHECK:        scf.for", "-// CHECK:          scf.for", "-// CHECK:            arith.addf", "-// CHECK:        tensor.insert", "-", "-// CHECK:      scf.for", "-// CHECK:        scf.for", "-// CHECK:          linalg.matmul", "-// CHECK:          scf.yield", "-// CHECK:        scf.for", "-// CHECK:          linalg.matmul", "-// CHECK:          scf.yield", "-// CHECK:        scf.for", "-// CHECK:          scf.for", "-// CHECK:            math.absf", "-// CHECK:        scf.for", "-// CHECK:          scf.for", "-// CHECK:            arith.addf", "-// CHECK:        tensor.insert", "+// CHECK:        arith.addf %{{.*}} : vector<1x8xf32>", "@@ -36,14 +36,13 @@ func.func @row_reduce_map_fuse_map(%arg0: tensor<?x?xf32>,", " // CHECK:     arith.addf %{{.*}} : vector<4x4xf32>", " // CHECK:     vector.multi_reduction <add>", " // CHECK:       : vector<4x4xf32> to vector<4xf32>", "-// CHECK:     scf.yield %{{.*}} : {{.*}}, vector<4xf32>", "+// CHECK:     scf.yield %{{.*}} : vector<4xf32>", " // CHECK:   scf.for", " // CHECK:     scf.for", " // CHECK:       arith.addf %{{.*}} : vector<4x1xf32>", "-// CHECK:       vector.multi_reduction <add>", "-// CHECK:         : vector<4x1xf32> to vector<4xf32>", "-// CHECK:       scf.yield %{{.*}} : {{.*}}, vector<4xf32>", "-// CHECK:     scf.yield %{{.*}} : {{.*}}, vector<4xf32>", "+// CHECK:       arith.addf %{{.*}} : vector<4xf32>", "+// CHECK:       scf.yield %{{.*}} : vector<4xf32>", "+// CHECK:     scf.yield %{{.*}} : vector<4xf32>", " // CHECK:   math.absf %{{.*}} : vector<4xf32>", " // CHECK:   vector.transfer_write", " ", "@@ -92,7 +91,7 @@ func.func @col_reduce_map_fuse_map(%arg0: tensor<?x?xf32>,", " // CHECK:     arith.addf %{{.*}} : vector<4x4xf32>", " // CHECK:     vector.multi_reduction <add>", " // CHECK:       : vector<4x4xf32> to vector<4xf32>", "-// CHECK:     scf.yield %{{.*}} : {{.*}}, vector<4xf32>", "+// CHECK:     scf.yield %{{.*}} : vector<4xf32>", " // CHECK:   scf.for", " // CHECK:     scf.for", " // CHECK:       scf.for", "@@ -17,7 +17,7 @@ func.func @matmul_static(%lhs: tensor<128x16xf32>, %rhs: tensor<16x64xf32>,", " // CHECK-NEXT:      scf.for", " // CHECK-COUNT-2:     vector.transfer_read", " // CHECK:             vector.contract {{.*}} vector<4x6xf32>, vector<6x5xf32>", "-// CHECK:             scf.yield {{.*}} : {{.*}}, vector<4x5xf32>", "+// CHECK:             scf.yield {{.*}} : vector<4x5xf32>", " // CHECK:           vector.transfer_write", " ", " // PACKED-LABEL: @matmul_static", "@@ -81,7 +81,7 @@ func.func @matmul(%lhs: tensor<?x?xf32>,", " // CHECK:           scf.for", " // CHECK-COUNT-2:     vector.transfer_read", " // CHECK:             vector.contract", "-// CHECK-NEXT:        scf.yield %{{.*}} : {{.*}}, vector<4x5xf32>", "+// CHECK-NEXT:        scf.yield %{{.*}} : vector<4x5xf32>", " // CHECK:           vector.transfer_write", " ", " // CHECK-NEXT:      scf.for", "@@ -115,10 +115,8 @@ func.func @matmul_narrow_static(%lhs: tensor<2x16xf32>, %rhs: tensor<16x64xf32>,", " ", " // CHECK:         scf.for", " // CHECK:           scf.for", "-// CHECK-COUNT-2:     vector.transfer_read", "-// CHECK:             vector.contract", "-// CHECK:             scf.yield {{.*}} : {{.*}}, vector<2x5xf32>", "-// CHECK:           vector.transfer_write", "+// CHECK:             linalg.matmul", "+// CHECK:             scf.yield {{.*}} : tensor<2x5xf32>", " ", " // PACKED-LABEL: @matmul_narrow_static", " ", "@@ -143,7 +141,7 @@ func.func @matmul_narrow_static(%lhs: tensor<2x16xf32>, %rhs: tensor<16x64xf32>,", " // PACKED:       scf.for", " // PACKED:         scf.for", " // PACKED:           vector.contract", "-// PACKED:           scf.yield %{{.*}} : {{.*}}, vector<1x1x2x8xf32>", "+// PACKED:           scf.yield %{{.*}} : vector<1x1x2x8xf32>", " // PACKED:         scf.yield", " ", " // PACKED:       tensor.empty() : tensor<2x64xf32>", "@@ -154,8 +152,8 @@ func.func @matmul_narrow_static(%lhs: tensor<2x16xf32>, %rhs: tensor<16x64xf32>,", " ", " // -----", " ", "-func.func @matmul_small_static_peeling(%lhs: tensor<2x4xf32>, %arg1: tensor<4x6xf32>,", "-                         %output: tensor<2x6xf32>) -> tensor<2x6xf32> {", "+func.func @matmul_small_static_peeling(%lhs: tensor<2x4xf32>,", "+    %arg1: tensor<4x6xf32>, %output: tensor<2x6xf32>) -> tensor<2x6xf32> {", "   %0 = linalg.matmul ins(%lhs, %arg1 : tensor<2x4xf32>, tensor<4x6xf32>)", "                      outs(%output : tensor<2x6xf32>) -> tensor<2x6xf32>", "   return %0 : tensor<2x6xf32>", "@@ -177,9 +175,6 @@ func.func @matvec_static(%lhs: tensor<1x16xf32>, %arg1: tensor<16x64xf32>,", " // CHECK-LABEL: @matvec_static", " ", " // CHECK:         scf.for", "-// CHECK:           vector.transfer_read", "-// CHECK-NEXT:      scf.for", "-// CHECK-COUNT-2:     vector.transfer_read", "-// CHECK:             vector.contract", "-// CHECK:             scf.yield {{.*}} : {{.*}}, vector<1x5xf32>", "-// CHECK:           vector.transfer_write", "+// CHECK:           scf.for", "+// CHECK:             linalg.matmul", "+// CHECK:             scf.yield {{.*}} : tensor<1x5xf32>", "@@ -16,7 +16,7 @@ func.func @reduce_1d_static(%arg0: tensor<100xf32>) -> tensor<f32> {", " //       CHECK: scf.for", " //       CHECK:   vector.multi_reduction <add>", " //  CHECK-SAME:     : vector<4x8xf32> to vector<8xf32>", "-//       CHECK:   scf.yield %{{.*}} : {{.*}}, vector<8xf32>", "+//       CHECK:   scf.yield %{{.*}} : vector<8xf32>", " ", " //       CHECK: vector.multi_reduction <add>", " //  CHECK-SAME:   : vector<8xf32> to f32", "@@ -40,7 +40,7 @@ func.func @reduce_1d_dynamic(%arg0: tensor<?xf32>) -> tensor<f32> {", " //       CHECK: scf.for", " //       CHECK:   vector.multi_reduction <add>", " //  CHECK-SAME:     : vector<4x8xf32> to vector<8xf32>", "-//       CHECK:   scf.yield %{{.*}} :  {{.*}}, vector<8xf32>", "+//       CHECK:   scf.yield %{{.*}} :  vector<8xf32>", " ", " //       CHECK: vector.multi_reduction <add>", " //  CHECK-SAME:   : vector<8xf32> to f32", "@@ -1,5 +1,5 @@", " // RUN: mlir-hlo-opt %s --split-input-file --gml-st-cpu-tiling-pipeline \\", "-// RUN: | FileCheck %s --dump-input=always", "+// RUN: | FileCheck %s", " ", " func.func @col_reduce_static(%input: tensor<100x10xf32>,", "                         %output: tensor<10xf32>) -> tensor<10xf32> {", "@@ -15,7 +15,7 @@ func.func @col_reduce_static(%input: tensor<100x10xf32>,", " //       CHECK:   scf.for", " //       CHECK:     vector.multi_reduction", " //  CHECK-SAME:       : vector<4x4xf32> to vector<4xf32>", "-//  CHECK-NEXT:     scf.yield %{{.*}} : {{.*}}, vector<4xf32>", "+//  CHECK-NEXT:     scf.yield %{{.*}} : vector<4xf32>", " //       CHECK:   vector.transfer_write", " ", " // -----", "@@ -39,12 +39,12 @@ func.func @row_reduce_dynamic(%input: tensor<?x?xf32>,", " // CHECK:        scf.for", " // CHECK:          vector.multi_reduction", " // CHECK-SAME:       : vector<4x4xf32> to vector<4xf32>", "-// CHECK-NEXT:     scf.yield %{{.*}} : {{.*}}, vector<4xf32>", "+// CHECK-NEXT:     scf.yield %{{.*}} : vector<4xf32>", " ", " // CHECK:        scf.for", "-// CHECK:          vector.multi_reduction", "-// CHECK-SAME:       : vector<4x1xf32> to vector<4xf32>", "-// CHECK-NEXT:     scf.yield %{{.*}} : {{.*}}, vector<4xf32>", "+// CHECK:          arith.mulf", "+// CHECK-SAME:       : vector<4xf32>", "+// CHECK-NEXT:     scf.yield %{{.*}} : vector<4xf32>", " // CHECK:        vector.transfer_write", " ", " // CHECK:      scf.for", "@@ -76,7 +76,7 @@ func.func @col_reduce_dynamic(%input: tensor<?x?xf32>,", " // CHECK:        scf.for", " // CHECK:          vector.multi_reduction", " // CHECK-SAME:       : vector<4x4xf32> to vector<4xf32>", "-// CHECK-NEXT:     scf.yield %{{.*}} : {{.*}}, vector<4xf32>", "+// CHECK-NEXT:     scf.yield %{{.*}} : vector<4xf32>", " ", " // CHECK:        scf.for", " // CHECK:          arith.mulf %{{.*}} : f32", "@@ -1493,7 +1493,6 @@ cc_library(", "         \"gml_st/transforms/cpu_tiling/transform_reduce_for_cpu.cc\",", "         \"gml_st/transforms/cpu_tiling/transform_scatter_for_cpu.cc\",", "         \"gml_st/transforms/fusion/fusion.cc\",", "-        \"gml_st/transforms/passes.cc\",", "         \"gml_st/transforms/passes.h.inc\",", "         \"gml_st/transforms/peeling/peeling.cc\",", "         \"gml_st/transforms/rewrite_from_elements_op/rewrite_from_elements_op.cc\",", "@@ -44,7 +44,6 @@ add_mlir_library(GmlStPasses", "   cpu_tiling/transform_reduce_for_cpu.cc", "   cpu_tiling/transform_scatter_for_cpu.cc", "   fusion/fusion.cc", "-  passes.cc", "   peeling/peeling.cc", "   rewrite_from_elements_op/rewrite_from_elements_op.cc", "   rewrite_scf_forall/rewrite_scf_forall.cc", "@@ -22,8 +22,7 @@ limitations under the License.", " #include \"mlir/IR/PatternMatch.h\"", " #include \"mlir/Transforms/GreedyPatternRewriteDriver.h\"", " ", "-namespace mlir {", "-namespace gml_st {", "+namespace mlir::gml_st {", " namespace {", " ", " #define GEN_PASS_DEF_COMPOSEEXTRACTINSERTSLICEPASS", "@@ -36,8 +35,6 @@ struct ComposeExtractInsertSlicePass", "     MLIRContext* ctx = &getContext();", "     RewritePatternSet patterns(ctx);", "     tensor::populateMergeConsecutiveInsertExtractSlicePatterns(patterns);", "-", "-    populateCollapseForallOpDimensionsPattern(patterns);", "     if (failed(applyPatternsAndFoldGreedily(getOperation(),", "                                             std::move(patterns)))) {", "       return signalPassFailure();", "@@ -52,5 +49,4 @@ createComposeExtractInsertSlicePass() {", "   return std::make_unique<ComposeExtractInsertSlicePass>();", " }", " ", "-}  // namespace gml_st", "-}  // namespace mlir", "+}  // namespace mlir::gml_st", "@@ -22,11 +22,9 @@ limitations under the License.", " #include \"gml_st/transforms/passes.h\"", " #include \"gml_st/transforms/transforms.h\"", " #include \"llvm/ADT/STLExtras.h\"", "-#include \"mlir/Dialect/Arith/IR/Arith.h\"", " #include \"mlir/Dialect/Func/IR/FuncOps.h\"", " #include \"mlir/Dialect/Linalg/IR/Linalg.h\"", " #include \"mlir/Dialect/Tensor/IR/Tensor.h\"", "-#include \"mlir/Dialect/Utils/StructuredOpsUtils.h\"", " #include \"mlir/IR/PatternMatch.h\"", " #include \"mlir/Interfaces/DestinationStyleOpInterface.h\"", " #include \"mlir/Interfaces/TilingInterface.h\"", "@@ -218,23 +216,22 @@ struct FusionPlanningForCpuPass", " ", "   void runOnOperation() override {", "     func::FuncOp f = getOperation();", "-    MLIRContext* context = &getContext();", "+    MLIRContext* ctx = &getContext();", " ", "     // Cleanup passes to prepare ops for better clustering.", "     {", "-      RewritePatternSet patterns(context);", "+      RewritePatternSet patterns(ctx);", "       // Duplicate linalg.fill and tensor.empty that used as init parameters.", "       patterns.add(duplicateInitOps<linalg::FillOp>);", "       patterns.add(duplicateInitOps<tensor::EmptyOp>);", " ", "-      if (failed(applyPatternsAndFoldGreedily(f, std::move(patterns)))) {", "+      if (failed(applyPatternsAndFoldGreedily(f, std::move(patterns))))", "         return signalPassFailure();", "-      }", "     }", " ", "     // Move ops to gml_st.fusion clusters.", "     {", "-      RewritePatternSet patterns(context);", "+      RewritePatternSet patterns(ctx);", "       patterns.add(fusionPattern<linalg::MapOp>);", "       patterns.add(fusionPattern<linalg::MatmulOp>);", "       patterns.add(fusionPattern<linalg::ReduceOp>);", "@@ -256,12 +253,11 @@ struct FusionPlanningForCpuPass", " ", "     // Add attributes with tile sizes.", "     {", "-      RewritePatternSet patterns(context);", "-      patterns.add<ComputeTileSizesPattern>(context, vectorSize);", "+      RewritePatternSet patterns(ctx);", "+      patterns.add<ComputeTileSizesPattern>(ctx, vectorSize);", " ", "-      if (failed(applyPatternsAndFoldGreedily(f, std::move(patterns)))) {", "+      if (failed(applyPatternsAndFoldGreedily(f, std::move(patterns))))", "         return signalPassFailure();", "-      }", "     }", "   }", " };", "@@ -270,14 +266,13 @@ struct InlineFusionClustersPass", "     : public impl::InlineFusionClustersPassBase<InlineFusionClustersPass> {", "   void runOnOperation() override {", "     func::FuncOp f = getOperation();", "-    MLIRContext* context = &getContext();", "+    MLIRContext* ctx = &getContext();", " ", "-    RewritePatternSet patterns(context);", "+    RewritePatternSet patterns(ctx);", "     patterns.add(inlineFusionCluster);", " ", "-    if (failed(applyPatternsAndFoldGreedily(f, std::move(patterns)))) {", "+    if (failed(applyPatternsAndFoldGreedily(f, std::move(patterns))))", "       return signalPassFailure();", "-    }", "   }", " };", " ", "@@ -22,6 +22,8 @@ limitations under the License.", " #include \"mlir/Dialect/Func/IR/FuncOps.h\"", " #include \"mlir/Dialect/Linalg/IR/Linalg.h\"", " #include \"mlir/Dialect/Linalg/Transforms/TilingInterfaceImpl.h\"", "+#include \"mlir/Dialect/Linalg/Transforms/Transforms.h\"", "+#include \"mlir/Dialect/SCF/IR/SCF.h\"", " #include \"mlir/Dialect/SCF/Transforms/TileUsingInterface.h\"", " #include \"mlir/Transforms/GreedyPatternRewriteDriver.h\"", " ", "@@ -148,11 +150,8 @@ struct TransformConvForCpuPass", " ", "     RewritePatternSet patterns(ctx);", "     patterns.add<Conv2DNhwcHwcfOpTransformPattern>(ctx);", "-    populateCollapseForallOpDimensionsPattern(patterns);", "-", "-    if (failed(applyPatternsAndFoldGreedily(f, std::move(patterns)))) {", "+    if (failed(applyPatternsAndFoldGreedily(f, std::move(patterns))))", "       return signalPassFailure();", "-    }", "   }", " };", " ", "@@ -377,7 +377,6 @@ struct TransformDotForCpuPass", "         [&](MatmulSizes) -> SmallVector<int64_t> { return {}; },", "         [&](MatmulSizes sizes) -> SmallVector<int64_t> { return {sizes.k}; });", " ", "-    populateCollapseForallOpDimensionsPattern(patterns);", "     if (failed(applyPatternsAndFoldGreedily(f, std::move(patterns))))", "       return signalPassFailure();", " ", "@@ -28,6 +28,7 @@ limitations under the License.", " #include \"mlir/Dialect/Func/IR/FuncOps.h\"", " #include \"mlir/Dialect/Linalg/IR/Linalg.h\"", " #include \"mlir/Dialect/Linalg/Transforms/TilingInterfaceImpl.h\"", "+#include \"mlir/Dialect/Linalg/Transforms/Transforms.h\"", " #include \"mlir/Dialect/SCF/IR/SCF.h\"", " #include \"mlir/Dialect/Tensor/IR/Tensor.h\"", " #include \"mlir/IR/PatternMatch.h\"", "@@ -312,10 +313,9 @@ struct TransformElementwiseForCpuPass", " ", "   void runOnOperation() override {", "     func::FuncOp f = getOperation();", "-    MLIRContext *context = &getContext();", "+    MLIRContext *ctx = &getContext();", " ", "-    RewritePatternSet patterns(context);", "-    populateCollapseForallOpDimensionsPattern(patterns);", "+    RewritePatternSet patterns(ctx);", "     // clang-format off", "     patterns.add<", "       TileElementwisePattern<linalg::BroadcastOp>,", "@@ -323,7 +323,7 @@ struct TransformElementwiseForCpuPass", "       TileElementwisePattern<linalg::MapOp>,", "       TileElementwisePattern<linalg::TransposeOp>,", "       TileElementwisePattern<thlo::ReverseOp>", "-    >(context, vectorSize, fuseDegenerateReshapes);", "+    >(ctx, vectorSize, fuseDegenerateReshapes);", "     // clang-format on", " ", "     if (failed(applyPatternsAndFoldGreedily(f, std::move(patterns))))", "@@ -24,6 +24,7 @@ limitations under the License.", " #include \"mlir/Dialect/Linalg/IR/Linalg.h\"", " #include \"mlir/Dialect/Linalg/Transforms/TilingInterfaceImpl.h\"", " #include \"mlir/Dialect/Linalg/Transforms/Transforms.h\"", "+#include \"mlir/Dialect/SCF/IR/SCF.h\"", " #include \"mlir/Dialect/SCF/Transforms/TileUsingInterface.h\"", " #include \"mlir/Dialect/SCF/Transforms/Transforms.h\"", " #include \"mlir/Dialect/Tensor/IR/Tensor.h\"", "@@ -127,10 +128,10 @@ struct TransformMmt4DForCpuPass", " ", "   void runOnOperation() override {", "     func::FuncOp func = getOperation();", "+    MLIRContext *ctx = &getContext();", " ", "-    RewritePatternSet patterns(&getContext());", "+    RewritePatternSet patterns(ctx);", "     patterns.add(tileMmt4DOp);", "-", "     if (failed(applyPatternsAndFoldGreedily(func, std::move(patterns))))", "       return signalPassFailure();", " ", "@@ -28,6 +28,7 @@ limitations under the License.", " #include \"mlir/Dialect/Linalg/Transforms/TilingInterfaceImpl.h\"", " #include \"mlir/Dialect/Linalg/Transforms/Transforms.h\"", " #include \"mlir/Dialect/MemRef/IR/MemRef.h\"", "+#include \"mlir/Dialect/SCF/IR/SCF.h\"", " #include \"mlir/Dialect/SCF/Transforms/TileUsingInterface.h\"", " #include \"mlir/Dialect/SCF/Transforms/Transforms.h\"", " #include \"mlir/Dialect/Tensor/IR/Tensor.h\"", "@@ -114,7 +115,6 @@ struct TransformPackForCpuPass", "       RewritePatternSet patterns(ctx);", "       patterns.add(tilePackOp);", "       patterns.add(tileUnpackOp);", "-", "       if (failed(applyPatternsAndFoldGreedily(func, std::move(patterns))))", "         return signalPassFailure();", "     }", "@@ -123,8 +123,8 @@ struct TransformPackForCpuPass", "     // canonicalize tiled ops.", "     {", "       RewritePatternSet patterns(ctx);", "-      patterns.add<linalg::GeneralizeOuterUnitDimsPackOpPattern>(ctx);", "-      patterns.add<linalg::GeneralizeOuterUnitDimsUnPackOpPattern>(ctx);", "+      patterns.add<linalg::GeneralizeOuterUnitDimsPackOpPattern,", "+                   linalg::GeneralizeOuterUnitDimsUnPackOpPattern>(ctx);", "       if (failed(applyPatternsAndFoldGreedily(func, std::move(patterns))))", "         return signalPassFailure();", "     }", "@@ -28,6 +28,7 @@ limitations under the License.", " #include \"mlir/Dialect/Func/IR/FuncOps.h\"", " #include \"mlir/Dialect/Linalg/IR/Linalg.h\"", " #include \"mlir/Dialect/Linalg/Transforms/TilingInterfaceImpl.h\"", "+#include \"mlir/Dialect/Linalg/Transforms/Transforms.h\"", " #include \"mlir/Dialect/Linalg/Utils/Utils.h\"", " #include \"mlir/Dialect/SCF/IR/SCF.h\"", " #include \"mlir/Dialect/SCF/Transforms/TileUsingInterface.h\"", "@@ -447,11 +448,8 @@ struct TransformReduceForCpuPass", "     RewritePatternSet patterns(ctx);", "     patterns.add<Reduce1DTransformPattern>(ctx, vectorSize, tileSize1D);", "     patterns.add<Reduce2DTransformPattern>(ctx, tileSizes2D[0], tileSizes2D[1]);", "-    populateCollapseForallOpDimensionsPattern(patterns);", "-", "-    if (failed(applyPatternsAndFoldGreedily(f, std::move(patterns)))) {", "+    if (failed(applyPatternsAndFoldGreedily(f, std::move(patterns))))", "       return signalPassFailure();", "-    }", " ", "     // Ensure we drop the marker in the end.", "     f.walk([](linalg::ReduceOp reduceOp) {", "@@ -23,6 +23,7 @@ limitations under the License.", " #include \"gml_st/transforms/transforms.h\"", " #include \"mlir/Dialect/Arith/IR/Arith.h\"", " #include \"mlir/Dialect/Func/IR/FuncOps.h\"", "+#include \"mlir/Dialect/Linalg/Transforms/Transforms.h\"", " #include \"mlir/Dialect/SCF/IR/SCF.h\"", " #include \"mlir/Dialect/SCF/Transforms/TileUsingInterface.h\"", " #include \"mlir/Dialect/Tensor/IR/Tensor.h\"", "@@ -110,9 +111,6 @@ struct TransformScatterForCpuPass", " };", " ", " }  // namespace", "-}  // namespace mlir::gml_st", "-", "-namespace mlir::gml_st {", " ", " std::unique_ptr<mlir::OperationPass<mlir::func::FuncOp>>", " createTransformScatterForCpuPass() {", "@@ -1,224 +0,0 @@", "-/* Copyright 2023 The TensorFlow Authors. All Rights Reserved.", "-", "-Licensed under the Apache License, Version 2.0 (the \"License\");", "-you may not use this file except in compliance with the License.", "-You may obtain a copy of the License at", "-", "-    http://www.apache.org/licenses/LICENSE-2.0", "-", "-Unless required by applicable law or agreed to in writing, software", "-distributed under the License is distributed on an \"AS IS\" BASIS,", "-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.", "-See the License for the specific language governing permissions and", "-limitations under the License.", "-==============================================================================*/", "-", "-#include \"gml_st/transforms/passes.h\"", "-", "-#include <optional>", "-", "-#include \"mlir/Dialect/Arith/Utils/Utils.h\"", "-#include \"mlir/Dialect/SCF/IR/SCF.h\"", "-#include \"mlir/Dialect/Tensor/IR/Tensor.h\"", "-#include \"mlir/Dialect/Utils/StaticValueUtils.h\"", "-#include \"mlir/IR/IRMapping.h\"", "-#include \"mlir/IR/PatternMatch.h\"", "-", "-namespace mlir::gml_st {", "-namespace {", "-", "-using scf::ForallOp;", "-", "-struct CollapseForallOpDimensions : public OpRewritePattern<ForallOp> {", "-  using OpRewritePattern<ForallOp>::OpRewritePattern;", "-", "-  LogicalResult matchAndRewrite(ForallOp op,", "-                                PatternRewriter &rewriter) const override {", "-    Location loc = op.getLoc();", "-", "-    // Compute new loop bounds that omit all single-iteration loop dimensions.", "-    SmallVector<OpFoldResult> newMixedLowerBounds, newMixedUpperBounds,", "-        newMixedSteps;", "-    IRMapping mapping;", "-    for (auto [lowerBound, upperBound, step, iv] :", "-         llvm::zip(op.getMixedLowerBound(), op.getMixedUpperBound(),", "-                   op.getMixedStep(), op.getInductionVars())) {", "-      // Collect the statically known loop bounds.", "-      std::optional<int64_t> lowerBoundConstant =", "-          getConstantIntValue(lowerBound);", "-      std::optional<int64_t> upperBoundConstant =", "-          getConstantIntValue(upperBound);", "-      std::optional<int64_t> stepConstant = getConstantIntValue(step);", "-      // Remove the loop if it performs zero iterations.", "-      if (lowerBoundConstant && upperBoundConstant &&", "-          *lowerBoundConstant == *upperBoundConstant) {", "-        rewriter.replaceOp(op, op.getOutputs());", "-        return success();", "-      }", "-      // Replace the loop induction variable by the lower bound if the loop", "-      // performs a single iteration. Otherwise, copy the loop bounds.", "-      if (lowerBoundConstant && upperBoundConstant && stepConstant &&", "-          (*upperBoundConstant - *lowerBoundConstant) > 0 &&", "-          (*upperBoundConstant - *lowerBoundConstant) <= *stepConstant) {", "-        mapping.map(iv,", "-                    getValueOrCreateConstantIndexOp(rewriter, loc, lowerBound));", "-      } else {", "-        newMixedLowerBounds.push_back(lowerBound);", "-        newMixedUpperBounds.push_back(upperBound);", "-        newMixedSteps.push_back(step);", "-      }", "-    }", "-    // Exit if none of the loop dimensions perform a single iteration.", "-    if (newMixedLowerBounds.size() == static_cast<unsigned>(op.getRank())) {", "-      return failure();", "-    }", "-", "-    // All of the loop dimensions perform a single iteration. Inline loop body.", "-    if (newMixedLowerBounds.empty()) {", "-      mapping.map(op.getOutputBlockArguments(), op.getOutputs());", "-      for (auto &bodyOp : op.getBody()->without_terminator())", "-        rewriter.clone(bodyOp, mapping);", "-      SmallVector<Value> results;", "-      results.reserve(op.getResults().size());", "-      scf::InParallelOp terminator = op.getTerminator();", "-      for (auto &yieldingOp : terminator.getYieldingOps()) {", "-        auto parallelInsertSliceOp =", "-            cast<tensor::ParallelInsertSliceOp>(yieldingOp);", "-", "-        Value dst = parallelInsertSliceOp.getDest();", "-        Value src = parallelInsertSliceOp.getSource();", "-", "-        auto getMappedValues = [&](ValueRange values) {", "-          return llvm::to_vector(llvm::map_range(values, [&](Value value) {", "-            return mapping.lookupOrDefault(value);", "-          }));", "-        };", "-", "-        Value srcVal = mapping.lookupOrDefault(src);", "-        if (srcVal.getType().isa<TensorType>()) {", "-          results.push_back(rewriter.create<tensor::InsertSliceOp>(", "-              op.getLoc(), dst.getType(), srcVal, mapping.lookupOrDefault(dst),", "-              getMappedValues(parallelInsertSliceOp.getOffsets()),", "-              getMappedValues(parallelInsertSliceOp.getSizes()),", "-              getMappedValues(parallelInsertSliceOp.getStrides()),", "-              parallelInsertSliceOp.getStaticOffsets(),", "-              parallelInsertSliceOp.getStaticSizes(),", "-              parallelInsertSliceOp.getStaticStrides()));", "-        }", "-      }", "-      rewriter.replaceOp(op, results);", "-      return success();", "-    }", "-", "-    // Replace the loop by a lower-dimensional loop.", "-    ForallOp newOp;", "-    newOp = rewriter.create<ForallOp>(loc, newMixedLowerBounds,", "-                                      newMixedUpperBounds, newMixedSteps,", "-                                      op.getOutputs(), std::nullopt, nullptr);", "-    newOp.getBodyRegion().getBlocks().clear();", "-    // The new loop needs to keep all attributes from the old one, except for", "-    // \"operand_segment_sizes\" which captures the outdated information of the", "-    // old iteration domain.", "-    SmallVector<StringAttr> elidedAttrs{newOp.getOperandSegmentSizesAttrName(),", "-                                        newOp.getStaticLowerBoundAttrName(),", "-                                        newOp.getStaticUpperBoundAttrName(),", "-                                        newOp.getStaticStepAttrName()};", "-    for (const auto &namedAttr : op->getAttrs()) {", "-      if (llvm::is_contained(elidedAttrs, namedAttr.getName())) continue;", "-      newOp->setAttr(namedAttr.getName(), namedAttr.getValue());", "-    }", "-", "-    // Clone the loop body and remap the block arguments of the collapsed loops", "-    // (inlining does not support a cancellable block argument mapping).", "-    rewriter.cloneRegionBefore(op.getRegion(), newOp.getRegion(),", "-                               newOp.getRegion().begin(), mapping);", "-    rewriter.replaceOp(op, newOp.getResults());", "-    return success();", "-  }", "-};", "-", "-/// Fold tensor.casts into the output arguments of scf.forall.", "-struct FoldTensorCastIntoForallOp : public OpRewritePattern<scf::ForallOp> {", "-  using OpRewritePattern<scf::ForallOp>::OpRewritePattern;", "-", "-  struct TypeCast {", "-    Type srcType;", "-    Type dstType;", "-  };", "-", "-  LogicalResult matchAndRewrite(scf::ForallOp forallOp,", "-                                PatternRewriter &rewriter) const final {", "-    llvm::SmallMapVector<unsigned, TypeCast, 2> tensorCastProducers;", "-    llvm::SmallVector<Value> newOutputTensors = forallOp.getOutputs();", "-    for (auto en : llvm::enumerate(newOutputTensors)) {", "-      auto castOp = en.value().getDefiningOp<tensor::CastOp>();", "-      if (!castOp) continue;", "-", "-      // Only casts that that preserve static information, i.e. will make the", "-      // loop result type \"more\" static then before, will be folded.", "-      if (!tensor::preservesStaticInformation(castOp.getDest().getType(),", "-                                              castOp.getSource().getType())) {", "-        continue;", "-      }", "-", "-      tensorCastProducers[en.index()] =", "-          TypeCast{castOp.getSource().getType(), castOp.getType()};", "-      newOutputTensors[en.index()] = castOp.getSource();", "-    }", "-", "-    if (tensorCastProducers.empty()) return failure();", "-", "-    // Create new loop.", "-    Location loc = forallOp.getLoc();", "-    auto newForallOp = rewriter.create<ForallOp>(", "-        loc, forallOp.getMixedLowerBound(), forallOp.getMixedUpperBound(),", "-        forallOp.getMixedStep(), newOutputTensors, forallOp.getMapping(),", "-        [&](OpBuilder nestedBuilder, Location nestedLoc, ValueRange bbArgs) {", "-          auto castBlockArgs =", "-              llvm::to_vector(bbArgs.take_back(forallOp->getNumResults()));", "-          for (auto [index, cast] : tensorCastProducers) {", "-            Value &oldTypeBBArg = castBlockArgs[index];", "-            oldTypeBBArg = nestedBuilder.create<tensor::CastOp>(", "-                nestedLoc, cast.dstType, oldTypeBBArg);", "-          }", "-", "-          // Move old body into new parallel loop.", "-          SmallVector<Value> ivsBlockArgs =", "-              llvm::to_vector(bbArgs.take_front(forallOp.getRank()));", "-          ivsBlockArgs.append(castBlockArgs);", "-          rewriter.mergeBlocks(forallOp.getBody(),", "-                               bbArgs.front().getParentBlock(), ivsBlockArgs);", "-        });", "-", "-    // Update destinations in the terminator.", "-    auto terminator = newForallOp.getTerminator();", "-    for (auto [yieldingOp, outputBlockArg] :", "-         llvm::zip(terminator.getYieldingOps(),", "-                   newForallOp.getOutputBlockArguments())) {", "-      auto insertSliceOp = cast<tensor::ParallelInsertSliceOp>(yieldingOp);", "-      insertSliceOp.getDestMutable().assign(outputBlockArg);", "-    }", "-", "-    // Cast results back to the original types.", "-    rewriter.setInsertionPointAfter(newForallOp);", "-    SmallVector<Value> castResults = newForallOp.getResults();", "-    for (auto &item : tensorCastProducers) {", "-      Value &oldTypeResult = castResults[item.first];", "-      oldTypeResult = rewriter.create<tensor::CastOp>(loc, item.second.dstType,", "-                                                      oldTypeResult);", "-    }", "-    rewriter.replaceOp(forallOp, castResults);", "-", "-    return success();", "-  }", "-};", "-", "-}  // namespace", "-", "-void populateCollapseForallOpDimensionsPattern(RewritePatternSet &patterns) {", "-  patterns.add<CollapseForallOpDimensions, FoldTensorCastIntoForallOp>(", "-      patterns.getContext());", "-  tensor::CastOp::getCanonicalizationPatterns(patterns, patterns.getContext());", "-}", "-", "-}  // namespace mlir::gml_st", "@@ -1,79 +0,0 @@", "-// RUN: mlir-hlo-opt %s --gml-compose-extract-insert-slice | FileCheck %s", "-", "-func.func @inline_single_iteration_parallel(", "-    %in: tensor<8x8xf32>) -> tensor<8x8xf32> {", "-  %c8 = arith.constant 8 : index", "-  %c0 = arith.constant 0 : index", "-  %c1 = arith.constant 1 : index", "-  %cst = arith.constant 0.000000e+00 : f32", "-  %0 = tensor.empty() : tensor<8x8xf32>", "-  %13 = scf.forall (%arg4, %arg5) = (%c0, %c0) to (%c1, %c1)", "-        step (%c8, %c8) shared_outs (%out_ = %0) -> (tensor<8x8xf32>) {", "-    %20 = tensor.extract_slice %out_[%arg4, %arg5] [8, 8] [1, 1]", "-      : tensor<8x8xf32> to tensor<8x8xf32>", "-    %11 = linalg.fill ins(%cst : f32) outs(%20 : tensor<8x8xf32>)", "-          -> tensor<8x8xf32>", "-    scf.forall.in_parallel {", "-      tensor.parallel_insert_slice %11 into %out_[%arg4, %arg5] [8, 8] [1, 1]", "-        : tensor<8x8xf32> into tensor<8x8xf32>", "-    }", "-  }", "-  return %13 : tensor<8x8xf32>", "-}", "-", "-// CHECK-LABEL: @inline_single_iteration_parallel", "-// CHECK-NOT:     scf.forall", "-// CHECK:         tensor.empty", "-// CHECK-NEXT:    linalg.fill", "-", "-// -----", "-", "-func.func @collapse_one_dim_parallel(%in: tensor<8x8xf32>) -> tensor<8x8xf32> {", "-  %c8 = arith.constant 8 : index", "-  %c0 = arith.constant 0 : index", "-  %c1 = arith.constant 1 : index", "-  %c16 = arith.constant 16 : index", "-  %cst = arith.constant 0.000000e+00 : f32", "-  %0 = tensor.empty() : tensor<8x8xf32>", "-  %13 = scf.forall (%arg4, %arg5) = (%c0, %c0) to (%c1, %c16)", "-        step (%c8, %c8) shared_outs (%out_ = %0) -> (tensor<8x8xf32>) {", "-    %11 = linalg.fill ins(%cst : f32) outs(%out_ : tensor<8x8xf32>)", "-          -> tensor<8x8xf32>", "-    scf.forall.in_parallel {", "-      tensor.parallel_insert_slice %11 into %out_[%arg4, %arg5] [8, 8] [1, 1]", "-        : tensor<8x8xf32> into tensor<8x8xf32>", "-    }", "-  }", "-  return %13 : tensor<8x8xf32>", "-}", "-", "-// CHECK-LABEL: @collapse_one_dim_parallel", "-// CHECK:         scf.forall (%[[ARG:.*]]) = (%c0) to (%c16) step (%c8)", "-// CHECK:           linalg.fill", "-// CHECK:           tensor.parallel_insert_slice", "-", "-// -----", "-", "-func.func @remove_empty_parallel(%in: tensor<8x8xf32>) -> tensor<8x8xf32> {", "-  %c8 = arith.constant 8 : index", "-  %c0 = arith.constant 0 : index", "-  %c1 = arith.constant 1 : index", "-  %c16 = arith.constant 16 : index", "-  %cst = arith.constant 0.000000e+00 : f32", "-  %0 = tensor.empty() : tensor<8x8xf32>", "-  %13 = scf.forall (%arg4, %arg5) = (%c0, %c16) to (%c1, %c16)", "-        step (%c8, %c8) shared_outs (%out_ = %0) -> (tensor<8x8xf32>) {", "-    %11 = linalg.fill ins(%cst : f32) outs(%out_ : tensor<8x8xf32>)", "-          -> tensor<8x8xf32>", "-    scf.forall.in_parallel {", "-      tensor.parallel_insert_slice %11 into %out_[%arg4, %arg5] [8, 8] [1, 1]", "-        : tensor<8x8xf32> into tensor<8x8xf32>", "-    }", "-  }", "-  return %13 : tensor<8x8xf32>", "-}", "-", "-// CHECK-LABEL: @remove_empty_parallel", "-// CHECK-NOT:   scf.forall", "-// CHECK:       %[[EMPTY:.*]] = tensor.empty", "-// CHECK:       return %[[EMPTY]]", "@@ -1,49 +0,0 @@", "-// RUN: mlir-hlo-opt %s --gml-compose-extract-insert-slice | FileCheck %s", "-", "-func.func @fold_tensor_cast_into_parallel(", "-    %in: tensor<2xi32>, %out: tensor<2xi32>) -> tensor<2xi32> {", "-  %cst = arith.constant dense<[100500]> : tensor<1xi32>", "-", "-", "-  %out_cast = tensor.cast %out : tensor<2xi32> to tensor<?xi32>", "-  %result = scf.forall (%i) = (0) to (2) step (1)", "-      shared_outs (%out_ = %out_cast) -> tensor<?xi32> {", "-", "-    scf.forall.in_parallel {", "-      tensor.parallel_insert_slice %cst into %out_[%i] [1] [1]", "-        : tensor<1xi32> into tensor<?xi32>", "-    }", "-  }", "-  %result_cast = tensor.cast %result : tensor<?xi32> to tensor<2xi32>", "-  func.return %result_cast : tensor<2xi32>", "-}", "-// CHECK-LABEL: @fold_tensor_cast_into_parallel", "-// CHECK-NOT:     tensor.cast", "-// CHECK:         parallel_insert_slice", "-// CHECK-SAME:      : tensor<1xi32> into tensor<2xi32>", "-// CHECK-NOT:     tensor.cast", "-", "-// -----", "-", "-func.func @do_not_fold_tensor_cast_from_dynamic_to_static_type_into_parallel(", "-    %in: tensor<?xi32>, %out: tensor<?xi32>) -> tensor<?xi32> {", "-  %cst = arith.constant dense<[100500]> : tensor<1xi32>", "-", "-", "-  %out_cast = tensor.cast %out : tensor<?xi32> to tensor<2xi32>", "-  %result = scf.forall (%i) = (0) to (2) step (1)", "-      shared_outs (%out_ = %out_cast) -> tensor<2xi32> {", "-", "-    scf.forall.in_parallel {", "-      tensor.parallel_insert_slice %cst into %out_[%i] [1] [1]", "-        : tensor<1xi32> into tensor<2xi32>", "-    }", "-  }", "-  %result_cast = tensor.cast %result : tensor<2xi32> to tensor<?xi32>", "-  func.return %result_cast : tensor<?xi32>", "-}", "-// CHECK-LABEL: @do_not_fold_tensor_cast_", "-// CHECK:         tensor.cast", "-// CHECK:         parallel_insert_slice", "-// CHECK-SAME:      : tensor<1xi32> into tensor<2xi32>", "-// CHECK:         tensor.cast", "@@ -27,7 +27,7 @@ namespace {", " TEST(TocoTest, MissingInputFile) {", "   ParsedTocoFlags toco_flags;", "   ParsedModelFlags model_flags;", "-  EXPECT_DEATH(Convert(toco_flags, model_flags).ok(),", "+  EXPECT_DEATH(EXPECT_TRUE(Convert(toco_flags, model_flags).ok()),", "                \"Missing required flag --input_file\");", " }", " ", "@@ -38,8 +38,9 @@ TEST(TocoTest, BadInputFormat) {", "   std::string input;", "   std::string output;", " ", "-  EXPECT_DEATH(Convert(input, toco_flags, model_flags, &output).ok(),", "-               \"Unhandled input_format='FILE_FORMAT_UNKNOWN'\");", "+  EXPECT_DEATH(", "+      EXPECT_TRUE(Convert(input, toco_flags, model_flags, &output).ok()),", "+      \"Unhandled input_format='FILE_FORMAT_UNKNOWN'\");", " }", " ", " TEST(TocoTest, MissingOutputArrays) {", "@@ -50,9 +51,10 @@ TEST(TocoTest, MissingOutputArrays) {", "   std::string input;", "   std::string output;", " ", "-  EXPECT_DEATH(Convert(input, toco_flags, model_flags, &output).ok(),", "-               \"This model does not define output arrays, so a --output_arrays \"", "-               \"flag must be given on the command-line\");", "+  EXPECT_DEATH(", "+      EXPECT_TRUE(Convert(input, toco_flags, model_flags, &output).ok()),", "+      \"This model does not define output arrays, so a --output_arrays \"", "+      \"flag must be given on the command-line\");", " }", " ", " TEST(TocoTest, BadOutputArray) {", "@@ -64,9 +66,10 @@ TEST(TocoTest, BadOutputArray) {", "   std::string input;", "   std::string output;", " ", "-  EXPECT_DEATH(Convert(input, toco_flags, model_flags, &output).ok(),", "-               \"Specified output array .output1. is not produced by any op \"", "-               \"in this graph. Is it a typo\");", "+  EXPECT_DEATH(", "+      EXPECT_TRUE(Convert(input, toco_flags, model_flags, &output).ok()),", "+      \"Specified output array .output1. is not produced by any op \"", "+      \"in this graph. Is it a typo\");", " }", " ", " TEST(TocoTest, BadOutputFormat) {", "@@ -87,8 +90,9 @@ TEST(TocoTest, BadOutputFormat) {", " ", "   std::string output;", " ", "-  EXPECT_DEATH(Convert(input, toco_flags, model_flags, &output).ok(),", "-               \"Unhandled output_format='FILE_FORMAT_UNKNOWN'\");", "+  EXPECT_DEATH(", "+      EXPECT_TRUE(Convert(input, toco_flags, model_flags, &output).ok()),", "+      \"Unhandled output_format='FILE_FORMAT_UNKNOWN'\");", " }", " ", " TEST(TocoTest, SimpleFloatModel) {", "@@ -15,6 +15,7 @@ limitations under the License.", " #include \"tensorflow/lite/graph_info.h\"", " ", " #include <algorithm>", "+#include <set>", " #include <vector>", " ", " #include \"tensorflow/lite/context_util.h\"", "@@ -25,8 +26,17 @@ namespace {", " ", " template <class T>", " void Uniquefy(std::vector<T>* items) {", "-  std::sort(items->begin(), items->end());", "-  items->erase(std::unique(items->begin(), items->end()), items->end());", "+  std::set<T> seen;", "+  size_t size = 0;", "+  for (size_t i = 0; i < items->size(); ++i) {", "+    const T& item = (*items)[i];", "+    if (seen.find(item) == seen.end()) {", "+      seen.insert(item);", "+      (*items)[size] = item;", "+      ++size;", "+    }", "+  }", "+  items->resize(size);", " }", " ", " // Helper class that actually performs partitioning by node sub set.", "@@ -540,7 +540,7 @@ TEST(PartitionTest, Nodes4PartitionNodes3_WithControlDependency) {", "                                         /*type=*/NodeSubset::kTfPartition,", "                                         /*nodes=*/{0, 1},", "                                         /*input_tensors=*/{0},", "-                                        /*output_tensors=*/{1, 2},", "+                                        /*output_tensors=*/{2, 1},", "                                     },", "                                     {", "                                         /*type=*/NodeSubset::kTfNonPartition,", "@@ -586,7 +586,7 @@ TEST(PartitionTest, Nodes4PartitionNodes3_WithExternalControlDependency) {", "                                         /*type=*/NodeSubset::kTfPartition,", "                                         /*nodes=*/{0, 1},", "                                         /*input_tensors=*/{0},", "-                                        /*output_tensors=*/{1, 2},", "+                                        /*output_tensors=*/{2, 1},", "                                     },", "                                     {", "                                         /*type=*/NodeSubset::kTfNonPartition,", "@@ -48,7 +48,7 @@ pytype_strict_library(", "         \":layout\",", "         \"//tensorflow/python/eager:context\",", "         \"//tensorflow/python/framework:ops\",", "-        \"//tensorflow/python/util\",", "+        \"//tensorflow/python/util:deprecation\",", "         \"//tensorflow/python/util:tf_export\",", "     ],", " )", "@@ -121,7 +121,6 @@ pytype_strict_library(", "         \"//tensorflow/dtensor/proto:layout_proto_py_pb2\",", "         \"//tensorflow/python:array_ops\",", "         \"//tensorflow/python:errors\",", "-        \"//tensorflow/python:util\",", "         \"//tensorflow/python/checkpoint\",", "         \"//tensorflow/python/checkpoint:checkpoint_options\",", "         \"//tensorflow/python/checkpoint:graph_view\",", "@@ -134,6 +133,8 @@ pytype_strict_library(", "         \"//tensorflow/python/training:py_checkpoint_reader\",", "         \"//tensorflow/python/training/saving:saveable_object\",", "         \"//tensorflow/python/training/saving:saveable_object_util\",", "+        \"//tensorflow/python/util:deprecation\",", "+        \"//tensorflow/python/util:nest\",", "         \"//tensorflow/python/util:tf_export\",", "     ],", " )", "@@ -306,7 +307,7 @@ pytype_strict_library(", "         \"//tensorflow/python/eager:context\",", "         \"//tensorflow/python/framework:tensor_shape\",", "         \"//tensorflow/python/types\",", "-        \"//tensorflow/python/util\",", "+        \"//tensorflow/python/util:nest\",", "         \"//tensorflow/python/util:tf_export\",", "     ],", " )", "@@ -415,7 +415,7 @@ dtensor_test(", "         \"//tensorflow/python/framework:errors\",", "         \"//tensorflow/python/framework:ops\",", "         \"//tensorflow/python/platform:client_testlib\",", "-        \"//tensorflow/python/util\",", "+        \"//tensorflow/python/util:nest\",", "         \"//third_party/py/numpy\",", "         \"@absl_py//absl/testing:parameterized\",", "     ],", "@@ -468,7 +468,7 @@ dtensor_test(", "         \"//tensorflow/python/framework:errors\",", "         \"//tensorflow/python/framework:ops\",", "         \"//tensorflow/python/platform:client_testlib\",", "-        \"//tensorflow/python/util\",", "+        \"//tensorflow/python/util:nest\",", "         \"//third_party/py/numpy\",", "         \"@absl_py//absl/testing:parameterized\",", "     ],", "@@ -320,6 +320,7 @@ class PrefetchDatasetOp::Dataset : public DatasetBase {", "       if (ctx->warm_start()) {", "         TF_RETURN_IF_ERROR(EnsureThreadsStarted(ctx));", "       }", "+      cond_var_->notify_all();", "       return OkStatus();", "     }", " ", "@@ -569,7 +569,10 @@ cc_library(", "     name = \"tfrt_compile_options\",", "     srcs = [\"translate/tfrt_compile_options.cc\"],", "     hdrs = [\"translate/tfrt_compile_options.h\"],", "-    deps = [\"@com_google_absl//absl/strings\"],", "+    deps = [", "+        \"//tensorflow/core/protobuf:for_core_protos_cc\",", "+        \"@com_google_absl//absl/strings\",", "+    ],", " )", " ", " cc_library(", "@@ -21,6 +21,8 @@ limitations under the License.", " #include <string>", " #include <vector>", " ", "+#include \"tensorflow/core/protobuf/config.pb.h\"", "+", " namespace tensorflow {", " ", " enum class TfrtDeviceInfraTarget {", "@@ -47,6 +49,10 @@ struct TfrtCompileOptions {", "   // If true, run grappler passes before compiling.", "   bool enable_grappler = true;", " ", "+  // Graph rewrite options that will be applied on GraphDef before converting to", "+  // MLIR.", "+  GraphOptions graph_options;", "+", "   // Force data format for all layout sensitive operations, eg. setting it to", "   // \"NHWC\" will changes all data format in the graph to \"NHWC\" by inserting", "   // or removing related tf.Transpose op. Currently the supported formats are", "@@ -28,6 +28,8 @@ tensorflow::SessionOptions CreateDefaultSessionOptions(", "   tensorflow::SessionOptions session_options;", "   auto& config = session_options.config;", " ", "+  *config.mutable_graph_options() = options.compile_options.graph_options;", "+", "   config.mutable_graph_options()", "       ->mutable_rewrite_options()", "       ->set_disable_meta_optimizer(!options.compile_options.enable_grappler);"]}]